<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Unsafe Rust - The Rust Programming Language 日本語版</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/em-to-bold.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language 日本語版</a></li><li class="chapter-item expanded affix "><a href="foreword.html">まえがき</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">はじめに</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 事始め</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> インストール</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 数当てゲームのプログラミング</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 一般的なプログラミングの概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 変数と可変性</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> データ型</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 関数</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> コメント</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 制御フロー</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 所有権を理解する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 所有権とは？</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 参照と借用</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> スライス型</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 構造体を使用して関係のあるデータを構造化する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 構造体を定義し、インスタンス化する</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 構造体を使ったプログラム例</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> メソッド記法</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enumとパターンマッチング</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Enumを定義する</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match制御フロー演算子</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if letで簡潔な制御フロー</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 肥大化していくプロジェクトをパッケージ、クレート、モジュールを利用して管理する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> パッケージとクレート</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> モジュールを定義して、スコープとプライバシーを制御する</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> モジュールツリーの要素を示すためのパス</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> useキーワードでパスをスコープに持ち込む</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> モジュールを複数のファイルに分割する</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 一般的なコレクション</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ベクタで値のリストを保持する</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 文字列でUTF-8でエンコードされたテキストを保持する</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> キーとそれに紐づいた値をハッシュマップに格納する</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> エラー処理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!で回復不能なエラー</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Resultで回復可能なエラー</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!すべきかするまいか</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ジェネリック型、トレイト、ライフタイム</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ジェネリックなデータ型</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> トレイト：共通の振る舞いを定義する</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ライフタイムで参照を検証する</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 自動テストを書く</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> テストの記述法</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> テストの実行のされ方を制御する</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> テストの体系化</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> 入出力プロジェクト：コマンドラインプログラムを構築する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> コマンドライン引数を受け付ける</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ファイルを読み込む</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> リファクタリングしてモジュール性とエラー処理を向上させる</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> テスト駆動開発でライブラリの機能を開発する</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 環境変数を取り扱う</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 標準出力ではなく標準エラーにエラーメッセージを書き込む</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 関数型言語の機能：イテレータとクロージャ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> クロージャ：環境をキャプチャできる匿名関数</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 一連の要素をイテレータで処理する</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> 入出力プロジェクトを改善する</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> パフォーマンス比較：ループVSイテレータ</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> CargoとCrates.ioについてより詳しく</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> リリースプロファイルでビルドをカスタマイズする</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.ioにクレートを公開する</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargoのワークスペース</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo installでCrates.ioからバイナリをインストールする</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 独自のコマンドでCargoを拡張する</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> スマートポインタ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ヒープのデータを指すBox&lt;T&gt;を使用する</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Derefトレイトでスマートポインタを普通の参照のように扱う</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Dropトレイトで片付け時にコードを走らせる</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;は、参照カウント方式のスマートポインタ</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt;と内部可変性パターン</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 循環参照は、メモリをリークすることもある</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 恐れるな！並行性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> スレッドを使用してコードを同時に走らせる</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> メッセージ受け渡しを使ってスレッド間でデータを転送する</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 状態共有並行性</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> SyncとSendトレイトで拡張可能な並行性</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rustのオブジェクト指向プログラミング機能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> オブジェクト指向言語の特徴</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> トレイトオブジェクトで異なる型の値を許容する</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> オブジェクト指向デザインパターンを実装する</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> パターンとマッチング</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> パターンが使用されることのある箇所全部</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 論駁可能性：パターンが合致しないかどうか</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> パターン記法</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 高度な機能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html" class="active"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> 高度なトレイト</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> 高度な型</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> 高度な関数とクロージャ</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> マクロ</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 最後のプロジェクト：マルチスレッドのWebサーバを構築する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> シングルスレッドのWebサーバを構築する</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> シングルスレッドサーバをマルチスレッド化する</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 正常なシャットダウンと片付け</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 付録</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> 付録A：キーワード</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> 付録B：演算子と記号</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> 付録C：導出可能なトレイト</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> 付録D：便利な開発ツール</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> 付録E：エディション</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> 付録F：本の翻訳</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> 付録G：Rustの作られ方と“Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language 日本語版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Unsafe Rust
-->
<h2 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h2>
<!--
All the code we’ve discussed so far has had Rust’s memory safety guarantees
enforced at compile time. However, Rust has a second language hidden inside it
that doesn’t enforce these memory safety guarantees: it’s called *unsafe Rust*
and works just like regular Rust, but gives us extra superpowers.
-->
<p>ここまでに議論してきたコードは全て、Rustのメモリ安全保証がコンパイル時に強制されていました。しかしながら、
Rustには、これらのメモリ安全保証を強制しない第2の言語が中に隠されています: それは<em>unsafe Rust</em>と呼ばれ、
普通のRustのように動きますが、おまけの強大な力を与えてくれます。</p>
<!--
Unsafe Rust exists because, by nature, static analysis is conservative. When
the compiler tries to determine whether or not code upholds the guarantees,
it’s better for it to reject some valid programs rather than accept some
invalid programs. Although the code might be okay, as far as Rust is able to
tell, it’s not! In these cases, you can use unsafe code to tell the compiler,
“Trust me, I know what I’m doing.” The downside is that you use it at our own
risk: if you use unsafe code incorrectly, problems due to memory unsafety, such
as null pointer dereferencing, can occur.
-->
<p>静的解析は原理的に保守的なので、unsafe Rustが存在します。コードが保証を保持しているかコンパイラが決定しようとする際、
なんらかの不正なプログラムを受け入れるよりも合法なプログラムを拒否したほうがいいのです。コードは大丈夫かもしれないけれど、
コンパイラにわかる範囲ではダメなのです！このような場合、unsafeコードを使用してコンパイラに「信じて！何をしているかわかってるよ」と教えられます。
欠点は、自らのリスクで使用することです: unsafeコードを誤って使用したら、
nullポインタ参照外しなどのメモリ非安全に起因する問題が起こることもあるのです。</p>
<!--
Another reason Rust has an unsafe alter ego is that the underlying computer
hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you
couldn’t do certain tasks. Rust needs to allow you to do low-level systems
programming, such as directly interacting with the operating system or even
writing your own operating system. Working with low-level systems programming
is one of the goals of the language. Let’s explore what we can do with unsafe
Rust and how to do it.
-->
<p>Rustにunsafeな分身がある別の理由は、根本にあるコンピュータのハードウェアが本質的にunsafeだからです。
Rustがunsafeな処理を行わせてくれなかったら、特定の仕事を行えないでしょう。Rustは、低レベルなシステムプログラミングを許可する必要があります。
直接OSと相互作用したり、独自のOSを書くことさえもそうです。低レベルなシステムプログラミングに取り組むことは、
言語の目標の1つなのです。unsafe Rustでできることとその方法を探究しましょう。</p>
<!--
### Unsafe Superpowers
-->
<h3 id="unsafeの強大な力superpower"><a class="header" href="#unsafeの強大な力superpower">unsafeの強大な力(superpower)</a></h3>
<!--
To switch to unsafe Rust, use the `unsafe` keyword and then start a new block
that holds the unsafe code. You can take four actions in unsafe Rust, called
*unsafe superpowers*, that you can’t in safe Rust. Those superpowers include
the ability to:
-->
<p>unsafe Rustに切り替えるには、<code>unsafe</code>キーワードを使用し、それからunsafeコードを保持する新しいブロックを開始してください。
safe Rustでは行えない4つの行動をunsafe Rustでは行え、これは<em>unsafe superpowers</em>と呼ばれます。
そのsuperpowerには、以下の能力が含まれています:</p>
<!--
* Dereference a raw pointer
* Call an unsafe function or method
* Access or modify a mutable static variable
* Implement an unsafe trait
-->
<ul>
<li>生ポインタを参照外しすること</li>
<li>unsafeな関数やメソッドを呼ぶこと</li>
<li>可変で静的な変数にアクセスしたり変更すること</li>
<li>unsafeなトレイトを実装すること</li>
</ul>
<!--
It’s important to understand that `unsafe` doesn’t turn off the borrow checker
or disable any other of Rust’s safety checks: if you use a reference in unsafe
code, it will still be checked. The `unsafe` keyword only gives you access to
these four features that are then not checked by the compiler for memory
safety. You'll still get some degree of safety inside of an unsafe block.
-->
<p><code>unsafe</code>は、借用チェッカーや他のRustの安全性チェックを無効にしないことを理解するのは重要なことです:
unsafeコードで参照を使用しても、チェックはされます。<code>unsafe</code>キーワードにより、これら4つの機能にアクセスできるようになり、
その場合、コンパイラによってこれらのメモリ安全性は確認されないのです。unsafeブロック内でも、ある程度の安全性は得られます。</p>
<!--
In addition, `unsafe` does not mean the code inside the block is necessarily
dangerous or that it will definitely have memory safety problems: the intent is
that as the programmer, you’ll ensure the code inside an `unsafe` block will
access memory in a valid way.
-->
<p>また、unsafeは、そのブロックが必ずしも危険だったり、絶対メモリ安全上の問題を抱えていることを意味するものではありません:
その意図は、プログラマとして<code>unsafe</code>ブロック内のコードがメモリに合法的にアクセスすることを保証することです。</p>
<!--
People are fallible, and mistakes will happen, but by requiring these four
unsafe operations to be inside blocks annotated with `unsafe` you’ll know that
any errors related to memory safety must be within an `unsafe` block. Keep
`unsafe` blocks small; you’ll be thankful later when you investigate memory
bugs.
-->
<p>人間は失敗をするもので、間違いも起きますが、これら4つのunsafeな処理を<code>unsafe</code>で注釈されたブロックに入れる必要があることで、
メモリ安全性に関するどんなエラーも<code>unsafe</code>ブロック内にあるに違いないと知ります。<code>unsafe</code>ブロックは小さくしてください;
メモリのバグを調査するときに感謝することになるでしょう。</p>
<!--
To isolate unsafe code as much as possible, it’s best to enclose unsafe code
within a safe abstraction and provide a safe API, which we’ll discuss later in
the chapter when we examine unsafe functions and methods. Parts of the standard
library are implemented as safe abstractions over unsafe code that has been
audited. Wrapping unsafe code in a safe abstraction prevents uses of `unsafe`
from leaking out into all the places that you or your users might want to use
the functionality implemented with `unsafe` code, because using a safe
abstraction is safe.
-->
<p>unsafeなコードをできるだけ分離するために、unsafeなコードを安全な抽象の中に閉じ込め、安全なAPIを提供するのが最善です。
これについては、後ほどunsafeな関数とメソッドを調査する際に議論します。標準ライブラリの一部は、
検査されたunsafeコードの安全な抽象として実装されています。安全な抽象にunsafeなコードを包むことで、
<code>unsafe</code>が、あなたやあなたのユーザが<code>unsafe</code>コードで実装された機能を使いたがる可能性のある箇所全部に漏れ出ることを防ぎます。
安全な抽象を使用することは、安全だからです。</p>
<!--
Let’s look at each of the four unsafe superpowers in turn. We’ll also look at
some abstractions that provide a safe interface to unsafe code.
-->
<p>4つのunsafeなsuperpowerを順に見ていきましょう。unsafeなコードへの安全なインターフェイスを提供する一部の抽象化にも目を向けます。</p>
<!--
### Dereferencing a Raw Pointer
-->
<h3 id="生ポインタを参照外しする"><a class="header" href="#生ポインタを参照外しする">生ポインタを参照外しする</a></h3>
<!--
In Chapter 4, in the “Dangling References” section, we mentioned that the
compiler ensures references are always valid. Unsafe Rust has two new types
called *raw pointers* that are similar to references. As with references, raw
pointers can be immutable or mutable and are written as `*const T` and `*mut
T`, respectively. The asterisk isn’t the dereference operator; it’s part of the
type name. In the context of raw pointers, *immutable* means that the pointer
can’t be directly assigned to after being dereferenced.
-->
<p>第4章の「ダングリング参照」節で、コンパイラは、参照が常に有効であることを保証することに触れました。
unsafe Rustには参照に類似した<em>生ポインタ</em>と呼ばれる2つの新しい型があります。参照同様、
生ポインタも不変や可変になり得て、それぞれ<code>*const T</code>と<code>*mut T</code>と表記されます。このアスタリスクは、参照外し演算子ではありません;
型名の一部です。生ポインタの文脈では、<em>不変</em>は、参照外し後に直接ポインタに代入できないことを意味します。</p>
<!--
Different from references and smart pointers, raw pointers:
-->
<p>参照やスマートポインタと異なり、生ポインタは:</p>
<!--
* Are allowed to ignore the borrowing rules by having both immutable and
mutable pointers or multiple mutable pointers to the same location
* Aren’t guaranteed to point to valid memory
* Are allowed to be null
* Don’t implement any automatic cleanup
-->
<ul>
<li>同じ場所への不変と可変なポインタや複数の可変なポインタが存在することで借用規則を無視できる</li>
<li>有効なメモリを指しているとは保証されない</li>
<li>nullの可能性がある</li>
<li>自動的な片付けは実装されていない</li>
</ul>
<!--
By opting out of having Rust enforce these guarantees, you can give up
the guaranteed safety in exchange for greater performance or the ability to
interface with another language or hardware where Rust’s guarantees don’t apply.
-->
<p>これらの保証をコンパイラに強制させることから抜けることで、保証された安全性を諦めてパフォーマンスを向上させたり、
Rustの保証が適用されない他の言語やハードウェアとのインターフェイスの能力を得ることができます。</p>
<!--
Listing 19-1 shows how to create an immutable and a mutable raw pointer from
references.
-->
<p>リスト19-1は、参照から不変と可変な生ポインタを生成する方法を示しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-1: Creating raw pointers from references</span>
-->
<p><span class="caption">リスト19-1: 参照から生ポインタを生成する</span></p>
<!--
Notice that we don’t include the `unsafe` keyword in this code. We can create
raw pointers in safe code; we just can’t dereference raw pointers outside an
unsafe block, as you’ll see in a bit.
-->
<p>このコードには<code>unsafe</code>キーワードを含めていないことに注意してください。safeコードで生ポインタを生成できます;
もうすぐわかるように、unsafeブロックの外では、生ポインタを参照外しできないだけなのです。</p>
<!--
We’ve created raw pointers by using `as` to cast an immutable and a mutable
reference into their corresponding raw pointer types. Because we created them
directly from references guaranteed to be valid, we know these particular raw
pointers are valid, but we can’t make that assumption about just any raw
pointer.
-->
<p><code>as</code>を使って不変と可変な参照を対応する生ポインタの型にキャストして生ポインタを生成しました。
有効であることが保証される参照から直接生ポインタを生成したので、これらの特定の生ポインタは有効であることがわかりますが、
その前提をあらゆる生ポインタに敷くことはできません。</p>
<!--
Next, we’ll create a raw pointer whose validity we can’t be so certain of.
Listing 19-2 shows how to create a raw pointer to an arbitrary location in
memory. Trying to use arbitrary memory is undefined: there might be data at
that address or there might not, the compiler might optimize the code so there
is no memory access, or the program might error with a segmentation fault.
Usually, there is no good reason to write code like this, but it is possible.
-->
<p>次に、有効であることが確信できない生ポインタを生成します。リスト19-2は、メモリの任意の箇所を指す生ポインタの生成法を示しています。
任意のメモリを使用しようとすることは未定義です: そのアドレスにデータがある可能性もあるし、ない可能性もあり、
コンパイラがコードを最適化してメモリアクセスがなくなる可能性もあるし、プログラムがセグメンテーションフォールトでエラーになる可能性もあります。
通常、このようなコードを書くいい理由はありませんが、可能ではあります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let address = 0x012345usize;
let r = address as *const i32;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-2: Creating a raw pointer to an arbitrary
memory address</span>
-->
<p><span class="caption">リスト19-2: 任意のメモリアドレスへの生ポインタを生成する</span></p>
<!--
Recall that we can create raw pointers in safe code, but we can’t *dereference*
raw pointers and read the data being pointed to. In Listing 19-3, we use the
dereference operator `*` on a raw pointer that requires an `unsafe` block.
-->
<p>safeコードで生ポインタを生成できるけれども、生ポインタを<em>参照外し</em>して指しているデータを読むことはできないことを思い出してください。
リスト19-3では、<code>unsafe</code>ブロックが必要になる参照外し演算子の<code>*</code>を生ポインタに使っています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

unsafe {
    println!(&quot;r1 is: {}&quot;, *r1);
    println!(&quot;r2 is: {}&quot;, *r2);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-3: Dereferencing raw pointers within an
`unsafe` block</span>
-->
<p><span class="caption">リスト19-3: <code>unsafe</code>ブロック内で生ポインタを参照外しする</span></p>
<!--
Creating a pointer does no harm; it’s only when we try to access the value that
it points at that we might end up dealing with an invalid value.
-->
<p>ポインタの生成は害を及ぼしません; 問題が起こり得るのはポインタが指している値にアクセスしようとするときのみで、この際に無効な値を扱うことになる可能性があります。</p>
<!--
Note also that in Listing 19-1 and 19-3, we created `*const i32` and `*mut i32`
raw pointers that both pointed to the same memory location, where `num` is
stored. If we instead tried to create an immutable and a mutable reference to
`num`, the code would not have compiled because Rust’s ownership rules don’t
allow a mutable reference at the same time as any immutable references. With
raw pointers, we can create a mutable pointer and an immutable pointer to the
same location and change data through the mutable pointer, potentially creating
a data race. Be careful!
-->
<p>また、リスト19-1とリスト19-3では、
<code>num</code>が格納されている同じメモリ上の場所を両方とも指す<code>*const i32</code>と<code>*mut i32</code>の生ポインタを生成したことに注目してください。
代わりに<code>num</code>への不変と可変な参照を生成しようとしたら、コードはコンパイルできなかったでしょう。
Rustの所有権規則により、不変参照と可変参照を同時に存在させられないからです。生ポインタなら、
同じ場所への可変なポインタと不変なポインタを生成でき、可変なポインタを通してデータを変更し、データ競合を引き起こす可能性があります。
気を付けてください！</p>
<!--
With all of these dangers, why would you ever use raw pointers? One major use
case is when interfacing with C code, as you’ll see in the next section,
“Calling an Unsafe Function or Method.” Another case is when building up safe
abstractions that the borrow checker doesn’t understand. We’ll introduce unsafe
functions and then look at an example of a safe abstraction that uses unsafe
code.
-->
<p>これらの危険がありながら、一体何故生ポインタを使うのでしょうか？主なユースケースの1つは、次の節「unsafeな関数やメソッドを呼ぶ」で見るように、
Cコードとのインターフェイスです。別のユースケースは、借用チェッカーには理解できない安全な抽象を構成する時です。
unsafeな関数を導入し、それからunsafeコードを使用する安全な抽象の例に目を向けます。</p>
<!--
### Calling an Unsafe Function or Method
-->
<h3 id="unsafeな関数やメソッドを呼ぶ"><a class="header" href="#unsafeな関数やメソッドを呼ぶ">unsafeな関数やメソッドを呼ぶ</a></h3>
<!--
The second type of operation that requires an unsafe block is calls to unsafe
functions. Unsafe functions and methods look exactly like regular functions and
methods, but they have an extra `unsafe` before the rest of the definition. The
`unsafe` keyword in this context indicates the function has requirements we
need to uphold when we call this function, because Rust can’t guarantee we’ve
met these requirements. By calling an unsafe function within an `unsafe` block,
we’re saying that we’ve read this function’s documentation and take
responsibility for upholding the function’s contracts.
-->
<p>unsafeブロックが必要になる2番目の処理は、unsafe関数の呼び出しです。unsafeな関数やメソッドも見た目は、
普通の関数やメソッドと全く同じですが、残りの定義の前に追加の<code>unsafe</code>があります。この文脈での<code>unsafe</code>キーワードは、
この関数を呼ぶ際に保持しておく必要のある要求が関数にあることを示唆します。コンパイラには、
この要求を満たしているか保証できないからです。<code>unsafe</code>ブロックでunsafeな関数を呼び出すことで、
この関数のドキュメンテーションを読み、関数の契約を守っているという責任を取ると宣言します。</p>
<!--
Here is an unsafe function named `dangerous` that doesn’t do anything in its
body:
-->
<p>こちらは、本体で何もしない<code>dangerous</code>というunsafeな関数です:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn dangerous() {}

unsafe {
    dangerous();
}
<span class="boring">}
</span></code></pre></pre>
<!--
We must call the `dangerous` function within a separate `unsafe` block. If we
try to call `dangerous` without the `unsafe` block, we’ll get an error:
-->
<p>個別の<code>unsafe</code>ブロックで<code>dangerous</code>関数を呼ばなければなりません。<code>unsafe</code>ブロックなしで<code>dangerous</code>を呼ぼうとすれば、
エラーになるでしょう:</p>
<pre><code class="language-text">error[E0133]: call to unsafe function requires unsafe function or block
(エラー: unsafe関数の呼び出しには、unsafeな関数かブロックが必要です)
 --&gt;
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
</code></pre>
<!--
By inserting the `unsafe` block around our call to `dangerous`, we’re asserting
to Rust that we’ve read the function’s documentation, we understand how to use
it properly, and we’ve verified that we’re fulfilling the contract of the
function.
-->
<p><code>dangerous</code>への呼び出しの周りに<code>unsafe</code>ブロックを挿入することで、コンパイラに関数のドキュメンテーションを読み、
適切に使用する方法を理解したことをアサートし、関数の契約を満たしていると実証しました。</p>
<!--
Bodies of unsafe functions are effectively `unsafe` blocks, so to perform other
unsafe operations within an unsafe function, we don’t need to add another
`unsafe` block.
-->
<p>unsafe関数の本体は、実効的に<code>unsafe</code>ブロックになるので、unsafe関数内でunsafeな別の処理を行うのに、
別の<code>unsafe</code>ブロックは必要ないのです。</p>
<!--
#### Creating a Safe Abstraction over Unsafe Code
-->
<h4 id="unsafeコードに安全な抽象を行う"><a class="header" href="#unsafeコードに安全な抽象を行う">unsafeコードに安全な抽象を行う</a></h4>
<!--
Just because a function contains unsafe code doesn’t mean we need to mark the
entire function as unsafe. In fact, wrapping unsafe code in a safe function is
a common abstraction. As an example, let’s study a function from the standard
library, `split_at_mut`, that requires some unsafe code and explore how we
might implement it. This safe method is defined on mutable slices: it takes one
slice and makes it two by splitting the slice at the index given as an
argument. Listing 19-4 shows how to use `split_at_mut`.
-->
<p>関数がunsafeなコードを含んでいるだけで関数全体をunsafeでマークする必要があることにはなりません。
事実、安全な関数でunsafeなコードをラップすることは一般的な抽象化です。例として、
なんらかのunsafeコードが必要になる標準ライブラリの関数<code>split_at_mut</code>を学び、その実装方法を探究しましょう。
この安全なメソッドは、可変なスライスに定義されています: スライスを1つ取り、引数で与えられた添え字でスライスを分割して2つにします。
リスト19-4は、<code>split_at_mut</code>の使用法を示しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &amp;mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &amp;mut [1, 2, 3]);
assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-4: Using the safe `split_at_mut`
function</span>
-->
<p><span class="caption">リスト19-4: 安全な<code>split_at_mut</code>関数を使用する</span></p>
<!--
We can’t implement this function using only safe Rust. An attempt might look
something like Listing 19-5, which won’t compile. For simplicity, we’ll
implement `split_at_mut` as a function rather than a method and only for slices
of `i32` values rather than for a generic type `T`.
-->
<p>この関数をsafe Rustだけを使用して実装することはできません。試みは、リスト19-5のようになる可能性がありますが、コンパイルできません。
簡単のため、<code>split_at_mut</code>をメソッドではなく関数として実装し、ジェネリックな型<code>T</code>ではなく、<code>i32</code>のスライス用に実装します。</p>
<pre><code class="language-rust ignore">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid],
     &amp;mut slice[mid..])
}
</code></pre>
<!--
<span class="caption">Listing 19-5: An attempted implementation of
`split_at_mut` using only safe Rust</span>
-->
<p><span class="caption">リスト19-5: safe Rustだけを使用した<code>split_at_mut</code>の未遂の実装</span></p>
<!--
This function first gets the total length of the slice. Then it asserts that
the index given as a parameter is within the slice by checking whether it’s
less than or equal to the length. The assertion means that if we pass an index
that is greater than the index to split the slice at, the function will panic
before it attempts to use that index.
-->
<p>この関数はまず、スライスの全体の長さを得ます。それから引数で与えられた添え字が長さ以下であるかを確認してスライス内にあることをアサートします。
このアサートは、スライスを分割する添え字よりも大きい添え字を渡したら、その添え字を使用しようとする前に関数がパニックすることを意味します。</p>
<!--
Then we return two mutable slices in a tuple: one from the start of the
original slice to the `mid` index and another from `mid` to the end of the
slice.
-->
<p>そして、2つの可変なスライスをタプルで返します: 1つは元のスライスの最初から<code>mid</code>添え字まで、
もう一方は、<code>mid</code>からスライスの終わりまでです。</p>
<!--
When we try to compile the code in Listing 19-5, we’ll get an error.
-->
<p>リスト19-5のコードのコンパイルを試みると、エラーになるでしょう。</p>
<pre><code class="language-text">error[E0499]: cannot borrow `*slice` as mutable more than once at a time
(エラー: 一度に2回以上、`*slice`を可変で借用できません)
 --&gt;
  |
6 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
</code></pre>
<!--
Rust’s borrow checker can’t understand that we’re borrowing different parts of
the slice; it only knows that we’re borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay because the two
slices aren’t overlapping, but Rust isn’t smart enough to know this. When we
know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.
-->
<p>Rustの借用チェッカーには、スライスの異なる部分を借用していることが理解できないのです; 
同じスライスから2回借用していることだけ知っています。2つのスライスが被らないので、
スライスの異なる部分を借用することは、根本的に大丈夫なのですが、コンパイラはこれを知れるほど賢くありません。
プログラマにはコードが大丈夫とわかるのに、コンパイラにはわからないのなら、unsafeコードに手を伸ばすタイミングです。</p>
<!--
Listing 19-6 shows how to use an `unsafe` block, a raw pointer, and some calls
to unsafe functions to make the implementation of `split_at_mut` work.
-->
<p>リスト19-6は<code>unsafe</code>ブロック、生ポインタ、unsafe関数への呼び出しをして<code>split_at_mut</code>の実装が動くようにする方法を示しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-6: Using unsafe code in the implementation of
the `split_at_mut` function</span>
-->
<p><span class="caption">リスト19-6: <code>split_at_mut</code>関数の実装でunsafeコードを使用する</span></p>
<!--
Recall from “The Slice Type” section in Chapter 4 that slices are a pointer to
some data and the length of the slice. We use the `len` method to get the
length of a slice and the `as_mut_ptr` method to access the raw pointer of a
slice. In this case, because we have a mutable slice to `i32` values,
`as_mut_ptr` returns a raw pointer with the type `*mut i32`, which we’ve stored
in the variable `ptr`.
-->
<p>第4章の「スライス型」節から、スライスはなんらかのデータへのポインタとスライスの長さであることを思い出してください。
<code>len</code>メソッドを使用してスライスの長さを得て、<code>as_mut_ptr</code>メソッドを使用してスライスの生ポインタにアクセスしています。
この場合、<code>i32</code>値の可変スライスがあるので、<code>as_mut_ptr</code>は型<code>*mut i32</code>の生ポインタを返し、これを変数<code>ptr</code>に格納しました。</p>
<!--
We keep the assertion that the `mid` index is within the slice. Then we get to
the unsafe code: the `slice::from_raw_parts_mut` function takes a raw pointer
and a length, and it creates a slice. We use this function to create a slice
that starts from `ptr` and is `mid` items long. Then we call the `offset`
method on `ptr` with `mid` as an argument to get a raw pointer that starts at
`mid`, and we create a slice using that pointer and the remaining number of
items after `mid` as the length.
-->
<p><code>mid</code>添え字がスライス内にあるかというアサートを残しています。そして、unsafeコードに到達します:
<code>slice::from_raw_parts_mut</code>関数は、生ポインタと長さを取り、スライスを生成します。この関数を使って、
<code>ptr</code>から始まり、<code>mid</code>の長さのスライスを生成しています。それから<code>ptr</code>に<code>mid</code>を引数として<code>offset</code>メソッドを呼び出し、
<code>mid</code>で始まる生ポインタを得て、そのポインタと<code>mid</code>の後の残りの要素数を長さとして使用してスライスを生成しています。</p>
<!--
The function `slice::from_raw_parts_mut` is unsafe because it takes a raw
pointer and must trust that this pointer is valid. The `offset` method on raw
pointers is also unsafe, because it must trust that the offset location is also
a valid pointer. Therefore, we had to put an `unsafe` block around our calls to
`slice::from_raw_parts_mut` and `offset` so we could call them. By looking at
the code and by adding the assertion that `mid` must be less than or equal to
`len`, we can tell that all the raw pointers used within the `unsafe` block
will be valid pointers to data within the slice. This is an acceptable and
appropriate use of `unsafe`.
-->
<p>関数<code>slice::from_raw_parts_mut</code>は、unsafeです。何故なら、生ポインタを取り、このポインタが有効であることを信用しなければならないからです。
生ポインタの<code>offset</code>メソッドもunsafeです。オフセット位置もまた有効なポインタであることを信用しなければならないからです。
故に、<code>slice::from_raw_parts_mut</code>と<code>offset</code>を呼べるように、その呼び出しの周りに<code>unsafe</code>ブロックを置かなければならなかったのです。
コードを眺めて<code>mid</code>が<code>len</code>以下でなければならないとするアサートを追加することで、
<code>unsafe</code>ブロック内で使用されている生ポインタが全てスライス内のデータへの有効なポインタであることがわかります。
これは、受け入れられ、適切な<code>unsafe</code>の使用法です。</p>
<!--
Note that we don’t need to mark the resulting `split_at_mut` function as
`unsafe`, and we can call this function from safe Rust. We’ve created a safe
abstraction to the unsafe code with an implementation of the function that uses
`unsafe` code in a safe way, because it creates only valid pointers from the
data this function has access to.
-->
<p>できあがった<code>split_at_mut</code>関数を<code>unsafe</code>でマークする必要はなく、この関数をsafe Rustから呼び出せることに注意してください。
<code>unsafe</code>コードを安全に使用する関数の実装で、unsafeコードへの安全な抽象化を行いました。
この関数がアクセスするデータからの有効なポインタだけを生成するからです。</p>
<!--
In contrast, the use of `slice::from_raw_parts_mut` in Listing 19-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice 10,000 items long:
-->
<p>対照的に、リスト19-7の<code>slice::from_raw_parts_mut</code>の使用は、スライスが使用されるとクラッシュする可能性が高いでしょう。
このコードは任意のメモリアドレスを取り、10,000要素の長さのスライスを生成します:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice;

let address = 0x012345usize;
let r = address as *mut i32;

let slice = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-7: Creating a slice from an arbitrary memory
location</span>
-->
<p><span class="caption">リスト19-7: 任意のメモリアドレスからスライスを生成する</span></p>
<!--
We don’t own the memory at this arbitrary location, and there is no guarantee
that the slice this code creates contains valid `i32` values. Attempting to use
`slice` as though it’s a valid slice results in undefined behavior.
-->
<p>この任意の場所のメモリは所有していなく、このコードが生成するスライスに有効な<code>i32</code>値が含まれる保証もありません。
<code>slice</code>を有効なスライスであるかのように使用しようとすると、未定義動作に陥ります。</p>
<!--
#### Using `extern` Functions to Call External Code
-->
<h4 id="extern関数を使用して外部のコードを呼び出す"><a class="header" href="#extern関数を使用して外部のコードを呼び出す"><code>extern</code>関数を使用して、外部のコードを呼び出す</a></h4>
<!--
Sometimes, your Rust code might need to interact with code written in another
language. For this, Rust has a keyword, `extern`, that facilitates the creation
and use of a *Foreign Function Interface (FFI)*. An FFI is a way for a
programming language to define functions and enable a different (foreign)
programming language to call those functions.
-->
<p>時として、自分のRustコードが他の言語で書かれたコードと相互作用する必要が出てくる可能性があります。このために、
Rustには<code>extern</code>というキーワードがあり、これは、
<em>FFI</em>(Foreign Function Interface: 外部関数インターフェイス)の生成と使用を容易にします。
FFIは、あるプログラミング言語に関数を定義させ、異なる(外部の)プログラミング言語にそれらの関数を呼び出すことを可能にする方法です</p>
<!--
Listing 19-8 demonstrates how to set up an integration with the `abs` function
from the C standard library. Functions declared within `extern` blocks are
always unsafe to call from Rust code. The reason is that other languages don’t
enforce Rust’s rules and guarantees, and Rust can’t check them, so
responsibility falls on the programmer to ensure safety.
-->
<p>リスト19-8は、Cの標準ライブラリから<code>abs</code>関数を統合するセットアップ方法をデモしています。
<code>extern</code>ブロック内で宣言された関数は、常にRustコードから呼ぶにはunsafeになります。理由は、
他の言語では、Rustの規則や保証が強制されず、コンパイラもチェックできないので、
安全性を保証する責任はプログラマに降りかかるのです。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        // -3の絶対値は、Cによると{}
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-8: Declaring and calling an `extern` function
defined in another language</span>
-->
<p><span class="caption">リスト19-8: 他の言語で定義された<code>extern</code>関数を宣言し、呼び出す</span></p>
<!--
Within the `extern "C"` block, we list the names and signatures of external
functions from another language we want to call. The `"C"` part defines which
*application binary interface (ABI)* the external function uses: the ABI
defines how to call the function at the assembly level. The `"C"` ABI is the
most common and follows the C programming language’s ABI.
-->
<p><code>extern &quot;C&quot;</code>ブロック内で他の言語から呼び出した関数の名前とシグニチャを列挙します。<code>&quot;C&quot;</code>の部分は、
外部関数がどの<em>ABI</em>(application binary interface: アプリケーション・バイナリ・インターフェイス)を使用しているか定義します:
ABIは関数の呼び出し方法をアセンブリレベルで定義します。<code>&quot;C&quot;</code>ABIは最も一般的でCプログラミング言語のABIに従っています。</p>
<!--
> #### Calling Rust Functions from Other Languages
>
> We can also use `extern` to create an interface that allows other languages
> to call Rust functions. Instead of an `extern` block, we add the `extern`
> keyword and specify the ABI to use just before the `fn` keyword. We also need
> to add a `#[no_mangle]` annotation to tell the Rust compiler not to mangle
> the name of this function. *Mangling* is when a compiler changes the name
> we’ve given a function to a different name that contains more information for
> other parts of the compilation process to consume but is less human readable.
> Every programming language compiler mangles names slightly differently, so
> for a Rust function to be nameable by other languages, we must disable the
> Rust compiler’s name mangling.
>
> In the following example, we make the `call_from_c` function accessible from
> C code, after it’s compiled to a shared library and linked from C:
>
> ```rust
> #[no_mangle]
> pub extern "C" fn call_from_c() {
>     println!("Just called a Rust function from C!");
> }
> ```
>
> This usage of `extern` does not require `unsafe`.
-->
<blockquote>
<h4 id="他の言語からrustの関数を呼び出す"><a class="header" href="#他の言語からrustの関数を呼び出す">他の言語からRustの関数を呼び出す</a></h4>
<p>また、<code>extern</code>を使用して他の言語にRustの関数を呼ばせるインターフェイスを生成することもできます。
<code>extern</code>ブロックの代わりに、<code>extern</code>キーワードを追加し、<code>fn</code>キーワードの直前に使用するABIを指定します。
さらに、<code>#[no_mangle]</code>注釈を追加してRustコンパイラに関数名をマングルしないように指示する必要もあります。
<em>マングル</em>とは、コンパイラが関数に与えた名前を他のコンパイル過程の情報をより多く含むけれども、人間に読みにくい異なる名前にすることです。
全ての言語のコンパイラは、少々異なる方法でマングルを行うので、Rustの関数が他の言語で名前付けできるように、
Rustコンパイラの名前マングルをオフにしなければならないのです。</p>
<p>以下の例では、共有ライブラリにコンパイルし、Cからリンクした後に<code>call_from_c</code>関数をCコードからアクセスできるようにしています:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    // CからRust関数を呼び出したばかり！
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>この<code>extern</code>の使用法では、<code>unsafe</code>は必要ありません。</p>
</blockquote>
<!--
### Accessing or Modifying a Mutable Static Variable
-->
<h3 id="可変で静的な変数にアクセスしたり変更する"><a class="header" href="#可変で静的な変数にアクセスしたり変更する">可変で静的な変数にアクセスしたり、変更する</a></h3>
<!--
Until now, we’ve not talked about *global variables*, which Rust does support
but can be problematic with Rust’s ownership rules. If two threads are
accessing the same mutable global variable, it can cause a data race.
-->
<p>今までずっと、<em>グローバル変数</em>について語りませんでした。グローバル変数をRustは確かにサポートしていますが、
Rustの所有権規則で問題になることもあります。2つのスレッドが同じ可変なグローバル変数にアクセスしていたら、
データ競合を起こすこともあります。</p>
<!--
In Rust, global variables are called *static* variables. Listing 19-9 shows an
example declaration and use of a static variable with a string slice as a
value.
-->
<p>Rustでは、グローバル変数は、<em>static</em>(静的)変数と呼ばれます。リスト19-9は、
値として文字列スライスのある静的変数の宣言例と使用を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
	// 名前は: {}
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-9: Defining and using an immutable static
variable</span>
-->
<p><span class="caption">リスト19-9: 不変で静的な変数を定義し、使用する</span></p>
<!--
Static variables are similar to constants, which we discussed in the
“Differences Between Variables and Constants” section in Chapter 3. The names
of static variables are in `SCREAMING_SNAKE_CASE` by convention, and we *must*
annotate the variable’s type, which is `&'static str` in this example. Static
variables can only store references with the `'static` lifetime, which means
the Rust compiler can figure out the lifetime; we don’t need to annotate it
explicitly. Accessing an immutable static variable is safe.
-->
<p>静的変数は、定数に似ています。定数については、第3章の「変数と定数の違い」節で議論しました。
静的変数の名前は慣習で<code>SCREAMING_SNAKE_CASE</code>(<code>直訳</code>: 叫ぶスネークケース)になり、変数の型を注釈し<em>なければなりません</em>。
この例では<code>&amp;'static str</code>です。静的変数は、<code>'static</code>ライフタイムの参照のみ格納でき、
これは、Rustコンパイラがライフタイムを推量できることを意味します; 明示的に注釈する必要はありません。
不変で静的な変数にアクセスすることは安全です。</p>
<!--
Constants and immutable static variables might seem similar, but a subtle
difference is that values in a static variable have a fixed address in memory.
Using the value will always access the same data. Constants, on the other hand,
are allowed to duplicate their data whenever they’re used.
-->
<p>定数と不変で静的な変数は、類似して見える可能性がありますが、微妙な差異は、
静的変数の値は固定されたメモリアドレスになることです。値を使用すると、常に同じデータにアクセスします。
一方、定数は使用される度にデータを複製させることができます。</p>
<!--
Another difference between constants and static variables is that static
variables can be mutable. Accessing and modifying mutable static variables is
*unsafe*. Listing 19-10 shows how to declare, access, and modify a mutable
static variable named `COUNTER`.
-->
<p>定数と静的変数の別の違いは、静的変数は可変にもなることです。可変で静的な変数にアクセスし変更することは、unsafeです。
リスト19-10は、<code>COUNTER</code>という可変で静的な変数を宣言し、アクセスし、変更する方法を表示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-10: Reading from or writing to a mutable
static variable is unsafe</span>
-->
<p><span class="caption">リスト19-10: 可変で静的な変数を読んだり、書き込むのはunsafeである</span></p>
<!--
As with regular variables, we specify mutability using the `mut` keyword. Any
code that reads or writes from `COUNTER` must be within an `unsafe` block. This
code compiles and prints `COUNTER: 3` as we would expect because it’s single
threaded. Having multiple threads access `COUNTER` would likely result in data
races.
-->
<p>普通の変数同様、<code>mut</code>キーワードを使用して可変性を指定します。<code>COUNTER</code>を読み書きするコードはどれも、<code>unsafe</code>ブロックになければなりません。
シングルスレッドなので、このコードは想定通り、コンパイルでき、<code>COUNTER: 3</code>と出力します。
複数のスレッドに<code>COUNTER</code>にアクセスさせると、データ競合になる可能性が高いでしょう。</p>
<!--
With mutable data that is globally accessible, it’s difficult to ensure there
are no data races, which is why Rust considers mutable static variables to be
unsafe. Where possible, it’s preferable to use the concurrency techniques and
thread-safe smart pointers we discussed in Chapter 16 so the compiler checks
that data accessed from different threads is done safely.
-->
<p>グローバルにアクセス可能な可変なデータがあると、データ競合がないことを保証するのは難しくなり、そのため、
Rustは可変で静的な変数をunsafeと考えるのです。可能なら、コンパイラが、データが異なるスレッドからアクセスされることが安全に行われているかを確認するように、
第16章で議論した並行性テクニックとスレッド安全なスマートポインタを使用するのが望ましいです。</p>
<!--
### Implementing an Unsafe Trait
-->
<h3 id="unsafeなトレイトを実装する"><a class="header" href="#unsafeなトレイトを実装する">unsafeなトレイトを実装する</a></h3>
<!--
The final action that works only with `unsafe` is implementing an unsafe trait.
A trait is unsafe when at least one of its methods has some invariant that the
compiler can’t verify. We can declare that a trait is `unsafe` by adding the
`unsafe` keyword before `trait` and marking the implementation of the trait as
`unsafe` too, as shown in Listing 19-11.
-->
<p><code>unsafe</code>でのみ動く最後の行動は、unsafeなトレイトを実装することです。少なくとも、1つのメソッドにコンパイラが確かめられないなんらかの不変条件があると、
トレイトはunsafeになります。<code>trait</code>の前に<code>unsafe</code>キーワードを追加し、トレイトの実装も<code>unsafe</code>でマークすることで、
トレイトが<code>unsafe</code>であると宣言できます。リスト19-11のようにですね。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe trait Foo {
    // methods go here
    // メソッドがここに来る
}

unsafe impl Foo for i32 {
    // method implementations go here
    // メソッドの実装がここに来る
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-11: Defining and implementing an unsafe
trait</span>
-->
<p><span class="caption">リスト19-11: unsafeなトレイトを定義して実装する</span></p>
<!--
By using `unsafe impl`, we’re promising that we’ll uphold the invariants that
the compiler can’t verify.
-->
<p><code>unsafe impl</code>を使用することで、コンパイラが確かめられない不変条件を守ることを約束しています。</p>
<!--
As an example, recall the `Sync` and `Send` marker traits we discussed in the
“Extensible Concurrency with the `Sync` and `Send` Traits” section in Chapter
16: the compiler implements these traits automatically if our types are
composed entirely of `Send` and `Sync` types. If we implement a type that
contains a type that is not `Send` or `Sync`, such as raw pointers, and we want
to mark that type as `Send` or `Sync`, we must use `unsafe`. Rust can’t verify
that our type upholds the guarantees that it can be safely sent across threads
or accessed from multiple threads; therefore, we need to do those checks
manually and indicate as such with `unsafe`.
-->
<p>例として、第16章の「<code>Sync</code>と<code>Send</code>トレイトで拡張可能な並行性」節で議論した<code>Sync</code>と<code>Send</code>マーカートレイトを思い出してください:
型が完全に<code>Send</code>と<code>Sync</code>型だけで構成されていたら、コンパイラはこれらのトレイトを自動的に実装します。
生ポインタなどの<code>Send</code>や<code>Sync</code>でない型を含む型を実装し、その型を<code>Send</code>や<code>Sync</code>でマークしたいなら、
<code>unsafe</code>を使用しなければなりません。コンパイラは、型がスレッド間を安全に送信できたり、
複数のスレッドから安全にアクセスできるという保証を保持しているか確かめられません; 故に、そのチェックを手動で行い、
<code>unsafe</code>でそのように示唆する必要があります。</p>
<!--
### When to Use Unsafe Code
-->
<h3 id="いつunsafeコードを使用するべきか"><a class="header" href="#いつunsafeコードを使用するべきか">いつunsafeコードを使用するべきか</a></h3>
<!--
Using `unsafe` to take one of the four actions (superpowers) just discussed
isn’t wrong or even frowned upon. But it is trickier to get `unsafe` code
correct because the compiler can’t help uphold memory safety. When you have a
reason to use `unsafe` code, you can do so, and having the explicit `unsafe`
annotation makes it easier to track down the source of problems if they occur.
-->
<p><code>unsafe</code>を使って議論したばかりの4つの行動(強大な力)のうちの1つを行うのは間違っていたり、認められさえもしないものではありません。
ですが、<code>unsafe</code>コードを正しくするのは、より巧妙なことでしょう。コンパイラがメモリ安全性を保持する手助けをできないからです。
<code>unsafe</code>コードを使用する理由があるなら、そうすることができ、明示的に<code>unsafe</code>注釈をすることで問題が起きたら、
その原因を追求するのが容易になります。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch19-00-advanced-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch19-03-advanced-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch19-00-advanced-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch19-03-advanced-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>


    </body>
</html>
