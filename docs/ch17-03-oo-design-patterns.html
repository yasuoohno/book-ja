<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>オブジェクト指向デザインパターンを実装する - The Rust Programming Language 日本語版</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/em-to-bold.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language 日本語版</a></li><li class="chapter-item expanded affix "><a href="foreword.html">まえがき</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">はじめに</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 事始め</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> インストール</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 数当てゲームのプログラミング</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 一般的なプログラミングの概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 変数と可変性</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> データ型</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 関数</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> コメント</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 制御フロー</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 所有権を理解する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 所有権とは？</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 参照と借用</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> スライス型</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 構造体を使用して関係のあるデータを構造化する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 構造体を定義し、インスタンス化する</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 構造体を使ったプログラム例</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> メソッド記法</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enumとパターンマッチング</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Enumを定義する</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match制御フロー演算子</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if letで簡潔な制御フロー</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 肥大化していくプロジェクトをパッケージ、クレート、モジュールを利用して管理する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> パッケージとクレート</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> モジュールを定義して、スコープとプライバシーを制御する</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> モジュールツリーの要素を示すためのパス</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> useキーワードでパスをスコープに持ち込む</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> モジュールを複数のファイルに分割する</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 一般的なコレクション</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ベクタで値のリストを保持する</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 文字列でUTF-8でエンコードされたテキストを保持する</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> キーとそれに紐づいた値をハッシュマップに格納する</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> エラー処理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!で回復不能なエラー</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Resultで回復可能なエラー</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!すべきかするまいか</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ジェネリック型、トレイト、ライフタイム</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ジェネリックなデータ型</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> トレイト：共通の振る舞いを定義する</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ライフタイムで参照を検証する</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 自動テストを書く</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> テストの記述法</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> テストの実行のされ方を制御する</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> テストの体系化</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> 入出力プロジェクト：コマンドラインプログラムを構築する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> コマンドライン引数を受け付ける</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ファイルを読み込む</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> リファクタリングしてモジュール性とエラー処理を向上させる</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> テスト駆動開発でライブラリの機能を開発する</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 環境変数を取り扱う</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 標準出力ではなく標準エラーにエラーメッセージを書き込む</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 関数型言語の機能：イテレータとクロージャ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> クロージャ：環境をキャプチャできる匿名関数</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 一連の要素をイテレータで処理する</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> 入出力プロジェクトを改善する</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> パフォーマンス比較：ループVSイテレータ</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> CargoとCrates.ioについてより詳しく</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> リリースプロファイルでビルドをカスタマイズする</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.ioにクレートを公開する</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargoのワークスペース</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo installでCrates.ioからバイナリをインストールする</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 独自のコマンドでCargoを拡張する</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> スマートポインタ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ヒープのデータを指すBox&lt;T&gt;を使用する</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Derefトレイトでスマートポインタを普通の参照のように扱う</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Dropトレイトで片付け時にコードを走らせる</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;は、参照カウント方式のスマートポインタ</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt;と内部可変性パターン</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 循環参照は、メモリをリークすることもある</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 恐れるな！並行性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> スレッドを使用してコードを同時に走らせる</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> メッセージ受け渡しを使ってスレッド間でデータを転送する</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 状態共有並行性</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> SyncとSendトレイトで拡張可能な並行性</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rustのオブジェクト指向プログラミング機能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> オブジェクト指向言語の特徴</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> トレイトオブジェクトで異なる型の値を許容する</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html" class="active"><strong aria-hidden="true">17.3.</strong> オブジェクト指向デザインパターンを実装する</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> パターンとマッチング</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> パターンが使用されることのある箇所全部</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 論駁可能性：パターンが合致しないかどうか</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> パターン記法</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 高度な機能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> 高度なトレイト</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> 高度な型</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> 高度な関数とクロージャ</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> マクロ</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 最後のプロジェクト：マルチスレッドのWebサーバを構築する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> シングルスレッドのWebサーバを構築する</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> シングルスレッドサーバをマルチスレッド化する</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 正常なシャットダウンと片付け</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 付録</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> 付録A：キーワード</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> 付録B：演算子と記号</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> 付録C：導出可能なトレイト</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> 付録D：便利な開発ツール</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> 付録E：エディション</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> 付録F：本の翻訳</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> 付録G：Rustの作られ方と“Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language 日本語版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
## Implementing an Object-Oriented Design Pattern
-->
<h2 id="オブジェクト指向デザインパターンを実装する"><a class="header" href="#オブジェクト指向デザインパターンを実装する">オブジェクト指向デザインパターンを実装する</a></h2>
<!--
The *state pattern* is an object-oriented design pattern. The crux of the
pattern is that a value has some internal state, which is represented by a set
of *state objects*, and the value’s behavior changes based on the internal
state. The state objects share functionality: in Rust, of course, we use
structs and traits rather than objects and inheritance. Each state object is
responsible for its own behavior and for governing when it should change into
another state. The value that holds a state object knows nothing about the
different behavior of the states or when to transition between states.
-->
<p>ステートパターンは、オブジェクト指向デザインパターンの1つです。このパターンの肝は、
値が一連の<em>ステートオブジェクト</em>で表されるなんらかの内部状態を持ち、
その内部の状態に基づいて値の振る舞いが変化するというものです。ステートオブジェクトは、
機能を共有します: Rustでは、もちろん、オブジェクトと継承ではなく、構造体とトレイトを使用します。
各ステートオブジェクトは、自身の振る舞いと別の状態に変化すべき時を司ることに責任を持ちます。
ステートオブジェクトを保持する値は、状態ごとの異なる振る舞いや、いつ状態が移行するかについては何も知りません。</p>
<!--
Using the state pattern means when the business requirements of the program
change, we won’t need to change the code of the value holding the state or the
code that uses the value. We’ll only need to update the code inside one of the
state objects to change its rules or perhaps add more state objects. Let’s look
at an example of the state design pattern and how to use it in Rust.
-->
<p>ステートパターンを使用することは、プログラムの業務要件が変わる時、状態を保持する値のコードや、
値を使用するコードを変更する必要はないことを意味します。ステートオブジェクトの1つのコードを更新して、
規則を変更したり、あるいはおそらくステートオブジェクトを追加する必要しかないのです。
ステートデザインパターンの例と、そのRustでの使用方法を見ましょう。</p>
<!--
We’ll implement a blog post workflow in an incremental way. The blog’s final
functionality will look like this:
-->
<p>ブログ記事のワークフローを少しずつ実装していきます。ブログの最終的な機能は以下のような感じになるでしょう:</p>
<!--
1. A blog post starts as an empty draft.
2. When the draft is done, a review of the post is requested.
3. When the post is approved, it gets published.
4. Only published blog posts return content to print, so unapproved posts can’t
accidentally be published.
-->
<ol>
<li>ブログ記事は、空の草稿から始まる。</li>
<li>草稿ができたら、査読が要求される。</li>
<li>記事が承認されたら、公開される。</li>
<li>公開されたブログ記事だけが表示する内容を返すので、未承認の記事は、誤って公開されない。</li>
</ol>
<!--
Any other changes attempted on a post should have no effect. For example, if we
try to approve a draft blog post before we’ve requested a review, the post
should remain an unpublished draft.
-->
<p>それ以外の記事に対する変更は、効果を持つべきではありません。例えば、査読を要求する前にブログ記事の草稿を承認しようとしたら、
記事は、非公開の草稿のままになるべきです。</p>
<!--
Listing 17-11 shows this workflow in code form: this is an example usage of the
API we’ll implement in a library crate named `blog`. This won’t compile yet
because we haven’t implemented the `blog` crate yet.
-->
<p>リスト17-11は、このワークフローをコードの形で示しています: これは、
<code>blog</code>というライブラリクレートに実装するAPIの使用例です。まだ<code>blog</code>クレートを実装していないので、
コンパイルはできません。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    // 今日はお昼にサラダを食べた
    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<!--
<span class="caption">Listing 17-11: Code that demonstrates the desired
behavior we want our `blog` crate to have</span>
-->
<p><span class="caption">リスト17-11: <code>blog</code>クレートに欲しい振る舞いをデモするコード</span></p>
<!--
We want to allow the user to create a new draft blog post with `Post::new`.
Then we want to allow text to be added to the blog post while it’s in the draft
state. If we try to get the post’s content immediately, before approval,
nothing should happen because the post is still a draft. We’ve added
`assert_eq!` in the code for demonstration purposes. An excellent unit test for
this would be to assert that a draft blog post returns an empty string from the
`content` method, but we’re not going to write tests for this example.
-->
<p>ユーザが<code>Post::new</code>で新しいブログ記事の草稿を作成できるようにしたいです。それから、
草稿状態の間にブログ記事にテキストを追加できるようにしたいです。承認前に記事の内容を即座に得ようとしたら、
記事はまだ草稿なので、何も起きるべきではありません。デモ目的でコードに<code>assert_eq!</code>を追加しました。
これに対する素晴らしい単体テストは、ブログ記事の草稿が<code>content</code>メソッドから空の文字列を返すことをアサートすることでしょうが、
この例に対してテストを書くつもりはありません。</p>
<!--
Next, we want to enable a request for a review of the post, and we want
`content` to return an empty string while waiting for the review. When the post
receives approval, it should get published, meaning the text of the post will
be returned when `content` is called.
-->
<p>次に、記事の査読を要求できるようにしたく、また査読を待機している間は<code>content</code>に空の文字列を返してほしいです。
記事が承認を受けたら、公開されるべきです。つまり、<code>content</code>を呼んだ時に記事のテキストが返されるということです。</p>
<!--
Notice that the only type we’re interacting with from the crate is the `Post`
type. This type will use the state pattern and will hold a value that will be
one of three state objects representing the various states a post can be
in—draft, waiting for review, or published. Changing from one state to another
will be managed internally within the `Post` type. The states change in
response to the methods called by our library’s users on the `Post` instance,
but they don’t have to manage the state changes directly. Also, users can’t
make a mistake with the states, like publishing a post before it’s reviewed.
-->
<p>クレートから相互作用している唯一の型は、<code>Post</code>だけであることに注意してください。
この型はステートパターンを使用し、記事がなり得る種々の状態を表す3つのステートオブジェクトのうちの1つになる値を保持します。
草稿、査読待ち、公開中です。1つの状態から別の状態への変更は、<code>Post</code>型内部で管理されます。
<code>Post</code>インスタンスのライブラリ使用者が呼び出すメソッドに呼応して状態は変化しますが、
状態の変化を直接管理する必要はありません。また、ユーザは、
査読前に記事を公開するなど状態を誤ることはありません。</p>
<!--
### Defining `Post` and Creating a New Instance in the Draft State
-->
<h3 id="postを定義し草稿状態で新しいインスタンスを生成する"><a class="header" href="#postを定義し草稿状態で新しいインスタンスを生成する"><code>Post</code>を定義し、草稿状態で新しいインスタンスを生成する</a></h3>
<!--
Let’s get started on the implementation of the library! We know we need a
public `Post` struct that holds some content, so we’ll start with the
definition of the struct and an associated public `new` function to create an
instance of `Post`, as shown in Listing 17-12. We’ll also make a private
`State` trait. Then `Post` will hold a trait object of `Box<State>` inside an
`Option` in a private field named `state`. You’ll see why the `Option` is
necessary in a bit.
-->
<p>ライブラリの実装に取り掛かりましょう！なんらかの内容を保持する公開の<code>Post</code>構造体が必要なことはわかるので、
構造体の定義と、関連する公開の<code>Post</code>インスタンスを生成する<code>new</code>関数から始めましょう。リスト17-12のようにですね。
また、非公開の<code>State</code>トレイトも作成します。それから、<code>Post</code>は<code>state</code>という非公開のフィールドに、
<code>Option</code>で<code>Box&lt;State&gt;</code>のトレイトオブジェクトを保持します。<code>Option</code>が必要な理由はすぐわかります。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    state: Option&lt;Box&lt;State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-12: Definition of a `Post` struct and a `new`
function that creates a new `Post` instance, a `State` trait, and a `Draft`
struct</span>
-->
<p><span class="caption">リスト17-12: <code>Post</code>構造体、新規<code>Post</code>インスタンスを生成する<code>new</code>関数、
<code>State</code>トレイト、<code>Draft</code>構造体の定義</span></p>
<!--
The `State` trait defines the behavior shared by different post states, and the
`Draft`, `PendingReview`, and `Published` states will all implement the `State`
trait. For now, the trait doesn’t have any methods, and we’ll start by defining
just the `Draft` state because that is the state we want a post to start in.
-->
<p><code>State</code>トレイトは、異なる記事の状態で共有される振る舞いを定義し、<code>Draft</code>、<code>PendingReview</code>、<code>Published</code>状態は全て、
<code>State</code>トレイトを実装します。今は、トレイトにメソッドは何もなく、<code>Draft</code>が記事の初期状態にしたい状態なので、
その状態だけを定義することから始めます。</p>
<!--
When we create a new `Post`, we set its `state` field to a `Some` value that
holds a `Box`. This `Box` points to a new instance of the `Draft` struct. This
ensures whenever we create a new instance of `Post`, it will start out as a
draft. Because the `state` field of `Post` is private, there is no way to
create a `Post` in any other state! In the `Post::new` function, we set the
`content` field to a new, empty `String`
-->
<p>新しい<code>Post</code>を作る時、<code>state</code>フィールドは、<code>Box</code>を保持する<code>Some</code>値にセットします。
この<code>Box</code>が<code>Draft</code>構造体の新しいインスタンスを指します。これにより、
新しい<code>Post</code>を作る度に、草稿から始まることが保証されます。<code>Post</code>の<code>state</code>フィールドは非公開なので、
<code>Post</code>を他の状態で作成する方法はないのです！<code>Post::new</code>関数では、<code>content</code>フィールドを新しい空の<code>String</code>にセットしています。</p>
<!--
### Storing the Text of the Post Content
-->
<h3 id="記事の内容のテキストを格納する"><a class="header" href="#記事の内容のテキストを格納する">記事の内容のテキストを格納する</a></h3>
<!--
Listing 17-11 showed that we want to be able to call a method named
`add_text` and pass it a `&str` that is then added to the text content of the
blog post. We implement this as a method rather than exposing the `content`
field as `pub`. This means we can implement a method later that will control
how the `content` field’s data is read. The `add_text` method is pretty
straightforward, so let’s add the implementation in Listing 17-13 to the `impl
Post` block:
-->
<p>リスト17-11は、<code>add_text</code>というメソッドを呼び出し、ブログ記事のテキスト内容に追加される<code>&amp;str</code>を渡せるようになりたいことを示しました。
これを<code>content</code>フィールドを<code>pub</code>にして晒すのではなく、メソッドとして実装しています。
これは、後ほど<code>content</code>フィールドデータの読まれ方を制御するメソッドを実装できることを意味しています。
<code>add_text</code>メソッドは非常に素直なので、リスト17-13の実装を<code>impl Post</code>ブロックに追加しましょう:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-13: Implementing the `add_text` method to add
text to a post’s `content`</span>
-->
<p><span class="caption">リスト17-13: 記事の<code>content</code>にテキストを追加する<code>add_text</code>メソッドを実装する</span></p>
<!--
The `add_text` method takes a mutable reference to `self`, because we’re
changing the `Post` instance that we’re calling `add_text` on. We then call
`push_str` on the `String` in `content` and pass the `text` argument to add to
the saved `content`. This behavior doesn’t depend on the state the post is in,
so it’s not part of the state pattern. The `add_text` method doesn’t interact
with the `state` field at all, but it is part of the behavior we want to
support.
-->
<p><code>add_text</code>メソッドは、<code>self</code>への可変参照を取ります。というのも、<code>add_text</code>を呼び出した<code>Post</code>インスタンスを変更しているからです。
それから<code>content</code>の<code>String</code>に対して<code>push_str</code>を呼び出し、<code>text</code>引数を渡して保存された<code>content</code>に追加しています。
この振る舞いは、記事の状態によらないので、ステートパターンの一部ではありません。<code>add_text</code>メソッドは、
<code>state</code>フィールドと全く相互作用しませんが、サポートしたい振る舞いの一部ではあります。</p>
<!--
### Ensuring the Content of a Draft Post Is Empty
-->
<h3 id="草稿の記事の内容は空であることを保証する"><a class="header" href="#草稿の記事の内容は空であることを保証する">草稿の記事の内容は空であることを保証する</a></h3>
<!--
Even after we’ve called `add_text` and added some content to our post, we still
want the `content` method to return an empty string slice because the post is
still in the draft state, as shown on line 8 of Listing 17-11. For now, let’s
implement the `content` method with the simplest thing that will fulfill this
requirement: always returning an empty string slice. We’ll change this later
once we implement the ability to change a post’s state so it can be published.
So far, posts can only be in the draft state, so the post content should always
be empty. Listing 17-14 shows this placeholder implementation:
-->
<p><code>add_text</code>を呼び出して記事に内容を追加した後でさえ、記事はまだ草稿状態なので、
それでも<code>content</code>メソッドには空の文字列スライスを返してほしいです。
リスト17-11の8行目で示したようにですね。とりあえず、この要求を実現する最も単純な方法で<code>content</code>メソッドを実装しましょう:
常に空の文字列スライスを返すことです。一旦、記事の状態を変更する能力を実装したら、公開できるように、
これを後ほど変更します。ここまで、記事は草稿状態にしかなり得ないので、記事の内容は常に空のはずです。
リスト17-14は、この仮の実装を表示しています:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-14: Adding a placeholder implementation for
the `content` method on `Post` that always returns an empty string slice</span>
-->
<p><span class="caption">リスト17-14: <code>Post</code>に常に空の文字列スライスを返す<code>content</code>の仮の実装を追加する</span></p>
<!--
With this added `content` method, everything in Listing 17-11 up to line 8
works as intended.
-->
<p>この追加された<code>content</code>メソッドとともに、リスト17-11の8行目までのコードは、想定通り動きます。</p>
<!--
[Requesting a Review of the Post] Changes ... ともRequesting that [a Review ...]とも読める。どちらがふさわしいだろうか
次の1行目にrequest a review of a post, whichとあるので、前者で訳しておく。
-->
<!--
### Requesting a Review of the Post Changes Its State
-->
<h3 id="記事の査読を要求すると状態が変化する"><a class="header" href="#記事の査読を要求すると状態が変化する">記事の査読を要求すると、状態が変化する</a></h3>
<!--
Next, we need to add functionality to request a review of a post, which should
change its state from `Draft` to `PendingReview`. Listing 17-15 shows this code:
-->
<p>次に、記事の査読を要求する機能を追加する必要があり、これをすると、状態が<code>Draft</code>から<code>PendingReview</code>に変わるはずです。
リスト17-15はこのコードを示しています:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-15: Implementing `request_review` methods on
`Post` and the `State` trait</span>
-->
<p><span class="caption">リスト17-15: <code>Post</code>と<code>State</code>トレイトに<code>request_review</code>メソッドを実装する</span></p>
<!--
We give `Post` a public method named `request_review` that will take a mutable
reference to `self`. Then we call an internal `request_review` method on the
current state of `Post`, and this second `request_review` method consumes the
current state and returns a new state.
-->
<p><code>Post</code>に<code>self</code>への可変参照を取る<code>request_review</code>という公開メソッドを与えます。それから、
<code>Post</code>の現在の状態に対して内部の<code>request_review</code>メソッドを呼び出し、
この2番目の<code>request_review</code>が現在の状態を消費し、新しい状態を返します。</p>
<!--
We’ve added the `request_review` method to the `State` trait; all types that
implement the trait will now need to implement the `request_review` method.
Note that rather than having `self`, `&self`, or `&mut self` as the first
parameter of the method, we have `self: Box<Self>`. This syntax means the
method is only valid when called on a `Box` holding the type. This syntax takes
ownership of `Box<Self>`, invalidating the old state so the state value of the
`Post` can transform into a new state.
-->
<p><code>State</code>トレイトに<code>request_review</code>メソッドを追加しました; このトレイトを実装する型は全て、
これで<code>request_review</code>メソッドを実装する必要があります。メソッドの第1引数に<code>self</code>、<code>&amp;self</code>、<code>&amp;mut self</code>ではなく、
<code>self: Box&lt;Self&gt;</code>としていることに注意してください。この記法は、型を保持する<code>Box</code>に対して呼ばれた時のみ、
このメソッドが合法になることを意味しています。この記法は、<code>Box&lt;Self&gt;</code>の所有権を奪い、古い状態を無効化するので、
<code>Post</code>の状態値は、新しい状態に変形できます。</p>
<!--
To consume the old state, the `request_review` method needs to take ownership
of the state value. This is where the `Option` in the `state` field of `Post`
comes in: we call the `take` method to take the `Some` value out of the `state`
field and leave a `None` in its place, because Rust doesn’t let us have
unpopulated fields in structs. This lets us move the `state` value out of
`Post` rather than borrowing it. Then we’ll set the post’s `state` value to the
result of this operation.
-->
<p>古い状態を消費するために、<code>request_review</code>メソッドは、状態値の所有権を奪う必要があります。
ここで<code>Post</code>の<code>state</code>フィールドの<code>Option</code>が問題になるのです: <code>take</code>メソッドを呼び出して、
<code>state</code>フィールドから<code>Some</code>値を取り出し、その箇所に<code>None</code>を残します。なぜなら、Rustは、
構造体に未代入のフィールドを持たせてくれないからです。これにより、借用するのではなく、
<code>Post</code>の<code>state</code>値をムーブすることができます。それから、記事の<code>state</code>値をこの処理の結果にセットするのです。</p>
<!--
We need to set `state` to `None` temporarily rather than setting it directly
with code like `self.state = self.state.request_review();` to get ownership of
the `state` value. This ensures `Post` can’t use the old `state` value after
we’ve transformed it into a new state.
-->
<p><code>self.state = self.state.request_review();</code>のようなコードで直接<code>state</code>値の所有権を得るよう設定するのではなく、
一時的に<code>None</code>に<code>state</code>をセットする必要があります。これにより、新しい状態に変形した後に、
<code>Post</code>が古い<code>state</code>値を使えないことが保証されるのです。</p>
<!--
The `request_review` method on `Draft` needs to return a new, boxed instance of
a new `PendingReview` struct, which represents the state when a post is waiting
for a review. The `PendingReview` struct also implements the `request_review`
method but doesn’t do any transformations. Rather, it returns itself, because
when we request a review on a post already in the `PendingReview` state, it
should stay in the `PendingReview` state.
-->
<p><code>Draft</code>の<code>request_review</code>メソッドは、新しい<code>PendingReview</code>構造体の新しいボックスのインスタンスを返す必要があり、
これが、記事が査読待ちの時の状態を表します。<code>PendingReview</code>構造体も<code>request_review</code>メソッドを実装しますが、
何も変形はしません。むしろ、自身を返します。というのも、既に<code>PendingReview</code>状態にある記事の査読を要求したら、
<code>PendingReview</code>状態に留まるべきだからです。</p>
<!--
Now we can start seeing the advantages of the state pattern: the
`request_review` method on `Post` is the same no matter its `state` value. Each
state is responsible for its own rules.
-->
<p>ようやくステートパターンの利点が見えてき始めました: <code>state</code>値が何であれ、<code>Post</code>の<code>request_review</code>メソッドは同じです。
各状態は、独自の規則にのみ責任を持ちます。</p>
<!--
We’ll leave the `content` method on `Post` as is, returning an empty string
slice. We can now have a `Post` in the `PendingReview` state as well as in the
`Draft` state, but we want the same behavior in the `PendingReview` state.
Listing 17-11 now works up to line 11!
-->
<p><code>Post</code>の<code>content</code>メソッドを空の文字列スライスを返してそのままにします。
これで<code>Post</code>は<code>PendingReview</code>と<code>Draft</code>状態になり得ますが、<code>PendingReview</code>状態でも、
同じ振る舞いが欲しいです。もうリスト17-11は11行目まで動くようになりました！</p>
<!--
### Adding the `approve` Method that Changes the Behavior of `content`
-->
<h3 id="contentの振る舞いを変化させるapproveメソッドを追加する"><a class="header" href="#contentの振る舞いを変化させるapproveメソッドを追加する"><code>content</code>の振る舞いを変化させる<code>approve</code>メソッドを追加する</a></h3>
<!--
The `approve` method will be similar to the `request_review` method: it will
set `state` to the value that the current state says it should have when that
state is approved, as shown in Listing 17-16:
-->
<p><code>approve</code>メソッドは、<code>request_review</code>メソッドと類似するでしょう: 状態が承認された時に、
現在の状態があるべきと言う値に<code>state</code>をセットします。リスト17-16のようにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-16: Implementing the `approve` method on
`Post` and the `State` trait</span>
-->
<p><span class="caption">リスト17-16: <code>Post</code>と<code>State</code>トレイトに<code>approve</code>メソッドを実装する</span></p>
<!--
We add the `approve` method to the `State` trait and add a new struct that
implements `State`, the `Published` state.
-->
<p><code>State</code>トレイトに<code>approve</code>メソッドを追加し、<code>Published</code>状態という<code>State</code>を実装する新しい構造体を追加します。</p>
<!--
Similar to `request_review`, if we call the `approve` method on a `Draft`, it
will have no effect because it will return `self`. When we call `approve` on
`PendingReview`, it returns a new, boxed instance of the `Published` struct.
The `Published` struct implements the `State` trait, and for both the
`request_review` method and the `approve` method, it returns itself, because
the post should stay in the `Published` state in those cases.
-->
<p><code>request_review</code>のように、<code>Draft</code>に対して<code>approve</code>メソッドを呼び出したら、<code>self</code>を返すので、
何も効果はありません。<code>PendingReview</code>に対して<code>approve</code>を呼び出すと、
<code>Published</code>構造体の新しいボックス化されたインスタンスを返します。<code>Published</code>構造体は<code>State</code>トレイトを実装し、
<code>request_review</code>メソッドと<code>approve</code>メソッド両方に対して、自身を返します。
そのような場合に記事は、<code>Published</code>状態に留まるべきだからです。</p>
<!--
Now we need to update the `content` method on `Post`: if the state is
`Published`, we want to return the value in the post’s `content` field;
otherwise, we want to return an empty string slice, as shown in Listing 17-17:
-->
<p>さて、<code>Post</code>の<code>content</code>メソッドを更新する必要が出てきました: 状態が<code>Published</code>なら、
記事の<code>content</code>フィールドの値を返したいのです; それ以外なら、空の文字列スライスを返したいです。
リスト17-17のようにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait State {
</span><span class="boring">    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str;
</span><span class="boring">}
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(&amp;self)
    }
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-17: Updating the `content` method on `Post` to
delegate to a `content` method on `State`</span>
-->
<p><span class="caption">リスト17-17: <code>Post</code>の<code>content</code>メソッドを更新して<code>State</code>の<code>content</code>メソッドに委譲する</span></p>
<!--
Because the goal is to keep all these rules inside the structs that implement
`State`, we call a `content` method on the value in `state` and pass the post
instance (that is, `self`) as an argument. Then we return the value that is
returned from using the `content` method on the `state` value.
-->
<p>目的は、これらの規則全てを<code>State</code>を実装する構造体の内部に押し留めることなので、<code>state</code>の値に対して<code>content</code>メソッドを呼び出し、
記事のインスタンス(要するに、<code>self</code>)を引数として渡します。そして、<code>state</code>値の<code>content</code>メソッドを使用したことから返ってきた値を返します。</p>
<!--
We call the `as_ref` method on the `Option` because we want a reference to the
value inside the `Option` rather than ownership of the value. Because `state`
is an `Option<Box<State>>`, when we call `as_ref`, an `Option<&Box<State>>` is
returned. If we didn’t call `as_ref`, we would get an error because we can’t
move `state` out of the borrowed `&self` of the function parameter.
-->
<p><code>Option</code>に対して<code>as_ref</code>メソッドを呼び出します。値の所有権ではなく、<code>Option</code>内部の値への参照が欲しいからです。
<code>state</code>は<code>Option&lt;Box&lt;State&gt;&gt;</code>なので、<code>as_ref</code>を呼び出すと、<code>Option&lt;&amp;Box&lt;State&gt;&gt;</code>が返ってきます。
<code>as_ref</code>を呼ばなければ、<code>state</code>を関数引数の借用した<code>&amp;self</code>からムーブできないので、エラーになるでしょう。</p>
<!--
We then call the `unwrap` method, which we know will never panic, because we
know the methods on `Post` ensure that `state` will always contain a `Some`
value when those methods are done. This is one of the cases we talked about in
the “Cases When You Have More Information Than the Compiler” section of Chapter
9 when we know that a `None` value is never possible, even though the compiler
isn’t able to understand that.
-->
<p>さらに<code>unwrap</code>メソッドを呼び出し、これは絶対にパニックしないことがわかっています。何故なら、
<code>Post</code>のメソッドが、それらのメソッドが完了した際に<code>state</code>は常に<code>Some</code>値を含んでいることを保証するからです。
これは、コンパイラには理解不能であるものの、
<code>None</code>値が絶対にあり得ないとわかる第9章の「コンパイラよりも情報を握っている場合」節で語った一例です。</p>
<!--
At this point, when we call `content` on the `&Box<State>`, deref coercion will
take effect on the `&` and the `Box` so the `content` method will ultimately be
called on the type that implements the `State` trait. That means we need to add
`content` to the `State` trait definition, and that is where we’ll put the
logic for what content to return depending on which state we have, as shown in
Listing 17-18:
-->
<p>この時点で、<code>&amp;Box&lt;State&gt;</code>に対して<code>content</code>を呼び出すと、参照外し型強制が<code>&amp;</code>と<code>Box</code>に働くので、
究極的に<code>content</code>メソッドが<code>State</code>トレイトを実装する型に対して呼び出されることになります。
つまり、<code>content</code>を<code>State</code>トレイト定義に追加する必要があり、そこが現在の状態に応じてどの内容を返すべきかというロジックを配置する場所です。
リスト17-18のようにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String
</span><span class="boring">}
</span>trait State {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
struct Published {}

impl State for Published {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-18: Adding the `content` method to the `State`
trait</span>
-->
<p><span class="caption">リスト17-18: <code>State</code>トレイトに<code>content</code>メソッドを追加する</span></p>
<!--
We add a default implementation for the `content` method that returns an empty
string slice. That means we don’t need to implement `content` on the `Draft`
and `PendingReview` structs. The `Published` struct will override the `content`
method and return the value in `post.content`.
-->
<p>空の文字列スライスを返すデフォルト実装を<code>content</code>メソッドに追加しています。これにより、
<code>Draft</code>と<code>PendingReview</code>構造体に<code>content</code>を実装する必要はありません。<code>Published</code>構造体は、
<code>content</code>メソッドをオーバーライドし、<code>post.content</code>の値を返します。</p>
<!--
Note that we need lifetime annotations on this method, as we discussed in
Chapter 10. We’re taking a reference to a `post` as an argument and returning a
reference to part of that `post`, so the lifetime of the returned reference is
related to the lifetime of the `post` argument.
-->
<p>第10章で議論したように、このメソッドにはライフタイム注釈が必要なことに注意してください。
<code>post</code>への参照を引数として取り、その<code>post</code>の一部への参照を返しているので、
返却される参照のライフタイムは、<code>post</code>引数のライフタイムに関連します。</p>
<!--
And we’re done—all of Listing 17-11 now works! We’ve implemented the state
pattern with the rules of the blog post workflow. The logic related to the
rules lives in the state objects rather than being scattered throughout `Post`.
-->
<p>出来上がりました。要するに、リスト17-11はもう動くようになったのです！ブログ記事ワークフローの規則でステートパターンを実装しました。
その規則に関連するロジックは、<code>Post</code>中に散乱するのではなく、ステートオブジェクトに息づいています。</p>
<!--
### Trade-offs of the State Pattern
-->
<h3 id="ステートパターンの代償"><a class="header" href="#ステートパターンの代償">ステートパターンの代償</a></h3>
<!--
The wayで「・・・の仕方によれば」という意味になるらしい
-->
<!--
We’ve shown that Rust is capable of implementing the object-oriented state
pattern to encapsulate the different kinds of behavior a post should have in
each state. The methods on `Post` know nothing about the various behaviors. The
way we organized the code, we have to look in only one place to know the
different ways a published post can behave: the implementation of the `State`
trait on the `Published` struct.
-->
<p>オブジェクト指向のステートパターンを実装して各状態の時に記事がなり得る異なる種類の振る舞いをカプセル化する能力が、
Rustにあることを示してきました。<code>Post</code>のメソッドは、種々の振る舞いについては何も知りません。
コードを体系化する仕方によれば、公開された記事が振る舞うことのある様々な方法を知るには、1箇所のみを調べればいいのです:
<code>Published</code>構造体の<code>State</code>トレイトの実装です。</p>
<!--
FIX: 5行目末尾がよくわからない。The more ..., the more ...のような感じで訳し文脈には合ってそうだが、合ってる自信がない
つまり、This would only increase, the more states we addedのように訳している
-->
<!--
If we were to create an alternative implementation that didn’t use the state
pattern, we might instead use `match` expressions in the methods on `Post` or
even in the `main` code that checks the state of the post and changes behavior
in those places. That would mean we would have to look in several places to
understand all the implications of a post being in the published state! This
would only increase the more states we added: each of those `match` expressions
would need another arm.
-->
<p>ステートパターンを使用しない対立的な実装を作ることになったら、代わりに<code>Post</code>のメソッドか、
あるいは記事の状態を確認し、それらの箇所(<code>編注</code>: <code>Post</code>のメソッドのことか)の振る舞いを変更する<code>main</code>コードでさえ、
<code>match</code>式を使用したかもしれません。そうなると、複数個所を調べて記事が公開状態にあることの裏の意味全てを理解しなければならなくなります！
これは、追加した状態が増えれば、さらに上がるだけでしょう: 各<code>match</code>式には、別のアームが必要になるのです。</p>
<!--
With the state pattern, the `Post` methods and the places we use `Post` don’t
need `match` expressions, and to add a new state, we would only need to add a
new struct and implement the trait methods on that one struct.
-->
<p>ステートパターンでは、<code>Post</code>のメソッドと<code>Post</code>を使用する箇所で、<code>match</code>式が必要になることはなく、
新しい状態を追加するのにも、新しい構造体を追加し、その1つの構造体にトレイトメソッドを実装するだけでいいわけです。</p>
<!--
The implementation using the state pattern is easy to extend to add more
functionality. To see the simplicity of maintaining code that uses the state
pattern, try a few of these suggestions:
-->
<p>ステートパターンを使用した実装は、拡張して機能を増やすことが容易です。
ステートパターンを使用するコードの管理の単純さを確認するために、以下の提言を試してみてください:</p>
<!--
* Add a `reject` method that changes the post’s state from `PendingReview` back
to `Draft`.
* Require two calls to `approve` before the state can be changed to `Published`.
* Allow users to add text content only when a post is in the `Draft` state.
Hint: have the state object responsible for what might change about the
content but not responsible for modifying the `Post`.
-->
<ul>
<li>記事の状態を<code>PendingReview</code>から<code>Draft</code>に戻す<code>reject</code>メソッドを追加する。</li>
<li>状態が<code>Published</code>に変化させられる前に<code>approve</code>を2回呼び出す必要があるようにする。</li>
<li>記事が<code>Draft</code>状態の時のみテキスト内容をユーザが追加できるようにする。
ヒント: ステートオブジェクトに内容について変わる可能性のあるものの責任を持たせつつも、
<code>Post</code>を変更することには責任を持たせない。</li>
</ul>
<!--
One downside of the state pattern is that, because the states implement the
transitions between states, some of the states are coupled to each other. If we
add another state between `PendingReview` and `Published`, such as `Scheduled`,
we would have to change the code in `PendingReview` to transition to
`Scheduled` instead. It would be less work if `PendingReview` didn’t need to
change with the addition of a new state, but that would mean switching to
another design pattern.
-->
<p>ステートパターンの欠点の1つは、状態が状態間の遷移を実装しているので、状態の一部が密に結合した状態になってしまうことです。
<code>PendingReview</code>と<code>Published</code>の間に、<code>Scheduled</code>のような別の状態を追加したら、
代わりに<code>PendingReview</code>のコードを<code>Scheduled</code>に遷移するように変更しなければならないでしょう。
状態が追加されても<code>PendingReview</code>を変更する必要がなければ、作業が減りますが、
そうすれば別のデザインパターンに切り替えることになるでしょう。</p>
<!--
Another downside is that we’ve duplicated some logic. To eliminate some of the
duplication, we might try to make default implementations for the
`request_review` and `approve` methods on the `State` trait that return `self`;
however, this would violate object safety, because the trait doesn’t know what
the concrete `self` will be exactly. We want to be able to use `State` as a
trait object, so we need its methods to be object safe.
-->
<p>別の欠点は、ロジックの一部を重複させてしまうことです。重複を除くためには、
<code>State</code>トレイトの<code>request_review</code>と<code>approve</code>メソッドに<code>self</code>を返すデフォルト実装を試みる可能性があります;
ですが、これはオブジェクト安全性を侵害するでしょう。というのも、具体的な<code>self</code>が一体なんなのかトレイトには知りようがないからです。
<code>State</code>をトレイトオブジェクトとして使用できるようにしたいので、メソッドにはオブジェクト安全になってもらう必要があるのです。</p>
<!--
Other duplication includes the similar implementations of the `request_review`
and `approve` methods on `Post`. Both methods delegate to the implementation of
the same method on the value in the `state` field of `Option` and set the new
value of the `state` field to the result. If we had a lot of methods on `Post`
that followed this pattern, we might consider defining a macro to eliminate the
repetition (see Appendix D for more on Macros).
-->
<p>他の重複には、<code>Post</code>の<code>request_review</code>と<code>approve</code>メソッドの実装が似ていることが含まれます。
両メソッドは<code>Option</code>の<code>state</code>の値に対する同じメソッドの実装に委譲していて、<code>state</code>フィールドの新しい値を結果にセットします。
このパターンに従う<code>Post</code>のメソッドが多くあれば、マクロを定義して繰り返しを排除することも考慮する可能性があります(マクロについては付録Dを参照)。</p>
<!--
By implementing the state pattern exactly as it’s defined for object-oriented
languages, we’re not taking as full advantage of Rust’s strengths as we could.
Let’s look at some changes we can make to the `blog` crate that can make
invalid states and transitions into compile time errors.
-->
<p>オブジェクト指向言語で定義されている通り忠実にステートパターンを実装することで、
Rustの強みをできるだけ発揮していません。<code>blog</code>クレートに対して行える無効な状態と遷移をコンパイルエラーにできる変更に目を向けましょう。</p>
<!--
#### Encoding States and Behavior as Types
-->
<h4 id="状態と振る舞いを型としてコード化する"><a class="header" href="#状態と振る舞いを型としてコード化する">状態と振る舞いを型としてコード化する</a></h4>
<!--
We’ll show you how to rethink the state pattern to get a different set of
trade-offs. Rather than encapsulating the states and transitions completely so
outside code has no knowledge of them, we’ll encode the states into different
types. Consequently, Rust’s type checking system will prevent attempts to use
draft posts where only published posts are allowed by issuing a compiler error.
-->
<p>ステートパターンを再考して別の代償を得る方法をお見せします。状態と遷移を完全にカプセル化して、
外部のコードに知らせないようにするよりも、状態を異なる型にコード化します。結果的に、
Rustの型検査システムが、公開記事のみが許可される箇所で草稿記事の使用を試みることをコンパイルエラーを発して阻止します。</p>
<!--
Let’s consider the first part of `main` in Listing 17-11:
-->
<p>リスト17-11の<code>main</code>の最初の部分を考えましょう:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
}
</code></pre>
<!--
We still enable the creation of new posts in the draft state using `Post::new`
and the ability to add text to the post’s content. But instead of having a
`content` method on a draft post that returns an empty string, we’ll make it so
draft posts don’t have the `content` method at all. That way, if we try to get
a draft post’s content, we’ll get a compiler error telling us the method
doesn’t exist. As a result, it will be impossible for us to accidentally
display draft post content in production, because that code won’t even compile.
Listing 17-19 shows the definition of a `Post` struct and a `DraftPost` struct,
as well as methods on each:
-->
<p>それでも、<code>Post::new</code>で草稿状態の新しい記事を生成することと記事の内容にテキストを追加する能力は可能にします。
しかし、空の文字列を返す草稿記事の<code>content</code>メソッドを保持する代わりに、草稿記事は、
<code>content</code>メソッドを全く持たないようにします。そうすると、草稿記事の内容を得ようとしたら、
メソッドが存在しないというコンパイルエラーになるでしょう。その結果、
誤ってプロダクションコードで草稿記事の内容を表示することが不可能になります。
そのようなコードは、コンパイルさえできないからです。リスト17-19は<code>Post</code>構造体、<code>DraftPost</code>構造体、
さらにメソッドの定義を示しています:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-19: A `Post` with a `content` method and a
`DraftPost` without a `content` method</span>
-->
<p><span class="caption">リスト17-19: <code>content</code>メソッドのある<code>Post</code>と<code>content</code>メソッドのない<code>DraftPost</code></span></p>
<!--
Both the `Post` and `DraftPost` structs have a private `content` field that
stores the blog post text. The structs no longer have the `state` field because
we’re moving the encoding of the state to the types of the structs. The `Post`
struct will represent a published post, and it has a `content` method that
returns the `content`.
-->
<p><code>Post</code>と<code>DraftPost</code>構造体どちらにもブログ記事のテキストを格納する非公開の<code>content</code>フィールドがあります。
状態のコード化を構造体の型に移動したので、この構造体は最早<code>state</code>フィールドを持ちません。
<code>Post</code>は公開された記事を表し、<code>content</code>を返す<code>content</code>メソッドがあります。</p>
<!--
We still have a `Post::new` function, but instead of returning an instance of
`Post`, it returns an instance of `DraftPost`. Because `content` is private
and there aren’t any functions that return `Post`, it’s not possible to create
an instance of `Post` right now.
-->
<p>それでも<code>Post::new</code>関数はありますが、<code>Post</code>のインスタンスを返すのではなく、<code>DraftPost</code>のインスタンスを返します。
<code>content</code>は非公開であり、<code>Post</code>を返す関数も存在しないので、現状<code>Post</code>のインスタンスを生成することは不可能です。</p>
<!--
The `DraftPost` struct has an `add_text` method, so we can add text to
`content` as before, but note that `DraftPost` does not have a `content` method
defined! So now the program ensures all posts start as draft posts, and draft
posts don’t have their content available for display. Any attempt to get around
these constraints will result in a compiler error.
-->
<p><code>DraftPost</code>構造体には、以前のようにテキストを<code>content</code>に追加できるよう<code>add_text</code>メソッドがありますが、
<code>DraftPost</code>には<code>content</code>メソッドが定義されていないことに注目してください！
従って、これでプログラムは、全ての記事が草稿記事から始まり、草稿記事は表示できる内容がないことを保証します。
この制限をかいくぐる試みは、全てコンパイルエラーに落ち着くでしょう。</p>
<!--
#### Implementing Transitions as Transformations into Different Types
-->
<h4 id="遷移を異なる型への変形として実装する"><a class="header" href="#遷移を異なる型への変形として実装する">遷移を異なる型への変形として実装する</a></h4>
<!--
1行目the rule thatは同格で訳しているが、the rule that a draft post has (the rule) to be...でも意味は通りそう
-->
<!--
So how do we get a published post? We want to enforce the rule that a draft
post has to be reviewed and approved before it can be published. A post in the
pending review state should still not display any content. Let’s implement
these constraints by adding another struct, `PendingReviewPost`, defining the
`request_review` method on `DraftPost` to return a `PendingReviewPost`, and
defining an `approve` method on `PendingReviewPost` to return a `Post`, as
shown in Listing 17-20:
-->
<p>では、どうやって公開された記事を得るのでしょうか？公開される前に草稿記事は査読され、
承認されなければならないという規則を強制したいです。査読待ち状態の記事は、それでも内容を表示するべきではありません。
別の構造体<code>PendingReviewPost</code>を追加し、<code>DraftPost</code>に<code>PendingReviewPost</code>を返す<code>request_review</code>メソッドを定義し、
<code>PendingReviewPost</code>に<code>Post</code>を返す<code>approve</code>メソッドを定義してこれらの制限を実装しましょう。リスト17-20のようにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--

    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-20: A `PendingReviewPost` that gets created by
calling `request_review` on `DraftPost` and an `approve` method that turns a
`PendingReviewPost` into a published `Post`</span>
-->
<p><span class="caption">リスト17-20: <code>DraftPost</code>の<code>request_review</code>を呼び出すことで生成される<code>PendingReviewPost</code>と、
<code>PendingReviewPost</code>を公開された<code>Post</code>に変換する<code>approve</code>メソッド</span></p>
<!--
The `request_review` and `approve` methods take ownership of `self`, thus
consuming the `DraftPost` and `PendingReviewPost` instances and transforming
them into a `PendingReviewPost` and a published `Post`, respectively. This way,
we won’t have any lingering `DraftPost` instances after we’ve called
`request_review` on them, and so forth. The `PendingReviewPost` struct doesn’t
have a `content` method defined on it, so attempting to read its content
results in a compiler error, as with `DraftPost`. Because the only way to get a
published `Post` instance that does have a `content` method defined is to call
the `approve` method on a `PendingReviewPost`, and the only way to get a
`PendingReviewPost` is to call the `request_review` method on a `DraftPost`,
we’ve now encoded the blog post workflow into the type system.
-->
<p><code>request_review</code>と<code>approve</code>メソッドは<code>self</code>の所有権を奪い、故に<code>DraftPost</code>と<code>PendingReviewPost</code>インスタンスを消費し、
それぞれ<code>PendingReviewPost</code>と公開された<code>Post</code>に変形します。このように、
<code>DraftPost</code>インスタンスに<code>request_review</code>を呼んだ後には、<code>DraftPost</code>インスタンスは生きながらえず、
以下同様です。<code>PendingReviewPost</code>構造体には、<code>content</code>メソッドが定義されていないので、
<code>DraftPost</code>同様に、その内容を読もうとするとコンパイルエラーに落ち着きます。
<code>content</code>メソッドが確かに定義された公開された<code>Post</code>インスタンスを得る唯一の方法が、
<code>PendingReviewPost</code>に対して<code>approve</code>を呼び出すことであり、<code>PendingReviewPost</code>を得る唯一の方法が、
<code>DraftPost</code>に<code>request_review</code>を呼び出すことなので、これでブログ記事のワークフローを型システムにコード化しました。</p>
<!--
But we also have to make some small changes to `main`. The `request_review` and
`approve` methods return new instances rather than modifying the struct they’re
called on, so we need to add more `let post =` shadowing assignments to save
the returned instances. We also can’t have the assertions about the draft and
pending review post’s contents be empty strings, nor do we need them: we can’t
compile code that tries to use the content of posts in those states any longer.
The updated code in `main` is shown in Listing 17-21:
-->
<p>ですが、さらに<code>main</code>にも多少小さな変更を行わなければなりません。<code>request_review</code>と<code>approve</code>メソッドは、
呼ばれた構造体を変更するのではなく、新しいインスタンスを返すので、<code>let post =</code>というシャドーイング代入をもっと追加し、
返却されたインスタンスを保存する必要があります。また、草稿と査読待ち記事の内容を空の文字列でアサートすることも、
する必要もありません: 最早、その状態にある記事の内容を使用しようとするコードはコンパイル不可能だからです。
<code>main</code>の更新されたコードは、リスト17-21に示されています:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<!--
<span class="caption">Listing 17-21: Modifications to `main` to use the new
implementation of the blog post workflow</span>
-->
<p><span class="caption">リスト17-21: ブログ記事ワークフローの新しい実装を使う<code>main</code>の変更</span></p>
<!--
The changes we needed to make to `main` to reassign `post` mean that this
implementation doesn’t quite follow the object-oriented state pattern anymore:
the transformations between the states are no longer encapsulated entirely
within the `Post` implementation. However, our gain is that invalid states are
now impossible because of the type system and the type checking that happens at
compile time! This ensures that certain bugs, such as display of the content of
an unpublished post, will be discovered before they make it to production.
-->
<p><code>post</code>を再代入するために<code>main</code>に行う必要のあった変更は、この実装がもう、
全くオブジェクト指向のステートパターンに沿っていないことを意味します: 
状態間の変形は最早、<code>Post</code>実装内に完全にカプセル化されていません。
ですが、型システムとコンパイル時に起きる型チェックのおかげでもう無効な状態があり得なくなりました。
これにより、未公開の記事の内容が表示されるなどの特定のバグが、プロダクションコードに移る前に発見されることが保証されます。</p>
<!--
特に2行目中盤、as it is afterがよくわからない
as it is, afterで訳した
-->
<!--
Try the tasks suggested for additional requirements that we mentioned at the
start of this section on the `blog` crate as it is after Listing 17-20 to see
what you think about the design of this version of the code. Note that some of
the tasks might be completed already in this design.
-->
<p><code>blog</code>クレートに関してこの節の冒頭で触れた追加の要求に提言される作業をそのままリスト17-20の後に試してみて、
このバージョンのコードについてどう思うか確かめてください。この設計では、
既に作業の一部が達成されている可能性があることに注意してください。</p>
<!--
We’ve seen that even though Rust is capable of implementing object-oriented
design patterns, other patterns, such as encoding state into the type system,
are also available in Rust. These patterns have different trade-offs. Although
you might be very familiar with object-oriented patterns, rethinking the
problem to take advantage of Rust’s features can provide benefits, such as
preventing some bugs at compile time. Object-oriented patterns won’t always be
the best solution in Rust due to certain features, like ownership, that
object-oriented languages don’t have.
-->
<p>Rustは、オブジェクト指向のデザインパターンを実装する能力があるものの、状態を型システムにコード化するなどの他のパターンも、
Rustでは利用可能なことを確かめました。これらのパターンには、異なる代償があります。
あなたが、オブジェクト指向のパターンには非常に馴染み深い可能性があるものの、問題を再考してRustの機能の強みを活かすと、
コンパイル時に一部のバグを回避できるなどの利益が得られることもあります。オブジェクト指向のパターンは、
オブジェクト指向言語にはない所有権などの特定の機能によりRustでは、必ずしも最善の解決策ではないでしょう。</p>
<!--
## Summary
-->
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<!--
No matter whether or not you think Rust is an object-oriented language after
reading this chapter, you now know that you can use trait objects to get some
object-oriented features in Rust. Dynamic dispatch can give your code some
flexibility in exchange for a bit of runtime performance. You can use this
flexibility to implement object-oriented patterns that can help your code’s
maintainability. Rust also has other features, like ownership, that
object-oriented languages don’t have. An object-oriented pattern won’t always
be the best way to take advantage of Rust’s strengths, but is an available
option.
-->
<p>この章読了後に、あなたがRustはオブジェクト指向言語であると考えるかどうかに関わらず、
もうトレイトオブジェクトを使用してRustでオブジェクト指向の機能の一部を得ることができると知っています。
ダイナミックディスパッチは、多少の実行時性能と引き換えにコードに柔軟性を<ruby>齎<rp>(</rp><rt>もたら</rt><rp>)</rp></ruby>してくれます。
この柔軟性を利用してコードのメンテナンス性に寄与するオブジェクト指向パターンを実装することができます。
Rustにはまた、オブジェクト指向言語にはない所有権などの他の機能もあります。オブジェクト指向パターンは、
必ずしもRustの強みを活かす最善の方法にはなりませんが、利用可能な選択肢の1つではあります。</p>
<!--
Next, we’ll look at patterns, which are another of Rust’s features that enable
lots of flexibility. We’ve looked at them briefly throughout the book but
haven’t seen their full capability yet. Let’s go!
-->
<p>次は、パターンを見ます。パターンも多くの柔軟性を可能にするRustの別の機能です。
本全体を通して僅かに見かけましたが、まだその全能力は目の当たりにしていません。さあ、行きましょう！</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-02-trait-objects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch18-00-patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-02-trait-objects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch18-00-patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>


    </body>
</html>
