<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust Programming Language 日本語版</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/em-to-bold.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language 日本語版</a></li><li class="chapter-item expanded affix "><a href="foreword.html">まえがき</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">はじめに</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 事始め</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> インストール</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 数当てゲームのプログラミング</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 一般的なプログラミングの概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 変数と可変性</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> データ型</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 関数</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> コメント</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 制御フロー</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 所有権を理解する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 所有権とは？</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 参照と借用</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> スライス型</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 構造体を使用して関係のあるデータを構造化する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 構造体を定義し、インスタンス化する</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 構造体を使ったプログラム例</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> メソッド記法</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enumとパターンマッチング</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Enumを定義する</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match制御フロー演算子</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if letで簡潔な制御フロー</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 肥大化していくプロジェクトをパッケージ、クレート、モジュールを利用して管理する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> パッケージとクレート</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> モジュールを定義して、スコープとプライバシーを制御する</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> モジュールツリーの要素を示すためのパス</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> useキーワードでパスをスコープに持ち込む</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> モジュールを複数のファイルに分割する</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 一般的なコレクション</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> ベクタで値のリストを保持する</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 文字列でUTF-8でエンコードされたテキストを保持する</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> キーとそれに紐づいた値をハッシュマップに格納する</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> エラー処理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic!で回復不能なエラー</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Resultで回復可能なエラー</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic!すべきかするまいか</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> ジェネリック型、トレイト、ライフタイム</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> ジェネリックなデータ型</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> トレイト：共通の振る舞いを定義する</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> ライフタイムで参照を検証する</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 自動テストを書く</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> テストの記述法</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> テストの実行のされ方を制御する</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> テストの体系化</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> 入出力プロジェクト：コマンドラインプログラムを構築する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> コマンドライン引数を受け付ける</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> ファイルを読み込む</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> リファクタリングしてモジュール性とエラー処理を向上させる</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> テスト駆動開発でライブラリの機能を開発する</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 環境変数を取り扱う</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 標準出力ではなく標準エラーにエラーメッセージを書き込む</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> 関数型言語の機能：イテレータとクロージャ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> クロージャ：環境をキャプチャできる匿名関数</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 一連の要素をイテレータで処理する</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> 入出力プロジェクトを改善する</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> パフォーマンス比較：ループVSイテレータ</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> CargoとCrates.ioについてより詳しく</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> リリースプロファイルでビルドをカスタマイズする</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Crates.ioにクレートを公開する</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargoのワークスペース</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> cargo installでCrates.ioからバイナリをインストールする</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> 独自のコマンドでCargoを拡張する</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> スマートポインタ</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> ヒープのデータを指すBox&lt;T&gt;を使用する</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Derefトレイトでスマートポインタを普通の参照のように扱う</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Dropトレイトで片付け時にコードを走らせる</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;は、参照カウント方式のスマートポインタ</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt;と内部可変性パターン</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 循環参照は、メモリをリークすることもある</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 恐れるな！並行性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> スレッドを使用してコードを同時に走らせる</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> メッセージ受け渡しを使ってスレッド間でデータを転送する</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 状態共有並行性</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> SyncとSendトレイトで拡張可能な並行性</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rustのオブジェクト指向プログラミング機能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> オブジェクト指向言語の特徴</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> トレイトオブジェクトで異なる型の値を許容する</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> オブジェクト指向デザインパターンを実装する</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> パターンとマッチング</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> パターンが使用されることのある箇所全部</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> 論駁可能性：パターンが合致しないかどうか</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> パターン記法</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 高度な機能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> 高度なトレイト</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> 高度な型</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> 高度な関数とクロージャ</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> マクロ</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 最後のプロジェクト：マルチスレッドのWebサーバを構築する</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> シングルスレッドのWebサーバを構築する</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> シングルスレッドサーバをマルチスレッド化する</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 正常なシャットダウンと片付け</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 付録</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> 付録A：キーワード</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> 付録B：演算子と記号</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> 付録C：導出可能なトレイト</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> 付録D：便利な開発ツール</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> 付録E：エディション</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> 付録F：本の翻訳</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> 付録G：Rustの作られ方と“Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language 日本語版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
# The Rust Programming Language
-->
<h1 id="the-rust-programming-language-日本語版"><a class="header" href="#the-rust-programming-language-日本語版">The Rust Programming Language 日本語版</a></h1>
<!--
*by Steve Klabnik and Carol Nichols, with contributions from the Rust Community*
-->
<p><em>著：Steve Klabnik、Carol Nichols、貢献：Rustコミュニティ</em></p>
<!--
This version of the text assumes you’re using Rust 1.58 (released 2022-01-13)
or later. See the [“Installation” section of Chapter 1][install]
to install or update Rust.
-->
<p>このテキストのこの版ではRust 1.58（2022年1月13日リリース）かそれ以降が使われていることを前提にしています。
Rustをインストールしたりアップデートしたりするには<a href="ch01-01-installation.html">第1章の「インストール」節</a>を読んでください。</p>
<!--
The HTML format is available online at
[https://doc.rust-lang.org/stable/book/](https://doc.rust-lang.org/stable/book/)
and offline with installations of Rust made with `rustup`; run `rustup docs
--book` to open.
-->
<p>HTML版は<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a>で公開されています。
オフラインのときは、<code>rustup</code>でインストールしたRustを使って<code>rustup docs --book</code>で開けます。</p>
<blockquote>
<p>訳注：日本語のHTML版は<a href="https://doc.rust-jp.rs/book-ja/">https://doc.rust-jp.rs/book-ja/</a>で公開されています。
<code>rustup</code>を使ってオフラインで読むことはできません。</p>
</blockquote>
<!--
Several community [translations] are also available.
-->
<p>また、コミュニティによるいくつかの<a href="appendix-06-translation.html">翻訳版</a>もあります。</p>
<!--
This text is available in [paperback and ebook format from No Starch
Press][nsprust].
-->
<p>このテキストの（英語版の）<a href="https://nostarch.com/rust">ペーパーバック版と電子書籍版はNo Starch出版</a>から発売されています。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Foreword
-->
<h1 id="まえがき"><a class="header" href="#まえがき">まえがき</a></h1>
<!--
It wasn’t always so clear, but the Rust programming language is fundamentally
about *empowerment*: no matter what kind of code you are writing now, Rust
empowers you to reach farther, to program with confidence in a wider variety of
domains than you did before.
-->
<p>すぐにはわかりにくいかもしれませんが、Rustプログラミング言語は、エンパワーメント(empowerment)を根本原理としています:
どんな種類のコードを現在書いているにせよ、Rustは幅広い領域で以前よりも遠くへ到達し、
自信を持ってプログラムを組む力を与え(empower)ます。</p>
<!--
Take, for example, “systems-level” work that deals with low-level details of
memory management, data representation, and concurrency. Traditionally, this
realm of programming is seen as arcane, accessible only to a select few who
have devoted the necessary years learning to avoid its infamous pitfalls. And
even those who practice it do so with caution, lest their code be open to
exploits, crashes, or corruption.
-->
<p>一例を挙げると、メモリ管理やデータ表現、並行性などの低レベルな詳細を扱う「システムレベル」のプログラミングがあります。
伝統的にこの分野は難解で、年月をかけてやっかいな落とし穴を回避する術を習得した選ばれし者にだけ可能と見なされています。
そのように鍛錬を積んだ者でさえ注意が必要で、さもないと書いたコードがクラッキングの糸口になったりクラッシュやデータ破損を引き起こしかねないのです。</p>
<!--
Rust breaks down these barriers by eliminating the old pitfalls and providing a
friendly, polished set of tools to help you along the way. Programmers who need
to “dip down” into lower-level control can do so with Rust, without taking on
the customary risk of crashes or security holes, and without having to learn
the fine points of a fickle toolchain. Better yet, the language is designed to
guide you naturally towards reliable code that is efficient in terms of speed
and memory usage.
-->
<p>この難しさを取り除くために、Rustは、古い落とし穴を排除し、その過程で使いやすく役に立つ洗練された一連のツールを提供します。
低レベルな制御に「下がる」必要があるプログラマは、お決まりのクラッシュやセキュリティホールのリスクを負わず、
気まぐれなツールチェーンのデリケートな部分を学ぶ必要なくRustで同じことができます。さらにいいことに、
Rustは、スピードとメモリ使用の観点で効率的な信頼性の高いコードへと自然に導くよう設計されています。</p>
<!--
Programmers who are already working with low-level code can use Rust to raise
their ambitions. For example, introducing parallelism in Rust is a relatively
low-risk operation: the compiler will catch the classical mistakes for you. And
you can tackle more aggressive optimizations in your code with the confidence
that you won’t accidentally introduce crashes or vulnerabilities.
-->
<p>既に低レベルコードに取り組んでいるプログラマは、Rustを使用してさらなる高みを目指せます。例えば、
Rustで並列性を導入することは、比較的低リスクです: コンパイラが伝統的なミスを捕捉してくれるのです。
そして、クラッシュや脆弱性の糸口を誤って導入しないという自信を持ってコードの大胆な最適化に取り組めるのです。</p>
<!--
But Rust isn’t limited to low-level systems programming. It’s expressive and
ergonomic enough to make CLI apps, web servers, and many other kinds of code
quite pleasant to write — you’ll find simple examples of both later in the
book. Working with Rust allows you to build skills that transfer from one
domain to another; you can learn Rust by writing a web app, then apply those
same skills to target your Raspberry Pi.
-->
<p>ですが、Rustは低レベルなシステムプログラミングに限定されているわけではありません。十分に表現力豊かでエルゴノミックなので、
コマンドラインアプリやWebサーバ、その他様々な楽しいコードを書けます。この本の後半に両者の単純な例が見つかるでしょう。
Rustを使うことで1つの領域から他の領域へと使い回せる技術を身につけられます;
ウェブアプリを書いてRustを学び、それからその同じ技術をラズベリーパイを対象に適用できるのです。</p>
<!--
This book fully embraces the potential of Rust to empower its users. It’s a
friendly and approachable text intended to help you level up not just your
knowledge of Rust, but also your reach and confidence as a programmer in
general. So dive in, get ready to learn—and welcome to the Rust community!
-->
<p>この本は、ユーザに力を与え(empower)るRustのポテンシャルを全て含んでいます。あなたのRustの知識のみをレベルアップさせるだけでなく、
プログラマとしての全般的な能力や自信をもレベルアップさせる手助けを意図した親しみやすくわかりやすいテキストです。
さあ、飛び込んで学ぶ準備をしてください。Rustコミュニティへようこそ！</p>
<!--
— Nicholas Matsakis and Aaron Turon
-->
<ul>
<li>ニコラス・マットサキス(Nicholas Matsakis)とアーロン・チューロン(Aaron Turon)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
# Introduction
-->
<h1 id="はじめに"><a class="header" href="#はじめに">はじめに</a></h1>
<!--
> Note: This edition of the book is the same as [The Rust Programming
> Language][nsprust] available in print and ebook format from [No Starch
> Press][nsp].
-->
<blockquote>
<p>注釈: この本のこの版は、本として利用可能な<a href="https://nostarch.com/rust">The Rust Programming Language</a>と、
<a href="https://nostarch.com/">No Starch Press</a>のebook形式と同じです。</p>
</blockquote>
<!--
Welcome to *The Rust Programming Language*, an introductory book about Rust.
-->
<p><em>The Rust Programming Language</em>へようこそ。Rustに関する入門書です。</p>
<!--
The Rust programming language helps you write faster, more reliable software.
High-level ergonomics and low-level control are often at odds in programming
language design; Rust challenges that conflict. Through balancing powerful
technical capacity and a great developer experience, Rust gives you the option
to control low-level details (such as memory usage) without all the hassle
traditionally associated with such control.
-->
<p>Rustプログラミング言語は、高速で信頼できるソフトウェアを書く手助けをしてくれます。
高レベルのエルゴノミクス(<code>訳注</code>: ergonomicsとは、人間工学的という意味。砕いて言えば、人間に優しいということ)と低レベルの制御は、
しばしばプログラミング言語の設計においてトレードオフの関係になります;
Rustは、その衝突に挑戦しています。バランスのとれた強力な技術の許容量と素晴らしい開発者経験を通して、
Rustは伝統的にそれらの制御と紐付いていた困難全てなしに低レベルの詳細(メモリ使用など)を制御する選択肢を与えてくれます。</p>
<!--
## Who Rust Is For
-->
<h2 id="rustは誰のためのものなの"><a class="header" href="#rustは誰のためのものなの">Rustは誰のためのものなの</a></h2>
<!--
Rust is ideal for many people for a variety of reasons. Let’s look at a few of
the most important groups.
-->
<p>Rustは、様々な理由により多くの人にとって理想的です。いくつか最も重要なグループを見ていきましょう。</p>
<!--
### Teams of Developers
-->
<h3 id="開発者チーム"><a class="header" href="#開発者チーム">開発者チーム</a></h3>
<!--
Rust is proving to be a productive tool for collaborating among large teams of
developers with varying levels of systems programming knowledge. Low-level code
is prone to a variety of subtle bugs, which in most other languages can be
caught only through extensive testing and careful code review by experienced
developers. In Rust, the compiler plays a gatekeeper role by refusing to
compile code with these elusive bugs, including concurrency bugs. By working
alongside the compiler, the team can spend their time focusing on the program’s
logic rather than chasing down bugs.
-->
<p>Rustは、いろんなレベルのシステムプログラミングの知識を持つ開発者の巨大なチームとコラボするのに生産的なツールであると証明してきています。
低レベルコードは様々な種類の微細なバグを抱える傾向があり、そのようなバグは他の言語だと広範なテストと、
経験豊富な開発者による注意深いコードレビューによってのみ捕捉されるものです。Rustにおいては、
コンパイラが並行性のバグも含めたこのようなとらえどころのないバグのあるコードをコンパイルするのを拒むことで、
門番の役割を担います。コンパイラとともに取り組むことで、チームはバグを追いかけるよりもプログラムのロジックに集中することに、
時間を費やせるのです。</p>
<!--
Rust also brings contemporary developer tools to the systems programming world:
-->
<p>Rustはまた、現代的な開発ツールをシステムプログラミング世界に導入します。</p>
<!--
* Cargo, the included dependency manager and build tool, makes adding,
  compiling, and managing dependencies painless and consistent across the Rust
  ecosystem.
* Rustfmt ensures a consistent coding style across developers.
* The Rust Language Server powers Integrated Development Environment (IDE)
  integration for code completion and inline error messages.
-->
<ul>
<li>Cargoは、付属の依存関係管理ツール兼ビルドツールで、依存関係の追加、コンパイル、管理を容易にし、Rustのエコシステム全体で一貫性を持たせます。</li>
<li>Rustfmtは開発者の間で一貫したコーディングスタイルを保証します。</li>
<li>Rust言語サーバーは、IDE(統合開発環境)との統合により、コード補完やインラインエラーメッセージに対応しています。</li>
</ul>
<!--
By using these and other tools in the Rust ecosystem, developers can be
productive while writing systems-level code.
-->
<p>これらのツールやRustのエコシステムの他のツールを使用することで、開発者はシステムレベルのコードを書きながら生産性を高めることができます。</p>
<!--
### Students
-->
<h3 id="学生"><a class="header" href="#学生">学生</a></h3>
<!--
Rust is for students and those who are interested in learning about systems
concepts. Using Rust, many people have learned about topics like operating
systems development. The community is very welcoming and happy to answer
student questions. Through efforts such as this book, the Rust teams want to
make systems concepts more accessible to more people, especially those new to
programming.
-->
<p>Rustは、学生やシステムの概念を学ぶことに興味のある方向けです。Rustを使用して、
多くの人がOS開発などの話題を学んできました。コミュニティはとても暖かく、喜んで学生の質問に答えてくれます。
この本のような努力を通じて、Rustチームはシステムの概念を多くの人、特にプログラミング初心者にとってアクセス可能にしたいと考えています。</p>
<!--
### Companies
-->
<h3 id="企業"><a class="header" href="#企業">企業</a></h3>
<!--
Hundreds of companies, large and small, use Rust in production for a variety of
tasks. Those tasks include command line tools, web services, DevOps tooling,
embedded devices, audio and video analysis and transcoding, cryptocurrencies,
bioinformatics, search engines, Internet of Things applications, machine
learning, and even major parts of the Firefox web browser.
-->
<p>数百の企業が、大企業、中小企業を問わず、様々なタスクにプロダクションでRustを使用しています。
そのタスクには、コマンドラインツール、Webサービス、DevOpsツール、組み込みデバイス、
オーディオとビデオの解析および変換、暗号通貨、生物情報学、サーチエンジン、IoTアプリケーション、
機械学習、Firefoxウェブブラウザの主要部分さえ含まれます。</p>
<!--
### Open Source Developers
-->
<h3 id="オープンソース開発者"><a class="header" href="#オープンソース開発者">オープンソース開発者</a></h3>
<!--
Rust is for people who want to build the Rust programming language, community,
developer tools, and libraries. We’d love to have you contribute to the Rust
language.
-->
<p>Rustは、Rustプログラミング言語やコミュニティ、開発者ツール、ライブラリを開発したい方向けです。
あなたがRust言語に貢献されることを心よりお待ちしております。</p>
<!--
### People Who Value Speed and Stability
-->
<h3 id="スピードと安定性に価値を見出す方"><a class="header" href="#スピードと安定性に価値を見出す方">スピードと安定性に価値を見出す方</a></h3>
<!--
Rust is for people who crave speed and stability in a language. By speed, we
mean the speed of the programs that you can create with Rust and the speed at
which Rust lets you write them. The Rust compiler’s checks ensure stability
through feature additions and refactoring. This is in contrast to the brittle
legacy code in languages without these checks, which developers are often
afraid to modify. By striving for zero-cost abstractions, higher-level features
that compile to lower-level code as fast as code written manually, Rust
endeavors to make safe code be fast code as well.
-->
<p>Rustは、スピードと安定性を言語に渇望する方向けです。ここでいうスピードとは、
Rustで作れるプログラムのスピードとソースコードを書くスピードのことです。Rustコンパイラのチェックにより、
機能の追加とリファクタリングを通して安定性を保証してくれます。これはこのようなチェックがない言語の脆いレガシーコードとは対照的で、
その場合開発者はしばしば、変更するのを恐れてしまいます。ゼロコスト抽象化を志向し、
手で書いたコードと同等の速度を誇る低レベルコードにコンパイルされる高レベル機能により、
Rustは安全なコードを高速なコードにもしようと努力しています。</p>
<!--
The Rust language hopes to support many other users as well; those mentioned
here are merely some of the biggest stakeholders. Overall, Rust’s greatest
ambition is to eliminate the trade-offs that programmers have accepted for
decades by providing safety *and* productivity, speed *and* ergonomics. Give
Rust a try and see if its choices work for you.
-->
<p>Rust言語は他の多くのユーザのサポートも望んでいます; ここで名前を出した方は、
ただの最大の出資者の一部です。総合すると、Rustの最大の野望は、プログラマが数十年間受け入れてきた代償を、安全性<em>と</em>生産性、
スピード<em>と</em>エルゴノミクスを提供することで排除することです。Rustを試してみて、その選択が自分に合っているか確かめてください。</p>
<!--
## Who This Book Is For
-->
<h2 id="この本は誰のためのものなの"><a class="header" href="#この本は誰のためのものなの">この本は誰のためのものなの</a></h2>
<!--
This book assumes that you’ve written code in another programming language but
doesn’t make any assumptions about which one. We’ve tried to make the material
broadly accessible to those from a wide variety of programming backgrounds. We
don’t spend a lot of time talking about what programming *is* or how to think
about it. If you’re entirely new to programming, you would be better served by
reading a book that specifically provides an introduction to programming.
-->
<p>この本は、あなたが他のプログラミング言語でコードを書いたことがあることを想定していますが、
具体的にどの言語かという想定はしません。私たちは、幅広い分野のプログラミング背景からの人にとってこの資料を広くアクセスできるようにしようとしてきました。
プログラミングとはなん<em>なのか</em>やそれについて考える方法について多くを語るつもりはありません。
もし、完全なプログラミング初心者であれば、プログラミング入門を特に行う本を読むことでよりよく役に立つでしょう。</p>
<!--
## How to Use This Book
-->
<h2 id="この本の使い方"><a class="header" href="#この本の使い方">この本の使い方</a></h2>
<!--
In general, this book assumes that you’re reading it in sequence from front to
back. Later chapters build on concepts in earlier chapters, and earlier
chapters might not delve into details on a topic; we typically revisit the
topic in a later chapter.
-->
<p>一般的に、この本は、順番に読み進めていくことを前提にしています。後の章は、前の章の概念の上に成り立ち、
前の章では、ある話題にさほど深入りしない可能性があります; 典型的に後ほどの章で同じ話題を再度しています。</p>
<!--
You’ll find two kinds of chapters in this book: concept chapters and project
chapters. In concept chapters, you’ll learn about an aspect of Rust. In project
chapters, we’ll build small programs together, applying what you’ve learned so
far. Chapters 2, 12, and 20 are project chapters; the rest are concept chapters.
-->
<p>この本には2種類の章があるとわかるでしょう: 概念の章とプロジェクトの章です。概念の章では、
Rustの一面を学ぶでしょう。プロジェクトの章では、それまでに学んだことを適用して一緒に小さなプログラムを構築します。
2、12、20章がプロジェクトの章です。つまり、残りは概念の章です。</p>
<!--
Chapter 1 explains how to install Rust, how to write a “Hello, world!” program,
and how to use Cargo, Rust’s package manager and build tool. Chapter 2 is a
hands-on introduction to the Rust language. Here we cover concepts at a high
level, and later chapters will provide additional detail. If you want to get
your hands dirty right away, Chapter 2 is the place for that. At first, you
might even want to skip Chapter 3, which covers Rust features similar to those
of other programming languages, and head straight to Chapter 4 to learn about
Rust’s ownership system. However, if you’re a particularly meticulous learner
who prefers to learn every detail before moving on to the next, you might want
to skip Chapter 2 and go straight to Chapter 3, returning to Chapter 2 when
you’d like to work on a project applying the details you’ve learned.
-->
<p>第1章はRustのインストール方法、“Hello, world!”プログラムの書き方、Rustのパッケージマネージャ兼、
ビルドツールのCargoの使用方法を説明します。第2章は、Rust言語への実践的な導入です。ここでは概念をざっくりと講義し、後ほどの章で追加の詳細を提供します。
今すぐRustの世界に飛び込みたいなら、第2章こそがそのためのものです。第3章は他のプログラミング言語の機能に似たRustの機能を講義していますが、
最初その3章すら飛ばして、まっすぐに第4章に向かい、Rustの所有権システムについて学びたくなる可能性があります。
しかしながら、あなたが次に進む前に全ての詳細を学ぶことを好む特別に几帳面な学習者なら、
第2章を飛ばして真っ先に第3章に行き、学んだ詳細を適用するプロジェクトに取り組みたくなった時に第2章に戻りたくなる可能性があります。</p>
<!--
Chapter 5 discusses structs and methods, and Chapter 6 covers enums, `match`
expressions, and the `if let` control flow construct. You’ll use structs and
enums to make custom types in Rust.
-->
<p>第5章は、構造体とメソッドについて議論し、第6章はenum、<code>match</code>式、<code>if let</code>制御フロー構文を講義します。
構造体とenumを使用してRustにおいて独自の型を作成します。</p>
<!--
In Chapter 7, you’ll learn about Rust’s module system and about privacy rules
for organizing your code and its public Application Programming Interface
(API). Chapter 8 discusses some common collection data structures that the
standard library provides, such as vectors, strings, and hash maps. Chapter 9
explores Rust’s error-handling philosophy and techniques.
-->
<p>第7章では、Rustのモジュールシステムと自分のコードとその公開されたAPI(Application Programming Interface)を体系化するプライバシー規則について学びます。
第8章では、ベクタ、文字列、ハッシュマップなどの標準ライブラリが提供する一般的なコレクションデータ構造の一部を議論します。
第9章では、Rustのエラー処理哲学とテクニックを探究します。</p>
<!--
Chapter 10 digs into generics, traits, and lifetimes, which give you the power
to define code that applies to multiple types. Chapter 11 is all about testing,
which even with Rust’s safety guarantees is necessary to ensure your program’s
logic is correct. In Chapter 12, we’ll build our own implementation of a subset
of functionality from the `grep` command line tool that searches for text
within files. For this, we’ll use many of the concepts we discussed in the
previous chapters.
-->
<p>第10章ではジェネリクス、トレイト、ライフタイムについて深入りし、これらは複数の型に適用されるコードを定義する力をくれます。
第11章は、完全にテストに関してで、Rustの安全性保証があってさえ、プログラムのロジックが正しいことを保証するために、
必要になります。第12章では、ファイル内のテキストを検索する<code>grep</code>コマンドラインツールの一部の機能を自身で構築します。
このために、以前の章で議論した多くの概念を使用します。</p>
<!--
Chapter 13 explores closures and iterators: features of Rust that come from
functional programming languages. In Chapter 14, we’ll examine Cargo in more
depth and talk about best practices for sharing your libraries with others.
Chapter 15 discusses smart pointers that the standard library provides and the
traits that enable their functionality.
-->
<p>第13章はクロージャとイテレータを探究します。これらは、関数型プログラミング言語由来のRustの機能です。
第14章では、Cargoをより詳しく調査し、他人と自分のライブラリを共有する最善の策について語ります。
第15章では、標準ライブラリが提供するスマートポインタとその機能を可能にするトレイトを議論します。</p>
<!--
In Chapter 16, we’ll walk through different models of concurrent programming
and talk about how Rust helps you to program in multiple threads fearlessly.
Chapter 17 looks at how Rust idioms compare to object-oriented programming
principles you might be familiar with.
-->
<p>第16章では、並行プログラミングの異なるモデルを見ていき、Rustが恐れなしに複数のスレッドでプログラムする手助けをする方法を語ります。
第17章では、馴染み深い可能性のあるオブジェクト指向プログラミングの原則とRustのイディオムがどう比較されるかに目を向けます。</p>
<!--
Chapter 18 is a reference on patterns and pattern matching, which are powerful
ways of expressing ideas throughout Rust programs. Chapter 19 contains a
smorgasbord of advanced topics of interest, including unsafe Rust, macros, and
more about lifetimes, traits, types, functions, and closures.
-->
<p>第18章は、パターンとパターンマッチングのリファレンスであり、これらはRustプログラムを通して、
考えを表現する強力な方法になります。第19章は、unsafe Rustやマクロ、ライフタイム、トレイト、型、関数、クロージャの詳細を含む、
興味のある高度な話題のスモーガスボード(<code>訳注</code>: 日本でいうバイキングのこと)を含みます。</p>
<!--
In Chapter 20, we’ll complete a project in which we’ll implement a low-level
multithreaded web server!
-->
<p>第20章では、低レベルなマルチスレッドのWebサーバを実装するプロジェクトを完成させます！</p>
<!--
Finally, some appendixes contain useful information about the language in a
more reference-like format. Appendix A covers Rust’s keywords, Appendix B
covers Rust’s operators and symbols, Appendix C covers derivable traits
provided by the standard library, Appendix D covers some useful development
tools, and Appendix E explains Rust editions.
-->
<p>最後に、言語についての有用な情報をよりリファレンスのような形式で含む付録があります。
付録AはRustのキーワードを講義し、付録Bは、Rustの演算子と記号、付録Cは、
標準ライブラリが提供する導出可能なトレイト、付録Dはいくつか便利な開発ツールを講義し、
付録EではRustのエディションについて説明します。</p>
<!--
There is no wrong way to read this book: if you want to skip ahead, go for it!
You might have to jump back to earlier chapters if you experience any
confusion. But do whatever works for you.
-->
<p>この本を読む間違った方法なんてありません: 飛ばしたければ、どうぞご自由に！
混乱したら、前の章に戻らなければならない可能性もあります。ですが、自分に合った方法でどうぞ。</p>
<!--
<span id="ferris"></span>
-->
<p><span id="ferris"></span></p>
<!--
An important part of the process of learning Rust is learning how to read the
error messages the compiler displays: these will guide you toward working code.
As such, we’ll provide many examples that don’t compile along with the error
message the compiler will show you in each situation. Know that if you enter
and run a random example, it may not compile! Make sure you read the
surrounding text to see whether the example you’re trying to run is meant to
error. Ferris will also help you distinguish code that isn’t meant to work:
-->
<p>Rustを学ぶ過程で重要な部分は、コンパイラが表示するエラーメッセージを読む方法を学ぶことです:
それは動くコードへと導いてくれます。そのため、各場面でコンパイラが表示するエラーメッセージとともに、
コンパイルできない例を多く提供します。適当に例を選んで走らせたら、コンパイルできないかもしれないことを知ってください！
周りのテキストを読んで実行しようとしている例がエラーになることを意図しているのか確認することを確かめてください。
フェリスもコードが動作するとは意図されていないコードを見分けるのを手助けしてくれます:</p>
<!--
| Ferris                                                                 | Meaning                                          |
|------------------------------------------------------------------------|--------------------------------------------------|
| <img src="img/ferris/does_not_compile.svg" class="ferris-explain"/>    | This code does not compile!                      |
| <img src="img/ferris/panics.svg" class="ferris-explain"/>              | This code panics!                                |
| <img src="img/ferris/unsafe.svg" class="ferris-explain"/>              | This code block contains unsafe code.            |
| <img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/>| This code does not produce the desired behavior. |
-->
<table><thead><tr><th>Ferris</th><th>Meaning</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>このコードはコンパイルできません！</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain"/></td><td>このコードはパニックします！</td></tr>
<tr><td><img src="img/ferris/unsafe.svg" class="ferris-explain"/></td><td>このコードはアンセーフなコードを含みます。</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td>このコードは求められている振る舞いをしません。</td></tr>
</tbody></table>
<!--
In most situations, we’ll lead you to the correct version of any code that
doesn’t compile.
-->
<p>ほとんどの場合、コンパイルできないあらゆるコードの正しいバージョンへと導きます。</p>
<!--
## Source Code
-->
<h2 id="ソースコード"><a class="header" href="#ソースコード">ソースコード</a></h2>
<!--
The source files from which this book is generated can be found on
[GitHub][book].
-->
<p>この本が生成されるソースファイルは、<a href="https://github.com/rust-lang/book/tree/master/src">GitHub</a>で見つかります。</p>
<blockquote>
<p>訳注: 日本語版は<a href="https://github.com/rust-lang-ja/book-ja">こちら</a>です。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><!--
# Getting Started
-->
<h1 id="事始め"><a class="header" href="#事始め">事始め</a></h1>
<!--
Let’s start your Rust journey! There’s a lot to learn, but every journey starts
somewhere. In this chapter, we’ll discuss:
-->
<p>Rustの旅を始めましょう！学ぶべきことはたくさんありますが、いかなる旅もどこかから始まります。
この章では、以下のことを説明します:</p>
<!--
* Installing Rust on Linux, macOS, and Windows
* Writing a program that prints `Hello, world!`
* Using `cargo`, Rust’s package manager and build system
-->
<ul>
<li>RustをLinux、macOS、Windowsにインストールする</li>
<li><code>Hello, world!</code>と表示するプログラムを書く</li>
<li><code>cargo</code>というRustのパッケージマネージャ兼ビルドシステムを使用する</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
## Installation
-->
<h2 id="インストール"><a class="header" href="#インストール">インストール</a></h2>
<!--
The first step is to install Rust. We’ll download Rust through `rustup`, a
command line tool for managing Rust versions and associated tools. You’ll need
an internet connection for the download.
-->
<p>最初の手順は、Rustをインストールすることです。Rustは、Rustのバージョンと関連するツールを管理する、<code>rustup</code>というコマンドラインツールを使用してダウンロードします。ダウンロードには、インターネットへの接続が必要になります。</p>
<!--
> Note: If you prefer not to use `rustup` for some reason, please see [the Rust
> installation page](https://www.rust-lang.org/tools/install) for other options.
-->
<blockquote>
<p>注釈: なんらかの理由で<code>rustup</code>を使用したくない場合、<a href="https://www.rust-lang.org/tools/install/">Rustインストールページ</a>で、
他の選択肢をご覧になってください。</p>
</blockquote>
<blockquote>
<p>訳注：日本語版のRustインストールページは<a href="https://www.rust-lang.org/ja/tools/install/">こちら</a>です。</p>
</blockquote>
<!--
The following steps install the latest stable version of the Rust compiler.
Rust’s stability guarantees ensure that all the examples in the book that
compile will continue to compile with newer Rust versions. The output might
differ slightly between versions, because Rust often improves error messages
and warnings. In other words, any newer, stable version of Rust you install
using these steps should work as expected with the content of this book.
-->
<p>以下の手順で最新の安定版のRustコンパイラをインストールします。
Rustは安定性 (stability) を保証しているので、現在この本の例でコンパイルできるものは、新しいバージョンになってもコンパイルでき続けることが保証されます。
出力は、バージョンによって多少異なる可能性があります。Rustは頻繁にエラーメッセージと警告を改善しているからです。
言い換えると、どんな新しいバージョンでもこの手順に従ってインストールした安定版なら、
この本の内容で想定通りに動くはずです。</p>
<!--
> ### Command Line Notation
>
> In this chapter and throughout the book, we’ll show some commands used in the
> terminal. Lines that you should enter in a terminal all start with `$`. You
> don’t need to type in the `$` character; it indicates the start of each
> command. Lines that don’t start with `$` typically show the output of the
> previous command. Additionally, PowerShell-specific examples will use `>`
> rather than `$`.
-->
<blockquote>
<h3 id="コマンドラインの記法"><a class="header" href="#コマンドラインの記法">コマンドラインの記法</a></h3>
<p>この章及び、本を通して、端末で使用するなんらかのコマンドを示すことがあります。読者が入力するべき行は、
全て<code>$</code>で始まります。ただし、読者が<code>$</code>文字を入力する必要はありません; これは各コマンドの開始を示しているだけです。
<code>$</code>で始まらない行は、典型的には直前のコマンドの出力を示します。また、PowerShell限定の例には、
<code>$</code>ではなく、<code>&gt;</code>を使用します。</p>
</blockquote>
<!--
### Installing `rustup` on Linux or macOS
-->
<h3 id="linuxとmacosにrustupをインストールする"><a class="header" href="#linuxとmacosにrustupをインストールする">LinuxとmacOSに<code>rustup</code>をインストールする</a></h3>
<!--
If you’re using Linux or macOS, open a terminal and enter the following command:
-->
<p>LinuxかmacOSを使用しているなら、端末（ターミナル）を開き、以下のコマンドを入力してください:</p>
<pre><code class="language-console">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<!--
The command downloads a script and starts the installation of the `rustup`
tool, which installs the latest stable version of Rust. You might be prompted
for your password. If the install is successful, the following line will appear:
-->
<p>このコマンドはスクリプトをダウンロードし、<code>rustup</code>ツールのインストールを開始し、Rustの最新の安定版をインストールします。
パスワードを求められる可能性があります。インストールがうまく行けば、以下の行が出現するでしょう:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<!--
Additionally, you’ll need a linker of some kind. It’s likely one is already
installed, but when you try to compile a Rust program and get errors indicating
that a linker could not execute, that means a linker isn’t installed on your
system and you’ll need to install one manually. C compilers usually come with
the correct linker. Check your platform’s documentation for how to install a C
compiler. Also, some common Rust packages depend on C code and will need a C
compiler. Therefore, it might be worth installing one now.
-->
<p>これに加えて、なんらかのリンカが必要になるでしょう。既にインストールされている可能性は高いものの、
Rustプログラムをコンパイルしようとした時、リンカが実行できないというエラーが出たら、
システムにリンカがインストールされていないということなので、手動でインストールする必要があるでしょう。
Cコンパイラは通常正しいリンカとセットになっています。
自分のプラットフォームのドキュメンテーションを見てCコンパイラのインストール方法を確認してください。
一般的なRustパッケージの中には、Cコードに依存し、Cコンパイラが必要になるものもあります。
ですので、Cコンパイラは今のうちにインストールしておく価値があるかもしれません。</p>
<!--
### Installing `rustup` on Windows
-->
<h3 id="windowsでrustupをインストールする"><a class="header" href="#windowsでrustupをインストールする">Windowsで<code>rustup</code>をインストールする</a></h3>
<!--
On Windows, go to [https://www.rust-lang.org/tools/install][install] and follow
the instructions for installing Rust. At some point in the installation, you’ll
receive a message explaining that you’ll also need the C++ build tools for
Visual Studio 2013 or later. The easiest way to acquire the build tools is to
install [Build Tools for Visual Studio 2019][visualstudio]. When asked which
workloads to install make sure "C++ build tools" is selected and that the Windows 10 SDK and the English language pack components are included.

-->
<p>Windowsでは、<a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a>に行き、手順に従ってRustをインストールしてください。
インストールの途中で、Visual Studio 2013以降用のC++ビルドツールも必要になるという旨のメッセージが出るでしょう。
ビルドツールを取得する最も簡単な方法は、<a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Visual Studio 2019用のビルドツール</a>をインストールすることです。
どのワークロード (workloads) をインストールするかと質問されたときは、&quot;C++ build tools&quot;が選択されており、Windows 10 SDKと英語の言語パック (English language pack) が含まれていることを確かめてください。</p>
<blockquote>
<p>訳注：Windowsの言語を日本語にしている場合は言語パックのところで「日本語」が選択されており、そのままの設定でインストールしても基本的に問題ないはずです。しかし、サードパーティーのツールやライブラリの中には英語の言語パックを必要とするものがあるため、「日本語」に加えて「英語」も選択することをお勧めします。</p>
</blockquote>
<!--
The rest of this book uses commands that work in both *cmd.exe* and PowerShell.
If there are specific differences, we’ll explain which to use.
-->
<p>これ以降、<em>cmd.exe</em>とPowerShellの両方で動くコマンドを使用します。
特段の違いがあったら、どちらを使用すべきか説明します。</p>
<!--
### Updating and Uninstalling
-->
<h3 id="更新及びアンインストール"><a class="header" href="#更新及びアンインストール">更新及びアンインストール</a></h3>
<!--
After you’ve installed Rust via `rustup`, updating to the latest version is
easy. From your shell, run the following update script:
-->
<p><code>rustup</code>経由でRustをインストールしたなら、最新版へ更新するのは簡単です。
シェルから以下の更新スクリプトを実行してください:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<!--
To uninstall Rust and `rustup`, run the following uninstall script from your
shell:
-->
<p>Rustと<code>rustup</code>をアンインストールするには、シェルから以下のアンインストールスクリプトを実行してください:</p>
<pre><code class="language-console">$ rustup self uninstall
</code></pre>
<!--
### Troubleshooting
-->
<h3 id="トラブルシューティング"><a class="header" href="#トラブルシューティング">トラブルシューティング</a></h3>
<!--
To check whether you have Rust installed correctly, open a shell and enter this
line:
-->
<p>Rustが正常にインストールされているか確かめるには、シェルを開いて以下の行を入力してください:</p>
<pre><code class="language-console">$ rustc --version
</code></pre>
<!--
You should see the version number, commit hash, and commit date for the latest
stable version that has been released in the following format:
-->
<p>バージョンナンバー、コミットハッシュ、最新の安定版がリリースされたコミット日時が以下のフォーマットで表示されるのを目撃するはずです。</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<!--
If you see this information, you have installed Rust successfully! If you don’t
see this information and you’re on Windows, check that Rust is in your `%PATH%`
system variable. If that’s all correct and Rust still isn’t working, there are
a number of places you can get help. The easiest is the #beginners channel on
[the official Rust Discord][discord]. There, you can chat with other Rustaceans
(a silly nickname we call ourselves) who can help you out. Other great
resources include [the Users forum][users] and [Stack Overflow][stackoverflow].
-->
<p>この情報が見られたなら、Rustのインストールに成功しています！この情報が出ず、Windowsを使っているなら、
Rustが<code>%PATH%</code>システム環境変数にあることを確認してください。これらが全て正常であるのに、それでもRustがうまく動かないなら、
助力を得られる場所はたくさんあります。最も簡単なのが<a href="https://discord.gg/rust-lang">Rustの公式Discord</a>の#beginnersチャンネルです。そのアドレスで、助けてくれる他のRustacean (Rustユーザが自分たちのことを呼ぶ、冗談めいたニックネーム) たちとチャットできます。
他にも、素晴らしいリソースとして<a href="https://users.rust-lang.org/">ユーザ・フォーラム</a>と<a href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>が挙げられます。</p>
<blockquote>
<p>訳注1：Rustaceanについて、いらないかもしれない補足です。<a href="https://mobile.twitter.com/rustlang/status/916284650674323457">公式Twitter曰く、Rustaceanはcrustaceans（甲殻類）から来ている</a>そうです。
そのため、Rustのマスコットは（非公式らしいですが）<a href="https://www.slideshare.net/wolf-dog/ss-64026540">カニ</a>。上の会話でCの欠点を削ぎ落としているからcを省いてるの？みたいなことを聞いていますが、
違うそうです。検索したら、堅牢性が高いから甲殻類という意見もありますが、真偽は不明です。
明日使えるかもしれないトリビアでした。</p>
</blockquote>
<blockquote>
<p>訳注2：上にある公式Discordは英語話者のコミュニティです。日本語話者のためのコミュニティが<a href="https://rust-lang-jp.zulipchat.com">Zulip rust-lang-jpにあり</a>、こちらでもRustaceanたちが活発に議論をしています。
公式Discord同様、初心者向けの#beginnersチャンネルが存在するので、気軽に質問してみてください。</p>
</blockquote>
<!--
### Local Documentation
-->
<h3 id="ローカルのドキュメンテーション"><a class="header" href="#ローカルのドキュメンテーション">ローカルのドキュメンテーション</a></h3>
<!--
The installation of Rust also includes a copy of the documentation locally, so
you can read it offline. Run `rustup doc` to open the local documentation in
your browser.
-->
<p>インストールされたRustには、ローカルに複製されたドキュメンテーションのコピーが含まれているので、これをオフラインで閲覧することができます。
ブラウザでローカルのドキュメンテーションを開くには、<code>rustup doc</code>を実行してください。</p>
<!--
Any time a type or function is provided by the standard library and you’re not
sure what it does or how to use it, use the application programming interface
(API) documentation to find out!
-->
<p>標準ライブラリにより提供される型や関数がなんなのかや、それをどう使えば良いのかがよくわからないときは、いつでもAPIのドキュメンテーションを検索してみてください！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Hello, World!
-->
<h2 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h2>
<!--
Now that you’ve installed Rust, let’s write your first Rust program. It’s
traditional when learning a new language to write a little program that prints
the text `Hello, world!` to the screen, so we’ll do the same here!
-->
<p>Rustをインストールしたので、最初のRustプログラムを書きましょう。新しい言語を学ぶ際に、
<code>Hello, world!</code>というテキストを画面に出力する小さなプログラムを書くことは伝統的なことなので、
ここでも同じようにしましょう！</p>
<!--
> Note: This book assumes basic familiarity with the command line. Rust makes
> no specific demands about your editing or tooling or where your code lives, so
> if you prefer to use an integrated development environment (IDE) instead of
> the command line, feel free to use your favorite IDE. Many IDEs now have some
> degree of Rust support; check the IDE’s documentation for details. Recently,
> the Rust team has been focusing on enabling great IDE support, and progress
> has been made rapidly on that front!
-->
<blockquote>
<p>注釈: この本は、コマンドラインに基礎的な馴染みがあることを前提にしています。Rustは、編集やツール、
どこにコードがあるかについて特定の要求をしないので、コマンドラインではなくIDEを使用することを好むのなら、
どうぞご自由にお気に入りのIDEを使用してください。今では、多くのIDEがなんらかの形でRustをサポートしています;
詳しくは、IDEのドキュメンテーションをご覧ください。最近、Rustチームは優れたIDEサポートを有効にすることに注力し、
その前線で急激に成果があがっています！</p>
</blockquote>
<!--
### Creating a Project Directory
-->
<h3 id="プロジェクトのディレクトリを作成する"><a class="header" href="#プロジェクトのディレクトリを作成する">プロジェクトのディレクトリを作成する</a></h3>
<!--
You’ll start by making a directory to store your Rust code. It doesn’t matter
to Rust where your code lives, but for the exercises and projects in this book,
we suggest making a *projects* directory in your home directory and keeping all
your projects there.
-->
<p>Rustコードを格納するディレクトリを作ることから始めましょう。Rustにとって、コードがどこにあるかは問題ではありませんが、
この本の練習とプロジェクトのために、ホームディレクトリに<em>projects</em>ディレクトリを作成してプロジェクトを全てそこに保管することを推奨します。</p>
<!--
Open a terminal and enter the following commands to make a *projects* directory
and a directory for the Hello, world! project within the *projects* directory.
-->
<p>端末を開いて以下のコマンドを入力し、<em>projects</em>ディレクトリと、
<em>projects</em>ディレクトリ内にHello, world!プロジェクトのディレクトリを作成してください。</p>
<!--
For Linux and macOS, enter this:
-->
<p>LinuxとmacOSなら、こう入力してください:</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<!--
For Windows CMD, enter this:
-->
<p>Windowsのcmdなら、こう:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<!--
For Windows PowerShell, enter this:
-->
<p>WindowsのPowerShellなら、こう:</p>
<pre><code class="language-powershell">&gt; mkdir $env:USERPROFILE\projects
&gt; cd $env:USERPROFILE\projects
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<!--
### Writing and Running a Rust Program
-->
<h3 id="rustプログラムを書いて走らせる"><a class="header" href="#rustプログラムを書いて走らせる">Rustプログラムを書いて走らせる</a></h3>
<!--
Next, make a new source file and call it *main.rs*. Rust files always end with
the *.rs* extension. If you’re using more than one word in your filename, use
an underscore to separate them. For example, use *hello_world.rs* rather than
*helloworld.rs*.
-->
<p>次にソースファイルを作り、<em>main.rs</em>というファイル名にしてください。Rustのファイルは常に <em>.rs</em>という拡張子で終わります。
ファイル名に2単語以上使っているなら、アンダースコアで区切ってください。例えば、<em>helloworld.rs</em>ではなく、
<em>hello_world.rs</em>を使用してください。</p>
<!--
Now open the *main.rs* file you just created and enter the code in Listing 1-1.
-->
<p>さて、作ったばかりの<em>main.rs</em>ファイルを開き、リスト1-1のコードを入力してください。</p>
<!--
<span class="filename">Filename: main.rs</span>
-->
<p><span class="filename">ファイル名: main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
	// 世界よ、こんにちは
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 1-1: A program that prints `Hello, world!`</span>
-->
<p><span class="caption">リスト1-1: <code>Hello, world!</code>と出力するプログラム</span></p>
<!--
Save the file and go back to your terminal window. On Linux or macOS, enter
the following commands to compile and run the file:
-->
<p>ファイルを保存し、端末ウィンドウに戻ってください。LinuxかmacOSなら、以下のコマンドを打ってファイルをコンパイルし、
実行してください:</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<!--
On Windows, enter the command `.\main.exe` instead of `./main`:
-->
<p>Windowsなら、<code>./main</code>の代わりに<code>.\main.exe</code>と打ちます:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<!--
Regardless of your operating system, the string `Hello, world!` should print to
the terminal. If you don’t see this output, refer back to the “Troubleshooting”
section for ways to get help.
-->
<p>OSに関わらず、<code>Hello, world!</code>という文字列が端末に出力されるはずです。この出力が見れないなら、
「トラブルシューティング」節に立ち戻って、助けを得る方法を参照してください。</p>
<!--
If `Hello, world!` did print, congratulations! You’ve officially written a Rust
program. That makes you a Rust programmer-welcome!
-->
<p><code>Hello, world!</code>が確かに出力されたら、おめでとうございます！正式にRustプログラムを書きました。
Rustプログラマになったのです！ようこそ！</p>
<!--
### Anatomy of a Rust Program
-->
<h3 id="rustプログラムの解剖"><a class="header" href="#rustプログラムの解剖">Rustプログラムの解剖</a></h3>
<!--
Let’s review in detail what just happened in your Hello, world! program.
Here’s the first piece of the puzzle:
-->
<p>Hello, world!プログラムでいま何が起こったのか詳しく確認しましょう。
こちらがパズルの最初のピースです:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}
</code></pre></pre>
<!--
These lines define a function in Rust. The `main` function is special: it is
always the first code that runs in every executable Rust program. The first
line declares a function named `main` that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses, `()`.
-->
<p>これらの行でRustで関数を定義しています。<code>main</code>関数は特別です: 常に全ての実行可能なRustプログラムで走る最初のコードになります。
1行目は、引数がなく、何も返さない<code>main</code>という関数を宣言しています。引数があるなら、かっこ(<code>()</code>)の内部に入ります。</p>
<!--
Also, note that the function body is wrapped in curly brackets, `{}`. Rust
requires these around all function bodies. It’s good style to place the opening
curly bracket on the same line as the function declaration, adding one space in
between.
-->
<p>また、関数の本体が波括弧(<code>{}</code>)に包まれていることにも注目してください。Rustでは、全ての関数本体の周りにこれらが必要になります。
スペースを1つあけて、開き波括弧を関数宣言と同じ行に配置するのがいいスタイルです。</p>
<!--
If you want to stick to a standard style across Rust projects, you can use an
automatic formatter tool called `rustfmt` to format your code in a particular
style. The Rust team has included this tool with the standard Rust distribution,
like `rustc`, so it should already be installed on your computer! Check the
online documentation for more details.
-->
<p>複数のRustプロジェクトに渡って標準的なスタイルにこだわりたいなら、<code>rustfmt</code>を使うことでコードを決まったスタイルに整形できるでしょう。
Rustチームは、<code>rustc</code>のように標準的なRustの配布にこのツールを含んでいるため、既にコンピューターにインストールされているはずです！
詳細は、オンラインのドキュメンテーションを確認してください。</p>
<!--
Inside the `main` function is the following code:
-->
<p><code>main</code>関数内には、こんなコードがあります:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hello, world!&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
This line does all the work in this little program: it prints text to the
screen. There are four important details to notice here. First, Rust style is
to indent with four spaces, not a tab.
-->
<p>この行が、この小さなプログラムの全作業をしています: テキストを画面に出力するのです。
ここで気付くべき重要な詳細が4つあります。まず、Rustのスタイルは、タブではなく、4スペースでインデントするということです。</p>
<!--
Second, `println!` calls a Rust macro. If it called a function instead, it
would be entered as `println` (without the `!`). We’ll discuss Rust macros in
more detail in Appendix D. For now, you just need to know that using a `!`
means that you’re calling a macro instead of a normal function.
-->
<p>2番目に<code>println!</code>はRustのマクロを呼び出すということです。代わりに関数を呼んでいたら、
<code>println</code>(<code>!</code>なし)と入力されているでしょう。Rustのマクロについて詳しくは、第19章で議論します。
とりあえず、<code>!</code>を使用すると、普通の関数ではなくマクロを呼んでいるのだということを知っておくだけでいいでしょう。</p>
<!--
Third, you see the `"Hello, world!"` string. We pass this string as an argument
to `println!`, and the string is printed to the screen.
-->
<p>3番目に、<code>&quot;Hello, world!&quot;</code>文字列が見えます。この文字列を引数として<code>println!</code>に渡し、
この文字列が画面に表示されているのです。</p>
<!--
Fourth, we end the line with a semicolon (`;`), which indicates that this
expression is over and the next one is ready to begin. Most lines of Rust code
end with a semicolon.
-->
<p>4番目にこの行をセミコロン(<code>;</code>)で終え、この式が終わり、次の式の準備ができていると示唆していることです。
Rustコードのほとんどの行は、セミコロンで終わります。</p>
<!--
### Compiling and Running Are Separate Steps
-->
<h3 id="コンパイルと実行は個別のステップ"><a class="header" href="#コンパイルと実行は個別のステップ">コンパイルと実行は個別のステップ</a></h3>
<!--
You’ve just run a newly created program, so let’s examine each step in the
process.
-->
<p>新しく作成したプログラムをちょうど実行したので、その途中の手順を調査しましょう。</p>
<!--
Before running a Rust program, you must compile it using the Rust compiler by
entering the `rustc` command and passing it the name of your source file, like
this:
-->
<p>Rustプログラムを実行する前に、以下のように、<code>rustc</code>コマンドを入力し、ソースファイルの名前を渡すことで、
Rustコンパイラを使用してコンパイルしなければなりません。</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<!--
If you have a C or C++ background, you’ll notice that this is similar to `gcc`
or `clang`. After compiling successfully, Rust outputs a binary executable.
-->
<p>あなたにCやC++の背景があるなら、これは<code>gcc</code>や<code>clang</code>と似ていると気付くでしょう。コンパイルに成功後、
Rustはバイナリの実行可能ファイルを出力します。</p>
<!--
On Linux, macOS, and PowerShell on Windows, you can see the executable by
entering the `ls` command in your shell as follows:
-->
<p>Linux、macOS、WindowsのPowerShellなら、シェルで以下のように<code>ls</code>コマンドを入力することで実行可能ファイルを見られます:</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<!--
With CMD on Windows, you would enter the following:
-->
<p>WindowsのCMDなら、以下のように入力するでしょう:</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
         %= /Bオプションは、ファイル名だけを表示することを宣言する =%
main.exe
main.pdb
main.rs
</code></pre>
<!--
This shows the source code file with the *.rs* extension, the executable file
(*main.exe* on Windows, but *main* on all other platforms), and, when using
CMD, a file containing debugging information with the *.pdb* extension. From
here, you run the *main* or *main.exe* file, like this:
-->
<p>これは、<em>.rs</em>拡張子のソースコードファイル、実行可能ファイル(Windowsなら<em>main.exe</em>、他のプラットフォームでは、<em>main</em>)、
そして、CMDを使用しているなら、<em>.pdb</em>拡張子のデバッグ情報を含むファイルを表示します。ここから、
<em>main</em>か<em>main.exe</em>を走らせます。このように:</p>
<pre><code class="language-text">$ ./main # or .\main.exe on Windows
         # または、Widnowsなら.\main.exe
</code></pre>
<!--
If *main.rs* was your Hello, world! program, this line would print `Hello,
world!` to your terminal.
-->
<p><em>main.rs</em>がHello, world!プログラムなら、この行は<code>Hello, world!</code>と端末に出力するでしょう。</p>
<!--
*.rb*がなぜかイタリックにならない
-->
<!--
If you’re more familiar with a dynamic language, such as Ruby, Python, or
JavaScript, you might not be used to compiling and running a program as
separate steps. Rust is an *ahead-of-time compiled* language, meaning you can
compile a program and give the executable to someone else, and they can run it
even without having Rust installed. If you give someone a *.rb*, *.py*, or
*.js* file, they need to have a Ruby, Python, or JavaScript implementation
installed (respectively). But in those languages, you only need one command to
compile and run your program. Everything is a trade-off in language design.
-->
<p>RubyやPython、JavaScriptなどの動的言語により造詣が深いなら、プログラムのコンパイルと実行を個別の手順で行うことに慣れていない可能性があります。
Rustは<em>AOTコンパイル</em>(ahead-of-time; <code>訳注</code>: 予め)言語です。つまり、プログラムをコンパイルし、
実行可能ファイルを誰かにあげ、あげた人がRustをインストールしていなくても実行できるわけです。
誰かに <em>.rb</em>、<em>.py</em>、<em>.js</em>ファイルをあげたら、それぞれRuby、Python、JavaScriptの処理系がインストールされている必要があります。
ですが、そのような言語では、プログラムをコンパイルし実行するには、1コマンドしか必要ないのです。
全ては言語設計においてトレードオフなのです。</p>
<!--
Just compiling with `rustc` is fine for simple programs, but as your project
grows, you’ll want to manage all the options and make it easy to share your
code. Next, we’ll introduce you to the Cargo tool, which will help you write
real-world Rust programs.
-->
<p>簡単なプログラムなら<code>rustc</code>でコンパイルするだけでも十分ですが、プロジェクトが肥大化してくると、
オプションを全て管理し、自分のコードを簡単に共有したくなるでしょう。次は、Cargoツールを紹介します。
これは、現実世界のRustプログラムを書く手助けをしてくれるでしょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Hello, Cargo!
-->
<h2 id="hello-cargo"><a class="header" href="#hello-cargo">Hello, Cargo!</a></h2>
<!--
Cargo is Rust’s build system and package manager. Most Rustaceans use this tool
to manage their Rust projects because Cargo handles a lot of tasks for you,
such as building your code, downloading the libraries your code depends on, and
building those libraries. (We call the libraries that your code needs
*dependencies*.)
-->
<p>CargoはRustのビルドシステム兼パッケージマネージャです。
ほとんどのRustaceanはこのツールを使ってRustプロジェクトを管理しています。
なぜなら、Cargoは多くの仕事、たとえばコードのビルド、コードが依存するライブラリのダウンロード、それらのライブラリのビルドなどを扱ってくれるからです。
（コードが必要とするライブラリのことを<em>依存</em>（dependencies）と呼びます）</p>
<!--
The simplest Rust programs, like the one we’ve written so far, don’t have any
dependencies. So if we had built the “Hello, world!” project with Cargo, it
would only use the part of Cargo that handles building your code. As you write
more complex Rust programs, you’ll add dependencies, and if you start a project
using Cargo, adding dependencies will be much easier to do.
-->
<p>いままでに書いたようなごく単純なRustプログラムには依存がありません。
そのため「Hello, world!」プロジェクトをCargoでビルドしても、Cargoの中のコードをビルドする部分しか使わないでしょう。
より複雑なRustプログラムを書くようになると依存を追加することになりますが、Cargoを使ってプロジェクトを開始したなら、依存の追加もずっと簡単になります。</p>
<!--
Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that you’re using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the
[“Installation”][installation] section. If you installed Rust
through some other means, check whether Cargo is installed by entering the
following into your terminal:
-->
<p>Rustプロジェクトの大多数がCargoを使用しているので、これ以降、この本では、あなたもCargoを使用していると想定します。
もし<a href="ch01-01-installation.html#%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB">「インストール」</a>節で紹介した公式のインストーラを使用したなら、CargoはRustと共にインストールされています。
Rustを他の方法でインストールした場合は、以下のコマンドをターミナルに入れて、Cargoがインストールされているか確認してください。</p>
<pre><code class="language-console">$ cargo --version
</code></pre>
<!--
If you see a version number, you have it! If you see an error, such as `command
not found`, look at the documentation for your method of installation to
determine how to install Cargo separately.
-->
<p>バージョンナンバーが表示されたならインストールされています！
<code>command not found</code>などのエラーが表示された場合は、自分がインストールした方法についてのドキュメントを参照して、Cargoを個別にインストールする方法を調べてください。</p>
<!--
### Creating a Project with Cargo
-->
<h3 id="cargoでプロジェクトを作成する"><a class="header" href="#cargoでプロジェクトを作成する">Cargoでプロジェクトを作成する</a></h3>
<!--
Let’s create a new project using Cargo and look at how it differs from our
original “Hello, world!” project. Navigate back to your *projects* directory (or
wherever you decided to store your code). Then, on any operating system, run
the following:
-->
<p>Cargoを使って新しいプロジェクトを作成し、元の「Hello, world!」プロジェクトとの違いを見ていきましょう。
<em>projects</em>ディレクトリ（または自分がコードを保存すると決めた場所）に戻ってください。
それから、OSに関係なく、以下を実行してください。</p>
<pre><code class="language-console">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<!--
The first command created a new directory called *hello_cargo*. We’ve named
our project *hello_cargo*, and Cargo creates its files in a directory of the
same name.
-->
<p>最初のコマンドは<em>hello_cargo</em>という名の新しいディレクトリを作成します。
プロジェクトを<em>hello_cargo</em>と名付けたので、Cargoはそれに関連するいくつかのファイルを同名のディレクトリに作成します。</p>
<!--
Go into the *hello_cargo* directory and list the files. You’ll see that Cargo
has generated two files and one directory for us: a *Cargo.toml* file and a
*src* directory with a *main.rs* file inside.
-->
<p><em>hello_cargo</em>ディレクトリに行き、ファイルの一覧を取得してください。
Cargoが2つのファイルと1つのディレクトリを生成してくれたことがわかるでしょう。
<em>Cargo.toml</em>ファイルと<em>src</em>ディレクトリがあり、<em>src</em>の中には<em>main.rs</em>ファイルがあります。</p>
<!--
It has also initialized a new Git repository along with a *.gitignore* file.
Git files won’t be generated if you run `cargo new` within an existing Git
repository; you can override this behavior by using `cargo new --vcs=git`.
-->
<p>また、<em>.gitignore</em>ファイルと共に新しいGitリポジトリも初期化されています。
もし、すでに存在するGitリポジトリの中で<code>cargo new</code>を実行したなら、Git関連のファイルは作られません。
<code>cargo new --vcs=git</code>とすることで、この振る舞いを変更できます。</p>
<!--
> Note: Git is a common version control system. You can change `cargo new` to
> use a different version control system or no version control system by using
> the `--vcs` flag. Run `cargo new --help` to see the available options.
-->
<blockquote>
<p>補足：Gitは一般的なバージョン管理システムです。
<code>cargo new</code>コマンドに<code>--vcs</code>フラグを与えることで、別のバージョン管理システムを使用したり、何も使用しないようにもできます。
利用可能なオプションを確認するには<code>cargo new --help</code>を実行します。</p>
</blockquote>
<!--
Open *Cargo.toml* in your text editor of choice. It should look similar to the
code in Listing 1-2.
-->
<p>お気に入りのテキストエディタで<em>Cargo.toml</em>を開いてください。
リスト1-2のコードのようになっているはずです。</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">ファイル名：Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
</code></pre>
<!--
<span class="caption">Listing 1-2: Contents of *Cargo.toml* generated by `cargo
new`</span>
-->
<p><span class="caption">リスト1-2：<code>cargo new</code>で生成された<em>Cargo.toml</em>の内容</span></p>
<!--
This file is in the [*TOML*](https://toml.io) (*Tom’s Obvious,
Minimal Language*) format, which is Cargo’s configuration format.
-->
<p>このファイルは<a href="https://toml.io">TOML</a>（<em>Tom's Obvious, Minimal Language</em>、トムの明確な最小限の言語）形式で、Cargoの設定フォーマットです。</p>
<!--
The first line, `[package]`, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we’ll add other sections.
-->
<p>最初の行の<code>[package]</code>はセクションヘッダーで、それ以降の文がパッケージを設定することを示します。
このファイルに情報を追加してく中で、他のセクションも追加していくことになります。</p>
<!--
The next three lines set the configuration information Cargo needs to compile
your program: the name, the version, and the edition of Rust to use. We’ll talk
about the `edition` key in [Appendix E][appendix-e].
-->
<p>次の3行はCargoがプログラムをコンパイルするのに必要となる設定情報を指定します。
ここでは、名前、バージョン、使用するRustのエディションを指定しています。
<code>edition</code>キーについては<a href="appendix-05-editions.html">付録E</a>で説明されています。</p>
<!--
The last line, `[dependencies]`, is the start of a section for you to list any
of your project’s dependencies. In Rust, packages of code are referred to as
*crates*. We won’t need any other crates for this project, but we will in the
first project in Chapter 2, so we’ll use this dependencies section then.
-->
<p>最後の行の<code>[dependencies]</code>は、プロジェクトの依存を列挙するためのセクションの始まりです。
Rustではコードのパッケージのことを<em>クレート</em>と呼びます。
このプロジェクトでは他のクレートは必要ありませんが、第2章の最初のプロジェクトでは必要になるので、そのときにこの依存セクションを使用します。</p>
<!--
Now open *src/main.rs* and take a look:
-->
<p>では、<em>src/main.rs</em>を開いて見てみましょう。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
Cargo has generated a “Hello, world!” program for you, just like the one we
wrote in Listing 1-1! So far, the differences between our previous project and
the project Cargo generated are that Cargo placed the code in the *src*
directory, and we have a *Cargo.toml* configuration file in the top directory.
-->
<p>Cargoはリスト1-1で書いたような「Hello, world!」プログラムを生成してくれています。
これまでのところ、以前のプロジェクトとCargoが生成したプロジェクトの違いは、Cargoがコードを<em>src</em>ディレクトリに配置したことと、
最上位のディレクトリに<em>Cargo.toml</em>設定ファイルがあることです。</p>
<!--
Cargo expects your source files to live inside the *src* directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code. Using Cargo
helps you organize your projects. There’s a place for everything, and
everything is in its place.
-->
<p>Cargoはソースファイルが<em>src</em>ディレクトリにあることを期待します。
プロジェクトの最上位のディレクトリは、READMEファイル、ライセンス情報、設定ファイル、その他のコードに関係しないものだけを置きます。
Cargoを使うとプロジェクトを整理することができます。
すべてのものに決まった場所があり、すべてがその場所にあるのです。</p>
<!--
If you started a project that doesn’t use Cargo, as we did with the “Hello,
world!” project, you can convert it to a project that does use Cargo. Move the
project code into the *src* directory and create an appropriate *Cargo.toml*
file.
-->
<p>「Hello, world!」プロジェクトのようにCargoを使用しないプロジェクトを開始したときでも、Cargoを使用するプロジェクトへと変換できます。
プロジェクトのコードを<em>src</em>ディレクトリに移動し、適切な<em>Cargo.toml</em>ファイルを作成すればいいのです。</p>
<!--
### Building and Running a Cargo Project
-->
<h3 id="cargoプロジェクトをビルドし実行する"><a class="header" href="#cargoプロジェクトをビルドし実行する">Cargoプロジェクトをビルドし、実行する</a></h3>
<!--
Now let’s look at what’s different when we build and run the “Hello, world!”
program with Cargo! From your *hello_cargo* directory, build your project by
entering the following command:
-->
<p>では「Hello, world!」プログラムをCargoでビルドして実行すると、何が違うのかを見てみましょう！
<em>hello_cargo</em>ディレクトリから以下のコマンドを入力して、プロジェクトをビルドします。</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<!--
This command creates an executable file in *target/debug/hello_cargo* (or
*target\debug\hello_cargo.exe* on Windows) rather than in your current
directory. You can run the executable with this command:
-->
<p>このコマンドは実行ファイルを現在のディレクトリではなく、<em>target/debug/hello_cargo</em>（Windowsでは<em>target/debug/hello_cargo.exe</em>）に作成します。
以下のコマンドで実行ファイルを実行できます。</p>
<pre><code class="language-console">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
$                              # Windowsでは .\target\debug\hello_cargo.exe
Hello, world!
</code></pre>
<!--
If all goes well, `Hello, world!` should print to the terminal. Running `cargo
build` for the first time also causes Cargo to create a new file at the top
level: *Cargo.lock*. This file keeps track of the exact versions of
dependencies in your project. This project doesn’t have dependencies, so the
file is a bit sparse. You won’t ever need to change this file manually; Cargo
manages its contents for you.
-->
<p>すべてがうまくいけば、ターミナルに<code>Hello, world!</code>と表示されるはずです。
<code>cargo build</code>を初めて実行したとき、Cargoは最上位に<em>Cargo.lock</em>という新しいファイルを作成します。
このファイルはプロジェクト内の依存関係の正確なバージョンを記録しています。
このプロジェクトには依存がないので、このファイルの中は少しまばらです。
このファイルは手動で変更する必要はありません。
Cargoがその内容を管理してくれます。</p>
<!--
We just built a project with `cargo build` and ran it with
`./target/debug/hello_cargo`, but we can also use `cargo run` to compile the
code and then run the resulting executable all in one command:
-->
<p>先ほどは<code>cargo build</code>でプロジェクトをビルドし、<code>./target/debug/hello_cargo</code>で実行しました。
<code>cargo run</code>を使うと、コードのコンパイルから、できた実行ファイルの実行までの全体を一つのコマンドで行えます。</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!--
Notice that this time we didn’t see output indicating that Cargo was compiling
`hello_cargo`. Cargo figured out that the files hadn’t changed, so it just ran
the binary. If you had modified your source code, Cargo would have rebuilt the
project before running it, and you would have seen this output:
-->
<p>今回はCargoが<code>hello_cargo</code>をコンパイルしていることを示す出力がないことに注目してください。
Cargoはファイルが変更されていないことに気づいたので、単にバイナリを実行したのです。
もしソースコードを変更していたら、Cargoは実行前にプロジェクトを再ビルドし、以下のような出力が表示されたことでしょう。</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<!--
Cargo also provides a command called `cargo check`. This command quickly checks
your code to make sure it compiles but doesn’t produce an executable:
-->
<p>Cargoは<code>cargo check</code>というコマンドも提供しています。
このコマンドはコードがコンパイルできるか素早くチェックしますが、実行ファイルは生成しません。</p>
<pre><code class="language-console">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<!--
Why would you not want an executable? Often, `cargo check` is much faster than
`cargo build`, because it skips the step of producing an executable. If you’re
continually checking your work while writing the code, using `cargo check` will
speed up the process! As such, many Rustaceans run `cargo check` periodically
as they write their program to make sure it compiles. Then they run `cargo
build` when they’re ready to use the executable.
-->
<p>なぜ実行可能ファイルが欲しくないのでしょうか？
<code>cargo check</code>は実行ファイルを生成するステップを省くことができるので、多くの場合、<code>cargo build</code>よりもずっと高速です。
もし、あなたがコードを書きながら継続的にチェックするのなら、<code>cargo check</code>を使えば、そのプロセスを高速化できます！
そのため多くのRustaceanはプログラムを書きながら定期的に<code>cargo check</code>を実行し、コンパイルできるか確かめます。
そして、実行ファイルを使う準備ができたときに<code>cargo build</code>を走らせるのです。</p>
<!--
Let’s recap what we’ve learned so far about Cargo:
-->
<p>ここまでにCargoについて学んだことをおさらいしておきましょう。</p>
<!--
* We can create a project using `cargo new`.
* We can build a project using `cargo build`.
* We can build and run a project in one step using `cargo run`.
* We can build a project without producing a binary to check for errors using
  `cargo check`.
* Instead of saving the result of the build in the same directory as our code,
  Cargo stores it in the *target/debug* directory.
-->
<ul>
<li><code>cargo new</code>を使ってプロジェクトを作成できる</li>
<li><code>cargo build</code>を使ってプロジェクトをビルドできる</li>
<li><code>cargo run</code>を使うとプロジェクトのビルドと実行を1ステップで行える</li>
<li><code>cargo check</code>を使うとバイナリを生成せずにプロジェクトをビルドして、エラーがないか確認できる</li>
<li>Cargoは、ビルドの成果物をコードと同じディレクトリに保存するのではなく、<em>target/debug</em>ディレクトリに格納する</li>
</ul>
<!--
An additional advantage of using Cargo is that the commands are the same no
matter which operating system you’re working on. So, at this point, we’ll no
longer provide specific instructions for Linux and macOS versus Windows.
-->
<p>Cargoを使用するもう一つの利点は、どのOSで作業していてもコマンドが同じであることです。
そのため、これ以降はLinuxやmacOS向けの手順と、Windows向けの手順を分けて説明することはありません。</p>
<!--
### Building for Release
-->
<h3 id="リリースに向けたビルド"><a class="header" href="#リリースに向けたビルド">リリースに向けたビルド</a></h3>
<!--
When your project is finally ready for release, you can use `cargo build
--release` to compile it with optimizations. This command will create an
executable in *target/release* instead of *target/debug*. The optimizations
make your Rust code run faster, but turning them on lengthens the time it takes
for your program to compile. This is why there are two different profiles: one
for development, when you want to rebuild quickly and often, and another for
building the final program you’ll give to a user that won’t be rebuilt
repeatedly and that will run as fast as possible. If you’re benchmarking your
code’s running time, be sure to run `cargo build --release` and benchmark with
the executable in *target/release*.
-->
<p>プロジェクトが最終的にリリースできるようになったら、<code>cargo build --release</code>を使い、最適化した状態でコンパイルできます。
このコマンドは実行ファイルを、<em>target/debug</em>ではなく、<em>target/release</em>に作成します。
最適化によってRustコードの実行速度が上がりますが、それを有効にすることでプログラムのコンパイルにかかる時間が長くなります。
このため二つの異なるプロファイルがあるのです。
一つは開発用で、素早く頻繁に再ビルドしたいときのもの。
もう一つはユーザに渡す最終的なプログラムをビルドするためのもので、繰り返し再ビルドすることはなく、可能な限り高速に動作するようにします。
コードの実行時間をベンチマークするなら、必ず<code>cargo build --release</code>を実行し、<em>target/release</em>の実行ファイルを使ってベンチマークを取ってください。</p>
<!--
### Cargo as Convention
-->
<h3 id="習慣としてのcargo"><a class="header" href="#習慣としてのcargo">習慣としてのCargo</a></h3>
<!--
With simple projects, Cargo doesn’t provide a lot of value over just using
`rustc`, but it will prove its worth as your programs become more intricate.
With complex projects composed of multiple crates, it’s much easier to let
Cargo coordinate the build.
-->
<p>単純なプロジェクトでは、Cargoは単に<code>rustc</code>を使うことに対してあまり多くの価値を生みません。
しかし、プログラムが複雑になるにつれて、その価値を証明することになるでしょう。
複数のクレートからなる複雑なプロジェクトでは、Cargoにビルドを調整させるほうがずっと簡単です。</p>
<!--
Even though the `hello_cargo` project is simple, it now uses much of the real
tooling you’ll use in the rest of your Rust career. In fact, to work on any
existing projects, you can use the following commands to check out the code
using Git, change to that project’s directory, and build:
-->
<p><code>hello_cargo</code>プロジェクトは単純ではありますが、Rustのキャリアを通じて使うことになる本物のツールの多くを使用しています。
実際、既存のどんなプロジェクトで作業するときも、以下のコマンドを使えば、Gitでコードをチェックアウトし、そのプロジェクトのディレクトリに移動し、ビルドすることができます。</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<!--
For more information about Cargo, check out [its documentation].

[its documentation]: https://doc.rust-lang.org/cargo/
-->
<p>Cargoの詳細については、<a href="https://doc.rust-lang.org/cargo/">ドキュメント</a>を参照してください。</p>
<!--
## Summary
-->
<h2 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h2>
<!--
You’re already off to a great start on your Rust journey! In this chapter,
you’ve learned how to:
-->
<p>既にRustの旅の素晴らしいスタートを切っています！
この章では以下を行う方法について学びました。</p>
<!--
* Install the latest stable version of Rust using `rustup`
* Update to a newer Rust version
* Open locally installed documentation
* Write and run a “Hello, world!” program using `rustc` directly
* Create and run a new project using the conventions of Cargo
-->
<ul>
<li><code>rustup</code>で最新の安定版のRustをインストールする</li>
<li>新しいRustのバージョンに更新する</li>
<li>ローカルにインストールされたドキュメントを開く</li>
<li>「Hello, world!」プログラムを書き、<code>rustc</code>を直接使って実行する</li>
<li>Cargoにおける習慣に従った新しいプロジェクトを作成し、実行する</li>
</ul>
<!--
This is a great time to build a more substantial program to get used to reading
and writing Rust code. So, in Chapter 2, we’ll build a guessing game program.
If you would rather start by learning how common programming concepts work in
Rust, see Chapter 3 and then return to Chapter 2.
-->
<p>いまは、より中身のあるプログラムを構築し、Rustコードの読み書きに慣れるのに良いタイミングでしょう。
そこで第2章では、数当てゲームプログラムを構築します。
もし、一般的なプログラミングの概念がRustでどう実現されるか学ぶことから始めたいのであれば、第3章を読んで、それから第2章に戻ってください。</p>
<!--
[installation]: ch01-01-installation.html#installation
[appendix-e]: appendix-05-editions.html
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Programming a Guessing Game
-->
<h1 id="数当てゲームのプログラミング"><a class="header" href="#数当てゲームのプログラミング">数当てゲームのプログラミング</a></h1>
<!--
Let’s jump into Rust by working through a hands-on project together! This
chapter introduces you to a few common Rust concepts by showing you how to use
them in a real program. You’ll learn about `let`, `match`, methods, associated
functions, using external crates, and more! In the following chapters, we’ll
explore these ideas in more detail. In this chapter, you’ll practice the
fundamentals.
-->
<p>ハンズオン形式のプロジェクトに一緒に取り組むことで、Rustの世界に飛び込んでみましょう！ 
この章ではRustの一般的な概念を、実際のプログラムでの使い方を示しながら紹介します。
<code>let</code>、<code>match</code>、メソッド、関連関数、外部クレートの使いかたなどについて学びます！ 
これらについての詳細は後続の章で取り上げますので、この章では基本的なところを練習します。</p>
<!--
We’ll implement a classic beginner programming problem: a guessing game. Here’s
how it works: the program will generate a random integer between 1 and 100. It
will then prompt the player to enter a guess. After a guess is entered, the
program will indicate whether the guess is too low or too high. If the guess is
correct, the game will print a congratulatory message and exit.
-->
<p>プログラミング初心者向けの定番問題である「数当てゲーム」を実装してみましょう。
これは次のように動作します。
プログラムは1から100までのランダムな整数を生成します。
そして、プレーヤーに予想（した数字）を入力するように促します。
予想が入力されると、プログラムはその予想が小さすぎるか大きすぎるかを表示します。
予想が当たっているなら、お祝いのメッセージを表示し、ゲームを終了します。</p>
<!--
## Setting Up a New Project
-->
<h2 id="新規プロジェクトの立ち上げ"><a class="header" href="#新規プロジェクトの立ち上げ">新規プロジェクトの立ち上げ</a></h2>
<!--
To set up a new project, go to the *projects* directory that you created in
Chapter 1 and make a new project using Cargo, like so:
-->
<p>新しいプロジェクトを立ち上げましょう。
第1章で作成した<em>projects</em>ディレクトリに移動し、以下のようにCargoを使って新規プロジェクトを作成します。</p>
<pre><code class="language-console">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<!--
The first command, `cargo new`, takes the name of the project (`guessing_game`)
as the first argument. The second command changes to the new project’s
directory.
-->
<p>最初のコマンド<code>cargo new</code>は、第1引数としてプロジェクト名 (<code>guessing_game</code>) を取ります。
2番目のコマンドは新規プロジェクトのディレクトリに移動します。</p>
<!--
Look at the generated *Cargo.toml* file:
-->
<p>生成された<em>Cargo.toml</em>ファイルを見てみましょう。</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">ファイル名：Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<!--
As you saw in Chapter 1, `cargo new` generates a “Hello, world!” program for
you. Check out the *src/main.rs* file:
-->
<p>第1章で見たように<code>cargo new</code>は「Hello, world!」プログラムを生成してくれます。
<em>src/main.rs</em>ファイルをチェックしてみましょう。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名：src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<!--
Now let’s compile this “Hello, world!” program and run it in the same step
using the `cargo run` command:
-->
<p>さて、<code>cargo run</code>コマンドを使って、この「Hello, world!」プログラムのコンパイルと実行を一気に行いましょう。</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<!--
The `run` command comes in handy when you need to rapidly iterate on a project,
as we’ll do in this game, quickly testing each iteration before moving on to
the next one.
-->
<p>このゲーム（の開発）では各イテレーションを素早くテストしてから、次のイテレーションに移ります。
<code>run</code>コマンドは、今回のようにプロジェクトのイテレーションを素早く回したいときに便利です。</p>
<blockquote>
<p>訳注：ここでのイテレーションは、アジャイルな開発手法で用いられている用語にあたります。</p>
<p>イテレーションとは開発工程の「一回のサイクル」のことで、サイクルには、設計、実装、テスト、改善（リリース後の振り返り）が含まれます。
アジャイル開発ではイテレーションを数週間の短いスパンで一通り回し、それを繰り返すことで開発を進めていきます。</p>
<p>この章では「実装」→「テスト」のごく短いサイクルを繰り返すことで、プログラムに少しずつ機能を追加していきます。</p>
</blockquote>
<!--
Reopen the *src/main.rs* file. You’ll be writing all the code in this file.
-->
<p><em>src/main.rs</em>ファイルを開き直しましょう。
このファイルにすべてのコードを書いていきます。</p>
<!--
## Processing a Guess
-->
<h2 id="予想を処理する"><a class="header" href="#予想を処理する">予想を処理する</a></h2>
<!--
The first part of the guessing game program will ask for user input, process
that input, and check that the input is in the expected form. To start, we’ll
allow the player to input a guess. Enter the code in Listing 2-1 into
*src/main.rs*.
-->
<p>数当てゲームプログラムの最初の部分は、ユーザに入力を求め、その入力を処理し、期待した形式になっていることを確認することです。
手始めに、プレーヤーが予想を入力できるようにしましょう。
リスト2-1のコードを<em>src/main.rs</em>に入力してください。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名：src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);          // 数を当ててごらん

    println!(&quot;Please input your guess.&quot;);   // ほら、予想を入力してね

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);     // 行の読み込みに失敗しました

    println!(&quot;You guessed: {}&quot;, guess);     // 次のように予想しました: {}
}
</code></pre>
<!--
<span class="caption">Listing 2-1: Code that gets a guess from the user and
prints it</span>
-->
<p><span class="caption">リスト2-1：ユーザに予想を入力してもらい、それを出力するコード</span></p>
<!--
This code contains a lot of information, so let’s go over it line by line. To
obtain user input and then print the result as output, we need to bring the
`io` input/output library into scope. The `io` library comes from the
standard library, known as `std`:
-->
<p>このコードには多くの情報が詰め込まれています。
行ごとに見ていきましょう。
ユーザ入力を受け付け、結果を出力するためには<code>io</code>（入出力）ライブラリをスコープに入れる必要があります。
<code>io</code>ライブラリは、<code>std</code>と呼ばれる標準ライブラリに含まれています。</p>
<pre><code class="language-rust ignore">use std::io;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);          // 数を当ててごらん
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);   // ほら、予想を入力してね
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);     // 行の読み込みに失敗しました
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);     // 次のように予想しました: {}
</span><span class="boring">}
</span></code></pre>
<!--
By default, Rust has a few items defined in the standard library that it brings
into the scope of every program. This set is called the *prelude*, and you can
see everything in it [in the standard library documentation][prelude].
-->
<p>Rustはデフォルトで、標準ライブラリで定義されているアイテムの中のいくつかを、すべてのプログラムのスコープに取り込みます。
このセットは<em>prelude</em>（プレリュード）と呼ばれ、<a href="https://doc.rust-lang.org/std/prelude/index.html">標準ライブラリのドキュメント</a>でその中のすべてを見ることができます。</p>
<!--
If a type you want to use isn’t in the prelude, you have to bring that type
into scope explicitly with a `use` statement. Using the `std::io` library
provides you with a number of useful features, including the ability to accept
user input.
-->
<p>使いたい型がpreludeにない場合は、その型を<code>use</code>文で明示的にスコープに入れる必要があります。
<code>std::io</code>ライブラリを<code>use</code>すると、ユーザ入力を受け付ける機能など（入出力に関する）多くの便利な機能が利用できるようになります。</p>
<!--
As you saw in Chapter 1, the `main` function is the entry point into the
program:
-->
<p>第1章で見た通り、<code>main</code>関数がプログラムへのエントリーポイント（訳注：スタート地点）になります。</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span>fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);          // 数を当ててごらん
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);   // ほら、予想を入力してね
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);     // 行の読み込みに失敗しました
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);     // 次のように予想しました: {}
</span><span class="boring">}
</span></code></pre>
<!--
The `fn` syntax declares a new function, the parentheses, `()`, indicate there
are no parameters, and the curly bracket, `{`, starts the body of the function.
-->
<p><code>fn</code>構文は関数を新しく宣言し、かっこの<code>()</code>は引数がないことを示し、波括弧の<code>{</code>は関数の本体を開始します。</p>
<!--
As you also learned in Chapter 1, `println!` is a macro that prints a string to
the screen:
-->
<p>また、第1章で学んだように、<code>println!</code>は画面に文字列を表示するマクロです.</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    println!(&quot;Guess the number!&quot;);          // 数を当ててごらん

    println!(&quot;Please input your guess.&quot;);   // ほら、予想を入力してね
<span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);     // 行の読み込みに失敗しました
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);     // 次のように予想しました: {}
</span><span class="boring">}
</span></code></pre>
<!--
This code is printing a prompt stating what the game is and requesting input
from the user.
-->
<p>このコードはゲームの内容などを示すプロンプトを表示し、ユーザに入力を求めています。</p>
<!--
### Storing Values with Variables
-->
<h3 id="値を変数に保持する"><a class="header" href="#値を変数に保持する">値を変数に保持する</a></h3>
<!--
Next, we’ll create a *variable* to store the user input, like this:
-->
<p>次に、ユーザの入力を格納するための<em>変数</em>を作りましょう。
こんな感じです。</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);          // 数を当ててごらん
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);   // ほら、予想を入力してね
</span><span class="boring">
</span>    let mut guess = String::new();
<span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);     // 行の読み込みに失敗しました
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);     // 次のように予想しました: {}
</span><span class="boring">}
</span></code></pre>
<!--
Now the program is getting interesting! There’s a lot going on in this little
line. We use the `let` statement to create the variable. Here’s another example:
-->
<p>プログラムが少し興味深いものになってきました。
この小さな行の中でいろいろなことが起きています。
<code>let</code>文を使って変数を作っています。
別の例も見てみましょう。</p>
<pre><code class="language-rust ignore">let apples = 5;
</code></pre>
<!--
This line creates a new variable named `apples` and binds it to the value 5. In
Rust, variables are immutable by default. We’ll be discussing this concept in
detail in the [“Variables and Mutability”][variables-and-mutability] section in Chapter 3. To make a variable mutable, we add `mut` before the
variable name:
-->
<p>この行では<code>apples</code>という名前の新しい変数を作成し<code>5</code>という値に束縛しています。
Rustでは変数はデフォルトで不変（immutable）になります。
この概念については第3章の<a href="ch03-01-variables-and-mutability.html#%E5%A4%89%E6%95%B0%E3%81%A8%E5%8F%AF%E5%A4%89%E6%80%A7">「変数と可変性」</a>の節で詳しく説明します。
変数を可変（mutable）にするには、変数名の前に<code>mut</code>をつけます。</p>
<pre><code class="language-rust ignore">let apples = 5; // immutable
                // 不変
let mut bananas = 5; // mutable
                     // 可変
</code></pre>
<!--
> Note: The `//` syntax starts a comment that continues until the end of the
> line. Rust ignores everything in comments. We’ll discuss comments in more
> detail in [Chapter 3][comments].
-->
<blockquote>
<p>注：<code>//</code>構文は行末まで続くコメントを開始し、Rustはコメント内のすべて無視します。
コメントについては<a href="ch03-04-comments.html">第3章</a>で詳しく説明します。</p>
</blockquote>
<!--
Returning to the guessing game program, you now know that `let mut guess` will
introduce a mutable variable named `guess`. The equal sign (`=`) tells Rust we
want to bind something to the variable now. On the right of the equals sign is
the value that `guess` is bound to, which is the result of calling
`String::new`, a function that returns a new instance of a `String`.
[`String`][string] is a string type provided by the standard
library that is a growable, UTF-8 encoded bit of text.
-->
<p>数当てゲームのプログラムに戻りましょう。
ここまでの話で<code>let mut guess</code>が<code>guess</code>という名前の可変変数を導入することがわかったと思います。
等号記号（<code>=</code>）はRustに、いまこの変数を何かに束縛したいことを伝えます。
等号記号の右側には<code>guess</code>が束縛される値があります。
これは<code>String::new</code>関数を呼び出すことで得られた値で、この関数は<code>String</code>型の新しいインスタンスを返します。
<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>は標準ライブラリによって提供される文字列型で、サイズが拡張可能な、UTF-8でエンコードされたテキスト片になります。</p>
<!--
The `::` syntax in the `::new` line indicates that `new` is an associated
function of the `String` type. An *associated function* is a function that’s
implemented on a type, in this case `String`. This `new` function creates a
new, empty string. You’ll find a `new` function on many types, because it’s a
common name for a function that makes a new value of some kind.
-->
<p><code>::new</code>の行にある<code>::</code>構文は<code>new</code>が<code>String</code>型の関連関数であることを示しています。
<em>関連関数</em>とは、ある型（ここでは<code>String</code>）に対して実装される関数のことです。
この<code>new</code>関数は新しい空の文字列を作成します。
<code>new</code>関数は多くの型に見られます。
なぜなら、何らかの新しい値を作成する関数によくある名前だからです。</p>
<!--
In full, the `let mut guess = String::new();` line has created a mutable
variable that is currently bound to a new, empty instance of a `String`. Whew!
-->
<p>つまり<code>let mut guess = String::new();</code>という行は可変変数を作成し、その変数は現時点では新しい空の<code>String</code>のインスタンスに束縛されているわけです。
ふう！</p>
<!--
### Receiving User Input
-->
<h3 id="ユーザの入力を受け取る"><a class="header" href="#ユーザの入力を受け取る">ユーザの入力を受け取る</a></h3>
<!--
Recall that we included the input/output functionality from the standard
library with `use std::io;` on the first line of the program. Now we’ll call
the `stdin` function from the `io` module, which will allow us to handle user
input:
-->
<p>プログラムの最初の行に<code>use std::io</code>と書いて、標準ライブラリの入出力機能を取り込んだことを思い出してください。
ここで<code>io</code>モジュールの<code>stdin</code>関数を呼び出して、ユーザ入力を処理できるようにしましょう。</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);          // 数を当ててごらん
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);   // ほら、予想を入力してね
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span>    io::stdin()
        .read_line(&amp;mut guess)
<span class="boring">        .expect(&quot;Failed to read line&quot;);     // 行の読み込みに失敗しました
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);     // 次のように予想しました: {}
</span><span class="boring">}
</span></code></pre>
<!--
If we hadn’t imported the `io` library with `use std::io` at the beginning of
the program, we could still use the function by writing this function call as
`std::io::stdin`. The `stdin` function returns an instance of
[`std::io::Stdin`][iostdin], which is a type that represents a
handle to the standard input for your terminal.
-->
<p>もし、プログラムの最初に<code>use std::io</code>と書いて<code>io</code>ライブラリをインポートしていなかったとしても、<code>std::io::stdin</code>のように呼び出せば、この関数を利用できます。
<code>stdin</code>関数はターミナルの標準入力へのハンドルを表す型である<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a>のインスタンスを返します。</p>
<!--
Next, the line `.read_line(&mut guess)` calls the [`read_line`][read_line] method on the standard input handle to get input from the user.
We’re also passing `&mut guess` as the argument to `read_line` to tell it what
string to store the user input in. The full job of `read_line` is to take
whatever the user types into standard input and append that into a string
(without overwriting its contents), so we therefore pass that string as an
argument. The string argument needs to be mutable so the method can change the
string’s content.
-->
<p>次の<code>.read_line(&amp;mut guess)</code>行は、標準入力ハンドルの<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a>メソッドを呼び出し、ユーザからの入力を得ています。
また、<code>read_line</code>の引数として<code>&amp;mut guess</code>を渡し、ユーザ入力をどの文字列に格納するかを指示しています。
<code>read_line</code>メソッドの仕事は、ユーザが標準入力に入力したものを文字列に（いまの内容を上書きせずに）追加することですので、文字列を引数として渡しているわけです。
引数の文字列は、その内容をメソッドが変更できるように、可変である必要があります。</p>
<!--
The `&` indicates that this argument is a *reference*, which gives you a way to
let multiple parts of your code access one piece of data without needing to
copy that data into memory multiple times. References are a complex feature,
and one of Rust’s major advantages is how safe and easy it is to use
references. You don’t need to know a lot of those details to finish this
program. For now, all you need to know is that like variables, references are
immutable by default. Hence, you need to write `&mut guess` rather than
`&guess` to make it mutable. (Chapter 4 will explain references more
thoroughly.)
-->
<p>この<code>&amp;</code>は、この引数が<em>参照</em>であることを示し、これによりコードの複数の部分が同じデータにアクセスしても、そのデータを何度もメモリにコピーしなくて済みます。
参照は複雑な機能（訳注：一部のプログラム言語では正しく使うのが難しい機能）ですが、Rustの大きな利点の一つは参照を安全かつ簡単に使用できることです。
このプログラムを完成させるのに、そのような詳細を知る必要はないでしょう。
とりあえず知っておいてほしいのは、変数のように参照もデフォルトで不変であることです。
したがって、<code>&amp;guess</code>ではなく<code>&amp;mut guess</code>と書いて可変にする必要があります。
（参照については第4章でより詳しく説明します）</p>
<!--
### Handling Potential Failure with the `Result` Type
-->
<h3 id="result型で失敗の可能性を扱う"><a class="header" href="#result型で失敗の可能性を扱う"><code>Result</code>型で失敗の可能性を扱う</a></h3>
<!--
We’re still working on this line of code. Although we’re now discussing a third
line of text, it’s still part of a single logical line of code. The next part
is this method:
-->
<p>まだ、このコードの行は終わってません。
これから説明するのはテキスト上は3行目になりますが、まだ一つの論理的な行の一部分に過ぎません。
次の部分はこのメソッドです。</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);          // 数を当ててごらん
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);   // ほら、予想を入力してね
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span>        .expect(&quot;Failed to read line&quot;);     // 行の読み込みに失敗しました
<span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);     // 次のように予想しました: {}
</span><span class="boring">}
</span></code></pre>
<!--
We could have written this code as:
-->
<p>このコードは、こう書くこともできました。</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
</code></pre>
<!--
However, one long line is difficult to read, so it’s best to divide it. It’s
often wise to introduce a newline and other whitespace to help break up long
lines when you call a method with the `.method_name()` syntax. Now let’s
discuss what this line does.
-->
<p>しかし、長い行は読みづらいので分割したほうがよいでしょう。
<code>.method_name()</code>構文でメソッドを呼び出すとき、長い行を改行と空白で分割するのが賢明なことがよくあります。
それでは、この行（<code>expect()</code>メソッド）が何をするのか説明します。</p>
<!--
As mentioned earlier, `read_line` puts whatever the user enters into the string
we pass to it, but it also returns a value—in this case, an
[`io::Result`][ioresult]. Rust has a number of types named
`Result` in its standard library: a generic [`Result`][result]
as well as specific versions for submodules, such as `io::Result`. The `Result`
types are [*enumerations*][enums], often referred to as *enums*,
which can have a fixed set of possibilities known as *variants*. Enums are
often used with `match`, a conditional that makes it convenient to execute
different code based on which variant an enum value is when the conditional is
evaluated.
-->
<p>前述したように、<code>read_line</code>メソッドは渡された文字列にユーザが入力したものを入れます。
しかし、同時に値（この場合は<a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>）も返します。
Rustの標準ライブラリには<code>Result</code>という名前の型がいくつかあります。
汎用の<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>と、<code>io::Result</code>といったサブモジュール用の特殊な型などです。
これらの<code>Result</code>型は<a href="ch06-00-enums.html"><em>列挙型</em></a>になります。
列挙型は<em>enum</em>とも呼ばれ、取りうる値として決まった数の<em>列挙子</em>（variant）を持ちます。
列挙型はよく<code>match</code>と一緒に使われます。
これは条件式の一種で、評価時に、列挙型の値がどの列挙子であるかに基づいて異なるコードを実行できるという便利なものです。</p>
<!--
Chapter 6 will cover enums in more detail. The purpose of these `Result` types
is to encode error-handling information.
-->
<p>enumについては第6章で詳しく説明します。
これらの<code>Result</code>型の目的は、エラー処理に関わる情報を符号化（エンコード）することです。</p>
<!--
`Result`’s variants are `Ok` and `Err`. The `Ok` variant indicates the operation
was successful, and inside `Ok` is the successfully generated value. The `Err`
variant means the operation failed, and `Err` contains information about how or
why the operation failed.
-->
<p><code>Result</code>の列挙子は<code>Ok</code>か<code>Err</code>です。
<code>Ok</code>列挙子は処理が成功したことを示し、<code>Ok</code>の中には正常に生成された値が入っています。
<code>Err</code>列挙子は処理が失敗したことを意味し、<code>Err</code>には処理が失敗した過程や理由についての情報が含まれています。</p>
<!--
Values of the `Result` type, like values of any type, have methods defined on
them. An instance of `io::Result` has an [`expect` method][expect] that you can call. If this instance of `io::Result` is an `Err` value,
`expect` will cause the program to crash and display the message that you
passed as an argument to `expect`. If the `read_line` method returns an `Err`,
it would likely be the result of an error coming from the underlying operating
system. If this instance of `io::Result` is an `Ok` value, `expect` will take
the return value that `Ok` is holding and return just that value to you so you
can use it. In this case, that value is the number of bytes in the user’s input.
-->
<p><code>Result</code>型の値にも、他の型と同様にメソッドが定義されています。
<code>io::Result</code>のインスタンスには<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.expect"><code>expect</code>メソッド</a>がありますので、これを呼び出せます。
この<code>io::Result</code>インスタンスが<code>Err</code>の値の場合、<code>expect</code>メソッドはプログラムをクラッシュさせ、引数として渡されたメッセージを表示します。
<code>read_line</code>メソッドが<code>Err</code>を返したら、それはおそらく基礎となるオペレーティング・システムに起因するものでしょう。
もしこの<code>io::Result</code>オブジェクトが<code>Ok</code>値の場合、<code>expect</code>メソッドは<code>Ok</code>列挙子が保持する戻り値を取り出して、その値だけを返してくれます。
こうして私たちはその値を使うことができるわけです。
今回の場合、その値はユーザ入力のバイト数になります。</p>
<!--
If you don’t call `expect`, the program will compile, but you’ll get a warning:
-->
<p>もし<code>expect</code>メソッドを呼び出さなかったら、コンパイルはできるものの警告が出るでしょう。</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
(警告: 使用されなければならない`std::result::Result`が使用されていません)
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_must_use)]` on by default
   = note: this `Result` may be an `Err` variant, which should be handled

warning: `guessing_game` (bin &quot;guessing_game&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<!--
Rust warns that you haven’t used the `Result` value returned from `read_line`,
indicating that the program hasn’t handled a possible error.
-->
<p>Rustは私たちが<code>read_line</code>から返された<code>Result</code>値を使用していないことを警告し、これはプログラムがエラーの可能性に対処していないことを示します。</p>
<!--
The right way to suppress the warning is to actually write error handling, but
in our case we just want to crash this program when a problem occurs, so we can
use `expect`. You’ll learn about recovering from errors in [Chapter
9][recover].
-->
<p>警告を抑制する正しい方法は実際にエラー処理を書くことです。
しかし、現時点では問題が起きたときにこのプログラムをクラッシュさせたいだけなので、<code>expect</code>が使えるわけです。
エラーからの回復については第9章で学びます。</p>
<!--
### Printing Values with `println!` Placeholders
-->
<h3 id="printlnマクロのプレースホルダーで値を表示する"><a class="header" href="#printlnマクロのプレースホルダーで値を表示する"><code>println!</code>マクロのプレースホルダーで値を表示する</a></h3>
<!--
Aside from the closing curly bracket, there’s only one more line to discuss in
the code so far:
-->
<p>閉じ波かっこを除けば、ここまでのコードで説明するのは残り1行だけです。</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);          // 数を当ててごらん
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);   // ほら、予想を入力してね
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);     // 行の読み込みに失敗しました
</span><span class="boring">
</span>    println!(&quot;You guessed: {}&quot;, guess);     // 次のように予想しました: {}
<span class="boring">}
</span></code></pre>
<!--
This line prints the string that now contains the user’s input. The `{}` set of
curly brackets is a placeholder: think of `{}` as little crab pincers that hold
a value in place. You can print more than one value using curly brackets: the
first set of curly brackets holds the first value listed after the format
string, the second set holds the second value, and so on. Printing multiple
values in one call to `println!` would look like this:
-->
<p>この行はユーザの入力を現在保持している文字列を表示します。
一組の波括弧の<code>{}</code>はプレースホルダーです。
<code>{}</code>は値を所定の場所に保持する小さなカニのはさみだと考えてください。
波括弧をいくつか使えば複数の値を表示できます。
最初の波括弧の組はフォーマット文字列のあとに並んだ最初の値に対応し、2組目は2番目の値、というように続いていきます。
一回の<code>println!</code>の呼び出しで複数の値を表示するなら次のようになります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {} and y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
This code would print `x = 5 and y = 10`.
-->
<p>このコードは<code>x = 5 and y = 10</code>と表示するでしょう。</p>
<!--
### Testing the First Part
-->
<h3 id="最初の部分をテストする"><a class="header" href="#最初の部分をテストする">最初の部分をテストする</a></h3>
<!--
Let’s test the first part of the guessing game. Run it using `cargo run`:
-->
<p>数当てゲームの最初の部分をテストしてみましょう。
<code>cargo run</code>で走らせてください。</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<!--
At this point, the first part of the game is done: we’re getting input from the
keyboard and then printing it.
-->
<p>これで、キーボードからの入力を得て、それを表示するという、ゲームの最初の部分は完成になります。</p>
<!--
## Generating a Secret Number
-->
<h2 id="秘密の数字を生成する"><a class="header" href="#秘密の数字を生成する">秘密の数字を生成する</a></h2>
<!--
Next, we need to generate a secret number that the user will try to guess. The
secret number should be different every time so the game is fun to play more
than once. We’ll use a random number between 1 and 100 so the game isn’t too
difficult. Rust doesn’t yet include random number functionality in its standard
library. However, the Rust team does provide a [`rand` crate][randcrate] with
said functionality.
-->
<p>次にユーザが数当てに挑戦する秘密の数字を生成する必要があります。
この数字を毎回変えることで何度やっても楽しいゲームになります。
ゲームが難しくなりすぎないように1から100までの乱数を使用しましょう。
Rustの標準ライブラリには、まだ乱数の機能は含まれていません。
ですが、Rustの開発チームがこの機能を持つ<a href="https://crates.io/crates/rand"><code>rand</code>クレート</a>を提供してくれています。</p>
<!--
### Using a Crate to Get More Functionality
-->
<h3 id="クレートを使用して機能を追加する"><a class="header" href="#クレートを使用して機能を追加する">クレートを使用して機能を追加する</a></h3>
<!--
Remember that a crate is a collection of Rust source code files. The project
we’ve been building is a *binary crate*, which is an executable. The `rand`
crate is a *library crate*, which contains code intended to be used in other
programs, and can’t be executed on its own.
-->
<p>クレートはRustソースコードを集めたものであることを思い出してください。
私たちがここまで作ってきたプロジェクトは<em>バイナリクレート</em>であり、これは実行可能ファイルになります。
<code>rand</code>クレートは<em>ライブラリクレート</em>です。
他のプログラムで使用するためのコードが含まれており、単独で実行することはできません。</p>
<!--
Cargo’s coordination of external crates is where Cargo really shines. Before we
can write code that uses `rand`, we need to modify the *Cargo.toml* file to
include the `rand` crate as a dependency. Open that file now and add the
following line to the bottom beneath the `[dependencies]` section header that
Cargo created for you. Be sure to specify `rand` exactly as we have here, with
this version number, or the code examples in this tutorial may not work.
-->
<p>Cargoがその力を発揮するのは外部クレートと連携するときです。
<code>rand</code>を使ったコードを書く前に、<em>Cargo.toml</em>ファイルを編集して<code>rand</code>クレートを依存関係に含める必要があります。
そのファイルを開いて、Cargoが作ってくれた<code>[dependencies]</code>セクションヘッダの下に次の行を追加してください。
バージョンナンバーを含め、ここに書かれている通り正確に<code>rand</code>を指定してください。
そうしないと、このチュートリアルのコード例が動作しないかもしれません。</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">ファイル名：Cargo.toml</span></p>
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<!--
In the *Cargo.toml* file, everything that follows a header is part of that
section that continues until another section starts. In `[dependencies]` you
tell Cargo which external crates your project depends on and which versions of
those crates you require. In this case, we specify the `rand` crate with the
semantic version specifier `0.8.3`. Cargo understands [Semantic
Versioning][semver] (sometimes called *SemVer*), which is a
standard for writing version numbers. The number `0.8.3` is actually shorthand
for `^0.8.3`, which means any version that is at least `0.8.3` but below
`0.9.0`. Cargo considers these versions to have public APIs compatible with
version `0.8.3`, and this specification ensures you’ll get the latest patch
release that will still compile with the code in this chapter. Any version
`0.9.0` or greater is not guaranteed to have the same API as what the following
examples use.
-->
<p><em>Cargo.toml</em>ファイルでは、ヘッダに続くものはすべて、他のセクションが始まるまで続くセクションの一部になります。
（訳注：Cargo.tomlファイル内には複数のセクションがあり、各セクションは<code>[ ]</code>で囲まれたヘッダ行から始まります）</p>
<p><code>[dependecies]</code>はプロジェクトが依存する外部クレートと必要とするバージョンをCargoに伝えます。
今回は<code>rand</code>クレートを<code>0.8.3</code>というセマンティックバージョン指定子で指定します。
Cargoは<a href="http://semver.org">セマンティックバージョニング</a>（<em>SemVer</em>と呼ばれることもあります）を理解しており、これはバージョンナンバーを記述するための標準です。
<code>0.8.3</code>という数字は実際には<code>^0.8.3</code>の省略記法で、<code>0.8.3</code>以上<code>0.9.0</code>未満の任意のバージョンを意味します。
Cargoはこれらのバージョンを、バージョン<code>0.8.3</code>と互換性のある公開APIを持つものとみなします。
この仕様により、この章のコードが引き続きコンパイルできるようにしつつ、最新のパッチリリースを取得できるようになります。
0.9.0以降のバージョンは、以下の例で使用しているものと同じAPIを持つことを保証しません。</p>
<!--
Now, without changing any of the code, let’s build the project, as shown in
Listing 2-2.
-->
<p>さて、コードを一切変えずに、次のリスト2-2のようにプロジェクトをビルドしてみましょう。</p>
<pre><code class="language-console">$ cargo build
    Updating crates.io index
    (crates.ioインデックスを更新しています)
  Downloaded rand v0.8.3
  (rand v0.8.3をダウンロードしています)
  Downloaded libc v0.2.86
  Downloaded getrandom v0.2.2
  Downloaded cfg-if v1.0.0
  Downloaded ppv-lite86 v0.2.10
  Downloaded rand_chacha v0.3.0
  Downloaded rand_core v0.6.2
   Compiling rand_core v0.6.2
   (rand_core v0.6.2をコンパイルしています)
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
   (guessing_game v0.1.0をコンパイルしています)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
</code></pre>
<!--
<span class="caption">Listing 2-2: The output from running `cargo build` after
adding the rand crate as a dependency</span>
-->
<p><span class="caption">リスト2-2：randクレートを依存として追加した後の<code>cargo build</code>コマンドの出力</span></p>
<!--
You may see different version numbers (but they will all be compatible with the
code, thanks to SemVer!), different lines (depending on the operating system),
and the lines may be in a different order.
-->
<p>もしかしたら異なるバージョンナンバー（とはいえ、SemVerのおかげですべてのコードに互換性があります）や、
異なる行（オペレーティングシステムに依存します）が表示されるかもしれません。
また、行の順序も違うかもしれません。</p>
<!--
When we include an external dependency, Cargo fetches the latest versions of
everything that dependency needs from the *registry*, which is a copy of data
from [Crates.io][cratesio]. Crates.io is where people in the Rust ecosystem
post their open source Rust projects for others to use.
-->
<p>外部依存を持つようになると、Cargoはその依存関係が必要とするすべてについて最新のバージョンを<em>レジストリ</em>から取得します。
レジストリとは<a href="https://crates.io">Crates.io</a>のデータのコピーです。
Crates.ioは、Rustのエコシステムにいる人たちがオープンソースのRustプロジェクトを投稿し、他の人が使えるようにする場所です。</p>
<!--
After updating the registry, Cargo checks the `[dependencies]` section and
downloads any crates listed that aren’t already downloaded. In this case,
although we only listed `rand` as a dependency, Cargo also grabbed other crates
that `rand` depends on to work. After downloading the crates, Rust compiles
them and then compiles the project with the dependencies available.
-->
<p>レジストリの更新後、Cargoは<code>[dependencies]</code>セクションにリストアップされているクレートをチェックし、まだ取得していないものがあればダウンロードします。
ここでは依存関係として<code>rand</code>だけを書きましたが、<code>rand</code>が動作するために依存している他のクレートも取り込まれています。
クレートをダウンロードしたあと、Rustはそれらをコンパイルし、依存関係が利用できる状態でプロジェクトをコンパイルします。</p>
<!--
If you immediately run `cargo build` again without making any changes, you
won’t get any output aside from the `Finished` line. Cargo knows it has already
downloaded and compiled the dependencies, and you haven’t changed anything
about them in your *Cargo.toml* file. Cargo also knows that you haven’t changed
anything about your code, so it doesn’t recompile that either. With nothing to
do, it simply exits.
-->
<p>何も変更せずにすぐに<code>cargo build</code>コマンドを再度実行すると、<code>Finished</code>の行以外は何も出力されないでしょう。
Cargoはすでに依存関係をダウンロードしてコンパイル済みであることを認識しており、また、あなたが<em>Cargo.toml</em>ファイルを変更していないことも知っているからです。
さらに、Cargoはあなたがコードを何も変更していないことも知っているので、再コンパイルもしません。
何もすることがないので単に終了します。</p>
<!--
If you open up the *src/main.rs* file, make a trivial change, and then save it
and build again, you’ll only see two lines of output:
-->
<p><em>src/main.rs</em>ファイルを開いて些細な変更を加え、それを保存して再度ビルドすると2行しか表示されません。</p>
<pre><code class="language-console">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<!--
These lines show Cargo only updates the build with your tiny change to the
*src/main.rs* file. Your dependencies haven’t changed, so Cargo knows it can
reuse what it has already downloaded and compiled for those.
-->
<p>これらの行はCargoが<em>src/main.rs</em>ファイルへの小さな変更に対して、ビルドを更新していることを示しています。
依存関係は変わっていないので、Cargoは既にダウンロードしてコンパイルしたものが再利用できることを知っています。</p>
<!--
#### Ensuring Reproducible Builds with the *Cargo.lock* File
-->
<h4 id="cargolockファイルで再現可能なビルドを確保する"><a class="header" href="#cargolockファイルで再現可能なビルドを確保する"><em>Cargo.lock</em>ファイルで再現可能なビルドを確保する</a></h4>
<!--
Cargo has a mechanism that ensures you can rebuild the same artifact every time
you or anyone else builds your code: Cargo will use only the versions of the
dependencies you specified until you indicate otherwise. For example, say that
next week version 0.8.4 of the `rand` crate comes out, and that version
contains an important bug fix, but it also contains a regression that will
break your code. To handle this, Rust creates the *Cargo.lock* file the first
time you run `cargo build`, so we now have this in the *guessing_game*
directory.
-->
<p>Cargoはあなたや他の人があなたのコードをビルドするたびに、同じ生成物をリビルドできるようにするしくみを備えています。
Cargoは何も指示されない限り、指定したバージョンの依存のみを使用します。
たとえば来週<code>rand</code>クレートのバージョン0.8.4が出て、そのバージョンには重要なバグ修正が含まれていますが、同時にあなたのコードを破壊するリグレッションも含まれているとします。
これに対応するため、Rustは<code>cargo build</code>を最初に実行したときに<em>Cargo.lock</em>ファイルを作成します。
（いまの<em>guessing_game</em>ディレクトリにもあるはずです）</p>
<!--
When you build a project for the first time, Cargo figures out all the
versions of the dependencies that fit the criteria and then writes them to
the *Cargo.lock* file. When you build your project in the future, Cargo will
see that the *Cargo.lock* file exists and use the versions specified there
rather than doing all the work of figuring out versions again. This lets you
have a reproducible build automatically. In other words, your project will
remain at `0.8.3` until you explicitly upgrade, thanks to the *Cargo.lock*
file.
-->
<p>プロジェクトを初めてビルドするとき、Cargoは条件に合うすべての依存関係のバージョンを計算し<em>Cargo.lock</em>ファイルに書き込みます。
次にプロジェクトをビルドすると、Cargoは<em>Cargo.lock</em>ファイルが存在することを確認し、バージョンを把握するすべての作業を再び行う代わりに、そこで指定されているバージョンを使います。
これにより再現性のあるビルドを自動的に行えます。
言い換えれば、<em>Cargo.lock</em>ファイルのおかげで、あなたが明示的にアップグレードするまで、プロジェクトは<code>0.8.3</code>を使い続けます。</p>
<!--
#### Updating a Crate to Get a New Version
-->
<h4 id="クレートを更新して新バージョンを取得する"><a class="header" href="#クレートを更新して新バージョンを取得する">クレートを更新して新バージョンを取得する</a></h4>
<!--
When you *do* want to update a crate, Cargo provides the command `update`,
which will ignore the *Cargo.lock* file and figure out all the latest versions
that fit your specifications in *Cargo.toml*. Cargo will then write those
versions to the *Cargo.lock* file. Otherwise, by default, Cargo will only look
for versions greater than `0.8.3` and less than `0.9.0`. If the `rand` crate
has released the two new versions `0.8.4` and `0.9.0` you would see the
following if you ran `cargo update`:
-->
<p>クレートを<em>本当に</em>アップグレードしたくなったときのために、Cargoは<code>update</code>コマンドを提供します。
このコマンドは<em>Cargo.lock</em>ファイルを無視して、<em>Cargo.toml</em>ファイル内の全ての指定に適合する最新バージョンを算出します。
成功したらCargoはそれらのバージョンを<em>Cargo.lock</em>ファイルに記録します。
ただし、デフォルトでCargoは<code>0.8.3</code>以上、<code>0.9.0</code>未満のバージョンのみを検索します。
もし<code>rand</code>クレートの新しいバージョンとして<code>0.8.4</code>と<code>0.9.0</code>の二つがリリースされていたなら、<code>cargo update</code>を実行したときに以下のようなメッセージが表示されるでしょう。</p>
<pre><code class="language-console">$ cargo update
    Updating crates.io index
    (crates.ioインデックスを更新しています)
    Updating rand v0.8.3 -&gt; v0.8.4
    (randクレートをv0.8.3 -&gt; v0.8.4に更新しています)
</code></pre>
<!--
Cargo ignores the `0.9.0` release. At this point, you would also notice a
change in your *Cargo.lock* file noting that the version of the `rand` crate
you are now using is `0.8.4`. To use `rand` version `0.9.0` or any version in
the `0.9.x` series, you’d have to update the *Cargo.toml* file to look like
this instead:
-->
<p>Cargoは<code>0.9.0</code>リリースを無視します。
またそのとき、<em>Cargo.lock</em>ファイルが変更され、<code>rand</code>クレートの現在使用中のバージョンが<code>0.8.4</code>になったことにも気づくでしょう。
そうではなく、<code>rand</code>のバージョン<code>0.9.0</code>か、<code>0.9.x</code>系のどれかを使用するには、<em>Cargo.toml</em>ファイルを以下のように変更する必要があります。</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.9.0&quot;
</code></pre>
<!--
The next time you run `cargo build`, Cargo will update the registry of crates
available and reevaluate your `rand` requirements according to the new version
you have specified.
-->
<p>次に<code>cargo build</code>コマンドを実行したとき、Cargoは利用可能なクレートのレジストリを更新し、あなたが指定した新しいバージョンに従って<code>rand</code>の要件を再評価します。</p>
<!--
There’s a lot more to say about [Cargo][doccargo] and [its
ecosystem][doccratesio] which we’ll discuss in Chapter 14, but
for now, that’s all you need to know. Cargo makes it very easy to reuse
libraries, so Rustaceans are able to write smaller projects that are assembled
from a number of packages.
-->
<p><a href="http://doc.crates.io">Cargo</a>と<a href="http://doc.crates.io/crates-io.html">そのエコシステム</a>については、まだ伝えたいことが山ほどありますが、それらについては第14章で説明します。
いまのところは、これだけ知っていれば十分です。
Cargoはライブラリの再利用をとても簡単にしてくれるので、Rustaceanが数多くのパッケージから構成された小さなプロジェクトを書くことが可能になっています。</p>
<!--
### Generating a Random Number
-->
<h3 id="乱数を生成する"><a class="header" href="#乱数を生成する">乱数を生成する</a></h3>
<!--
Let’s start using `rand` to generate a number to guess. The next step is to
update *src/main.rs*, as shown in Listing 2-3.
-->
<p><code>rand</code>クレートを使って予想する数字を生成しましょう。
次のステップは<em>src/main.rs</em>ファイルをリスト2-3のように更新することです。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名：src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!(&quot;The secret number is: {}&quot;, secret_number);    //秘密の数字は次の通り: {}

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<!--
<span class="caption">Listing 2-3: Adding code to generate a random
number</span>
-->
<p><span class="caption">リスト2-3：乱数を生成するコードの追加</span></p>
<!--
First, we add the line `use rand::Rng`. The `Rng` trait defines methods that
random number generators implement, and this trait must be in scope for us to
use those methods. Chapter 10 will cover traits in detail.
-->
<p>まず<code>use rand::Rng</code>という行を追加します。
<code>Rng</code>トレイトは乱数生成器が実装すべきメソッドを定義しており、それらのメソッドを使用するには、このトレイトがスコープ内になければなりません。
トレイトについて詳しくは第10章で解説します。</p>
<!--
Next, we’re adding two lines in the middle. In the first line, we call the
`rand::thread_rng` function that gives us the particular random number
generator that we’re going to use: one that is local to the current thread of
execution and seeded by the operating system. Then we call the `gen_range`
method on the random number generator. This method is defined by the `Rng`
trait that we brought into scope with the `use rand::Rng` statement. The
`gen_range` method takes a range expression as an argument and generates a
random number in the range. The kind of range expression we’re using here takes
the form `start..end` and is inclusive on the lower bound but exclusive on the
upper bound, so we need to specify `1..101` to request a number between 1 and
100. Alternatively, we could pass the range `1..=100`, which is equivalent.
-->
<p>次に、途中に2行を追加しています。
最初の行では<code>rand::thread_rng</code>関数を呼び出して、これから使う、ある特定の乱数生成器を取得しています。
なお、この乱数生成器は現在のスレッドに固有で、オペレーティングシステムからシード値を得ています。
そして、この乱数生成器の<code>gen_range</code>メソッドを呼び出しています。
このメソッドは<code>use rand::Rng</code>文でスコープに導入した<code>Rng</code>トレイトで定義されています。
<code>gen_range</code>メソッドは範囲式を引数にとり、その範囲内の乱数を生成してくれます。
ここで使っている範囲式の種類は<code>開始..終了</code>という形式で、下限値は含みますが上限値は含みません。
そのため、1から100までの数をリクエストするには<code>1..101</code>と指定する必要があります。
あるいは、これと同等の<code>1..=100</code>という範囲を渡すこともできます。</p>
<!--
> Note: You won’t just know which traits to use and which methods and functions
> to call from a crate, so each crate has documentation with instructions for
> using it. Another neat feature of Cargo is that running the `cargo doc
> --open` command will build documentation provided by all of your dependencies
> locally and open it in your browser. If you’re interested in other
> functionality in the `rand` crate, for example, run `cargo doc --open` and
> click `rand` in the sidebar on the left.
-->
<blockquote>
<p>注：クレートのどのトレイトを<code>use</code>するかや、どのメソッドや関数を呼び出すかを知るために、各クレートにはその使い方を説明したドキュメントが用意されています。
Cargoのもう一つの素晴らしい機能は、<code>cargo doc --open</code>コマンドを走らせると、すべての依存クレートが提供するドキュメントをローカルでビルドして、ブラウザで開いてくれることです。
たとえば<code>rand</code>クレートの他の機能に興味があるなら、<code>cargo doc --open</code>コマンドを実行して、左側のサイドバーにある<code>rand</code>をクリックしてください。</p>
</blockquote>
<!--
The second new line prints the secret number. This is useful while we’re
developing the program to be able to test it, but we’ll delete it from the
final version. It’s not much of a game if the program prints the answer as soon
as it starts!
-->
<p>コードに追加した2行目は秘密の数字を表示します。
これはプログラムを開発している間のテストに便利ですが、最終版からは削除する予定です。
プログラムが始まってすぐに答えが表示されたらゲームになりませんからね！</p>
<!--
Try running the program a few times:
-->
<p>試しにプログラムを何回か走らせてみてください。</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<!--
You should get different random numbers, and they should all be numbers between
1 and 100. Great job!
-->
<p>毎回異なる乱数を取得し、それらはすべて1から100の範囲内の数字になるはずです。
よくやりました！</p>
<!--
## Comparing the Guess to the Secret Number
-->
<h2 id="予想と秘密の数字を比較する"><a class="header" href="#予想と秘密の数字を比較する">予想と秘密の数字を比較する</a></h2>
<!--
Now that we have user input and a random number, we can compare them. That step
is shown in Listing 2-4. Note that this code won’t compile quite yet, as we
will explain.
-->
<p>さて、ユーザ入力と乱数が揃ったので両者を比較してみましょう。
このステップをリスト2-4に示します。
これから説明するように、このコードはまだコンパイルできないことに注意してください。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名：src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    // --snip--
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span>
    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),       //小さすぎ！
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),      //大きすぎ！
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),        //やったね！
    }
}
</code></pre>
<!--
<span class="caption">Listing 2-4: Handling the possible return values of
comparing two numbers</span>
-->
<p><span class="caption">リスト2-4：二つの数値を比較したときに返される可能性のある値を処理する</span></p>
<!--
First we add another `use` statement, bringing a type called
`std::cmp::Ordering` into scope from the standard library. The `Ordering` type
is another enum and has the variants `Less`, `Greater`, and `Equal`. These are
the three outcomes that are possible when you compare two values.
-->
<p>まず<code>use</code>文を追加して標準ライブラリから<code>std::cmp::Ordering</code>という型をスコープに導入しています。
<code>Ordering</code>もenumの一つで<code>Less</code>、<code>Greater</code>、<code>Equal</code>という列挙子を持っています。
これらは二つの値を比較したときに得られる3種類の結果です。</p>
<pre><code class="language-rust ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less =&gt; println!(&quot;Too small!&quot;),
    Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
    Ordering::Equal =&gt; println!(&quot;You win!&quot;),
}
</code></pre>
<!--
Then we add five new lines at the bottom that use the `Ordering` type. The
`cmp` method compares two values and can be called on anything that can be
compared. It takes a reference to whatever you want to compare with: here it’s
comparing the `guess` to the `secret_number`. Then it returns a variant of the
`Ordering` enum we brought into scope with the `use` statement. We use a
[`match`][match] expression to decide what to do next based on
which variant of `Ordering` was returned from the call to `cmp` with the values
in `guess` and `secret_number`.
-->
<p>それから<code>Ordering</code>型を使用する新しい5行をいちばん下に追加してしています。
<code>cmp</code>メソッドは二つの値の比較を行い、比較できるものになら何に対しても呼び出せます。
比較対象への参照をとり、ここでは<code>guess</code>と<code>secret_number</code>を比較しています。
そして<code>use</code>文でスコープに導入した<code>Ordering</code>列挙型の列挙子を返します。
ここでは<a href="ch06-02-match.html"><code>match</code></a>式を使用しており、<code>guess</code>と<code>secret_number</code>の値に対して<code>cmp</code>を呼んだ結果返された<code>Ordering</code>の列挙子に基づき、次の動作を決定しています。</p>
<!--
A `match` expression is made up of *arms*. An arm consists of a *pattern* to
match against, and the code that should be run if the value given to `match`
fits that arm’s pattern. Rust takes the value given to `match` and looks
through each arm’s pattern in turn. Patterns and the `match` construct are
powerful Rust features that let you express a variety of situations your code
might encounter and make sure that you handle them all. These features will be
covered in detail in Chapter 6 and Chapter 18, respectively.
-->
<p><code>match</code>式は複数の<em>アーム</em>（腕）で構成されます。
各アームはマッチさせる<em>パターン</em>と、<code>match</code>に与えられた値がそのアームのパターンにマッチしたときに実行されるコードで構成されます。
Rustは<code>match</code>に与えられた値を受け取って、各アームのパターンを順に照合していきます。
パターンと<code>match</code>式はRustの強力な機能で、コードか遭遇する可能性のあるさまざまな状況を表現し、それらすべてを確実に処理できるようにします。
これらの機能については、それぞれ第6章と第18章で詳しく説明します。</p>
<!--
Let’s walk through an example with the `match` expression we use here. Say that
the user has guessed 50 and the randomly generated secret number this time is
38. When the code compares 50 to 38, the `cmp` method will return
`Ordering::Greater`, because 50 is greater than 38. The `match` expression gets
the `Ordering::Greater` value and starts checking each arm’s pattern. It looks
at the first arm’s pattern, `Ordering::Less`, and sees that the value
`Ordering::Greater` does not match `Ordering::Less`, so it ignores the code in
that arm and moves to the next arm. The next arm’s pattern is
`Ordering::Greater`, which *does* match `Ordering::Greater`! The associated
code in that arm will execute and print `Too big!` to the screen. The `match`
expression ends because it has no need to look at the last arm in this scenario.
-->
<p>ここで使われている<code>match</code>式に対して、例を通して順に見ていきましょう。
たとえばユーザが50と予想し、今回ランダムに生成された秘密の数字は38だったとしましょう。
コードが50と38を比較すると、50は38よりも大きいので<code>cmp</code>メソッドは<code>Ordering::Greater</code>を返します。
<code>match</code>式は<code>Ordering::Greater</code>の値を取得し、各アームのパターンを吟味し始めます。
まず最初のアームのパターンである<code>Ordering::Less</code>を見て、<code>Ordering::Greater</code>の値と<code>Ordering::Less</code>がマッチしないことがわかります。
そのため、このアームのコードは無視して、次のアームに移ります。
次のアームのパターンは<code>Ordering::Greater</code>で、これは<code>Ordering::Greater</code>と<em>マッチ</em>します！ 
このアームに関連するコードが実行され、画面に<code>Too big!</code>と表示されます。
このシナリオでは最後のアームと照合する必要がないため<code>match</code>式（の評価）は終了します。</p>
<!--
However, the code in Listing 2-4 won’t compile yet. Let’s try it:
-->
<p>ところがリスト2-4のコードはまだコンパイルできません。
試してみましょう。</p>
<pre><code class="language-console">$ cargo build
   Compiling libc v0.2.86
   Compiling getrandom v0.2.2
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.10
   Compiling rand_core v0.6.2
   Compiling rand_chacha v0.3.0
   Compiling rand v0.8.3
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types          (型が合いません)
  --&gt; src/main.rs:22:21
   |
22 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `String`, found integer
   |                                    (構造体`std::string::String`を予期したけど、整数型変数が見つかりました)
   |
   = note: expected reference `&amp;String`
              found reference `&amp;{integer}`

error[E0283]: type annotations needed for `{integer}`
   --&gt; src/main.rs:8:44
    |
8   |     let secret_number = rand::thread_rng().gen_range(1..101);
    |         -------------                      ^^^^^^^^^ cannot infer type for type `{integer}`
    |         |
    |         consider giving `secret_number` a type
    |
    = note: multiple `impl`s satisfying `{integer}: SampleUniform` found in the `rand` crate:
            - impl SampleUniform for i128;
            - impl SampleUniform for i16;
            - impl SampleUniform for i32;
            - impl SampleUniform for i64;
            and 8 more
note: required by a bound in `gen_range`
   --&gt; /Users/carolnichols/.cargo/registry/src/github.com-1ecc6299db9ec823/rand-0.8.3/src/rng.rs:129:12
    |
129 |         T: SampleUniform,
    |            ^^^^^^^^^^^^^ required by this bound in `gen_range`
help: consider specifying the type arguments in the function call
    |
8   |     let secret_number = rand::thread_rng().gen_range::&lt;T, R&gt;(1..101);
    |                                                     ++++++++

Some errors have detailed explanations: E0283, E0308.
For more information about an error, try `rustc --explain E0283`.
error: could not compile `guessing_game` due to 2 previous errors      (先の2つのエラーのため、`guessing_game`をコンパイルできませんでした)
</code></pre>
<!--
The core of the error states that there are *mismatched types*. Rust has a
strong, static type system. However, it also has type inference. When we wrote
`let mut guess = String::new()`, Rust was able to infer that `guess` should be
a `String` and didn’t make us write the type. The `secret_number`, on the other
hand, is a number type. A few of Rust’s number types can have a value between 1
and 100: `i32`, a 32-bit number; `u32`, an unsigned 32-bit number; `i64`, a
64-bit number; as well as others. Unless otherwise specified, Rust defaults to
an `i32`, which is the type of `secret_number` unless you add type information
elsewhere that would cause Rust to infer a different numerical type. The reason
for the error is that Rust cannot compare a string and a number type.
-->
<p>このエラーの核心は<em>型の不一致</em>があると述べていることです。
Rustは強い静的型システムを持ちますが、型推論も備えています。
<code>let guess = String::new()</code>と書いたとき、Rustは<code>guess</code>が<code>String</code>型であるべきと推論したので、私たちはその型を書かずに済みました。
一方で<code>secret_number</code>は数値型です。
Rustのいくつかの数値型は1から100までの値を表現でき、それらの型には32ビット数値の<code>i32</code>、符号なしの32ビット数値の<code>u32</code>、64ビット数値の<code>i64</code>などがあります。
Rustのデフォルトは<code>i32</code>型で、型情報をどこかに追加してRustに異なる数値型だと推論させない限り<code>secret_number</code>の型はこれになります。
エラーの原因はRustが文字列と数値型を比較できないためです。</p>
<!--
Ultimately, we want to convert the `String` the program reads as input into a
real number type so we can compare it numerically to the secret number. We do so
by adding this line to the `main` function body:
-->
<p>最終的にはプログラムが入力として読み込んだ<code>String</code>を実数型に変換し、秘密の数字と数値として比較できるようにしたいわけです。
そのためには<code>main</code>関数の本体に次の行を追加します。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span>    // --snip--

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse()
        .expect(&quot;Please type a number!&quot;);                 //数値を入力してください！

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
<span class="boring">}
</span></code></pre>
<!--
The line is:
-->
<p>その行とはこれのことです。</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</code></pre>
<!--
We create a variable named `guess`. But wait, doesn’t the program already have
a variable named `guess`? It does, but helpfully Rust allows us to *shadow* the
previous value of `guess` with a new one. Shadowing lets us reuse the `guess`
variable name rather than forcing us to create two unique variables, such as
`guess_str` and `guess` for example. We’ll cover this in more detail in Chapter
3, but for now know that this feature is often used when you want to convert a
value from one type to another type.
-->
<p><code>guess</code>という名前の変数を作成しています。
しかし待ってください、このプログラムには既に<code>guess</code>という名前の変数がありませんでしたか？ 
たしかにありますが、Rustでは<code>guess</code>の前の値を新しい値で<em>覆い隠す</em>（shadowする）ことが許されているのです。
シャドーイング（shadowing）は、<code>guess_str</code>と<code>guess</code>のような重複しない変数を二つ作る代わりに、<code>guess</code>という変数名を再利用させてくれるのです。
これについては第3章で詳しく説明しますが、今のところ、この機能はある型から別の型に値を変換するときによく使われることを知っておいてください。</p>
<!--
We bind this new variable to the expression `guess.trim().parse()`. The `guess`
in the expression refers to the original `guess` variable that contained the
input as a string. The `trim` method on a `String` instance will eliminate any
whitespace at the beginning and end, which we must do to be able to compare the
string to the `u32`, which can only contain numerical data. The user must press
<span class="keystroke">enter</span> to satisfy `read_line` and input their
guess, which adds a newline character to the string. For example, if the user
types <span class="keystroke">5</span> and presses <span
class="keystroke">enter</span>, `guess` looks like this: `5\n`. The `\n`
represents “newline”. (On Windows, pressing <span
class="keystroke">enter</span> results in a carriage return and a newline,
`\r\n`). The `trim` method eliminates `\n` or `\r\n`, resulting in just `5`.
-->
<p>この新しい変数を<code>guess.trim().parse()</code>という式に束縛しています。
式の中にある<code>guess</code>は、入力が文字列として格納されたオリジナルの<code>guess</code>変数を指しています。
<code>String</code>インスタンスの<code>trim</code>メソッドは文字列の先頭と末尾の空白をすべて削除します。
これは数値データのみを表現できる<code>u32</code>型とこの文字列を比較するために（準備として）行う必要があります。
ユーザは予想を入力したあと<code>read_line</code>の処理を終えるために<span class="keystroke">Enterキー</span>を押す必要がありますが、これにより文字列に改行文字が追加されます。
たとえばユーザが<span class="keystroke">5</span>と入力して<span class="keystroke">Enterキー</span>を押すと、<code>guess</code>は<code>5\n</code>になります。
この<code>\n</code>は「改行」を表しています。（WindowsではEnterキーを押すとキャリッジリターンと改行が入り<code>\r\n</code>となります）
<code>trim</code>メソッドは<code>\n</code>や<code>\r\n</code>を削除するので、その結果<code>5</code>だけになります。</p>
<!--
The [`parse` method on strings][parse] parses a string into some
kind of number. Because this method can parse a variety of number types, we
need to tell Rust the exact number type we want by using `let guess: u32`. The
colon (`:`) after `guess` tells Rust we’ll annotate the variable’s type. Rust
has a few built-in number types; the `u32` seen here is an unsigned, 32-bit
integer. It’s a good default choice for a small positive number. You’ll learn
about other number types in Chapter 3. Additionally, the `u32` annotation in
this example program and the comparison with `secret_number` means that Rust
will infer that `secret_number` should be a `u32` as well. So now the
comparison will be between two values of the same type!
-->
<p><a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse">文字列の<code>parse</code>メソッド</a>は文字列をパース（解析）して何らかの数値にします。
このメソッドは（文字列を）さまざまな数値型へとパースできるので、<code>let guess: u32</code>としてRustに正確な数値型を伝える必要があります。
<code>guess</code>の後にコロン（<code>:</code>）を付けることで変数の型に注釈をつけることをRustに伝えています。
Rustには組み込みの数値型がいくつかあります。
ここにある<code>u32</code>は符号なし32ビット整数で、小さな正の数を表すデフォルトの型に適しています。
他の数値型については第3章で学びます。
さらに、このサンプルプログラムでは、<code>u32</code>という注釈と<code>secret_number</code>変数との比較していることから、Rustは<code>secret_number</code>変数も<code>u32</code>型であるべきだと推論しています。
つまり、いまでは二つの同じ型の値を比較することになるわけです！</p>
<!--
The `parse` method will only work on characters that can logically be converted
into numbers and so can easily cause errors. If, for example, the string
contained `A👍%`, there would be no way to convert that to a number. Because it
might fail, the `parse` method returns a `Result` type, much as the `read_line`
method does (discussed earlier in [“Handling Potential Failure with the
`Result` Type”](#handling-potential-failure-with-the-result-type)). We’ll treat this `Result` the same way by using the `expect` method
again. If `parse` returns an `Err` `Result` variant because it couldn’t create
a number from the string, the `expect` call will crash the game and print the
message we give it. If `parse` can successfully convert the string to a number,
it will return the `Ok` variant of `Result`, and `expect` will return the
number that we want from the `Ok` value.
-->
<p><code>parse</code>メソッドは論理的に数値に変換できる文字にしか使えないので、よくエラーになります。
たとえば文字列に<code>A👍%</code>が含まれていたら数値に変換する術はありません。
解析に失敗する可能性があるため、<code>parse</code>メソッドは<code>read_line</code>メソッドと同様に<code>Result</code>型を返します
（<a href="ch02-00-guessing-game-tutorial.html#result%E5%9E%8B%E3%81%A7%E5%A4%B1%E6%95%97%E3%81%AE%E5%8F%AF%E8%83%BD%E6%80%A7%E3%82%92%E6%89%B1%E3%81%86">「<code>Result</code>型で失敗の可能性を扱う」</a>で説明しました） 
今回も<code>expect</code>メソッドを使用して<code>Result</code>型を同じように扱います。
<code>parse</code>メソッドが文字列から数値を作成できなかったために<code>Result</code>型の<code>Err</code>列挙子を返したら、<code>expect</code>の呼び出しはゲームをクラッシュさせ、私たちが与えたメッセージを表示します。
<code>parse</code>が文字列をうまく数値へ変換できたときは<code>Result</code>型の<code>Ok</code>列挙子を返し、<code>expect</code>は<code>Ok</code>値から欲しい数値を返してくれます。</p>
<!--
Let’s run the program now!
-->
<p>さあ、プログラムを走らせましょう！</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<!--
Nice! Even though spaces were added before the guess, the program still figured
out that the user guessed 76. Run the program a few times to verify the
different behavior with different kinds of input: guess the number correctly,
guess a number that is too high, and guess a number that is too low.
-->
<p>いい感じです！ 
予想の前にスペースを追加したにもかかわらず、プログラムはちゃんとユーザが76と予想したことを理解しました。
このプログラムを何回か走らせ、数字を正しく言い当てたり、大きすぎる数字や小さすぎる数字を予想したりといった、異なる種類の入力に対する動作の違いを検証してください。</p>
<!--
We have most of the game working now, but the user can make only one guess.
Let’s change that by adding a loop!
-->
<p>現在、ゲームの大半は動作していますが、まだユーザは1回しか予想できません。
ループを追加して、その部分を変更しましょう！</p>
<!--
## Allowing Multiple Guesses with Looping
-->
<h2 id="ループで複数回の予想を可能にする"><a class="header" href="#ループで複数回の予想を可能にする">ループで複数回の予想を可能にする</a></h2>
<!--
The `loop` keyword creates an infinite loop. We’ll add a loop to give users
more chances at guessing the number:
-->
<p><code>loop</code>キーワードは無限ループを作成します。
ループを追加してユーザが数字を予想する機会を増やします。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span>    // --snip--

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        // --snip--

<span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">
</span>        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<!--
As you can see, we’ve moved everything from the guess input prompt onward into
a loop. Be sure to indent the lines inside the loop another four spaces each
and run the program again. The program will now ask for another guess forever,
which actually introduces a new problem. It doesn’t seem like the user can quit!
-->
<p>見ての通り予想入力のプロンプト以降をすべてループ内に移動しました。
ループ内の行をさらに4つのスペースでインデントして、もう一度プログラムを実行してください。
プログラムはいつまでも推測を求めるようになりましたが、実はこれが新たな問題を引き起こしています。
これではユーザが（ゲームを）終了できません！</p>
<!--
The user could always interrupt the program by using the keyboard shortcut
<span class="keystroke">ctrl-c</span>. But there’s another way to escape this
insatiable monster, as mentioned in the `parse` discussion in [“Comparing the
Guess to the Secret Number”](#comparing-the-guess-to-the-secret-number): if the user enters a non-number answer, the program will crash. We
can take advantage of that to allow the user to quit, as shown here:
-->
<p>ユーザはキーボードショートカットの<span class="keystroke">ctrl-c</span>を使えば、いつでもプログラムを中断させられます。
しかし「<a href="ch02-00-guessing-game-tutorial.html#%E4%BA%88%E6%83%B3%E3%81%A8%E7%A7%98%E5%AF%86%E3%81%AE%E6%95%B0%E5%AD%97%E3%82%92%E6%AF%94%E8%BC%83%E3%81%99%E3%82%8B">予想と秘密の数字を比較する</a>」の<code>parse</code>で述べたように、この飽くなきモンスターから逃れる方法はもう一つあります。
ユーザが数字以外の答えを入力すればプログラムはクラッシュします。
それを利用して以下のようにすれば終了できます。</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
(スレッド'main'は'数字を入力してください！：ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785でパニックしました)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
(注：`RUST_BACKTRACE=1`で走らせるとバックトレースを見れます)
</code></pre>
<!--
Typing `quit` will quit the game, but as you’ll notice so will entering any
other non-number input. This is suboptimal to say the least; we want the game
to also stop when the correct number is guessed.
-->
<p><code>quit</code>と入力すればゲームが終了しますが、数字以外の入力でもそうなります。
これは控えめに言っても最適ではありません。
私たちは正しい数字が予想されたときにゲームが停止するようにしたいのです。</p>
<!--
### Quitting After a Correct Guess
-->
<h3 id="正しい予想をした後に終了する"><a class="header" href="#正しい予想をした後に終了する">正しい予想をした後に終了する</a></h3>
<!--
Let’s program the game to quit when the user wins by adding a `break` statement:
-->
<p><code>break</code>文を追加して、ユーザが勝ったらゲームが終了するようにプログラムしましょう。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">        io::stdin()
</span><span class="boring">            .read_line(&amp;mut guess)
</span><span class="boring">            .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">        let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">        println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">
</span>        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!--
Adding the `break` line after `You win!` makes the program exit the loop when
the user guesses the secret number correctly. Exiting the loop also means
exiting the program, because the loop is the last part of `main`.
-->
<p><code>You win!</code>の後に<code>break</code>の行を追記することで、ユーザが秘密の数字を正確に予想したときにプログラムがループを抜けるようになりました。
ループは<code>main</code>関数の最後の部分なので、ループを抜けることはプログラムを抜けることを意味します。</p>
<!--
### Handling Invalid Input
-->
<h3 id="不正な入力を処理する"><a class="header" href="#不正な入力を処理する">不正な入力を処理する</a></h3>
<!--
To further refine the game’s behavior, rather than crashing the program when
the user inputs a non-number, let’s make the game ignore a non-number so the
user can continue guessing. We can do that by altering the line where `guess`
is converted from a `String` to a `u32`, as shown in Listing 2-5.
-->
<p>このゲームの動作をさらに洗練させるために、ユーザが数値以外を入力したときにプログラムをクラッシュさせるのではなく、数値以外を無視してユーザが数当てを続けられるようにしましょう。
これはリスト2-5のように、<code>String</code>から<code>u32</code>に<code>guess</code>を変換する行を変えることで実現できます。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名：src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span><span class="boring">use std::cmp::Ordering;
</span><span class="boring">use std::io;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1..101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">        let mut guess = String::new();
</span><span class="boring">
</span>        // --snip--

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        // --snip--
<span class="boring">
</span><span class="boring">        match guess.cmp(&amp;secret_number) {
</span><span class="boring">            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">            Ordering::Equal =&gt; {
</span><span class="boring">                println!(&quot;You win!&quot;);
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 2-5: Ignoring a non-number guess and asking for
another guess instead of crashing the program</span>
-->
<p><span class="caption">リスト2-5：数値以外の予想を無視し、プログラムをクラッシュさせるのではなく、もう1回予想してもらう</span></p>
<!--
We switch from an `expect` call to a `match` expression to move from crashing
on an error to handling the error. Remember that `parse` returns a `Result`
type and `Result` is an enum that has the variants `Ok` and `Err`. We’re using a
`match` expression here, as we did with the `Ordering` result of the `cmp`
method.
-->
<p><code>expect</code>の呼び出しから<code>match</code>式に切り替えて、エラーによるクラッシュからエラー処理へと移行します。
<code>parse</code>が<code>Result</code>型を返すことと、<code>Result</code>が<code>Ok</code>と<code>Err</code>の列挙子を持つ列挙型であることを思い出してください。
ここでは<code>match</code>式を、<code>cmp</code>メソッドから返される<code>Ordering</code>を処理したときと同じように使っています。</p>
<!--
If `parse` is able to successfully turn the string into a number, it will
return an `Ok` value that contains the resulting number. That `Ok` value will
match the first arm’s pattern, and the `match` expression will just return the
`num` value that `parse` produced and put inside the `Ok` value. That number
will end up right where we want it in the new `guess` variable we’re creating.
-->
<p>もし<code>parse</code>メソッドが文字列から数値への変換に成功したなら、結果の数値を保持する<code>Ok</code>値を返します。
この<code>Ok</code>値は最初のアームのパターンにマッチします。
<code>match</code>式は<code>parse</code>メソッドが生成して<code>Ok</code>値に格納した<code>num</code>の値を返します。
その数値は私たちが望んだように、これから作成する新しい<code>guess</code>変数に収まります。</p>
<!--
If `parse` is *not* able to turn the string into a number, it will return an
`Err` value that contains more information about the error. The `Err` value
does not match the `Ok(num)` pattern in the first `match` arm, but it does
match the `Err(_)` pattern in the second arm. The underscore, `_`, is a
catchall value; in this example, we’re saying we want to match all `Err`
values, no matter what information they have inside them. So the program will
execute the second arm’s code, `continue`, which tells the program to go to the
next iteration of the `loop` and ask for another guess. So, effectively, the
program ignores all errors that `parse` might encounter!
-->
<p>もし<code>parse</code>メソッドが文字列から数値への変換に<em>失敗</em>したなら、エラーに関する詳細な情報を含む<code>Err</code>値を返します。
この<code>Err</code>値は最初の<code>match</code>アームの<code>Ok(num)</code>パターンにはマッチしませんが、2番目のアームの<code>Err(_)</code>パターンにはマッチします。
アンダースコアの<code>_</code>はすべての値を受け付けます。
この例ではすべての<code>Err</code>値に対して、その中にどんな情報があってもマッチさせたいと言っているのです。
したがってプログラムは2番目のアームのコードである<code>continue</code>を実行します。
これは<code>loop</code>の次の繰り返しに移り、別の予想を求めるようプログラムに指示します。
つまり実質的にプログラムは<code>parse</code>メソッドが遭遇し得るエラーをすべて無視するようになります！</p>
<!--
Now everything in the program should work as expected. Let’s try it:
-->
<p>これでプログラム内のすべてが期待通りに動作するはずです。
試してみましょう。</p>
<pre><code class="language-console">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 4.45s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<!--
Awesome! With one tiny final tweak, we will finish the guessing game. Recall
that the program is still printing the secret number. That worked well for
testing, but it ruins the game. Let’s delete the `println!` that outputs the
secret number. Listing 2-6 shows the final code.
-->
<p>素晴らしい！ 
最後にほんの少し手を加えれば数当てゲームは完成です。
このプログラムはまだ秘密の数字を表示していることを思い出してください。
テストには便利でしたが、これではゲームが台無しです。
秘密の数字を表示している<code>println!</code>を削除しましょう。
最終的なコードをリスト2-6に示します。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名：src/main.rs</span></p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 2-6: Complete guessing game code</span>
-->
<p><span class="caption">リスト2-6：数当てゲームの完全なコード</span></p>
<!--
## Summary
-->
<h2 id="まとめ-1"><a class="header" href="#まとめ-1">まとめ</a></h2>
<!--
At this point, you’ve successfully built the guessing game. Congratulations!
-->
<p>数当てゲームを無事に作り上げることができました。
おめでとうございます！</p>
<!--
This project was a hands-on way to introduce you to many new Rust concepts:
`let`, `match`, functions, the use of external crates, and more. In the next
few chapters, you’ll learn about these concepts in more detail. Chapter 3
covers concepts that most programming languages have, such as variables, data
types, and functions, and shows how to use them in Rust. Chapter 4 explores
ownership, a feature that makes Rust different from other languages. Chapter 5
discusses structs and method syntax, and Chapter 6 explains how enums work.
-->
<p>このプロジェクトではハンズオンを通して、<code>let</code>、<code>match</code>、メソッド、関連関数、外部クレートの使いかたなど、多くの新しいRustの概念に触れました。
以降の章では、これらの概念についてより詳しく学びます。
第3章では変数、データ型、関数など多くのプログラミング言語が持つ概念を取り上げ、Rustでの使い方を説明します。
第4章ではRustを他の言語とは異なるものに特徴づける、所有権について説明します。
第5章では構造体とメソッドの構文について説明し、第6章では列挙型がどのように動くのかについて説明します。</p>
<!--
[prelude]: ../std/prelude/index.html
[variables-and-mutability]: ch03-01-variables-and-mutability.html#variables-and-mutability
[comments]: ch03-04-comments.html
[string]: ../std/string/struct.String.html
[iostdin]: ../std/io/struct.Stdin.html
[read_line]: ../std/io/struct.Stdin.html#method.read_line
[ioresult]: ../std/io/type.Result.html
[result]: ../std/result/enum.Result.html
[enums]: ch06-00-enums.html
[expect]: ../std/result/enum.Result.html#method.expect
[recover]: ch09-02-recoverable-errors-with-result.html
[randcrate]: https://crates.io/crates/rand
[semver]: http://semver.org
[cratesio]: https://crates.io/
[doccargo]: http://doc.crates.io
[doccratesio]: http://doc.crates.io/crates-io.html
[match]: ch06-02-match.html
[parse]: ../std/primitive.str.html#method.parse
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Common Programming Concepts
-->
<h1 id="一般的なプログラミングの概念"><a class="header" href="#一般的なプログラミングの概念">一般的なプログラミングの概念</a></h1>
<!--
This chapter covers concepts that appear in almost every programming language
and how they work in Rust. Many programming languages have much in common at
their core. None of the concepts presented in this chapter are unique to Rust,
but we’ll discuss them in the context of Rust and explain the conventions
around using these concepts.
-->
<p>この章では、ほとんど全てのプログラミング言語で見られる概念を講義し、それらがRustにおいて、
どう動作するかを見ていきます。多くのプログラミング言語は、その核心において、いろいろなものを共有しています。
この章で提示する概念は、全てRustに固有のものではありませんが、Rustの文脈で議論し、
これらの概念を使用することにまつわる仕様を説明します。</p>
<!--
Specifically, you’ll learn about variables, basic types, functions, comments,
and control flow. These foundations will be in every Rust program, and learning
them early will give you a strong core to start from.
-->
<p>具体的には、変数、基本的な型、関数、コメント、そして制御フローについて学びます。
これらの基礎は全てのRustプログラムに存在するものであり、それらを早期に学ぶことにより、強力な基礎を築くことになるでしょう。</p>
<!--
> ### Keywords
>
> The Rust language has a set of *keywords* that have been reserved for use by
> the language only, much as in other languages. Keep in mind that you cannot
> use these words as names of variables or functions. Most of the keywords have
> special meanings, and you’ll be using them to do various tasks in your Rust
> programs; a few have no current functionality associated with them but have
> been reserved for functionality that might be added to Rust in the future. You
> can find a list of the keywords in Appendix A.
-->
<blockquote>
<h3 id="キーワード"><a class="header" href="#キーワード">キーワード</a></h3>
<p>Rust言語にも他の言語同様、キーワードが存在し、これらは言語だけが使用できるようになっています。
これらの単語は、変数や関数名には使えないことを弁えておいてください。ほとんどのキーワードは、特別な意味を持っており、
自らのRustプログラムにおいて、様々な作業をこなすために使用することができます;
いくつかは、紐付けられた機能がないものの、将来Rustに追加されるかもしれない機能用に予約されています。
キーワードの一覧は、付録Aで確認できます。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><!--
## Variables and Mutability
-->
<h2 id="変数と可変性"><a class="header" href="#変数と可変性">変数と可変性</a></h2>
<!--
As mentioned in Chapter 2, by default variables are immutable. This is one of
many nudges Rust gives you to write your code in a way that takes advantage of
the safety and easy concurrency that Rust offers. However, you still have the
option to make your variables mutable. Let’s explore how and why Rust
encourages you to favor immutability and why sometimes you might want to opt
out.
-->
<p>第2章で触れた通り、変数は標準で不変になります。これは、
Rustが提供する安全性や簡便な並行性の利点を享受する形でコードを書くための選択の1つです。
ところが、まだ変数を可変にするという選択肢も残されています。
どのように、そしてなぜRustは不変性を推奨するのか、さらには、なぜそれとは違う道を選びたくなることがあるのか見ていきましょう。</p>
<!--
When a variable is immutable, once a value is bound to a name, you can't change
that value. To illustrate this, let’s generate a new project called *variables*
in your *projects* directory by using `cargo new --bin variables`.
-->
<p>変数が不変であると、値が一旦名前に束縛されたら、その値を変えることができません。
これを具体的に説明するために、<em>projects</em>ディレクトリに<code>cargo new --bin variables</code>コマンドを使って、
<em>variables</em>という名前のプロジェクトを生成しましょう。</p>
<!--
Then, in your new *variables* directory, open *src/main.rs* and replace its
code with the following code that won't compile just yet:
-->
<p>それから、新規作成した<em>variables</em>ディレクトリで、<em>src/main.rs</em>ファイルを開き、
その中身を以下のコードに置き換えましょう。このコードはまだコンパイルできません:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);     // xの値は{}です
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<!--
Save and run the program using `cargo run`. You should receive an error
message, as shown in this output:
-->
<p>これを保存し、<code>cargo run</code>コマンドでプログラムを走らせてください。次の出力に示されているようなエラーメッセージを受け取るはずです:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0384]: cannot assign twice to immutable variable `x`
              (不変変数`x`に2回代入できません)
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         (`x`への最初の代入)
  |         help: consider making this binding mutable: `mut x`
3 |     println!(&quot;The value of x is: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `variables` due to previous error
</code></pre>
<!--
This example shows how the compiler helps you find errors in your programs.
Even though compiler errors can be frustrating, they only mean your program
isn’t safely doing what you want it to do yet; they do *not* mean that you’re
not a good programmer! Experienced Rustaceans still get compiler errors.
-->
<p>この例では、コンパイラがプログラムに潜むエラーを見つけ出す手助けをしてくれることが示されています。
コンパイルエラーは、イライラすることもあるものですが、まだプログラムにしてほしいことを安全に行えていないだけということなのです。
エラーが出るからといって、あなたがいいプログラマではないという意味ではあり<em>ません</em>！
経験豊富なRustaceanでも、コンパイルエラーを出すことはあります。</p>
<!--
The error message indicates that the cause of the error is that you `cannot
assign twice to immutable variable x`, because you tried to assign a second
value to the immutable `x` variable.
-->
<p>このエラーは、エラーの原因が<code>不変変数xに2回代入できない</code>であると示しています。不変な<code>x</code>という変数に別の値を代入しようとしたからです。</p>
<!--
It’s important that we get compile-time errors when we attempt to change a
value that we previously designated as immutable because this very situation
can lead to bugs. If one part of our code operates on the assumption that a
value will never change and another part of our code changes that value, it’s
possible that the first part of the code won’t do what it was designed to do.
This cause of bugs can be difficult to track down after the fact,
especially when the second piece of code changes the value only *sometimes*.
-->
<p>以前に不変と指定された値を変えようとした時に、コンパイルエラーが出るのは重要なことです。
なぜなら、この状況はまさしく、バグに繋がるからです。コードのある部分は、
値が変わることはないという前提のもとに処理を行い、別の部分がその値を変更していたら、
最初の部分が目論見通りに動いていない可能性があるのです。このようなバグは、発生してしまってからでは原因が追いかけづらいものです。
特に第2のコード片が、値を<em>時々</em>しか変えない場合、尚更です。</p>
<!--
In Rust the compiler guarantees that when you state that a value won’t change,
it really won’t change. That means that when you’re reading and writing code,
you don’t have to keep track of how and where a value might change. Your code
is thus easier to reason through.
-->
<p>Rustでは、値が不変であると宣言したら、本当に変わらないことをコンパイラが担保してくれます。
つまり、コードを読み書きする際に、どこでどうやって値が変化しているかを追いかける必要がなくなります。
故にコードを通して正しいことを確認するのが簡単になるのです。</p>
<!--
But mutability can be very useful. Variables are immutable only by default; as
you did in Chapter 2, you can make them mutable by adding `mut` in front of the
variable name. In addition to allowing this value to change, `mut` conveys
intent to future readers of the code by indicating that other parts of the code
will be changing this variable value.
-->
<p>しかし、可変性は時として非常に有益なこともあります。変数は、標準でのみ、不変です。つまり、
第2章のように変数名の前に<code>mut</code>キーワードを付けることで、可変にできるわけです。この値が変化できるようにするとともに、
<code>mut</code>により、未来の読者に対してコードの別の部分がこの変数の値を変える可能性を示すことで、その意図を汲ませることができるのです。</p>
<!--
For example, change *src/main.rs* to the following:
-->
<p>例として、<em>src/main.rs</em>ファイルを以下のように書き換えてください:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<!--
When we run the program now, we get this:
-->
<p>今、このプログラムを走らせると、以下のような出力が得られます:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/variables`
The value of x is: 5   (xの値は5です)
The value of x is: 6
</code></pre>
<!--
We’re allowed to change the value that `x` binds to from `5` to `6` when `mut`
is used. In some cases, you’ll want to make a variable mutable because it makes
the code more convenient to write than if it had only immutable variables.
-->
<p><code>mut</code>キーワードが使われると、<code>x</code>が束縛している値を<code>5</code>から<code>6</code>に変更できます。
変数を可変にする方が、不変変数だけがあるよりも書きやすくなるので、変数を可変にしたくなることもあるでしょう。</p>
<!--
There are multiple trade-offs to consider, in addition to the prevention of
bugs. For example, in cases where you’re using large data structures, mutating
an instance in place may be faster than copying and returning newly allocated
instances. With smaller data structures, creating new instances and writing in
a more functional programming style may be easier to think through, so lower
performance might be a worthwhile penalty for gaining that clarity.
-->
<p>考えるべきトレードオフはバグの予防以外にも、いくつかあります。例えば、大きなデータ構造を使う場合などです。
インスタンスを可変にして変更できるようにする方が、いちいちインスタンスをコピーして新しくメモリ割り当てされたインスタンスを返すよりも速くなります。
小規模なデータ構造なら、新規インスタンスを生成して、もっと関数型っぽいコードを書く方が通して考えやすくなるため、
低パフォーマンスは、その簡潔性を得るのに足りうるペナルティになるかもしれません。</p>
<!--
### Differences Between Variables and Constants
-->
<h3 id="変数と定数constantsの違い"><a class="header" href="#変数と定数constantsの違い">変数と定数(constants)の違い</a></h3>
<!--
Being unable to change the value of a variable might have reminded you of
another programming concept that most other languages have: *constants*. Like
immutable variables, constants are values that are bound to a name and are not
allowed to change, but there are a few differences between constants and
variables.
-->
<p>変数の値を変更できないようにするといえば、他の多くの言語も持っている別のプログラミング概念を思い浮かべるかもしれません:
<em>定数</em>です。不変変数のように、定数は名前に束縛され、変更することが叶わない値のことですが、
定数と変数の間にはいくつかの違いがあります。</p>
<!--
First, we aren’t allowed to use `mut` with constants. Constants aren't just
immutable by default-they're always immutable.
-->
<p>まず、定数には<code>mut</code>キーワードは使えません: 定数は標準で不変であるだけでなく、常に不変なのです。</p>
<!--
You declare constants using the `const` keyword instead of the `let` keyword,
and the type of the value *must* be annotated. We're about to cover types and
type annotations in the next section, “Data Types,” so don't worry about the
details right now. Just know that we must always annotate the type.
-->
<p>定数は<code>let</code>キーワードの代わりに、<code>const</code>キーワードで宣言し、値の型は<em>必ず</em>注釈しなければなりません。
型と型注釈については次のセクション、「データ型」で講義しますので、その詳細について気にする必要はありません。
ただ単に型は常に注釈しなければならないのだと思っていてください。</p>
<!--
Constants can be declared in any scope, including the global scope, which makes
them useful for values that many parts of code need to know about.
-->
<p>定数はどんなスコープでも定義できます。グローバルスコープも含めてです。なので、
いろんなところで使用される可能性のある値を定義するのに役に立ちます。</p>
<!--
The last difference is that constants may be set only to a constant expression,
not the result of a function call or any other value that could only be
computed at runtime.
-->
<p>最後の違いは、定数は定数式にしかセットできないことです。関数呼び出し結果や、実行時に評価される値にはセットできません。</p>
<!--
Here's an example of a constant declaration where the constant's name is
`MAX_POINTS` and its value is set to 100,000. (Rust naming convention for
constants is to use all upper case with underscores between words):
-->
<p>定数の名前が<code>MAX_POINTS</code>で、値が100,000にセットされた定数定義の例をご覧ください。(Rustの定数の命名規則は、
全て大文字でアンダースコアで単語区切りすることです):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_POINTS: u32 = 100_000;
<span class="boring">}
</span></code></pre></pre>
<!--
Constants are valid for the entire time a program runs, within the scope they
were declared in, making them a useful choice for values in your application
domain that multiple parts of the program might need to know about, such as the
maximum number of points any player of a game is allowed to earn or the speed
of light.
-->
<p>定数は、プログラムが走る期間、定義されたスコープ内でずっと有効です。従って、
プログラムのいろんなところで使用される可能性のあるアプリケーション空間の値を定義するのに有益な選択肢になります。
例えば、ゲームでプレイヤーが取得可能なポイントの最高値や、光速度などですね。</p>
<!--
Naming hardcoded values used throughout your program as constants is useful in
conveying the meaning of that value to future maintainers of the code. It also
helps to have only one place in your code you would need to change if the
hardcoded value needed to be updated in the future.
-->
<p>プログラム中で使用されるハードコードされた値に対して、定数として名前付けすることは、
コードの将来的な管理者にとって値の意味を汲むのに役に立ちます。将来、ハードコードされた値を変える必要が出た時に、
たった1箇所を変更するだけで済むようにもしてくれます。</p>
<!--
### Shadowing
-->
<h3 id="シャドーイング"><a class="header" href="#シャドーイング">シャドーイング</a></h3>
<!--
As you saw in the guessing game tutorial in the “Comparing the Guess to the
Secret Number” section in Chapter 2, you can declare a new variable with the
same name as a previous variable, and the new variable shadows the previous
variable. Rustaceans say that the first variable is *shadowed* by the second,
which means that the second variable’s value is what appears when the variable
is used. We can shadow a variable by using the same variable’s name and
repeating the use of the `let` keyword as follows:
-->
<p>第2章の数当てゲームのチュートリアル、「予想と秘密の数字を比較する」節で見たように、前に定義した変数と同じ名前の変数を新しく宣言でき、
新しい変数は、前の変数を覆い隠します。Rustaceanはこれを最初の変数は、
2番目の変数に<em>覆い隠さ</em>れたと言い、この変数を使用した際に、2番目の変数の値が現れるということです。
以下のようにして、同じ変数名を用いて変数を覆い隠し、<code>let</code>キーワードの使用を繰り返します:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!(&quot;The value of x in the inner scope is: {}&quot;, x);
    }

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<!--
This program first binds `x` to a value of `5`. Then it shadows `x` by
repeating `let x =`, taking the original value and adding `1` so the value of
`x` is then `6`. Then, within an inner scope, the third `let` statement also
shadows `x`, multiplying the previous value by `2` to give `x` a value of `12`.
When that scope is over, the inner shadowing ends and `x` returns to being `6`.
When we run this program, it will output the following:
-->
<p>このプログラムはまず、<code>x</code>を<code>5</code>という値に束縛します。それから<code>let x =</code>を繰り返すことで<code>x</code>を覆い隠し、
元の値に<code>1</code>を加えることになるので、<code>x</code>の値は<code>6</code>になります。
3番目の<code>let</code>文も<code>x</code>を覆い隠し、以前の値に<code>2</code>をかけることになるので、<code>x</code>の最終的な値は<code>12</code>になります。
括弧を抜けるとシャドーイングは終了し、<code>x</code>の値は元の<code>6</code>に戻ります。
このプログラムを走らせたら、以下のように出力するでしょう:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/variables`
The value of x in the inner scope is: 12
The value of x is: 6
</code></pre>
<!--
Shadowing is different than marking a variable as `mut`, because we’ll get a
compile-time error if we accidentally try to reassign to this variable without
using the `let` keyword. By using `let`, we can perform a few transformations
on a value but have the variable be immutable after those transformations have
been completed.
-->
<p>シャドーイングは、変数を<code>mut</code>にするのとは違います。なぜなら、<code>let</code>キーワードを使わずに、
誤ってこの変数に再代入を試みようものなら、コンパイルエラーが出るからです。<code>let</code>を使うことで、
値にちょっとした加工は行えますが、その加工が終わったら、変数は不変になるわけです。</p>
<!--
The other difference between `mut` and shadowing is that because we’re
effectively creating a new variable when we use the `let` keyword again, we can
change the type of the value but reuse the same name. For example, say our
program asks a user to show how many spaces they want between some text by
inputting space characters, but we really want to store that input as a number:
-->
<p><code>mut</code>と上書きのもう一つの違いは、再度<code>let</code>キーワードを使用したら、実効的には新しい変数を生成していることになるので、
値の型を変えつつ、同じ変数名を使いまわせることです。例えば、
プログラムがユーザに何らかのテキストに対して空白文字を入力することで何個分のスペースを表示したいかを尋ねますが、
ただ、実際にはこの入力を数値として保持したいとしましょう:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let spaces = &quot;   &quot;;
    let spaces = spaces.len();
<span class="boring">}
</span></code></pre></pre>
<!--
This construct is allowed because the first `spaces` variable is a string type
and the second `spaces` variable, which is a brand-new variable that happens to
have the same name as the first one, is a number type. Shadowing thus spares us
from having to come up with different names, like `spaces_str` and
`spaces_num`; instead, we can reuse the simpler `spaces` name. However, if we
try to use `mut` for this, as shown here, we'll get a compile-time error:
-->
<p>この文法要素は、容認されます。というのも、最初の<code>spaces</code>変数は文字列型であり、2番目の<code>spaces</code>変数は、
たまたま最初の変数と同じ名前になったまっさらな変数のわけですが、数値型になるからです。故に、シャドーイングのおかげで、
異なる名前を思いつく必要がなくなるわけです。<code>spaces_str</code>と<code>spaces_num</code>などですね; 代わりに、
よりシンプルな<code>spaces</code>という名前を再利用できるわけです。一方で、この場合に<code>mut</code>を使おうとすると、
以下に示した通りですが、コンパイルエラーになるわけです:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut spaces = &quot;   &quot;;
    spaces = spaces.len();
<span class="boring">}
</span></code></pre>
<!--
The error says we’re not allowed to mutate a variable’s
type:
-->
<p>変数の型を可変にすることは許されていないと言われているわけです:</p>
<pre><code class="language-console">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
error[E0308]: mismatched types          (型が合いません)
 --&gt; src/main.rs:3:14
  |
2 |     let mut spaces = &quot;   &quot;;
  |                      ----- expected due to this value
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`
  |                           (&amp;str型を予期しましたが、usizeが見つかりました)

For more information about this error, try `rustc --explain E0308`.
error: could not compile `variables` due to previous error
</code></pre>
<!--
Now that we’ve explored how variables work, let’s look at more data types they
can have.
-->
<p>さあ、変数が動作する方法を見てきたので、今度は変数が取りうるデータ型について見ていきましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Data Types
-->
<h2 id="データ型"><a class="header" href="#データ型">データ型</a></h2>
<!--
Every value in Rust is of a certain *data type*, which tells Rust what kind of
data is being specified so it knows how to work with that data. We'll look at
two data type subsets: scalar and compound.
-->
<p>Rustにおける値は全て、何らかの<em>データ型</em>になり、コンパイラがどんなデータが指定されているか知れるので、
そのデータの取り扱い方も把握できるというわけです。2種のデータ型のサブセットを見ましょう: スカラー型と複合型です。</p>
<!--
Keep in mind that Rust is a *statically typed* language, which means that it
must know the types of all variables at compile time. The compiler can usually
infer what type we want to use based on the value and how we use it. In cases
when many types are possible, such as when we converted a `String` to a numeric
type using `parse` in the “Comparing the Guess to the Secret Number” section in
Chapter 2, we must add a type annotation, like this:
-->
<p>Rustは<em>静的型付き</em>言語であることを弁えておいてください。つまり、
コンパイル時に全ての変数の型が判明している必要があるということです。コンパイラは通常、値と使用方法に基づいて、
使用したい型を推論してくれます。複数の型が推論される可能性がある場合、例えば、
第2章の「予想と秘密の数字を比較する」節で<code>parse</code>メソッドを使って<code>String</code>型を数値型に変換した時のように、
複数の型が可能な場合には、型注釈をつけなければいけません。以下のようにですね:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);    // 数字ではありません！
<span class="boring">}
</span></code></pre></pre>
<!--
If we don’t add the type annotation here, Rust will display the following
error, which means the compiler needs more information from us to know which
type we want to use:
-->
<p>ここで型注釈を付けなければ、コンパイラは以下のエラーを表示し、これは可能性のある型のうち、
どの型を使用したいのかを知るのに、コンパイラがプログラマからもっと情報を得る必要があることを意味します:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
              (型注釈が必要です)
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^ consider giving `guess` a type
  |               (`guess`に型を与えることを検討してください)

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations` due to previous error
</code></pre>
<!--
You’ll see different type annotations for other data types.
-->
<p>他のデータ型についても、様々な型注釈を目にすることになるでしょう。</p>
<!--
### Scalar Types
-->
<h3 id="スカラー型"><a class="header" href="#スカラー型">スカラー型</a></h3>
<!--
A *scalar* type represents a single value. Rust has four primary scalar types:
integers, floating-point numbers, Booleans, and characters. You may recognize
these from other programming languages. Let’s jump into how they work in Rust.
-->
<p>スカラー型は、単独の値を表します。Rustには主に4つのスカラー型があります:
整数、浮動小数点数、論理値、最後に文字です。他のプログラミング言語でも、これらの型を見かけたことはあるでしょう。
Rustでの動作方法に飛び込みましょう。</p>
<!--
#### Integer Types
-->
<h4 id="整数型"><a class="header" href="#整数型">整数型</a></h4>
<!--
An *integer* is a number without a fractional component. We used one integer
type in Chapter 2, the `u32` type. This type declaration indicates that the
value it’s associated with should be an unsigned integer (signed integer types
start with `i` instead of `u`) that takes up 32 bits of space. Table 3-1 shows
the built-in integer types in Rust. Each variant in the Signed and Unsigned
columns (for example, `i16`) can be used to declare the type of an integer
value.
-->
<p>整数とは、小数部分のない数値のことです。第2章で一つの整数型を使用しましたね。<code>u32</code>型です。
この型定義は、紐付けられる値が、符号なし整数(符号付き整数は<code>u</code>ではなく、<code>i</code>で始まります)になり、
これは、32ビット分のサイズを取ります。表3-1は、Rustの組み込み整数型を表示しています。
符号付きと符号なし欄の各バリアント(例: <code>i16</code>)を使用して、整数値の型を宣言することができます。</p>
<!--
<span class="caption">Table 3-1: Integer Types in Rust</span>
-->
<p><span class="caption">表3-1: Rustの整数型</span></p>
<!--
| Length | Signed  | Unsigned |
|--------|---------|----------|
| 8-bit  | `i8`    | `u8`     |
| 16-bit | `i16`   | `u16`    |
| 32-bit | `i32`   | `u32`    |
| 64-bit | `i64`   | `u64`    |
| arch   | `isize` | `usize`  |
-->
<table><thead><tr><th>大きさ</th><th>符号付き</th><th>符号なし</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<!--
Each variant can be either signed or unsigned and has an explicit size.
*Signed* and *unsigned* refers to whether it’s possible for the number to be
negative or positive-in other words, whether the number needs to have a sign
with it (signed) or whether it will only ever be positive and can therefore be
represented without a sign (unsigned). It’s like writing numbers on paper: when
the sign matters, a number is shown with a plus sign or a minus sign; however,
when it’s safe to assume the number is positive, it’s shown with no sign.
Signed numbers are stored using two’s complement representation (if you’re
unsure what this is, you can search for it online; an explanation is outside
the scope of this book).
-->
<p>各バリアントは、符号付きか符号なしかを選べ、明示的なサイズを持ちます。<em>符号付き</em>と<em>符号なし</em>は、
数値が正負を持つかどうかを示します。つまり、数値が符号を持つ必要があるかどうか(符号付き)、または、
絶対に正数にしかならず符号なしで表現できるかどうか(符号なし)です。これは、数値を紙に書き下すのと似ています:
符号が問題になるなら、数値はプラス記号、またはマイナス記号とともに表示されます; しかしながら、
その数値が正数であると仮定することが安全なら、符号なしで表示できるわけです。符号付き数値は、
2の補数表現で保持されます(これが何なのか確信を持てないのであれば、ネットで検索することができます。
まあ要するに、この解説は、この本の範疇外というわけです)。</p>
<!--
Each signed variant can store numbers from -(2<sup>n - 1</sup>) to 2<sup>n -
1</sup> - 1 inclusive, where *n* is the number of bits that variant uses. So an
`i8` can store numbers from -(2<sup>7</sup>) to 2<sup>7</sup> - 1, which equals
-128 to 127. Unsigned variants can store numbers from 0 to 2<sup>n</sup> - 1,
so a `u8` can store numbers from 0 to 2<sup>8</sup> - 1, which equals 0 to 255.
-->
<p>各符号付きバリアントは、-(2<sup>n - 1</sup>)以上2<sup>n - 1</sup> - 1以下の数値を保持でき、
ここで<em>n</em>はこのバリアントが使用するビット数です。以上から、<code>i8</code>型は-(2<sup>7</sup>)から2<sup>7</sup> - 1まで、
つまり、-128から127までを保持できます。符号なしバリアントは、0以上2<sup>n</sup> - 1以下を保持できるので、
<code>u8</code>型は、0から2<sup>8</sup> - 1までの値、つまり、0から255までを保持できることになります。</p>
<!--
Additionally, the `isize` and `usize` types depend on the kind of computer your
program is running on: 64-bits if you’re on a 64-bit architecture and 32-bits
if you’re on a 32-bit architecture.
-->
<p>加えて、<code>isize</code>と<code>usize</code>型は、プログラムが動作しているコンピュータの種類に依存します:
64ビットアーキテクチャなら、64ビットですし、32ビットアーキテクチャなら、32ビットになります。</p>
<!--
You can write integer literals in any of the forms shown in Table 3-2. Note
that all number literals except the byte literal allow a type suffix, such as
`57u8`, and `_` as a visual separator, such as `1_000`.
-->
<p>整数リテラル(<code>訳注</code>: リテラルとは、見たままの値ということ)は、表3-2に示すどの形式でも記述することができます。
バイトリテラルを除く数値リテラルは全て、
型接尾辞(例えば、<code>57u8</code>)と<code>_</code>を見た目の区切り記号(例えば、<code>1_000</code>)に付加することができます。</p>
<!--
<span class="caption">Table 3-2: Integer Literals in Rust</span>
-->
<p><span class="caption">表3-2: Rustの整数リテラル</span></p>
<!--
| Number literals  | Example       |
|------------------|---------------|
| Decimal          | `98_222`      |
| Hex              | `0xff`        |
| Octal            | `0o77`        |
| Binary           | `0b1111_0000` |
| Byte (`u8` only) | `b'A'`        |
-->
<table><thead><tr><th>数値リテラル</th><th>例</th></tr></thead><tbody>
<tr><td>10進数</td><td><code>98_222</code></td></tr>
<tr><td>16進数</td><td><code>0xff</code></td></tr>
<tr><td>8進数</td><td><code>0o77</code></td></tr>
<tr><td>2進数</td><td><code>0b1111_0000</code></td></tr>
<tr><td>バイト (<code>u8</code>だけ)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<!--
So how do you know which type of integer to use? If you’re unsure, Rust’s
defaults are generally good choices, and integer types default to `i32`: this
type is generally the fastest, even on 64-bit systems. The primary situation in
which you’d use `isize` or `usize` is when indexing some sort of collection.
-->
<p>では、どの整数型を使うべきかはどう把握すればいいのでしょうか？もし確信が持てないのならば、
Rustの基準型は一般的にいい選択肢になります。整数型の基準は<code>i32</code>型です: 64ビットシステム上でも、
この型が普通最速になります。<code>isize</code>と<code>usize</code>を使う主な状況は、何らかのコレクションにアクセスすることです。</p>
<!--
#### Floating-Point Types
-->
<h4 id="浮動小数点型"><a class="header" href="#浮動小数点型">浮動小数点型</a></h4>
<!--
Rust also has two primitive types for *floating-point numbers*, which are
numbers with decimal points. Rust’s floating-point types are `f32` and `f64`,
which are 32 bits and 64 bits in size, respectively. The default type is `f64`
because on modern CPUs it’s roughly the same speed as `f32` but is capable of
more precision.
-->
<p>Rustにはさらに、<em>浮動小数点数</em>に対しても、2種類の基本型があり、浮動小数点数とは数値に小数点がついたもののことです。
Rustの浮動小数点型は、<code>f32</code>と<code>f64</code>で、それぞれ32ビットと64ビットサイズです。基準型は<code>f64</code>です。
なぜなら、現代のCPUでは、<code>f32</code>とほぼ同スピードにもかかわらず、より精度が高くなるからです。</p>
<!--
Here’s an example that shows floating-point numbers in action:
-->
<p>実際に動作している浮動小数点数の例をご覧ください:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<!--
Floating-point numbers are represented according to the IEEE-754 standard. The
`f32` type is a single-precision float, and `f64` has double precision.
-->
<p>浮動小数点数は、IEEE-754規格に従って表現されています。<code>f32</code>が単精度浮動小数点数、
<code>f64</code>が倍精度浮動小数点数です。</p>
<!--
#### Numeric Operations
-->
<h4 id="数値演算"><a class="header" href="#数値演算">数値演算</a></h4>
<!--
Rust supports the usual basic mathematical operations you’d expect for all of the
number types: addition, subtraction, multiplication, division, and remainder.
The following code shows how you’d use each one in a `let` statement:
-->
<p>Rustにも全数値型に期待されうる標準的な数学演算が用意されています: 足し算、引き算、掛け算、割り算、余りです。
以下の例では、<code>let</code>文での各演算の使用方法をご覧になれます:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // addition
    // 足し算
    let sum = 5 + 10;

    // subtraction
    // 引き算
    let difference = 95.5 - 4.3;

    // multiplication
    // 掛け算
    let product = 4 * 30;

    // division
    // 割り算
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // Results in 0
                         // 結果は0

    // remainder
    // 余り
    let remainder = 43 % 5;
}
</code></pre></pre>
<!--
Each expression in these statements uses a mathematical operator and evaluates
to a single value, which is then bound to a variable. Appendix B contains a
list of all operators that Rust provides.
-->
<p>これらの文の各式は、数学演算子を使用しており、一つの値に評価され、そして、変数に束縛されます。
付録BにRustで使える演算子の一覧が載っています。</p>
<!--
#### The Boolean Type
-->
<h4 id="論理値型"><a class="header" href="#論理値型">論理値型</a></h4>
<!--
As in most other programming languages, a boolean type in Rust has two possible
values: `true` and `false`. The boolean type in Rust is specified using `bool`.
For example:
-->
<p>他の多くの言語同様、Rustの論理値型も取りうる値は二つしかありません: <code>true</code>と<code>false</code>です。
Rustの論理値型は、<code>bool</code>と指定されます。
例です:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
                         // 明示的型注釈付きで
}
</code></pre></pre>
<!--
The main way to use Boolean values is through conditionals, such as an `if`
expression. We’ll cover how `if` expressions work in Rust in the “Control Flow”
section.
-->
<p>論理値を使う主な手段は、条件式です。例えば、<code>if</code>式などですね。<code>if</code>式のRustでの動作方法については、
「制御フロー」節で講義します。</p>
<!--
#### The Character Type
-->
<h4 id="文字型"><a class="header" href="#文字型">文字型</a></h4>
<!--
So far we’ve worked only with numbers, but Rust supports letters too. Rust’s
`char` type is the language’s most primitive alphabetic type, and the following
code shows one way to use it. (Note that the `char` type is specified with
single quotes, as opposed to strings, which use double quotes.)
-->
<p>ここまで、数値型のみ扱ってきましたが、Rustには文字も用意されています。Rustの<code>char</code>型は、
言語の最も基本的なアルファベット型であり、以下のコードでその使用方法の一例を見ることができます。
(<code>char</code>は、ダブルクォーテーションマークを使用する文字列に対して、シングルクォートで指定されることに注意してください。)</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';    //ハート目の猫
}
</code></pre></pre>
<!--
Rust’s `char` type represents a Unicode Scalar Value, which means it can
represent a lot more than just ASCII. Accented letters; Chinese, Japanese and
Korean characters; emoji; and zero-width spaces are all valid `char` types in
Rust. Unicode Scalar Values range from `U+0000` to `U+D7FF` and `U+E000` to
`U+10FFFF` inclusive. However, a “character” isn’t really a concept in Unicode,
so your human intuition for what a “character” is may not match up with what a
`char` is in Rust. We’ll discuss this topic in detail in the “Strings” in Chapter 8.
-->
<p>Rustの<code>char</code>型は、ユニコードのスカラー値を表します。これはつまり、アスキーよりもずっとたくさんのものを表せるということです。
アクセント文字; 中国語、日本語、韓国語文字;
絵文字; ゼロ幅スペースは、全てRustでは、有効な<code>char</code>型になります。ユニコードスカラー値は、
<code>U+0000</code>から<code>U+D7FF</code>までと<code>U+E000</code>から<code>U+10FFFF</code>までの範囲になります。
ところが、「文字」は実はユニコードの概念ではないので、文字とは何かという人間としての直観は、
Rustにおける<code>char</code>値が何かとは合致しない可能性があります。この話題については、第8章の「文字列」で詳しく議論しましょう。</p>
<!--
### Compound Types
-->
<h3 id="複合型"><a class="header" href="#複合型">複合型</a></h3>
<!--
*Compound types* can group multiple values into one type. Rust has two
primitive compound types: tuples and arrays.
-->
<p><em>複合型</em>により、複数の値を一つの型にまとめることができます。Rustには、
2種類の基本的な複合型があります: タプルと配列です。</p>
<!--
#### The Tuple type
-->
<h4 id="タプル型"><a class="header" href="#タプル型">タプル型</a></h4>
<!--
A tuple is a general way of grouping together some number of other values with
a variety of types into one compound type.
-->
<p>タプルは、複数の型の何らかの値を一つの複合型にまとめ上げる一般的な手段です。</p>
<!--
We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don’t have to be the same. We’ve added optional
type annotations in this example:
-->
<p>タプルは、丸かっこの中にカンマ区切りの値リストを書くことで生成します。タプルの位置ごとに型があり、
タプル内の値はそれぞれ全てが同じ型である必要はありません。今回の例では、型注釈をあえて追加しました:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<!--
The variable `tup` binds to the entire tuple, because a tuple is considered a
single compound element. To get the individual values out of a tuple, we can
use pattern matching to destructure a tuple value, like this:
-->
<p>変数<code>tup</code>は、タプル全体に束縛されています。なぜなら、タプルは、一つの複合要素と考えられるからです。
タプルから個々の値を取り出すには、パターンマッチングを使用して分解することができます。以下のように:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<!--
This program first creates a tuple and binds it to the variable `tup`. It then
uses a pattern with `let` to take `tup` and turn it into three separate
variables, `x`, `y`, and `z`. This is called *destructuring*, because it breaks
the single tuple into three parts. Finally, the program prints the value of
`y`, which is `6.4`.
-->
<p>このプログラムは、まずタプルを生成し、それを変数<code>tup</code>に束縛しています。
それから<code>let</code>とパターンを使って<code>tup</code>変数の中身を3つの個別の変数(<code>x</code>、<code>y</code>、<code>z</code>ですね)に変換しています。
この過程は、<em>分配</em>と呼ばれます。単独のタプルを破壊して三分割しているからです。最後に、
プログラムは<code>y</code>変数の値を出力し、<code>6.4</code>と表示されます。</p>
<!--
In addition to destructuring through pattern matching, we can also access a tuple
element directly by using a period (`.`) followed by the index of the value we
want to access. For example:
-->
<p>パターンマッチングを通しての分配の他にも、アクセスしたい値の番号をピリオド(<code>.</code>)に続けて書くことで、
タプルの要素に直接アクセスすることもできます。例です:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<!--
This program creates a tuple, `x`, and then makes new variables for each
element by using their index. As with most programming languages, the first
index in a tuple is 0.
-->
<p>このプログラムは、新しいタプル<code>x</code>を作成し、添え字アクセスで各要素に対して新しい変数も作成しています。
多くのプログラミング言語同様、タプルの最初の添え字は0です。</p>
<!--
#### The Array Type
-->
<h4 id="配列型"><a class="header" href="#配列型">配列型</a></h4>
<!--
Another way to have a collection of multiple values is with an *array*. Unlike
a tuple, every element of an array must have the same type. Arrays in Rust are
different than arrays in some other languages because arrays in Rust have a
fixed length: once declared, they cannot grow or shrink in size.
-->
<p><em>配列</em>によっても、複数の値のコレクションを得ることができます。タプルと異なり、配列の全要素は、
同じ型でなければなりません。Rustの配列は、他の言語と異なっています。Rustの配列は、
固定長なのです: 一度宣言されたら、サイズを伸ばすことも縮めることもできません。</p>
<!--
In Rust, the values going into an array are written as a comma-separated list
inside square brackets:
-->
<p>Rustでは、配列に入れる要素は、角かっこ内にカンマ区切りリストとして記述します:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<!--
Arrays are useful when you want your data allocated on the stack rather than
the heap (we will discuss the stack and the heap more in Chapter 4) or when
you want to ensure you always have a fixed number of elements. An array isn't
as flexible as the vector type, though. A vector is a similar collection type
provided by the standard library that *is* allowed to grow or shrink in size.
If you’re unsure whether to use an array or a vector, you should probably use a
vector. Chapter 8 discusses vectors in more detail.
-->
<p>配列は、ヒープよりもスタック(スタックとヒープについては第4章で<ruby>詳<rp>(</rp><rt>つまび</rt><rp>)</rp></ruby>らかに議論します)にデータのメモリを確保したい時、
または、常に固定長の要素があることを確認したい時に有効です。
ただ、配列は、ベクタ型ほど柔軟ではありません。ベクタは、標準ライブラリによって提供されている配列と似たようなコレクション型で、
こちらは、サイズを伸縮させることが<em>できます</em>。配列とベクタ型、どちらを使うべきか確信が持てない時は、
おそらくベクタ型を使うべきです。第8章でベクタについて詳細に議論します。</p>
<!--
An example of when you might want to use an array rather than a vector is in a
program that needs to know the names of the months of the year. It’s very
unlikely that such a program will need to add or remove months, so you can use
an array because you know it will always contain 12 items:
-->
<p>ベクタ型よりも配列を使いたくなるかもしれない例は、1年の月の名前を扱うプログラムです。そのようなプログラムで、
月を追加したり削除したりすることまずないので、配列を使用できます。常に12個要素があることもわかってますからね:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
<span class="boring">}
</span></code></pre></pre>
<!--
You write an array’s type using square brackets with the type of each element,
a semicolon, and then the number of elements in the array, like so:
-->
<p>例えば次のように、配列の型は角かっこの中に要素の型とセミコロン、そして配列の要素数を与えます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<!--
Here, `i32` is the type of each element. After the semicolon, the number `5`
indicates the array contains five elements.
-->
<p>ここでの<code>i32</code>は要素の型です。セミコロンのあとの<code>5</code>という数字は配列の要素が5つあることを表しています。</p>
<!--
You can also initialize an array to contain the same value for each element by
specifying the initial value, followed by a semicolon, and then the length of
the array in square brackets, as shown here:
-->
<p>次のように、角かっこの中に初期値とセミコロン、そして配列の長さを与えることで、各要素に同じ値を持つように配列を初期化することができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<!--
The array named `a` will contain `5` elements that will all be set to the value
`3` initially. This is the same as writing `let a = [3, 3, 3, 3, 3];` but in a
more concise way.
-->
<p>この<code>a</code>という名前の配列は<code>3</code>という値が5つあるものです。これは<code>let a = [3, 3, 3, 3, 3];</code>と書くのと同じですが、より簡潔になります。</p>
<!--
##### Accessing Array Elements
-->
<h5 id="配列の要素にアクセスする"><a class="header" href="#配列の要素にアクセスする">配列の要素にアクセスする</a></h5>
<!--
An array is a single chunk of memory allocated on the stack. You can access
elements of an array using indexing, like this:
-->
<p>配列は、スタック上に確保される一塊のメモリです。添え字によって、
配列の要素にこのようにアクセスすることができます:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<!--
In this example, the variable named `first` will get the value `1`, because
that is the value at index `[0]` in the array. The variable named `second` will
get the value `2` from index `[1]` in the array.
-->
<p>この例では、<code>first</code>という名前の変数には<code>1</code>という値が格納されます。配列の<code>[0]</code>番目にある値が、
それだからですね。<code>second</code>という名前の変数には、配列の<code>[1]</code>番目の値<code>2</code>が格納されます。</p>
<!--
##### Invalid Array Element Access
-->
<h5 id="配列要素への無効なアクセス"><a class="header" href="#配列要素への無効なアクセス">配列要素への無効なアクセス</a></h5>
<!--
What happens if you try to access an element of an array that is past the end
of the array? Say you change the example to the following code, which will
compile but exit with an error when it runs:
-->
<p>配列の終端を越えて要素にアクセスしようとしたら、どうなるでしょうか？
先ほどの例を以下のように変えたとすると、コンパイルは通りますが、実行するとエラーで終了します:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!(&quot;Please enter an array index.&quot;);
           // 配列の何番目の要素にアクセスするか指定してください

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect(&quot;Failed to read line&quot;);
              // 値の読み込みに失敗しました

    let index: usize = index
        .trim()
        .parse()
        .expect(&quot;Index entered was not a number&quot;);
        　　　// 入力された値は数字ではありません

    let element = a[index];

    println!(
        &quot;The value of the element at index {} is: {}&quot;,
        // {}番目の要素の値は{}です
        index, element
    );
}
</code></pre>
<!--
This code compiles successfully. If you run this code using `cargo run` and
enter 0, 1, 2, 3, or 4, the program will print out the corresponding value at
that index in the array. If you instead enter a number past the end of the
array, such as 10, you’ll see output like this:
-->
<p>このコードはコンパイルされます。<code>cargo run</code>で走らせ、0, 1, 2, 3, または4をこのプログラムに入力すると配列の対応する値を出力します。もし配列の末尾を超えるような、例えば10などの数字を与えると、次のような出力が表示されます。</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19
スレッド'main'は'範囲外アクセス: 長さは5ですが、添え字は10でした', src/main.rs:19:19
でパニックしました
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<!--
The compilation didn’t produce any errors, but the program results in a
*runtime* error and didn’t exit successfully. When you attempt to access an
element using indexing, Rust will check that the index you’ve specified is less
than the array length. If the index is greater than the length, Rust will
*panic*, which is the term Rust uses when a program exits with an error.
-->
<p>コンパイルでは何もエラーが出なかったものの、プログラムは<em>実行時</em>エラーに陥り、
正常終了しませんでした。要素に添え字アクセスを試みると、言語は、
指定されたその添え字が配列長よりも小さいかを確認してくれます。添え字が配列長よりも大きければ、言語は<em>パニック</em>します。
パニックとは、プログラムがエラーで終了したことを表すRust用語です。</p>
<!--
This is the first example of Rust’s safety principles in action. In many
low-level languages, this kind of check is not done, and when you provide an
incorrect index, invalid memory can be accessed. Rust protects you against this
kind of error by immediately exiting instead of allowing the memory access and
continuing. Chapter 9 discusses more of Rust’s error handling.
-->
<p>これは、実際に稼働しているRustの安全機構の最初の例になります。低レベル言語の多くでは、
この種のチェックは行われないため、間違った添え字を与えると、無効なメモリにアクセスできてしまいます。
Rustでは、メモリアクセスを許可し、処理を継続する代わりに即座にプログラムを終了することで、
この種のエラーからプログラマを保護しています。Rustのエラー処理については、第9章でもっと議論します。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Functions
-->
<h2 id="関数"><a class="header" href="#関数">関数</a></h2>
<!--
Functions are pervasive in Rust code. You’ve already seen one of the most
important functions in the language: the `main` function, which is the entry
point of many programs. You’ve also seen the `fn` keyword, which allows you to
declare new functions.
-->
<p>関数は、Rustのコードにおいてよく見かける存在です。既に、言語において最も重要な関数のうちの一つを目撃していますね:
そう、<code>main</code>関数です。これは、多くのプログラムのエントリーポイント(<code>訳注</code>: プログラム実行時に最初に走る関数のこと)になります。
<code>fn</code>キーワードもすでに見かけましたね。これによって新しい関数を宣言することができます。</p>
<!--
Rust code uses *snake case* as the conventional style for function and variable
names. In snake case, all letters are lowercase and underscores separate words.
Here’s a program that contains an example function definition:
-->
<p>Rustの関数と変数の命名規則は、<em>スネークケース</em>(<code>訳注</code>: some_variableのような命名規則)を使うのが慣例です。
スネークケースとは、全文字を小文字にし、単語区切りにアンダースコアを使うことです。
以下のプログラムで、サンプルの関数定義をご覧ください:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);  // 別の関数
}
</code></pre></pre>
<!--
Function definitions in Rust start with `fn` and have a set of parentheses
after the function name. The curly brackets tell the compiler where the function
body begins and ends.
-->
<p>Rustにおいて関数定義は、<code>fn</code>キーワードで始まり、関数名の後に丸かっこの組が続きます。
波かっこが、コンパイラに関数本体の開始と終了の位置を伝えます。</p>
<!--
We can call any function we’ve defined by entering its name followed by a set
of parentheses. Because `another_function` is defined in the program, it can be
called from inside the `main` function. Note that we defined `another_function`
*after* the `main` function in the source code; we could have defined it before
as well. Rust doesn’t care where you define your functions, only that they’re
defined somewhere.
-->
<p>定義した関数は、名前に丸かっこの組を続けることで呼び出すことができます。
<code>another_function</code>関数がプログラム内で定義されているので、<code>main</code>関数内から呼び出すことができるわけです。
ソースコード中で<code>another_function</code>を<code>main</code>関数の<em>後</em>に定義していることに注目してください;
勿論、main関数の前に定義することもできます。コンパイラは、関数がどこで定義されているかは気にしません。
どこかで定義されていることのみ気にします。</p>
<!--
Let’s start a new binary project named *functions* to explore functions
further. Place the `another_function` example in *src/main.rs* and run it. You
should see the following output:
-->
<p><em>functions</em>という名前の新しいバイナリ生成プロジェクトを始めて、関数についてさらに深く探究していきましょう。
<code>another_function</code>の例を<em>src/main.rs</em>ファイルに配置して、走らせてください。
以下のような出力が得られるはずです:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<!--
The lines execute in the order in which they appear in the `main` function.
First, the “Hello, world!” message prints, and then `another_function` is
called and its message is printed.
-->
<p>行出力は、<code>main</code>関数内に書かれた順序で実行されています。最初に&quot;Hello, world&quot;メッセージが出て、
それから<code>another_function</code>が呼ばれて、こちらのメッセージが出力されています。</p>
<!--
### Function Parameters
-->
<h3 id="関数の引数"><a class="header" href="#関数の引数">関数の引数</a></h3>
<!--
Functions can also be defined to have *parameters*, which are special variables
that are part of a function's signature. When a function has parameters, you
can provide it with concrete values for those parameters. Technically, the
concrete values are called *arguments*, but in casual conversation people tend
to use the words “parameter” and “argument” interchangeably for either the
variables in a function's definition or the concrete values passed in when you
call a function.
-->
<p>関数は、引数を持つようにも定義できます。引数とは、関数シグニチャの一部になる特別な変数のことです。
関数に引数があると、引数の位置に実際の値を与えることができます。技術的にはこの実際の値は
<em>実引数</em>と呼ばれますが、普段の会話では、仮引数(&quot;parameter&quot;)と実引数(&quot;argument&quot;)を関数定義の変数と関数呼び出し時に渡す実際の値、
両方の意味に区別なく使います(<code>訳注</code>: 日本語では、特別区別する意図がない限り、どちらも単に引数と呼ぶことが多いでしょう)。</p>
<!--
The following rewritten version of `another_function` shows what parameters
look like in Rust:
-->
<p>以下の書き直した<code>another_function</code>では、Rustの仮引数がどのようなものかを示しています:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {}&quot;, x);   // xの値は{}です
}
</code></pre></pre>
<!--
Try running this program; you should get the following output:
-->
<p>このプログラムを走らせてみてください; 以下のような出力が得られるはずです:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<!--
The declaration of `another_function` has one parameter named `x`. The type of
`x` is specified as `i32`. When `5` is passed to `another_function`, the
`println!` macro puts `5` where the pair of curly brackets were in the format
string.
-->
<p><code>another_function</code>の宣言には、<code>x</code>という名前の仮引数があります。<code>x</code>の型は、
<code>i32</code>と指定されています。値<code>5</code>が<code>another_function</code>に渡されると、<code>println!</code>マクロにより、
フォーマット文字列中の1組の波かっこがあった位置に値<code>5</code>が出力されます。</p>
<!--
In function signatures, you *must* declare the type of each parameter. This is
a deliberate decision in Rust’s design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what you mean.
-->
<p>関数シグニチャにおいて、各仮引数の型を宣言しなければ<em>なりません</em>。これは、Rustの設計において、
意図的な判断です: 関数定義で型注釈が必要不可欠ということは、コンパイラがその意図するところを推し量るのに、
プログラマがコードの他の箇所で使用する必要がないということを意味します。</p>
<!--
When you want a function to have multiple parameters, separate the parameter
declarations with commas, like this:
-->
<p>関数に複数の仮引数を持たせたいときは、仮引数定義をカンマで区切ってください。
こんな感じです:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    print_labeled_measurement(5, 'h');
}

fn print_labeled_measurement(value: i32, unit_label: char) {
    println!(&quot;The measurement is: {}{}&quot;, value, unit_label);
}
</code></pre></pre>
<!--
This example creates a function with two parameters, both of which are `i32`
types. The function then prints the values in both of its parameters. Note that
function parameters don't all need to be the same type, they just happen to be
in this example.
-->
<p>この例では、2引数の関数を生成しています。そして、引数はどちらも<code>i32</code>型です。それからこの関数は、
仮引数の値を両方出力します。関数引数は、全てが同じ型である必要はありません。今回は、
偶然同じになっただけです。</p>
<!--
Let’s try running this code. Replace the program currently in your *functions*
project’s *src/main.rs* file with the preceding example and run it using `cargo
run`:
-->
<p>このコードを走らせてみましょう。今、<em>function</em>プロジェクトの<em>src/main.rs</em>ファイルに記載されているプログラムを先ほどの例と置き換えて、
<code>cargo run</code>で走らせてください:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
The measurement is: 5h
</code></pre>
<!--
Because we called the function with `5` as the value for `x` and `6` is passed
as the value for `y`, the two strings are printed with these values.
-->
<p><code>x</code>に対して値<code>5</code>、<code>y</code>に対して値<code>6</code>を渡して関数を呼び出したので、この二つの文字列は、
この値で出力されました。</p>
<!--
NOTE: doc.rust-lang.orgのものではヘッダが変わっている
-->
<!--
### Function Bodies Contain Statements and Expressions
-->
<h3 id="関数本体は文と式を含む"><a class="header" href="#関数本体は文と式を含む">関数本体は、文と式を含む</a></h3>
<!--
Function bodies are made up of a series of statements optionally ending in an
expression. So far, we’ve only covered functions without an ending expression,
but we have seen an expression as part of a statement. Because Rust is an
expression-based language, this is an important distinction to understand.
Other languages don’t have the same distinctions, so let’s look at what
statements and expressions are and how their differences affect the bodies of
functions.
-->
<p>関数本体は、文が並び、最後に式を置くか文を置くという形で形成されます。現在までには、
式で終わらない関数だけを見てきたわけですが、式が文の一部になっているものなら見かけましたね。Rustは、式指向言語なので、
これは理解しておくべき重要な差異になります。他の言語にこの差異はありませんので、文と式がなんなのかと、
その違いが関数本体にどんな影響を与えるかを見ていきましょう。</p>
<!--
We’ve actually already used statements and expressions. *Statements* are
instructions that perform some action and do not return a value. *Expressions*
evaluate to a resulting value. Let’s look at some examples.
-->
<p>実のところ、もう文と式は使っています。<em>文</em>とは、なんらかの動作をして値を返さない命令です。
<em>式</em>は結果値に評価されます。ちょっと例を眺めてみましょう。</p>
<!--
Creating a variable and assigning a value to it with the `let` keyword is a
statement. In Listing 3-1, `let y = 6;` is a statement.
-->
<p><code>let</code>キーワードを使用して変数を生成し、値を代入することは文になります。
リスト3-1で<code>let y = 6;</code>は文です。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-1: A `main` function declaration containing one statement</span>
-->
<p><span class="caption">リスト3-1: 1文を含む<code>main</code>関数宣言</span></p>
<!--
Function definitions are also statements; the entire preceding example is a
statement in itself.
-->
<p>関数定義も文になります。つまり、先の例は全体としても文になるわけです。</p>
<!--
asは前の文にかかるべきだが、大して意味が変わらないので、語順をそのままにして後ろにかかるように訳した
-->
<!--
Statements do not return values. Therefore, you can’t assign a `let` statement
to another variable, as the following code tries to do; you'll get an error:
-->
<p>文は値を返しません。故に、<code>let</code>文を他の変数に代入することはできません。
以下のコードではそれを試みていますが、エラーになります:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}
</code></pre>
<!--
When you run this program, the error you’ll get looks like this:
-->
<p>このプログラムを実行すると、以下のようなエラーが出るでしょう:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
(エラー: 式を予期しましたが、文が見つかりました (`let`))
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: variable declaration using `let` is a statement
    (注釈: `let`を使う変数宣言は、文です)

error[E0658]: `let` expressions in this position are experimental
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^^^^^^^
  |
  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information
  = help: you can write `matches!(&lt;expr&gt;, &lt;pattern&gt;)` instead of `let &lt;pattern&gt; = &lt;expr&gt;`

warning: unnecessary parentheses around assigned value
 --&gt; src/main.rs:2:13
  |
2 |     let x = (let y = 6);
  |             ^         ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 -     let x = (let y = 6);
2 +     let x = let y = 6;
  | 

For more information about this error, try `rustc --explain E0658`.
warning: `functions` (bin &quot;functions&quot;) generated 1 warning
error: could not compile `functions` due to 2 previous errors; 1 warning emitted
</code></pre>
<!--
The `let y = 6` statement does not return a value, so there isn’t anything for
`x` to bind to. This is different from what happens in other languages, such as
C and Ruby, where the assignment returns the value of the assignment. In those
languages, you can write `x = y = 6` and have both `x` and `y` have the value
`6`; that is not the case in Rust.
-->
<p>この<code>let y = 6</code>という文は値を返さないので、<code>x</code>に束縛するものがないわけです。これは、
CやRubyなどの言語とは異なる動作です。CやRubyでは、代入は代入値を返します。これらの言語では、
<code>x = y = 6</code>と書いて、<code>x</code>も<code>y</code>も値6になるようにできるのですが、Rustにおいては、
そうは問屋が卸さないわけです。</p>
<!--
Expressions evaluate to something and make up most of the rest of the code that
you’ll write in Rust. Consider a simple math operation, such as `5 + 6`, which
is an expression that evaluates to the value `11`. Expressions can be part of
statements: in Listing 3-1, the `6` in the statement `let y = 6;` is an
expression that evaluates to the value `6`. Calling a function is an
expression. Calling a macro is an expression. The block that we use to create
new scopes, `{}`, is an expression, for example:
-->
<p>式は何かに評価され、これからあなたが書くRustコードの多くを構成します。
簡単な数学演算(<code>5 + 6</code>など)を思い浮かべましょう。この例は、値<code>11</code>に評価される式です。式は文の一部になりえます:
リスト3-1において、<code>let y = 6</code>という文の<code>6</code>は値<code>6</code>に評価される式です。関数呼び出しも式です。マクロ呼び出しも式です。
新しいスコープを作る際に使用するブロック(<code>{}</code>)も式です:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<!--
This expression:
-->
<p>以下の式:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<!--
is a block that, in this case, evaluates to `4`. That value gets bound to `y`
as part of the `let` statement. Note the `x + 1` line without a semicolon at
the end, which is unlike most of the lines you’ve seen so far. Expressions do
not include ending semicolons. If you add a semicolon to the end of an
expression, you turn it into a statement, which will then not return a value.
Keep this in mind as you explore function return values and expressions next.
-->
<p>は今回の場合、<code>4</code>に評価されるブロックです。その値が、<code>let</code>文の一部として<code>y</code>に束縛されます。
今まで見かけてきた行と異なり、文末にセミコロンがついていない<code>x + 1</code>の行に気をつけてください。
式は終端にセミコロンを含みません。式の終端にセミコロンを付けたら、文に変えてしまいます。そして、文は値を返しません。
次に関数の戻り値や式を見ていく際にこのことを肝に銘じておいてください。</p>
<!--
### Functions with Return Values
-->
<h3 id="戻り値のある関数"><a class="header" href="#戻り値のある関数">戻り値のある関数</a></h3>
<!--
Functions can return values to the code that calls them. We don’t name return
values, but we do declare their type after an arrow (`->`). In Rust, the return
value of the function is synonymous with the value of the final expression in
the block of the body of a function. You can return early from a function by
using the `return` keyword and specifying a value, but most functions return
the last expression implicitly. Here’s an example of a function that
returns a value:
-->
<p>関数は、それを呼び出したコードに値を返すことができます。戻り値に名前を付けはしませんが、
矢印(<code>-&gt;</code>)の後に型を書いて確かに宣言します。Rustでは、関数の戻り値は、関数本体ブロックの最後の式の値と同義です。
<code>return</code>キーワードで関数から早期リターンし、値を指定することもできますが、多くの関数は最後の式を暗黙的に返します。
こちらが、値を返す関数の例です:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<!--
There are no function calls, macros, or even `let` statements in the `five`
function—just the number `5` by itself. That’s a perfectly valid function in
Rust. Note that the function’s return type is specified, too, as `-> i32`. Try
running this code; the output should look like this:
-->
<p><code>five</code>関数内には、関数呼び出しもマクロ呼び出しも、<code>let</code>文でさえ存在しません。数字の5が単独であるだけです。
これは、Rustにおいて、完璧に問題ない関数です。関数の戻り値型が<code>-&gt; i32</code>と指定されていることにも注目してください。
このコードを実行してみましょう; 出力はこんな感じになるはずです:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<!--
The `5` in `five` is the function’s return value, which is why the return type
is `i32`. Let’s examine this in more detail. There are two important bits:
first, the line `let x = five();` shows that we’re using the return value of a
function to initialize a variable. Because the function `five` returns a `5`,
that line is the same as the following:
-->
<p><code>five</code>内の<code>5</code>が関数の戻り値です。だから、戻り値型が<code>i32</code>なのです。これについてもっと深く考察しましょう。
重要な箇所は2つあります: まず、<code>let x = five()</code>という行は、関数の戻り値を使って変数を初期化していることを示しています。
関数<code>five</code>は<code>5</code>を返すので、この行は以下のように書くのと同義です:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<!--
Second, the `five` function has no parameters and defines the type of the
return value, but the body of the function is a lonely `5` with no semicolon
because it’s an expression whose value we want to return.
-->
<p>2番目に、<code>five</code>関数は仮引数をもたず、戻り値型を定義していますが、関数本体はセミコロンなしの<code>5</code>単独です。
なぜなら、これが返したい値になる式だからです。</p>
<!--
Let's look at another example:
-->
<p>もう一つ別の例を見ましょう:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<!--
Running this code will print `The value of x is: 6`. But if we place a
semicolon at the end of the line containing `x + 1`, changing it from an
expression to a statement, we'll get an error:
-->
<p>このコードを走らせると、<code>The value of x is: 6</code>と出力されるでしょう。しかし、
<code>x + 1</code>を含む行の終端にセミコロンを付けて、式から文に変えたら、エラーになるでしょう:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<!--
Running this code produces an error, as follows:
-->
<p>このコードを実行すると、以下のようにエラーが出ます:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
              (型が合いません)
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions` due to previous error
</code></pre>
<!--
The main error message, “mismatched types,” reveals the core issue with this
code. The definition of the function `plus_one` says that it will return an
`i32`, but statements don’t evaluate to a value, which is expressed by `()`,
the empty tuple. Therefore, nothing is returned, which contradicts the function
definition and results in an error. In this output, Rust provides a message to
possibly help rectify this issue: it suggests removing the semicolon, which
would fix the error.
-->
<p>メインのエラーメッセージである「型が合いません」でこのコードの根本的な問題が明らかになるでしょう。
関数<code>plus_one</code>の定義では、<code>i32</code>型を返すと言っているのに、文は値に評価されないからです。このことは、
<code>()</code>、つまり空のタプルとして表現されています。それゆえに、何も戻り値がなく、これが関数定義と矛盾するので、
結果としてエラーになるわけです。この出力内で、コンパイラは問題を修正する手助けになりそうなメッセージも出していますね: 
セミコロンを削除するよう提言しています。そして、そうすれば、エラーは直るわけです。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Comments
-->
<h2 id="コメント"><a class="header" href="#コメント">コメント</a></h2>
<!--
All programmers strive to make their code easy to understand, but sometimes
extra explanation is warranted. In these cases, programmers leave notes, or
*comments*, in their source code that the compiler will ignore but people
reading the source code may find useful.
-->
<p>全プログラマは、自分のコードがわかりやすくなるよう努めますが、時として追加の説明が許されることもあります。
このような場合、プログラマは注釈または<em>コメント</em>をソースコードに残し、コメントをコンパイラは無視しますが、
ソースコードを読む人間には有益なものと思えるでしょう。</p>
<!--
Here’s a simple comment:
-->
<p>こちらが単純なコメントです:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}
</span></code></pre></pre>
<!--
In Rust, comments must start with two slashes and continue until the end of the
line. For comments that extend beyond a single line, you’ll need to include
`//` on each line, like this:
-->
<p>Rustでは、コメントは2連スラッシュで始め、行の終わりまで続きます。コメントが複数行にまたがる場合、
各行に<code>//</code>を含める必要があります。こんな感じに:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
// ここで何か複雑なことをしていて、長すぎるから複数行のコメントが必要なんだ。
// ふう！願わくば、このコメントで何が起きているか説明されていると嬉しい。
<span class="boring">}
</span></code></pre></pre>
<!--
Comments can also be placed at the end of lines containing code:
-->
<p>コメントは、コードが書かれた行の末尾にも配置することができます:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let lucky_number = 7; // I’m feeling lucky today(今日はラッキーな気がするよ)
}
</code></pre></pre>
<!--
But you’ll more often see them used in this format, with the comment on a
separate line above the code it's annotating:
-->
<p>しかし、こちらの形式のコメントの方が見かける機会は多いでしょう。注釈しようとしているコードの1行上に書く形式です:</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // I’m feeling lucky today
    // 今日はラッキーな気がするよ
    let lucky_number = 7;
}
</code></pre></pre>
<!--
Rust also has another kind of comment, documentation comments, which we’ll
discuss in Chapter 14.
-->
<p>Rustには他の種類のコメント、ドキュメントコメントもあり、それについては第14章で議論します。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Control Flow
-->
<h2 id="制御フロー"><a class="header" href="#制御フロー">制御フロー</a></h2>
<!--
Deciding whether or not to run some code depending on if a condition is true
and deciding to run some code repeatedly while a condition is true are basic
building blocks in most programming languages. The most common constructs that
let you control the flow of execution of Rust code are `if` expressions and
loops.
-->
<p>条件が真かどうかによってコードを走らせるかどうかを決定したり、
条件が真の間繰り返しコードを走らせるか決定したりすることは、多くのプログラミング言語において、基本的な構成ブロックです。
Rustコードの実行フローを制御する最も一般的な文法要素は、<code>if</code>式とループです。</p>
<!--
### `if` Expressions
-->
<h3 id="if式"><a class="header" href="#if式"><code>if</code>式</a></h3>
<!--
An `if` expression allows us to branch your code depending on conditions. We
provide a condition and then state, “If this condition is met, run this block
of code. If the condition is not met, do not run this block of code.”
-->
<p>if式によって、条件に依存して枝分かれをさせることができます。条件を与え、以下のように宣言します。
「もし条件が合ったら、この一連のコードを実行しろ。条件に合わなければ、この一連のコードは実行するな」と。</p>
<!--
Create a new project called *branches* in your *projects* directory to explore
the `if` expression. In the *src/main.rs* file, input the following:
-->
<p><em>projects</em>ディレクトリに<em>branches</em>という名のプロジェクトを作って<code>if</code>式について掘り下げていきましょう。
<em>src/main.rs</em>ファイルに、以下のように入力してください:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);       // 条件は真でした
    } else {
        println!(&quot;condition was false&quot;);      // 条件は偽でした
    }
}
</code></pre></pre>
<!--
NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199
-->
<!--
All `if` expressions start with the keyword `if`, which is followed by a
condition. In this case, the condition checks whether or not the variable
`number` has a value less than 5. The block of code we want to execute if the
condition is true is placed immediately after the condition inside curly
brackets. Blocks of code associated with the conditions in `if` expressions are
sometimes called *arms*, just like the arms in `match` expressions that we
discussed in the “Comparing the Guess to the Secret Number” section of
Chapter 2.
-->
<p><code>if</code>式は全て、キーワードの<code>if</code>から始め、条件式を続けます。今回の場合、
条件式は変数<code>number</code>が5未満の値になっているかどうかをチェックします。
条件が真の時に実行したい一連のコードを条件式の直後に波かっこで包んで配置します。<code>if</code>式の条件式と紐付けられる一連のコードは、
時として<em>アーム</em>と呼ばれることがあります。
第2章の「予想と秘密の数字を比較する」の節で議論した<code>match</code>式のアームと同じです。</p>
<!--
Optionally, we can also include an `else` expression, which we chose
to do here, to give the program an alternative block of code to execute should
the condition evaluate to false. If you don’t provide an `else` expression and
the condition is false, the program will just skip the `if` block and move on
to the next bit of code.
-->
<p>オプションとして、<code>else</code>式を含むこともでき(ここではそうしています)、これによりプログラムは、
条件式が偽になった時に実行するコードを与えられることになります。仮に、<code>else</code>式を与えずに条件式が偽になったら、
プログラムは単に<code>if</code>ブロックを飛ばして次のコードを実行しにいきます。</p>
<!--
Try running this code; you should see the following output:
-->
<p>このコードを走らせてみましょう; 以下のような出力を目の当たりにするはずです:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was true
</code></pre>
<!--
Let’s try changing the value of `number` to a value that makes the condition
`false` to see what happens:
-->
<p><code>number</code>の値を条件が<code>false</code>になるような値に変更してどうなるか確かめてみましょう:</p>
<pre><code class="language-rust ignore"><span class="boring">fn main() {
</span>    let number = 7;
<span class="boring">
</span><span class="boring">    if number &lt; 5 {
</span><span class="boring">        println!(&quot;condition was true&quot;);
</span><span class="boring">    } else {
</span><span class="boring">        println!(&quot;condition was false&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Run the program again, and look at the output:
-->
<p>再度プログラムを実行して、出力に注目してください:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
condition was false
</code></pre>
<!--
It’s also worth noting that the condition in this code *must* be a `bool`. If
the condition isn’t a `bool`, we’ll get an error. For example, try running the
following code:
-->
<p>このコード内の条件式は、<code>bool</code>型で<em>なければならない</em>ことにも触れる価値があります。
条件式が、<code>bool</code>型でない時は、エラーになります。例えば、試しに以下のコードを実行してみてください:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);     // 数値は3です
    }
}
</code></pre>
<!--
The `if` condition evaluates to a value of `3` this time, and Rust throws an
error:
-->
<p>今回、<code>if</code>の条件式は<code>3</code>という値に評価され、コンパイラがエラーを投げます:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: mismatched types
              (型が合いません)
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected `bool`, found integer
  |               (bool型を予期したのに、整数変数が見つかりました)

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<!--
The error indicates that Rust expected a `bool` but got an integer. Unlike
languages such as Ruby and JavaScript, Rust will not automatically try to
convert non-Boolean types to a Boolean. You must be explicit and always provide
`if` with a Boolean as its condition. If we want the `if` code block to run
only when a number is not equal to `0`, for example, we can change the `if`
expression to the following:
-->
<p>このエラーは、コンパイラは<code>bool</code>型を予期していたのに、整数だったことを示唆しています。
RubyやJavaScriptなどの言語とは異なり、Rustでは、論理値以外の値が、自動的に論理値に変換されることはありません。
明示し、必ず<code>if</code>には条件式として、<code>論理値</code>を与えなければなりません。
例えば、数値が<code>0</code>以外の時だけ<code>if</code>のコードを走らせたいなら、以下のように<code>if</code>式を変更することができます:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);   // 数値は0以外の何かです
    }
}
</code></pre></pre>
<!--
Running this code will print `number was something other than zero`.
-->
<p>このコードを実行したら、<code>number was something other than zero</code>と表示されるでしょう。</p>
<!--
#### Handling Multiple Conditions with `else if`
-->
<h4 id="else-ifで複数の条件を扱う"><a class="header" href="#else-ifで複数の条件を扱う"><code>else if</code>で複数の条件を扱う</a></h4>
<!--
You can have multiple conditions by combining `if` and `else` in an `else if`
expression. For example:
-->
<p><code>if</code>と<code>else</code>を組み合わせて<code>else if</code>式にすることで複数の条件を持たせることもできます。例です:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        // 数値は4で割り切れます
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        // 数値は3で割り切れます
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        // 数値は2で割り切れます
        println!(&quot;number is divisible by 2&quot;);
    } else {
        // 数値は4、3、2で割り切れません
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<!--
This program has four possible paths it can take. After running it, you should
see the following output:
-->
<p>このプログラムには、通り道が4つあります。実行後、以下のような出力を目の当たりにするはずです:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<!--
When this program executes, it checks each `if` expression in turn and executes
the first body for which the condition holds true. Note that even though 6 is
divisible by 2, we don’t see the output `number is divisible by 2`, nor do we
see the `number is not divisible by 4, 3, or 2` text from the `else` block.
That's because Rust will only execute the block for the first true condition, and
once it finds one, it won’t even check the rest.
-->
<p>このプログラムを実行すると、<code>if</code>式が順番に吟味され、最初に条件が真になった本体が実行されます。
6は2で割り切れるものの、<code>number is devisible by 2</code>や、
<code>else</code>ブロックの<code>number is not divisible by 4, 3, or 2</code>という出力はされないことに注目してください。
それは、Rustが最初の真条件のブロックのみを実行し、
条件に合ったものが見つかったら、残りはチェックすらしないからです。</p>
<!--
Using too many `else if` expressions can clutter your code, so if you have more
than one, you might want to refactor your code. Chapter 6 describes a powerful
Rust branching construct called `match` for these cases.
-->
<p><code>else if</code>式を使いすぎると、コードがめちゃくちゃになってしまうので、1つ以上あるなら、
コードをリファクタリングしたくなるかもしれません。これらのケースに有用な<code>match</code>と呼ばれる、
強力なRustの枝分かれ文法要素については第6章で解説します。</p>
<!--
#### Using `if` in a `let` Statement
-->
<h4 id="let文内でif式を使う"><a class="header" href="#let文内でif式を使う"><code>let</code>文内で<code>if</code>式を使う</a></h4>
<!--
Because `if` is an expression, we can use it on the right side of a `let`
statement, as in Listing 3-2.
-->
<p><code>if</code>は式なので、<code>let</code>文の右辺に持ってくることができます。リスト3-2のようにですね。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    // numberの値は、{}です
    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<!-- <span class="caption">Listing 3-2: Assigning the result of an `if` expression
to a variable</span> -->
<p><span class="caption">リスト3-2: <code>if</code>式の結果を変数に代入する</span></p>
<!--
The `number` variable will be bound to a value based on the outcome of the `if`
expression. Run this code to see what happens:
-->
<p>この<code>number</code>変数は、<code>if</code>式の結果に基づいた値に束縛されます。このコードを走らせてどうなるか確かめてください:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<!--
Remember that blocks of code evaluate to the last expression in them, and
numbers by themselves are also expressions. In this case, the value of the
whole `if` expression depends on which block of code executes. This means the
values that have the potential to be results from each arm of the `if` must be
the same type; in Listing 3-2, the results of both the `if` arm and the `else`
arm were `i32` integers. If the types are mismatched, as in the following
example, we'll get an error:
-->
<p>一連のコードは、そのうちの最後の式に評価され、数値はそれ単独でも式になることを思い出してください。
今回の場合、この<code>if</code>式全体の値は、どのブロックのコードが実行されるかに基づきます。これはつまり、
<code>if</code>の各アームの結果になる可能性がある値は、同じ型でなければならないということになります;
リスト3-2で、<code>if</code>アームも<code>else</code>アームも結果は、<code>i32</code>の整数でした。以下の例のように、
型が合わない時には、エラーになるでしょう:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition { 5 } else { &quot;six&quot; };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre>
<!--
When we try to compile this code, we’ll get an error. The `if` and `else` arms
have value types that are incompatible, and Rust indicates exactly where to
find the problem in the program:
-->
<p>このコードをコンパイルしようとすると、エラーになります。<code>if</code>と<code>else</code>アームは互換性のない値の型になり、
コンパイラがプログラム内で問題の見つかった箇所をズバリ指摘してくれます:</p>
<pre><code class="language-console">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
error[E0308]: `if` and `else` have incompatible types
              (ifとelseの型に互換性がありません)
 --&gt; src/main.rs:4:44
  |
4 |     let number = if condition { 5 } else { &quot;six&quot; };
  |                                 -          ^^^^^ expected integer, found `&amp;str`
  |                                                 (整数変数を予期しましたが、&amp;strが見つかりました)
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `branches` due to previous error
</code></pre>
<!--
The expression in the `if` block evaluates to an integer, and the expression in
the `else` block evaluates to a string. This won’t work because variables must
have a single type. Rust needs to know at compile time what type the `number`
variable is, definitively, so it can verify at compile time that its type is
valid everywhere we use `number`. Rust wouldn’t be able to do that if the type
of `number` was only determined at runtime; the compiler would be more complex
and would make fewer guarantees about the code if it had to keep track of
multiple hypothetical types for any variable.
-->
<p><code>if</code>ブロックの式は整数に評価され、<code>else</code>ブロックの式は文字列に評価されます。これでは動作しません。
変数は単独の型でなければならないからです。コンパイラは、コンパイル時に<code>number</code>変数の型を確実に把握する必要があるため、
コンパイル時に<code>number</code>が使われている箇所全部で型が有効かどうか検査することができるのです。
<code>number</code>の型が実行時にしか決まらないのであれば、コンパイラはそれを実行することができなくなってしまいます;
どの変数に対しても、架空の複数の型があることを追いかけなければならないのであれば、コンパイラはより複雑になり、
コードに対して行える保証が少なくなってしまうでしょう。</p>
<!--
### Repetition with Loops
-->
<h3 id="ループでの繰り返し"><a class="header" href="#ループでの繰り返し">ループでの繰り返し</a></h3>
<!--
It’s often useful to execute a block of code more than once. For this task,
Rust provides several *loops*. A loop runs through the code inside the loop
body to the end and then starts immediately back at the beginning. To
experiment with loops, let’s make a new project called *loops*.
-->
<p>一連のコードを1回以上実行できると、しばしば役に立ちます。この作業用に、
Rustにはいくつかの<em>ループ</em>が用意されています。ループは、本体内のコードを最後まで実行し、
直後にまた最初から処理を開始します。
ループを試してみるのに、<em>loops</em>という名の新プロジェクトを作りましょう。</p>
<!--
Rust has three kinds of loops: `loop`, `while`, and `for`. Let’s try each one.
-->
<p>Rustには3種類のループが存在します: <code>loop</code>と<code>while</code>と<code>for</code>です。それぞれ試してみましょう。</p>
<!--
#### Repeating Code with `loop`
-->
<h4 id="loopでコードを繰り返す"><a class="header" href="#loopでコードを繰り返す"><code>loop</code>でコードを繰り返す</a></h4>
<!--
The `loop` keyword tells Rust to execute a block of code over and over again
forever or until you explicitly tell it to stop.
-->
<p><code>loop</code>キーワードを使用すると、同じコードを何回も何回も永遠に、明示的にやめさせるまで実行します。</p>
<!--
As an example, change the *src/main.rs* file in your *loops* directory to look
like this:
-->
<p>例として、<em>loops</em>ディレクトリの<em>src/main.rs</em>ファイルを以下のような感じに書き換えてください:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);   // また
    }
}
</code></pre>
<!--
When we run this program, we’ll see `again!` printed over and over continuously
until we stop the program manually. Most terminals support a keyboard shortcut,
<span class="keystroke">ctrl-c</span>, to halt a program that is stuck in a
continual loop. Give it a try:
-->
<p>このプログラムを実行すると、プログラムを手動で止めるまで、何度も何度も続けて<code>again!</code>と出力するでしょう。
ほとんどの端末で<span class="keystroke">ctrl-c</span>というショートカットが使え、
永久ループに囚われてしまったプログラムを終了させられます。試しにやってみましょう:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<!--
The symbol `^C` represents where you pressed <span class="keystroke">ctrl-c
</span>. You may or may not see the word `again!` printed after the `^C`,
depending on where the code was in the loop when it received the halt signal.
-->
<p><code>^C</code>という記号が出た場所が、<span class="keystroke">ctrl-c</span>を押した場所です。<code>^C</code>の後には<code>again!</code>と表示されたり、
されなかったりします。ストップシグナルをコードが受け取った時にループのどこにいたかによります。</p>
<!--
Fortunately, Rust provides another, more reliable way to break out of a loop.
You can place the `break` keyword within the loop to tell the program when to
stop executing the loop. Recall that we did this in the guessing game in the
“Quitting After a Correct Guess” section of Chapter 2 to exit the program when
the user won the game by guessing the correct number.
-->
<p>幸いなことに、Rustにはループを抜け出す別のより信頼できる手段があります。
ループ内に<code>break</code>キーワードを配置することで、プログラムに実行を終了すべきタイミングを教えることができます。
第2章の「正しい予想をした後に終了する」節の数当てゲーム内でこれをして、ユーザが予想を的中させ、
ゲームに勝った時にプログラムを終了させたことを思い出してください。</p>
<!--
We also used `continue` in the guessing game, which in a loop tells the program
to skip over any remaining code in this iteration of the loop and go to the
next iteration.
-->
<p>数当てゲームで<code>continue</code>を使用しました。<code>continue</code>はループの中で残っているコードをスキップして次のループに移るためのものです。</p>
<!--
If you have loops within loops, `break` and `continue` apply to the innermost
loop at that point. You can optionally specify a *loop label* on a loop that we
can then use with `break` or `continue` to specify that those keywords apply to
the labeled loop instead of the innermost loop. Here’s an example with two
nested loops:
-->
<p>ループ内にループがある場合、<code>break</code>と<code>continue</code>は最も内側のループに適用されます。
<em>ループラベル</em>を使用することで、<code>break</code>や<code>continue</code>が適用されるループを指定することができます。
以下に例を示します。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!(&quot;count = {}&quot;, count);
        let mut remaining = 10;

        loop {
            println!(&quot;remaining = {}&quot;, remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(&quot;End count = {}&quot;, count);
}
</code></pre></pre>
<!--
The outer loop has the label `'counting_up`, and it will count up from 0 to 2.
The inner loop without a label counts down from 10 to 9. The first `break` that
doesn’t specify a label will exit the inner loop only. The `break
'counting_up;` statement will exit the outer loop. This code prints:
-->
<p>外側のループには<code>'counting_up</code>というラベルがついていて、0から2まで数え上げます。
内側のラベルのないループは10から9までカウントダウンします。最初のラベルの無い<code>break</code>は内側のループを終了させます。
<code>break 'counting_up;</code>は外側のループを終了させます。
このコードは以下のような出力をします。</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/loops`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
<!--
#### Conditional Loops with `while`
-->
<h4 id="whileで条件付きループ"><a class="header" href="#whileで条件付きループ"><code>while</code>で条件付きループ</a></h4>
<!--
It’s often useful for a program to evaluate a condition within a loop. While
the condition is true, the loop runs. When the condition ceases to be true, the
program calls `break`, stopping the loop. This loop type could be implemented
using a combination of `loop`, `if`, `else`, and `break`; you could try that
now in a program, if you’d like.
-->
<p>プログラムにとってループ内で条件式を評価できると、有益なことがしばしばあります。条件が真の間、
ループが走るわけです。条件が真でなくなった時にプログラムは<code>break</code>を呼び出し、ループを終了します。
このタイプのループは、<code>loop</code>、<code>if</code>、<code>else</code>、<code>break</code>を組み合わせることでも実装できます;
お望みなら、プログラムで今、試してみるのもいいでしょう。</p>
<!--
However, this pattern is so common that Rust has a built-in language construct
for it, called a `while` loop. Listing 3-3 uses `while`: the program loops
three times, counting down each time, and then, after the loop, it prints
another message and exits:
-->
<p>しかし、このパターンは頻出するので、Rustにはそれ用の文法要素が用意されていて、<code>while</code>ループと呼ばれます。
リスト3-3は、<code>while</code>を使用しています: プログラムは3回ループし、それぞれカウントダウンします。
それから、ループ後に別のメッセージを表示して終了します:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number -= 1;
    }

    // 発射！
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-3: Using a `while` loop to run code while a
condition holds true</span>
-->
<p><span class="caption">リスト3-3: 条件が真の間、コードを走らせる<code>while</code>ループを使用する</span></p>
<!--
This construct eliminates a lot of nesting that would be necessary if you used
`loop`, `if`, `else`, and `break`, and it’s clearer. While a condition holds
true, the code runs; otherwise, it exits the loop.
-->
<p>この文法要素により、<code>loop</code>、<code>if</code>、<code>else</code>、<code>break</code>を使った時に必要になるネストがなくなり、
より明確になります。条件が真の間、コードは実行されます; そうでなければ、ループを抜けます.</p>
<!--
#### Looping Through a Collection with `for`
-->
<h4 id="forでコレクションを覗き見る"><a class="header" href="#forでコレクションを覗き見る"><code>for</code>でコレクションを覗き見る</a></h4>
<!--
You could use the `while` construct to loop over the elements of a collection,
such as an array. For example, let's look at Listing 3-4.
-->
<p><code>while</code>要素を使って配列などのコレクションの要素を覗き見ることができます。例えば、リスト3-4を見ましょう。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        // 値は{}です
        println!(&quot;the value is: {}&quot;, a[index]);

        index += 1;
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-4: Looping through each element of a collection
using a `while` loop</span>
-->
<p><span class="caption">リスト3-4: <code>while</code>ループでコレクションの各要素を覗き見る</span></p>
<!--
Here, the code counts up through the elements in the array. It starts at index
`0`, and then loops until it reaches the final index in the array (that is,
when `index < 5` is no longer true). Running this code will print every element
in the array:
-->
<p>ここで、コードは配列の要素を順番にカウントアップして覗いています。番号0から始まり、
配列の最終番号に到達するまでループします(つまり、<code>index &lt; 5</code>が真でなくなる時です)。
このコードを走らせると、配列内の全要素が出力されます:</p>
<pre><code class="language-console">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32s
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<!--
All five array values appear in the terminal, as expected. Even though `index`
will reach a value of `5` at some point, the loop stops executing before trying
to fetch a sixth value from the array.
-->
<p>予想通り、配列の5つの要素が全てターミナルに出力されています。<code>index</code>変数の値はどこかで<code>5</code>という値になるものの、
配列から6番目の値を拾おうとする前にループは実行を終了します。</p>
<!--
But this approach is error prone; we could cause the program to panic if the
index length is incorrect. It’s also slow, because the compiler adds runtime
code to perform the conditional check on every element on every iteration
through the loop.
-->
<p>しかし、このアプローチは間違いが発生しやすいです; 添え字の長さが間違っていれば、
プログラムはパニックしてしまいます。また遅いです。
コンパイラが実行時にループの各回ごとに境界値チェックを行うようなコードを追加するからです。</p>
<!--
As a more efficient alternative, you can use a `for` loop and execute some code
for each item in a collection. A `for` loop looks like this code in Listing 3-5.
-->
<p>より効率的な対立案として、<code>for</code>ループを使ってコレクションの各アイテムに対してコードを実行することができます。
<code>for</code>ループはリスト3-5のこんな見た目です。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 3-5: Looping through each element of a collection
using a `for` loop</span>
-->
<p><span class="caption">リスト3-5: <code>for</code>ループを使ってコレクションの各要素を覗き見る</span></p>
<!--
When we run this code, we’ll see the same output as in Listing 3-4. More
importantly, we’ve now increased the safety of the code and eliminated the
chance of bugs that might result from going beyond the end of the array or not
going far enough and missing some items.
-->
<p>このコードを走らせたら、リスト3-4と同じ出力が得られるでしょう。より重要なのは、
コードの安全性を向上させ、配列の終端を超えてアクセスしたり、
終端に届く前にループを終えてアイテムを見逃してしまったりするバグの可能性を完全に排除したことです。</p>
<!--
For example, in the code in Listing 3-4, if you removed an item from the `a`
array but forgot to update the condition to `while index < 4`, the code would
panic. Using the `for` loop, you don’t need to remember to change any other
code if you changed the number of values in the array.
-->
<p>例えば、リスト3-4のコードで、<code>a</code>配列からアイテムを1つ削除したのに、条件式を<code>while index &lt; 4</code>にするのを忘れていたら、
コードはパニックします。<code>for</code>ループを使っていれば、配列の要素数を変えても、
他のコードをいじることを覚えておく必要はなくなるわけです。</p>
<!--
The safety and conciseness of `for` loops make them the most commonly used loop
construct in Rust. Even in situations in which you want to run some code a
certain number of times, as in the countdown example that used a `while` loop
in Listing 3-3, most Rustaceans would use a `for` loop. The way to do that
would be to use a `Range`, which is a type provided by the standard library
that generates all numbers in sequence starting from one number and ending
before another number.
-->
<p><code>for</code>ループのこの安全性と簡潔性により、Rustで使用頻度の最も高いループになっています。
リスト3-3で<code>while</code>ループを使ったカウントダウンサンプルのように、一定の回数、同じコードを実行したいような状況であっても、
多くのRustaceanは、<code>for</code>ループを使うでしょう。どうやってやるかといえば、
<code>Range</code>型を使うのです。Range型は、標準ライブラリで提供される片方の数字から始まって、
もう片方の数字未満の数値を順番に生成する型です。</p>
<!--
Here’s what the countdown would look like using a `for` loop and another method
we’ve not yet talked about, `rev`, to reverse the range:
-->
<p><code>for</code>ループと、まだ話していない別のメソッド<code>rev</code>を使って範囲を逆順にしたカウントダウンはこうなります:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<!--
This code is a bit nicer, isn’t it?
-->
<p>こちらのコードの方が少しいいでしょう？</p>
<!--
## Summary
-->
<h2 id="まとめ-2"><a class="header" href="#まとめ-2">まとめ</a></h2>
<!--
You made it! That was a sizable chapter: you learned about variables, scalar
and compound data types, functions, comments, `if` expressions, and loops! If
you want to practice with the concepts discussed in this chapter, try building
programs to do the following:
-->
<p>やりましたね！結構長い章でした: 変数、スカラー値と複合データ型、関数、コメント、<code>if</code>式、そして、ループについて学びました！
この章で議論した概念について経験を積みたいのであれば、以下のことをするプログラムを組んでみてください:</p>
<!--
* Convert temperatures between Fahrenheit and Celsius.
* Generate the nth Fibonacci number.
* Print the lyrics to the Christmas carol “The Twelve Days of Christmas,”
taking advantage of the repetition in the song.
-->
<ul>
<li>温度を華氏と摂氏で変換する。</li>
<li>フィボナッチ数列のn番目を生成する。</li>
<li>クリスマスキャロルの定番、&quot;The Twelve Days of Christmas&quot;の歌詞を、
曲の反復性を利用して出力する。</li>
</ul>
<!--
When you’re ready to move on, we’ll talk about a concept in Rust that *doesn’t*
commonly exist in other programming languages: ownership.
-->
<p>次に進む準備ができたら、他の言語にはあまり存在<em>しない</em>Rustの概念について話しましょう: 所有権です。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Understanding Ownership
-->
<h1 id="所有権を理解する"><a class="header" href="#所有権を理解する">所有権を理解する</a></h1>
<!--
Ownership is Rust’s most unique feature, and it enables Rust to make memory
safety guarantees without needing a garbage collector. Therefore, it’s
important to understand how ownership works in Rust. In this chapter we’ll
talk about ownership as well as several related features: borrowing, slices,
and how Rust lays data out in memory.
-->
<p>所有権はRustの最もユニークな機能であり、これのおかげでガベージコレクタなしで安全性担保を行うことができるのです。
故に、Rustにおいて、所有権がどう動作するのかを理解するのは重要です。この章では、所有権以外にも、関連する機能を
いくつか話していきます: 借用、スライス、そして、コンパイラがデータをメモリにどう配置するかです。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## What Is Ownership?
-->
<h2 id="所有権とは"><a class="header" href="#所有権とは">所有権とは？</a></h2>
<!--
Rust’s central feature is *ownership*. Although the feature is straightforward
to explain, it has deep implications for the rest of the language.
-->
<p>Rustの中心的な機能は、<em>所有権</em>です。この機能は、説明するのは簡単なのですが、言語の残りの機能全てにかかるほど
深い裏の意味を含んでいるのです。</p>
<!--
All programs have to manage the way they use a computer’s memory while running.
Some languages have garbage collection that constantly looks for no longer used
memory as the program runs; in other languages, the programmer must explicitly
allocate and free the memory. Rust uses a third approach: memory is managed
through a system of ownership with a set of rules that the compiler checks at
compile time. None of the ownership features slow down your proram while it's
running.
-->
<p>全てのプログラムは、実行中にコンピュータのメモリの使用方法を管理する必要があります。プログラムが動作するにつれて、
定期的に使用されていないメモリを検索するガベージコレクションを持つ言語もありますが、他の言語では、
プログラマが明示的にメモリを確保したり、解放したりしなければなりません。Rustでは第3の選択肢を取っています: 
メモリは、コンパイラがコンパイル時にチェックする一定の規則とともに所有権システムを通じて管理されています。
どの所有権機能も、実行中にプログラムの動作を遅くすることはありません。</p>
<!--
Because ownership is a new concept for many programmers, it does take some time
to get used to. The good news is that the more experienced you become with Rust
and the rules of the ownership system, the more you’ll be able to naturally
develop code that is safe and efficient. Keep at it!
-->
<p>所有権は多くのプログラマにとって新しい概念なので、慣れるまでに時間がかかります。
嬉しいことに、Rustと、所有権システムの規則の経験を積むと、より自然に安全かつ効率的なコードを構築できるようになります。
その調子でいきましょう！</p>
<!--
When you understand ownership, you’ll have a solid foundation for understanding
the features that make Rust unique. In this chapter, you’ll learn ownership by
working through some examples that focus on a very common data structure:
strings.
-->
<p>所有権を理解した時、Rustを際立たせる機能の理解に対する強固な礎を得ることになるでしょう。この章では、
非常に一般的なデータ構造に着目した例を取り扱うことで所有権を学んでいきます: 文字列です。</p>
<!--
PROD: START BOX
-->
<!--
引用符付きの行は、日本語と英語を交互に書くとmdbookに正しく解析してもらえないので、英語、日本語の順にまとめて配置します
### The Stack and the Heap
-->
<!--
> In many programming languages, you don’t have to think about the stack and
> the heap very often. But in a systems programming language like Rust, whether
> a value is on the stack or the heap has more of an effect on how the language
> behaves and why you have to make certain decisions. Parts of ownership will
> be described in relation to the stack and the heap later in this chapter, so
> here is a brief explanation in preparation.
-->
<!--
> Both the stack and the heap are parts of memory that is available to your code
> to use at runtime, but they are structured in different ways. The stack stores
> values in the order it gets them and removes the values in the opposite order.
> This is referred to as *last in, first out*. Think of a stack of plates: when
> you add more plates, you put them on top of the pile, and when you need a
> plate, you take one off the top. Adding or removing plates from the middle or
> bottom wouldn’t work as well! Adding data is called *pushing onto the stack*,
> and removing data is called *popping off the stack*.
-->
<!--
> The stack is fast because of the way it accesses the data: it never has to
> search for a place to put new data or a place to get data from because that
> place is always the top. Another property that makes the stack fast is that all
> data on the stack must take up a known, fixed size.
-->
<!--
> Data with a size unknown at compile time or a size that might change can be
> stored on the heap instead. The heap is less organized: when you put data on
> the heap, you ask for some amount of space. The operating system finds an
> empty spot somewhere in the heap that is big enough, marks it as being in
> use, and returns a *pointer*, which is the address of that location. This
> process is called *allocating on the heap*, sometimes abbreviated as just
> “allocating.” Pushing values onto the stack is not considered allocating.
> Because the pointer is a known, fixed size, you can store the pointer on the
> stack, but when you want the actual data, you have to follow the pointer.
-->
<!--
> Think of being seated at a restaurant. When you enter, you state the number of
> people in your group, and the staff finds an empty table that fits everyone and
> leads you there. If someone in your group comes late, they can ask where
> you've been seated to find you.
-->
<!--
> Accessing data in the heap is slower than accessing data on the stack because
> you have to follow a pointer to get there. Contemporary processors are faster
> if they jump around less in memory. Continuing the analogy, consider a server
> at a restaurant taking orders from many tables. It’s most efficient to get
> all the orders at one table before moving on to the next table. Taking an
> order from table A, then an order from table B, then one from A again, and
> then one from B again would be a much slower process. By the same token, a
> processor can do its job better if it works on data that’s close to other
> data (as it is on the stack) rather than farther away (as it can be on the
> heap). Allocating a large amount of space on the heap can also take time.
-->
<!--
> When your code calls a function, the values passed into the function
> (including, potentially, pointers to data on the heap) and the function’s
> local variables get pushed onto the stack. When the function is over, those
> values get popped off the stack.
-->
<!--
> Keeping track of what parts of code are using what data on the heap,
> minimizing the amount of duplicate data on the heap, and cleaning up unused
> data on the heap so we don’t run out of space are all problems that ownership
> addresses. Once you understand ownership, you won’t need to think about the
> stack and the heap very often, but knowing that managing heap data is why
> ownership exists can help explain why it works the way it does.
-->
<blockquote>
<h3 id="スタックとヒープ"><a class="header" href="#スタックとヒープ">スタックとヒープ</a></h3>
<p>多くのプログラミング言語において、スタックとヒープについて考える機会はそう多くないでしょう。
しかし、Rustのようなシステムプログラミング言語においては、値がスタックに積まれるかヒープに置かれるかは、
言語の振る舞い方や、特定の決断を下す理由などに影響以上のものを与えるのです。
この章の後半でスタックとヒープを交えて所有権の一部が解説されるので、ここでちょっと予行演習をしておきましょう。</p>
<p>スタックもヒープも、実行時にコードが使用できるメモリの一部になりますが、異なる手段で構成されています。
スタックは、得た順番に値を並べ、逆の順で値を取り除いていきます。これは、
<em>last in, first out</em>(<code>訳注</code>: あえて日本語にするなら、「最後に入れたものが最初に出てくる」といったところでしょうか)と呼ばれます。
お皿の山を思い浮かべてください: お皿を追加する時には、山の一番上に置き、お皿が必要になったら、一番上から1枚を取り去りますよね。
途中や一番下に追加したり、取り除いたりすることもできません。データを追加することは、
<em>スタックにpushする</em>といい、データを取り除くことは、<em>スタックからpopする</em>と表現します(<code>訳注</code>:
日本語では単純に英語をそのまま活用してプッシュ、ポップと表現するでしょう)。</p>
<p>データへのアクセス方法のおかげで、スタックは高速です: 新しいデータを置いたり、
データを取得する場所を探す必要が絶対にないわけです。というのも、その場所は常に一番上だからですね。
スタックを高速にする特性は他にもあり、それはスタック上のデータは全て既知の固定サイズでなければならないということです。</p>
<p>コンパイル時にサイズがわからなかったり、サイズが可変のデータについては、代わりにヒープに格納することができます。
ヒープは、もっとごちゃごちゃしています: ヒープにデータを置く時、あるサイズのスペースを求めます。
OSはヒープ上に十分な大きさの空の領域を見つけ、使用中にし、<em>ポインタ</em>を返します。ポインタとは、その場所へのアドレスです。
この過程は、<em>ヒープに領域を確保する(allocating on the heap)<em>と呼ばれ、時としてそのフレーズを単に</em>allocateする</em>などと省略したりします。
(<code>訳注</code>: こちらもこなれた日本語訳はないでしょう。allocateは「メモリを確保する」と訳したいところですが)
スタックに値を積むことは、メモリ確保とは考えられません。ポインタは、既知の固定サイズなので、
スタックに保管することができますが、実データが必要になったら、ポインタを追いかける必要があります。</p>
<p>レストランで席を確保することを考えましょう。入店したら、グループの人数を告げ、
店員が全員座れる空いている席を探し、そこまで誘導します。もしグループの誰かが遅れて来るのなら、
着いた席の場所を尋ねてあなたを発見することができます。</p>
<p>ヒープへのデータアクセスは、スタックのデータへのアクセスよりも低速です。
ポインタを追って目的の場所に到達しなければならないからです。現代のプロセッサは、メモリをあちこち行き来しなければ、
より速くなります。似た例えを続けましょう。レストランで多くのテーブルから注文を受ける給仕人を考えましょう。最も効率的なのは、
次のテーブルに移らずに、一つのテーブルで全部の注文を受け付けてしまうことです。テーブルAで注文を受け、
それからテーブルBの注文、さらにまたA、それからまたBと渡り歩くのは、かなり低速な過程になってしまうでしょう。
同じ意味で、プロセッサは、
データが隔離されている(ヒープではそうなっている可能性がある)よりも近くにある(スタックではこうなる)ほうが、
仕事をうまくこなせるのです。ヒープに大きな領域を確保する行為も時間がかかることがあります。</p>
<p>コードが関数を呼び出すと、関数に渡された値(ヒープのデータへのポインタも含まれる可能性あり)と、
関数のローカル変数がスタックに載ります。関数の実行が終了すると、それらの値はスタックから取り除かれます。</p>
<p>どの部分のコードがどのヒープ上のデータを使用しているか把握すること、ヒープ上の重複するデータを最小化すること、
メモリ不足にならないようにヒープ上の未使用のデータを掃除することは全て、所有権が解決する問題です。
一度所有権を理解したら、あまり頻繁にスタックとヒープに関して考える必要はなくなるでしょうが、
ヒープデータを管理することが所有権の存在する理由だと知っていると、所有権がありのままで動作する理由を
説明するのに役立つこともあります。</p>
</blockquote>
<!--
PROD: END BOX
-->
<!--
### Ownership Rules
-->
<h3 id="所有権規則"><a class="header" href="#所有権規則">所有権規則</a></h3>
<!--
First, let’s take a look at the ownership rules. Keep these rules in mind as we
work through the examples that illustrate them:
-->
<p>まず、所有権のルールについて見ていきましょう。
この規則を具体化する例を扱っていく間もこれらのルールを肝に銘じておいてください:</p>
<!--
* Each value in Rust has a variable that’s called its *owner*.
* There can only be one owner at a time.
* When the owner goes out of scope, the value will be dropped.
-->
<ul>
<li>Rustの各値は、<em>所有者</em>と呼ばれる変数と対応している。</li>
<li>いかなる時も所有者は一つである。</li>
<li>所有者がスコープから外れたら、値は破棄される。</li>
</ul>
<!--
### Variable Scope
-->
<h3 id="変数スコープ"><a class="header" href="#変数スコープ">変数スコープ</a></h3>
<!--
We’ve walked through an example of a Rust program already in Chapter 2. Now
that we’re past basic syntax, we won’t include all the `fn main() {` code in
examples, so if you’re following along, you’ll have to put the following
examples inside a `main` function manually. As a result, our examples will be a
bit more concise, letting us focus on the actual details rather than
boilerplate code.
-->
<p>第2章で、Rustプログラムの例はすでに見ています。もう基本的な記法は通り過ぎたので、
<code>fn main() {</code>というコードはもう例に含みません。従って、例をなぞっているなら、
これからの例は<code>main</code>関数に手動で入れ込まなければいけなくなるでしょう。結果的に、例は少々簡潔になり、
定型コードよりも具体的な詳細に集中しやすくなります。</p>
<!--
As a first example of ownership, we’ll look at the *scope* of some variables. A
scope is the range within a program for which an item is valid. Let’s say we
have a variable that looks like this:
-->
<p>所有権の最初の例として、何らかの変数の<em>スコープ</em>について見ていきましょう。スコープとは、
要素が有効になるプログラム内の範囲のことです。以下のような変数があるとしましょう:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The variable `s` refers to a string literal, where the value of the string is
hardcoded into the text of our program. The variable is valid from the point at
which it’s declared until the end of the current *scope*. Listing 4-1 has
comments annotating where the variable `s` is valid.
-->
<p>変数<code>s</code>は、文字列リテラルを参照し、ここでは、文字列の値はプログラムのテキストとしてハードコードされています。
この変数は、宣言された地点から、現在の<em>スコープ</em>の終わりまで有効になります。リスト4-1には、
変数<code>s</code>が有効な場所に関する注釈がコメントで付記されています。</p>
<!--
```rust
{                      // s is not valid here, it’s not yet declared
let s = "hello";   // s is valid from this point forward
-->
<!--
// do stuff with s
}                      // this scope is now over, and s is no longer valid
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{                      // sは、ここでは有効ではない。まだ宣言されていない
    let s = &quot;hello&quot;;   // sは、ここから有効になる

    // sで作業をする
}                      // このスコープは終わり。もうsは有効ではない
<span class="boring">}
</span></code></pre></pre>
<!-- <span class="caption">Listing 4-1: A variable and the scope in which it is
valid</span> -->
<p><span class="caption">リスト4-1: 変数と有効なスコープ</span></p>
<!--
In other words, there are two important points in time here:
-->
<p>言い換えると、ここまでに重要な点は二つあります:</p>
<!--
* When `s` comes *into scope*, it is valid.
* It remains valid until it goes *out of scope*.
-->
<ul>
<li><code>s</code>が<em>スコープに入る</em>と、有効になる</li>
<li><em>スコープを抜ける</em>まで、有効なまま</li>
</ul>
<!--
At this point, the relationship between scopes and when variables are valid is
similar to other programming languages. Now we’ll build on top of this
understanding by introducing the `String` type.
-->
<p>ここで、スコープと変数が有効になる期間の関係は、他の言語に類似しています。さて、この理解のもとに、
<code>String</code>型を導入して構築していきましょう。</p>
<!--
### The `String` Type
-->
<h3 id="string型"><a class="header" href="#string型"><code>String</code>型</a></h3>
<!--
To illustrate the rules of ownership, we need a data type that is more complex
than the ones we covered in the "Data Types" section of Chapter 3. The types
covered previously are all stored on the stack and popped off the stack when
their scope is over, but we want to look at data that is stored on the heap and
explore how Rust knows when to clean up that data.
-->
<p>所有権の規則を具体化するには、第3章の「データ型」節で講義したものよりも、より複雑なデータ型が必要になります。
以前講義した型は全てスタックに保管され、スコープが終わるとスタックから取り除かれますが、
ヒープに確保されるデータ型を観察して、
コンパイラがどうそのデータを掃除すべきタイミングを把握しているかを掘り下げていきたいと思います。</p>
<!--
We’ll use `String` as the example here and concentrate on the parts of `String`
that relate to ownership. These aspects also apply to other complex data types
provided by the standard library and that you create. We’ll discuss `String` in
more depth in Chapter 8.
-->
<p>ここでは、例として<code>String</code>型を使用し、<code>String</code>型の所有権にまつわる部分に着目しましょう。
また、この観点は、標準ライブラリや自分で生成する他の複雑なデータ型にも適用されます。
<code>String</code>型については、第8章でより深く議論します。</p>
<!--
We’ve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they aren’t suitable for every
situation in which we may want to use text. One reason is that they’re
immutable. Another is that not every string value can be known when we write
our code: for example, what if we want to take user input and store it? For
these situations, Rust has a second string type, `String`. This type is
allocated on the heap and as such is able to store an amount of text that is
unknown to us at compile time. You can create a `String` from a string literal
using the `from` function, like so:
-->
<p>既に文字列リテラルは見かけましたね。文字列リテラルでは、文字列の値はプログラムにハードコードされます。
文字列リテラルは便利ですが、テキストを使いたいかもしれない場面全てに最適なわけではありません。一因は、
文字列リテラルが不変であることに起因します。別の原因は、コードを書く際に、全ての文字列値が判明するわけではないからです:
例えば、ユーザ入力を受け付け、それを保持したいとしたらどうでしょうか？このような場面用に、Rustには、
2種類目の文字列型、<code>String</code>型があります。この型はヒープにメモリを確保するので、
コンパイル時にはサイズが不明なテキストも保持することができるのです。<code>from</code>関数を使用して、
文字列リテラルから<code>String</code>型を生成できます。以下のように:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
The double colon (`::`) is an operator that allows us to namespace this
particular `from` function under the `String` type rather than using some sort
of name like `string_from`. We’ll discuss this syntax more in the “Method
Syntax” section of Chapter 5 and when we talk about namespacing with modules in
"Module Definitions" in Chapter 7.
-->
<p>この二重コロンは、<code>string_from</code>などの名前を使うのではなく、
<code>String</code>型直下の<code>from</code>関数を特定する働きをする演算子です。この記法について詳しくは、
第5章の「メソッド記法」節と、第7章の「モジュール定義」でモジュールを使った名前空間分けについて話をするときに議論します。</p>
<!--
This kind of string *can* be mutated:
-->
<p>この種の文字列は、可変化することが<em>できます</em>:</p>
<!--
```rust
let mut s = String::from("hello");
-->
<!--
s.push_str(", world!"); // push_str() appends a literal to a String
-->
<!--
println!("{}", s); // This will print `hello, world!`
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

s.push_str(&quot;, world!&quot;); // push_str()関数は、リテラルをStringに付け加える

println!(&quot;{}&quot;, s); // これは`hello, world!`と出力する
<span class="boring">}
</span></code></pre></pre>
<!--
So, what’s the difference here? Why can `String` be mutated but literals
cannot? The difference is how these two types deal with memory.
-->
<p>では、ここでの違いは何でしょうか？なぜ、<code>String</code>型は可変化できるのに、リテラルはできないのでしょうか？
違いは、これら二つの型がメモリを扱う方法にあります。</p>
<!--
### Memory and Allocation
-->
<h3 id="メモリと確保"><a class="header" href="#メモリと確保">メモリと確保</a></h3>
<!--
In the case of a string literal, we know the contents at compile time, so the
text is hardcoded directly into the final executable. This is why string
literals are fast and efficient. But these properties only come from the string
literal's immutability. Unfortunately, we can’t put a blob of memory into the
binary for each piece of text whose size is unknown at compile time and whose
size might change while running the program.
-->
<p>文字列リテラルの場合、中身はコンパイル時に判明しているので、テキストは最終的なバイナリファイルに直接ハードコードされます。
このため、文字列リテラルは、高速で効率的になるのです。しかし、これらの特性は、
その文字列リテラルの不変性にのみ端を発するものです。残念なことに、コンパイル時にサイズが不明だったり、
プログラム実行に合わせてサイズが可変なテキスト片用に一塊のメモリをバイナリに確保しておくことは不可能です。</p>
<!--
With the `String` type, in order to support a mutable, growable piece of text,
we need to allocate an amount of memory on the heap, unknown at compile time,
to hold the contents. This means:
-->
<p><code>String</code>型では、可変かつ伸長可能なテキスト破片をサポートするために、コンパイル時には不明な量のメモリを
ヒープに確保して内容を保持します。つまり:</p>
<!--
* The memory must be requested from the operating system at runtime.
* We need a way of returning this memory to the operating system when we’re
done with our `String`.
-->
<ul>
<li>メモリは、実行時にOSに要求される。</li>
<li><code>String</code>型を使用し終わったら、OSにこのメモリを返還する方法が必要である。</li>
</ul>
<!--
That first part is done by us: when we call `String::from`, its implementation
requests the memory it needs. This is pretty much universal in programming
languages.
-->
<p>この最初の部分は、既にしています: <code>String::from</code>関数を呼んだら、その実装が必要なメモリを要求するのです。
これは、プログラミング言語において、極めて普遍的です。</p>
<!--
However, the second part is different. In languages with a *garbage collector
(GC)*, the GC keeps track and cleans up memory that isn’t being used anymore,
and we don’t need to think about it. Without a GC, it’s our responsibility to
identify when memory is no longer being used and call code to explicitly return
it, just as we did to request it. Doing this correctly has historically been a
difficult programming problem. If we forget, we’ll waste memory. If we do it
too early, we’ll have an invalid variable. If we do it twice, that’s a bug too.
We need to pair exactly one `allocate` with exactly one `free`.
-->
<!--
かっこがあると、*が機能しないようなので、(GC)の部分には指定していません
-->
<p>しかしながら、2番目の部分は異なります。<em>ガベージコレクタ</em>(GC)付きの言語では、GCがこれ以上、
使用されないメモリを検知して片付けるため、プログラマは、そのことを考慮する必要はありません。
GCがないなら、メモリがもう使用されないことを見計らって、明示的に返還するコードを呼び出すのは、
プログラマの責任になります。ちょうど要求の際にしたようにですね。これを正確にすることは、
歴史的にも難しいプログラミング問題の一つであり続けています。もし、忘れていたら、メモリを無駄にします。
タイミングが早すぎたら、無効な変数を作ってしまいます。2回解放してしまっても、バグになるわけです。
<code>allocate</code>と<code>free</code>は完璧に1対1対応にしなければならないのです。</p>
<!--
Rust takes a different path: the memory is automatically returned once the
variable that owns it goes out of scope. Here’s a version of our scope example
from Listing 4-1 using a `String` instead of a string literal:
-->
<p>Rustは、異なる道を歩んでいます: ひとたび、メモリを所有している変数がスコープを抜けたら、
メモリは自動的に返還されます。こちらの例は、
リスト4-1のスコープ例を文字列リテラルから<code>String</code>型を使うものに変更したバージョンになります:</p>
<!--
```rust
{
let s = String::from("hello"); // s is valid from this point forward
-->
<!--
// do stuff with s
}                                 // this scope is now over, and s is no
// longer valid
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;hello&quot;); // sはここから有効になる

    // sで作業をする
}                                  // このスコープはここでおしまい。sは
                                   // もう有効ではない
<span class="boring">}
</span></code></pre></pre>
<!--
There is a natural point at which we can return the memory our `String` needs
to the operating system: when `s` goes out of scope. When a variable goes out
of scope, Rust calls a special function for us. This function is called `drop`,
and it’s where the author of `String` can put the code to return the memory.
Rust calls `drop` automatically at the closing curly bracket.
-->
<p><code>String</code>型が必要とするメモリをOSに返還することが自然な地点があります: <code>s</code>変数がスコープを抜ける時です。
変数がスコープを抜ける時、Rustは特別な関数を呼んでくれます。この関数は、<code>drop</code>と呼ばれ、
ここに<code>String</code>型の書き手はメモリを返還するコードを配置することができます。Rustは、閉じ波括弧で自動的に<code>drop</code>関数を呼び出します。</p>
<!--
Note: In C++, this pattern of deallocating resources at the end of an item's
lifetime is sometimes called *Resource Acquisition Is Initialization (RAII)*.
The `drop` function in Rust will be familiar to you if you’ve used RAII
patterns.
-->
<blockquote>
<p>注釈: C++では、要素の生存期間の終了地点でリソースを解放するこのパターンを時に、
<em>RAII</em>(Resource Aquisition Is Initialization: リソースの獲得は、初期化である)と呼んだりします。
Rustの<code>drop</code>関数は、あなたがRAIIパターンを使ったことがあれば、馴染み深いものでしょう。</p>
</blockquote>
<!--
This pattern has a profound impact on the way Rust code is written. It may seem
simple right now, but the behavior of code can be unexpected in more
complicated situations when we want to have multiple variables use the data
we’ve allocated on the heap. Let’s explore some of those situations now.
-->
<p>このパターンは、Rustコードの書かれ方に甚大な影響をもたらします。現状は簡単そうに見えるかもしれませんが、
ヒープ上に確保されたデータを複数の変数に使用させるようなもっと複雑な場面では、コードの振る舞いは、
予期しないものになる可能性もあります。これから、そのような場面を掘り下げてみましょう。</p>
<!--
#### Ways Variables and Data Interact: Move
-->
<h4 id="変数とデータの相互作用法-ムーブ"><a class="header" href="#変数とデータの相互作用法-ムーブ">変数とデータの相互作用法: ムーブ</a></h4>
<!--
Multiple variables can interact with the same data in different ways in Rust.
Let’s look at an example using an integer in Listing 4-2.
-->
<p>Rustにおいては、複数の変数が同じデータに対して異なる手段で相互作用することができます。
整数を使用したリスト4-2の例を見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<!-- <span class="caption">Listing 4-2: Assigning the integer value of variable `x`
to `y`</span> -->
<p><span class="caption">リスト4-2: 変数<code>x</code>の整数値を<code>y</code>に代入する</span></p>
<!--
We can probably guess what this is doing: “bind the value `5` to `x`; then make
a copy of the value in `x` and bind it to `y`.” We now have two variables, `x`
and `y`, and both equal `5`. This is indeed what is happening, because integers
are simple values with a known, fixed size, and these two `5` values are pushed
onto the stack.
-->
<p>もしかしたら、何をしているのか予想することができるでしょう: 
「値<code>5</code>を<code>x</code>に束縛する; それから<code>x</code>の値をコピーして<code>y</code>に束縛する。」これで、
二つの変数(<code>x</code>と<code>y</code>)が存在し、両方、値は<code>5</code>になりました。これは確かに起こっている現象を説明しています。
なぜなら、整数は既知の固定サイズの単純な値で、これら二つの<code>5</code>という値は、スタックに積まれるからです。</p>
<!--
Now let’s look at the `String` version:
-->
<p>では、<code>String</code>バージョンを見ていきましょう:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<!--
This looks very similar to the previous code, so we might assume that the way
it works would be the same: that is, the second line would make a copy of the
value in `s1` and bind it to `s2`. But this isn’t quite what happens.
-->
<p>このコードは先ほどのコードに酷似していますので、動作方法も同じだと思い込んでしまうかもしれません:
要するに、2行目で<code>s1</code>の値をコピーし、<code>s2</code>に束縛するということです。ところが、
これは全く起こることを言い当てていません。</p>
<!--
Take a look at Figure 4-1 to see what is happening to `String` under the
covers. A `String` is made up of three parts, shown on the left: a pointer to
the memory that holds the contents of the string, a length, and a capacity.
This group of data is stored on the stack. On the right is the memory on the
heap that holds the contents.
-->
<p>図4-1を見て、ベールの下で<code>String</code>に何が起きているかを確かめてください。
<code>String</code>型は、左側に示されているように、3つの部品でできています: 
文字列の中身を保持するメモリへのポインタと長さ、そして、許容量です。この種のデータは、スタックに保持されます。
右側には、中身を保持したヒープ上のメモリがあります。 </p>
<!--
<img alt="String in memory" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
-->
<img alt="メモリ上の文字列" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<!-- <span class="caption">Figure 4-1: Representation in memory of a `String`
holding the value `"hello"` bound to `s1`</span> -->
<p><span class="caption">図4-1: <code>s1</code>に束縛された<code>&quot;hello&quot;</code>という値を保持する<code>String</code>のメモリ上の表現</span></p>
<!--
The length is how much memory, in bytes, the contents of the `String` is
currently using. The capacity is the total amount of memory, in bytes, that the
`String` has received from the operating system. The difference between length
and capacity matters, but not in this context, so for now, it’s fine to ignore
the capacity.
-->
<p>長さは、<code>String</code>型の中身が現在使用しているメモリ量をバイトで表したものです。許容量は、
<code>String</code>型がOSから受け取った全メモリ量をバイトで表したものです。長さと許容量の違いは問題になることですが、
この文脈では違うので、とりあえずは、許容量を無視しても構わないでしょう。 </p>
<!--
When we assign `s1` to `s2`, the `String` data is copied, meaning we copy the
pointer, the length, and the capacity that are on the stack. We do not copy the
data on the heap that the pointer refers to. In other words, the data
representation in memory looks like Figure 4-2.
-->
<p><code>s1</code>を<code>s2</code>に代入すると、<code>String</code>型のデータがコピーされます。つまり、スタックにあるポインタ、長さ、
許容量をコピーするということです。ポインタが指すヒープ上のデータはコピーしません。言い換えると、
メモリ上のデータ表現は図4-2のようになるということです。</p>
<!--
<img alt="s1 and s2 pointing to the same value" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
-->
<img alt="同じ値を指すs1とs2" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<!-- <span class="caption">Figure 4-2: Representation in memory of the variable `s2`
that has a copy of the pointer, length, and capacity of `s1`</span> -->
<p><span class="caption">図4-2: <code>s1</code>のポインタ、長さ、許容量のコピーを保持する変数<code>s2</code>のメモリ上での表現</span></p>
<!--
The representation does *not* look like Figure 4-3, which is what memory would
look like if Rust instead copied the heap data as well. If Rust did this, the
operation `s2 = s1` could be very expensive in terms of runtime performance if
the data on the heap were large.
-->
<p>メモリ上の表現は、図4-3のようにはなり<em>ません</em>。これは、
Rustが代わりにヒープデータもコピーするという選択をしていた場合のメモリ表現ですね。Rustがこれをしていたら、
ヒープ上のデータが大きい時に<code>s2 = s1</code>という処理の実行時性能がとても悪くなっていた可能性があるでしょう。</p>
<!--
<img alt="s1 and s2 to two places" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
-->
<img alt="2箇所へのs1とs2" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<!-- <span class="caption">Figure 4-3: Another possibility of what `s2 = s1` might
do if Rust copied the heap data as well</span> -->
<p><span class="caption">図4-3: Rustがヒープデータもコピーしていた場合に<code>s2 = s1</code>という処理が行なった可能性のあること</span></p>
<!--
Earlier, we said that when a variable goes out of scope, Rust automatically
calls the `drop` function and cleans up the heap memory for that variable. But
Figure 4-2 shows both data pointers pointing to the same location. This is a
problem: when `s2` and `s1` go out of scope, they will both try to free the
same memory. This is known as a *double free* error and is one of the memory
safety bugs we mentioned previously. Freeing memory twice can lead to memory
corruption, which can potentially lead to security vulnerabilities.
-->
<p>先ほど、変数がスコープを抜けたら、Rustは自動的に<code>drop</code>関数を呼び出し、
その変数が使っていたヒープメモリを片付けると述べました。しかし、図4-2は、
両方のデータポインタが同じ場所を指していることを示しています。これは問題です: <code>s2</code>と<code>s1</code>がスコープを抜けたら、
両方とも同じメモリを解放しようとします。これは<em>二重解放</em>エラーとして知られ、以前触れたメモリ安全性上のバグの一つになります。
メモリを2回解放することは、memory corruption (<code>訳注</code>: メモリの崩壊。意図せぬメモリの書き換え) につながり、
セキュリティ上の脆弱性を生む可能性があります。</p>
<!--
To ensure memory safety, there’s one more detail to what happens in this
situation in Rust. Instead of trying to copy the allocated memory, Rust
considers `s1` to no longer be valid and, therefore, Rust doesn’t need to free
anything when `s1` goes out of scope. Check out what happens when you try to
use `s1` after `s2` is created, it won't work:
-->
<!--
この最初の文は、こなれた日本語にしにくい
-->
<p>メモリ安全性を保証するために、Rustにおいてこの場面で起こることの詳細がもう一つあります。
確保されたメモリをコピーしようとする代わりに、コンパイラは、<code>s1</code>が最早有効ではないと考え、
故に<code>s1</code>がスコープを抜けた際に何も解放する必要がなくなるわけです。<code>s2</code>の生成後に<code>s1</code>を使用しようとしたら、
どうなるかを確認してみましょう。動かないでしょう:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
</code></pre>
<!--
You’ll get an error like this because Rust prevents you from using the
invalidated reference:
-->
<p>コンパイラが無効化された参照は使用させてくれないので、以下のようなエラーが出るでしょう:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
              (ムーブされた値の使用: `s1`)
 --&gt; src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value used here after move
  |                               (ムーブ後にここで使用されています)
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
    (注釈: ムーブが起きたのは、`s1`が`std::string::String`という
    `Copy`トレイトを実装していない型だからです)
</code></pre>
<!--
If you’ve heard the terms “shallow copy” and “deep copy” while working with
other languages, the concept of copying the pointer, length, and capacity
without copying the data probably sounds like a shallow copy. But
because Rust also invalidates the first variable, instead of being called a
shallow copy, it’s known as a *move*. In this example, we would say that `s1`
was *moved* into `s2`. So what actually happens is shown in Figure 4-4.
-->
<p>他の言語を触っている間に&quot;shallow copy&quot;と&quot;deep copy&quot;という用語を耳にしたことがあるなら、
データのコピーなしにポインタと長さ、許容量をコピーするという概念は、shallow copyのように思えるかもしれません。
ですが、コンパイラは最初の変数をも無効化するので、shallow copyと呼ばれる代わりに、
<em>ムーブ</em>として知られているわけです。この例では、<code>s1</code>は<code>s2</code>に<em>ムーブ</em>されたと表現するでしょう。
以上より、実際に起きることを図4-4に示してみました。</p>
<!--
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
-->
<img alt="s2にムーブされたs1" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<!-- <span class="caption">Figure 4-4: Representation in memory after `s1` has been
invalidated</span> -->
<p><span class="caption">図4-4: <code>s1</code>が無効化された後のメモリ表現</span></p>
<!--
That solves our problem! With only `s2` valid, when it goes out of scope, it
alone will free the memory, and we’re done.
-->
<p>これにて一件落着です。<code>s2</code>だけが有効なので、スコープを抜けたら、それだけがメモリを解放して、
終わりになります。</p>
<!--
In addition, there’s a design choice that’s implied by this: Rust will never
automatically create “deep” copies of your data. Therefore, any *automatic*
copying can be assumed to be inexpensive in terms of runtime performance.
-->
<p>付け加えると、これにより暗示される設計上の選択があります: Rustでは、
自動的にデータの&quot;deep copy&quot;が行われることは絶対にないわけです。それ故に、あらゆる<em>自動</em>コピーは、実行時性能の観点で言うと、
悪くないと考えてよいことになります。</p>
<!--
#### Ways Variables and Data Interact: Clone
-->
<h4 id="変数とデータの相互作用法-クローン"><a class="header" href="#変数とデータの相互作用法-クローン">変数とデータの相互作用法: クローン</a></h4>
<!--
If we *do* want to deeply copy the heap data of the `String`, not just the
stack data, we can use a common method called `clone`. We’ll discuss method
syntax in Chapter 5, but because methods are a common feature in many
programming languages, you’ve probably seen them before.
-->
<p>仮に、スタック上のデータだけでなく、<em>本当に</em><code>String</code>型のヒープデータのdeep copyが必要ならば、
<code>clone</code>と呼ばれるよくあるメソッドを使うことができます。メソッド記法については第5章で議論しますが、
メソッドは多くのプログラミング言語に見られる機能なので、以前に見かけたこともあるんじゃないでしょうか。</p>
<!--
Here’s an example of the `clone` method in action:
-->
<p>これは、<code>clone</code>メソッドの動作例です:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<!--
This works just fine and explicitly produces the behavior shown in Figure 4-3,
where the heap data *does* get copied.
-->
<p>これは問題なく動作し、図4-3で示した動作を明示的に生み出します。ここでは、
ヒープデータが<em>実際に</em>コピーされています。</p>
<!--
When you see a call to `clone`, you know that some arbitrary code is being
executed and that code may be expensive. It’s a visual indicator that something
different is going on.
-->
<p><code>clone</code>メソッドの呼び出しを見かけたら、何らかの任意のコードが実行され、その実行コストは高いと把握できます。
何か違うことが起こっているなと見た目でわかるわけです。</p>
<!--
#### Stack-Only Data: Copy
-->
<h4 id="スタックのみのデータ-コピー"><a class="header" href="#スタックのみのデータ-コピー">スタックのみのデータ: コピー</a></h4>
<!--
There’s another wrinkle we haven’t talked about yet. This code using integers,
part of which was shown in Listing 4-2, works and is valid:
-->
<p>まだ話題にしていない別の問題があります。
この整数を使用したコードは、一部をリスト4-2で示しましたが、うまく動作する有効なものです:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<!--
But this code seems to contradict what we just learned: we don’t have a call to
`clone`, but `x` is still valid and wasn’t moved into `y`.
-->
<p>ですが、このコードは一見、今学んだことと矛盾しているように見えます:
<code>clone</code>メソッドの呼び出しがないのに、<code>x</code>は有効で、<code>y</code>にムーブされませんでした。</p>
<!--
The reason is that types such as integers that have a known size at compile
time are stored entirely on the stack, so copies of the actual values are quick
to make. That means there’s no reason we would want to prevent `x` from being
valid after we create the variable `y`. In other words, there’s no difference
between deep and shallow copying here, so calling `clone` wouldn’t do anything
differently from the usual shallow copying and we can leave it out.
-->
<p>その理由は、整数のようなコンパイル時に既知のサイズを持つ型は、スタック上にすっぽり保持されるので、
実際の値をコピーするのも高速だからです。これは、変数<code>y</code>を生成した後にも<code>x</code>を無効化したくなる理由がないことを意味します。
換言すると、ここでは、shallow copyとdeep copyの違いがないことになり、
<code>clone</code>メソッドを呼び出しても、一般的なshallow copy以上のことをしなくなり、
そのまま放置しておけるということです。</p>
<!--
Rust has a special annotation called the `Copy` trait that we can place on
types like integers that are stored on the stack (we’ll talk more about traits
in Chapter 10). If a type has the `Copy` trait, an older variable is still
usable after assignment. Rust won’t let us annotate a type with the `Copy`
trait if the type, or any of its parts, has implemented the `Drop` trait. If
the type needs something special to happen when the value goes out of scope and
we add the `Copy` annotation to that type, we’ll get a compile-time error. To
learn about how to add the `Copy` annotation to your type, see "Derivable
Traits" in Appendix C.
-->
<p>Rustには<code>Copy</code>トレイトと呼ばれる特別な注釈があり、
整数のようなスタックに保持される型に対して配置することができます(トレイトについては第10章でもっと詳しく話します)。
型が<code>Copy</code>トレイトに適合していれば、代入後も古い変数が使用可能になります。コンパイラは、
型やその一部分でも<code>Drop</code>トレイトを実装している場合、<code>Copy</code>トレイトによる注釈をさせてくれません。
型の値がスコープを外れた時に何か特別なことを起こす必要がある場合に、<code>Copy</code>注釈を追加すると、コンパイルエラーが出ます。
型に<code>Copy</code>注釈をつける方法について学ぶには、付録Cの「導出可能なトレイト」をご覧ください。</p>
<!--
So what types are `Copy`? You can check the documentation for the given type to
be sure, but as a general rule, any group of simple scalar values can be
`Copy`, and nothing that requires allocation or is some form of resource is
`Copy`. Here are some of the types that are `Copy`:
-->
<p>では、どの型が<code>Copy</code>なのでしょうか？ある型について、ドキュメントをチェックすればいいのですが、
一般規則として、単純なスカラー値の集合は何でも<code>Copy</code>であり、メモリ確保が必要だったり、
何らかの形態のリソースだったりするものは<code>Copy</code>ではありません。ここに<code>Copy</code>の型の一部を並べておきます。</p>
<!--
* All the integer types, like `u32`.
* The Boolean type, `bool`, with values `true` and `false`.
* All the floating point types, like `f64`.
* The character type, `char`.
* Tuples, but only if they contain types that are also `Copy`. For example
`(i32, i32)` is `Copy`, but `(i32, String)` is not.
-->
<ul>
<li>あらゆる整数型。<code>u32</code>など。</li>
<li>論理値型である<code>bool</code>。<code>true</code>と<code>false</code>という値がある。</li>
<li>あらゆる浮動小数点型、<code>f64</code>など。</li>
<li>文字型である<code>char</code>。</li>
<li>タプル。ただ、<code>Copy</code>の型だけを含む場合。例えば、<code>(i32, i32)</code>は<code>Copy</code>だが、
<code>(i32, String)</code>は違う。</li>
</ul>
<!--
### Ownership and Functions
-->
<h3 id="所有権と関数"><a class="header" href="#所有権と関数">所有権と関数</a></h3>
<!--
The semantics for passing a value to a function are similar to those for
assigning a value to a variable. Passing a variable to a function will move or
copy, just as assignment does. Listing 4-3 has an example with some annotations
showing where variables go into and out of scope.
-->
<p>意味論的に、関数に値を渡すことと、値を変数に代入することは似ています。関数に変数を渡すと、
代入のようにムーブやコピーされます。リスト4-3は変数がスコープに入ったり、
抜けたりする地点について注釈してある例です。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<!--
```rust
fn main() {
let s = String::from("hello");  // s comes into scope
-->
<!--
takes_ownership(s);             // s's value moves into the function...
// ... and so is no longer valid here
-->
<!--
let x = 5;                      // x comes into scope
-->
<!--
makes_copy(x);                  // x would move into the function,
// but i32 is Copy, so it’s okay to still
// use x afterward
-->
<!--
} // Here, x goes out of scope, then s. But since s's value was moved, nothing
// special happens.
-->
<!--
fn takes_ownership(some_string: String) { // some_string comes into scope.
println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
// memory is freed.
-->
<!--
fn makes_copy(some_integer: i32) { // some_integer comes into scope
println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // sがスコープに入る

    takes_ownership(s);             // sの値が関数にムーブされ...
                                    // ... ここではもう有効ではない

    let x = 5;                      // xがスコープに入る

    makes_copy(x);                  // xも関数にムーブされるが、
                                    // i32はCopyなので、この後にxを使っても
                                    // 大丈夫

} // ここでxがスコープを抜け、sもスコープを抜ける。ただし、sの値はムーブされているので、何も特別なことは起こらない。
  //

fn takes_ownership(some_string: String) { // some_stringがスコープに入る。
    println!(&quot;{}&quot;, some_string);
} // ここでsome_stringがスコープを抜け、`drop`が呼ばれる。後ろ盾してたメモリが解放される。
  // 

fn makes_copy(some_integer: i32) { // some_integerがスコープに入る
    println!(&quot;{}&quot;, some_integer);
} // ここでsome_integerがスコープを抜ける。何も特別なことはない。
</code></pre></pre>
<!-- <span class="caption">Listing 4-3: Functions with ownership and scope
annotated</span> -->
<p><span class="caption">リスト4-3: 所有権とスコープが注釈された関数群</span></p>
<!--
If we tried to use `s` after the call to `takes_ownership`, Rust would throw a
compile-time error. These static checks protect us from mistakes. Try adding
code to `main` that uses `s` and `x` to see where you can use them and where
the ownership rules prevent you from doing so.
-->
<p><code>takes_ownership</code>の呼び出し後に<code>s</code>を呼び出そうとすると、コンパイラは、コンパイルエラーを投げるでしょう。
これらの静的チェックにより、ミスを犯さないでいられます。<code>s</code>や<code>x</code>を使用するコードを<code>main</code>に追加してみて、
どこで使えて、そして、所有権規則により、どこで使えないかを確認してください。</p>
<!--
### Return Values and Scope
-->
<h3 id="戻り値とスコープ"><a class="header" href="#戻り値とスコープ">戻り値とスコープ</a></h3>
<!--
Returning values can also transfer ownership. Listing 4-4 is an example with
similar annotations to those in Listing 4-3.
-->
<p>値を返すことでも、所有権は移動します。リスト4-4は、リスト4-3と似た注釈のついた例です。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<!--
```rust
fn main() {
let s1 = gives_ownership();         // gives_ownership moves its return
// value into s1
-->
<!--
let s2 = String::from("hello");     // s2 comes into scope
-->
<!--
let s3 = takes_and_gives_back(s2);  // s2 is moved into
// takes_and_gives_back, which also
// moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
// moved, so nothing happens. s1 goes out of scope and is dropped.
-->
<!--
fn gives_ownership() -> String {             // gives_ownership will move its
// return value into the function
// that calls it
-->
<!--
let some_string = String::from("hello"); // some_string comes into scope
-->
<!--
some_string                              // some_string is returned and
// moves out to the calling
// function
}
-->
<!--
// takes_and_gives_back will take a String and return one.
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
// scope
-->
<!--
a_string  // a_string is returned and moves out to the calling function
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownershipは、戻り値をs1に
                                        // ムーブする

    let s2 = String::from(&quot;hello&quot;);     // s2がスコープに入る

    let s3 = takes_and_gives_back(s2);  // s2はtakes_and_gives_backにムーブされ
                                        // 戻り値もs3にムーブされる
} // ここで、s3はスコープを抜け、ドロップされる。s2もスコープを抜けるが、ムーブされているので、
  // 何も起きない。s1もスコープを抜け、ドロップされる。

fn gives_ownership() -&gt; String {             // gives_ownershipは、戻り値を
                                             // 呼び出した関数にムーブする

    let some_string = String::from(&quot;hello&quot;); // some_stringがスコープに入る

    some_string                              // some_stringが返され、呼び出し元関数に
                                             // ムーブされる
}

// takes_and_gives_backは、Stringを一つ受け取り、返す。
fn takes_and_gives_back(a_string: String) -&gt; String { // a_stringがスコープに入る。

    a_string  // a_stringが返され、呼び出し元関数にムーブされる
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-4: Transferring ownership of return
values</span>
-->
<p><span class="caption">リスト4-4: 戻り値の所有権を移動する</span></p>
<!--
The ownership of a variable follows the same pattern every time: assigning a
value to another variable moves it. When a variable that includes data on the
heap goes out of scope, the value will be cleaned up by `drop` unless the data
has been moved to be owned by another variable.
-->
<p>変数の所有権は、毎回同じパターンを辿っています: 別の変数に値を代入すると、ムーブされます。
ヒープにデータを含む変数がスコープを抜けると、データが別の変数に所有されるようムーブされていない限り、
<code>drop</code>により片付けられるでしょう。</p>
<!--
Taking ownership and then returning ownership with every function is a bit
tedious. What if we want to let a function use a value but not take ownership?
It’s quite annoying that anything we pass in also needs to be passed back if we
want to use it again, in addition to any data resulting from the body of the
function that we might want to return as well.
-->
<p>所有権を取り、またその所有権を戻す、ということを全ての関数でしていたら、ちょっとめんどくさいですね。
関数に値は使わせるものの所有権を取らないようにさせるにはどうするべきでしょうか。
返したいと思うかもしれない関数本体で発生したあらゆるデータとともに、再利用したかったら、渡されたものをまた返さなきゃいけないのは、
非常に煩わしいことです。</p>
<!--
It’s possible to return multiple values using a tuple, as shown in Listing 4-5.
-->
<p>タプルで、複数の値を返すことは可能です。リスト4-5のようにですね。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<!--
```rust
fn main() {
let s1 = String::from("hello");
-->
<!--
let (s2, len) = calculate_length(s1);
-->
<!--
println!("The length of '{}' is {}.", s2, len);
}
-->
<!--
fn calculate_length(s: String) -> (String, usize) {
let length = s.len(); // len() returns the length of a String
-->
<!--
(s, length)
}
```
-->
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    //'{}'の長さは、{}です
    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len()メソッドは、Stringの長さを返します

    (s, length)
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-5: Returning ownership of parameters</span>
-->
<p><span class="caption">リスト4-5: 引数の所有権を返す</span></p>
<!--
But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Rust has a feature for this concept, called
*references*.
-->
<p>でも、これでは、大袈裟すぎますし、ありふれているはずの概念に対して、作業量が多すぎます。
私たちにとって幸運なことに、Rustにはこの概念に対する機能があり、<em>参照</em>と呼ばれます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## References and Borrowing
-->
<h2 id="参照と借用"><a class="header" href="#参照と借用">参照と借用</a></h2>
<!--
The issue with the tuple code in Listing 4-5 is that we have to return the
`String` to the calling function so we can still use the `String` after the
call to `calculate_length`, because the `String` was moved into
`calculate_length`.
-->
<p>リスト4-5のタプルコードの問題は、<code>String</code>型を呼び出し元の関数に戻さないと、<code>calculate_length</code>を呼び出した後に、
<code>String</code>オブジェクトが使えなくなることであり、これは<code>String</code>オブジェクトが<code>calculate_length</code>にムーブされてしまうためでした。</p>
<!--
Here is how you would define and use a `calculate_length` function that has a
reference to an object as a parameter instead of taking ownership of the
value:
-->
<p>ここで、値の所有権をもらう代わりに引数としてオブジェクトへの参照を取る<code>calculate_length</code>関数を定義し、
使う方法を見てみましょう:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    // '{}'の長さは、{}です
    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<!--
First, notice that all the tuple code in the variable declaration and the
function return value is gone. Second, note that we pass `&s1` into
`calculate_length` and, in its definition, we take `&String` rather than
`String`.
-->
<p>まず、変数宣言と関数の戻り値にあったタプルコードは全てなくなったことに気付いてください。
2番目に、<code>&amp;s1</code>を<code>calcuate_length</code>に渡し、その定義では、<code>String</code>型ではなく、<code>&amp;String</code>を受け取っていることに注目してください。</p>
<!--
These ampersands are *references*, and they allow you to refer to some value
without taking ownership of it. Figure 4-5 shows a diagram.
-->
<p>これらのアンド記号が参照であり、これのおかげで所有権をもらうことなく値を参照することができるのです。
図4-5はその図解です。</p>
<!--
<img alt="&String s pointing at String s1" src="img/trpl04-05.svg" class="center" />
-->
<img alt="文字列s1を指す&amp;String型のs" src="img/trpl04-05.svg" class="center" />
<!--
<span class="caption">Figure 4-5: A diagram of `&String s` pointing at `String
s1`</span>
-->
<p><span class="caption">図4-5: <code>String s1</code>を指す<code>&amp;String s</code>の図表</span></p>
<!--
Note: The opposite of referencing by using `&` is *dereferencing*, which is
accomplished with the dereference operator, `*`. We’ll see some uses of the
dereference operator in Chapter 8 and discuss details of dereferencing in
Chapter 15.
-->
<blockquote>
<p>注釈: <code>&amp;</code>による参照の逆は、<em>参照外し</em>であり、参照外し演算子の<code>*</code>で達成できます。
第8章で参照外し演算子の使用例を眺め、第15章で参照外しについて詳しく議論します。</p>
</blockquote>
<!--
Let’s take a closer look at the function call here:
-->
<p>ここの関数呼び出しについて、もっと詳しく見てみましょう:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span>let s1 = String::from(&quot;hello&quot;);

let len = calculate_length(&amp;s1);
<span class="boring">}
</span></code></pre></pre>
<!--
The `&s1` syntax lets us create a reference that *refers* to the value of `s1`
but does not own it. Because it does not own it, the value it points to will
not be dropped when the reference goes out of scope.
-->
<p>この<code>&amp;s1</code>という記法により、<code>s1</code>の値を<em>参照する</em>参照を生成することができますが、これを所有することはありません。
所有してないということは、指している値は、参照がスコープを抜けてもドロップされないということです。</p>
<!--
Likewise, the signature of the function uses `&` to indicate that the type of
the parameter `s` is a reference. Let’s add some explanatory annotations:
-->
<p>同様に、関数のシグニチャでも、<code>&amp;</code>を使用して引数<code>s</code>の型が参照であることを示しています。
説明的な注釈を加えてみましょう:</p>
<!--
```rust
fn calculate_length(s: &String) -> usize { // s is a reference to a String
s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
// it refers to, nothing happens.
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_length(s: &amp;String) -&gt; usize { // sはStringへの参照
    s.len()
} // ここで、sはスコープ外になる。けど、参照しているものの所有権を持っているわけではないので
  // 何も起こらない
<span class="boring">}
</span></code></pre></pre>
<!--
The scope in which the variable `s` is valid is the same as any function
parameter's scope, but we don’t drop what the reference points to when it goes
out of scope because we don’t have ownership. When functions have references as
parameters instead of the actual values, we won’t need to return the values in
order to give back ownership, since we never had ownership.
-->
<p>変数<code>s</code>が有効なスコープは、あらゆる関数の引数のものと同じですが、所有権はないので、<code>s</code>がスコープを抜けても、
参照が指しているものをドロップすることはありません。関数が実際の値の代わりに参照を引数に取ると、
所有権をもらわないので、所有権を返す目的で値を返す必要はありません。</p>
<!--
We call having references as function parameters *borrowing*. As in real life,
if a person owns something, you can borrow it from them. When you’re done, you
have to give it back.
-->
<p>関数の引数に参照を取ることを<em>借用</em>と呼びます。現実生活のように、誰かが何かを所有していたら、
それを借りることができます。用が済んだら、返さなきゃいけないわけです。</p>
<!--
So what happens if we try to modify something we’re borrowing? Try the code in
Listing 4-6. Spoiler alert: it doesn’t work!
-->
<p>では、借用した何かを変更しようとしたら、どうなるのでしょうか？リスト4-6のコードを試してください。
ネタバレ注意: 動きません！</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<!--
<span class="caption">Listing 4-6: Attempting to modify a borrowed value</span>
-->
<p><span class="caption">リスト4-6: 借用した値を変更しようと試みる</span></p>
<!--
Here’s the error:
-->
<p>これがエラーです:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable borrowed content `*some_string` as mutable
(エラー: 不変な借用をした中身`*some_string`を可変で借用できません)
 --&gt; error.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- use `&amp;mut String` here to make mutable
8 |     some_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^ cannot borrow as mutable
</code></pre>
<!--
Just as variables are immutable by default, so are references. We’re not
allowed to modify something we have a reference to.
-->
<p>変数が標準で不変なのと全く同様に、参照も不変なのです。参照している何かを変更することは叶わないわけです。</p>
<!--
### Mutable References
-->
<h3 id="可変な参照"><a class="header" href="#可変な参照">可変な参照</a></h3>
<!--
We can fix the error in the code from Listing 4-6 with just a small tweak:
-->
<p>一捻り加えるだけでリスト4-6のコードのエラーは解決します:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<!--
First, we had to change `s` to be `mut`. Then we had to create a mutable
reference with `&mut s` and accept a mutable reference with `some_string: &mut
String`.
-->
<p>始めに、<code>s</code>を<code>mut</code>に変えなければなりませんでした。そして、<code>&amp;mut s</code>で可変な参照を生成し、
<code>some_string: &amp;mut String</code>で可変な参照を受け入れなければなりませんでした。</p>
<!--
But mutable references have one big restriction: you can have only one mutable
reference to a particular piece of data in a particular scope. This code will
fail:
-->
<p>ところが、可変な参照には大きな制約が一つあります: 特定のスコープで、ある特定のデータに対しては、
一つしか可変な参照を持てないことです。こちらのコードは失敗します:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
</code></pre>
<!--
Here’s the error:
-->
<p>これがエラーです:</p>
<pre><code class="language-text">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
(エラー: 一度に`s`を可変として2回以上借用することはできません)
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
  |                    (最初の可変な参照はここ)
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
  |                    (二つ目の可変な参照はここ)
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership`

To learn more, run the command again with --verbose.
</code></pre>
<!--
This restriction allows for mutation but in a very controlled fashion. It’s
something that new Rustaceans struggle with, because most languages let you
mutate whenever you’d like.
-->
<p>この制約は、可変化を許可するものの、それを非常に統制の取れた形で行えます。これは、新たなRustaceanにとっては、
壁です。なぜなら、多くの言語では、いつでも好きな時に可変化できるからです。</p>
<!--
The benefit of having this restriction is that Rust can prevent data races at
compile time. A *data race* is similar to a race condition and happens when
these three behaviors occur:
-->
<p>この制約がある利点は、コンパイラがコンパイル時にデータ競合を防ぐことができる点です。
データ競合とは、競合条件と類似していて、これら3つの振る舞いが起きる時に発生します:</p>
<!--
* Two or more pointers access the same data at the same time.
* At least one of the pointers is being used to write to the data.
* There’s no mechanism being used to synchronize access to the data.
-->
<ul>
<li>2つ以上のポインタが同じデータに同時にアクセスする。</li>
<li>少なくとも一つのポインタがデータに書き込みを行っている。</li>
<li>データへのアクセスを同期する機構が使用されていない。</li>
</ul>
<!--
Data races cause undefined behavior and can be difficult to diagnose and fix
when you’re trying to track them down at runtime; Rust prevents this problem
from happening because it won’t even compile code with data races!
-->
<p>データ競合は未定義の振る舞いを引き起こし、実行時に追いかけようとした時に特定し解決するのが難しい問題です。
しかし、Rustは、データ競合が起こるコードをコンパイルさえしないので、この問題が発生しないようにしてくれるわけです。</p>
<!--
As always, we can use curly brackets to create a new scope, allowing for
multiple mutable references, just not *simultaneous* ones:
-->
<p>いつものように、波かっこを使って新しいスコープを生成し、<em>同時並行</em>なものでなく、複数の可変な参照を作ることができます。</p>
<!--
```rust
let mut s = String::from("hello");
-->
<!--
{
let r1 = &mut s;
-->
<!--
} // r1 goes out of scope here, so we can make a new reference with no problems.
-->
<!--
let r2 = &mut s;
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;mut s;

} // r1はここでスコープを抜けるので、問題なく新しい参照を作ることができる

let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<!--
A similar rule exists for combining mutable and immutable references. This code
results in an error:
-->
<p>可変と不変な参照を組み合わせることに関しても、似たような規則が存在しています。このコードはエラーになります:</p>
<!--
```rust,ignore
let mut s = String::from("hello");
-->
<!--
let r1 = &s; // no problem
let r2 = &s; // no problem
let r3 = &mut s; // BIG PROBLEM
```
-->
<pre><code class="language-rust ignore">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s; // 問題なし
let r2 = &amp;s; // 問題なし
let r3 = &amp;mut s; // 大問題！
</code></pre>
<!--
Here’s the error:
-->
<p>これがエラーです:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as
immutable
(エラー: `s`は不変で借用されているので、可変で借用できません)
 --&gt; borrow_thrice.rs:6:19
  |
4 |     let r1 = &amp;s; // no problem
  |               - immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |                   ^ mutable borrow occurs here
7 | }
  | - immutable borrow ends here
</code></pre>
<!--
Whew! We *also* cannot have a mutable reference while we have an immutable one.
Users of an immutable reference don’t expect the values to suddenly change out
from under them! However, multiple immutable references are okay because no one
who is just reading the data has the ability to affect anyone else’s reading of
the data.
-->
<p>ふう！<em>さらに</em>不変な参照をしている間は、可変な参照をすることはできません。不変参照の使用者は、
それ以降に値が突然変わることなんて予想してません！しかしながら、複数の不変参照をすることは可能です。
データを読み込んでいるだけの人に、他人がデータを読み込むことに対して影響を与える能力はないからです。</p>
<!--
Even though these errors may be frustrating at times, remember that it’s the
Rust compiler pointing out a potential bug early (at compile time rather than
at runtime) and showing you exactly where the problem is. Then you don't have
to track down why your data isn’t what you thought it was.
-->
<p>これらのエラーは、時としてイライラするものではありますが、Rustコンパイラがバグの可能性を早期に指摘してくれ(それも実行時ではなくコンパイル時に)、
問題の発生箇所をズバリ示してくれるのだと覚えておいてください。そうして想定通りにデータが変わらない理由を追いかける必要がなくなります。</p>
<!--
### Dangling References
-->
<h3 id="宙に浮いた参照"><a class="header" href="#宙に浮いた参照">宙に浮いた参照</a></h3>
<!--
In languages with pointers, it’s easy to erroneously create a *dangling
pointer*, a pointer that references a location in memory that may have been
given to someone else, by freeing some memory while preserving a pointer to
that memory. In Rust, by contrast, the compiler guarantees that references will
never be dangling references: if you have a reference to some data, the
compiler will ensure that the data will not go out of scope before the
reference to the data does.
-->
<p>ポインタのある言語では、誤ってダングリングポインタを生成してしまいやすいです。ダングリングポインタとは、
他人に渡されてしまった可能性のあるメモリを指すポインタのことであり、その箇所へのポインタを保持している間に、
メモリを解放してしまうことで発生します。対照的にRustでは、コンパイラが、
参照がダングリング参照に絶対ならないよう保証してくれます: つまり、何らかのデータへの参照があったら、
コンパイラは参照がスコープを抜けるまで、データがスコープを抜けることがないよう確認してくれるわけです。</p>
<!--
Let’s try to create a dangling reference, which Rust will prevent with a
compile-time error:
-->
<p>ダングリング参照作りを試してみますが、コンパイラはこれをコンパイルエラーで阻止します:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<!--
Here’s the error:
-->
<p>こちらがエラーです:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
(エラー: ライフタイム指定子がありません)
 --&gt; main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no
    value for it to be borrowed from
    (助言: この関数の戻り値型は、借用した値を含んでいますが、借用される値がどこにもありません)
  = help: consider giving it a 'static lifetime
  ('staticライフタイムを与えることを考慮してみてください)
</code></pre>
<!--
This error message refers to a feature we haven’t covered yet: *lifetimes*. We'll
discuss lifetimes in detail in Chapter 10. But, if you disregard the parts
about lifetimes, the message does contain the key to why this code is a problem:
-->
<p>このエラーメッセージは、まだ講義していない機能について触れています: <em>ライフタイム</em>です。
ライフタイムについては第10章で詳しく議論しますが、ライフタイムに関する部分を無視すれば、
このメッセージは、確かにこのコードが問題になる理由に関する鍵を握っています:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre>
<!--
Let’s take a closer look at exactly what’s happening at each stage of our
`dangle` code:
-->
<p><code>dangle</code>コードの各段階で一体何が起きているのかを詳しく見ていきましょう:</p>
<!--
```rust,ignore
fn dangle() -> &String { // dangle returns a reference to a String
-->
<!--
let s = String::from("hello"); // s is a new String
-->
<!--
&s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
// Danger!
```
-->
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn dangle() -&gt; &amp;String { // dangleはStringへの参照を返す

    let s = String::from(&quot;hello&quot;); // sは新しいString

    &amp;s // String sへの参照を返す
} // ここで、sはスコープを抜け、ドロップされる。そのメモリは消される。
  // 危険だ
</code></pre>
<!--
Because `s` is created inside `dangle`, when the code of `dangle` is finished,
`s` will be deallocated. But we tried to return a reference to it. That means
this reference would be pointing to an invalid `String`. That’s no good! Rust
won’t let us do this.
-->
<p><code>s</code>は、<code>dangle</code>内で生成されているので、<code>dangle</code>のコードが終わったら、<code>s</code>は解放されてしまいますが、
そこへの参照を返そうとしました。つまり、この参照は無効な<code>String</code>を指していると思われるのです。
よくないことです！コンパイラは、これを阻止してくれるのです。</p>
<!--
The solution here is to return the `String` directly:
-->
<p>ここでの解決策は、<code>String</code>を直接返すことです:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
<span class="boring">}
</span></code></pre></pre>
<!--
This works without any problems. Ownership is moved out, and nothing is
deallocated.
-->
<p>これは何の問題もなく動きます。所有権はムーブされ、何も解放されることはありません。</p>
<!--
### The Rules of References
-->
<h3 id="参照の規則"><a class="header" href="#参照の規則">参照の規則</a></h3>
<!--
Let’s recap what we’ve discussed about references:
-->
<p>参照について議論したことを再確認しましょう:</p>
<!--
* At any given time, you can have *either* one mutable reference *or* any
number of immutable references.
* References must always be valid.
-->
<ul>
<li>任意のタイミングで、一つの可変参照<em>か</em>不変な参照いくつでもの<em>どちらか</em>を行える。</li>
<li>参照は常に有効でなければならない。</li>
</ul>
<!--
Next, we’ll look at a different kind of reference: slices.
-->
<p>次は、違う種類の参照を見ていきましょう: スライスです。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## The Slice Type
-->
<h2 id="スライス型"><a class="header" href="#スライス型">スライス型</a></h2>
<!--
Another data type that does not have ownership is the *slice*. Slices let you
reference a contiguous sequence of elements in a collection rather than the
whole collection.
-->
<p>所有権のない別のデータ型は、<em>スライス</em>です。スライスにより、コレクション全体ではなく、
その内の一連の要素を参照することができます。</p>
<!--
Here’s a small programming problem: write a function that takes a string and
returns the first word it finds in that string. If the function doesn’t find a
space in the string, the whole string must be one word, so the entire string
should be returned.
-->
<p>ちょっとしたプログラミングの問題を考えてみましょう: 文字列を受け取って、その文字列中の最初の単語を返す関数を書いてください。
関数が文字列中に空白を見つけられなかったら、文字列全体が一つの単語に違いないので、文字列全体が返されるべきです。</p>
<!--
Let’s think about the signature of this function:
-->
<p>この関数のシグニチャについて考えてみましょう:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<!--
This function, `first_word`, has a `&String` as a parameter. We don’t want
ownership, so this is fine. But what should we return? We don’t really have a
way to talk about *part* of a string. However, we could return the index of the
end of the word. Let’s try that, as shown in Listing 4-7.
-->
<p>この関数、<code>first_word</code>は引数に<code>&amp;String</code>をとります。所有権はいらないので、これで十分です。
ですが、何を返すべきでしょうか？文字列の<em>一部</em>について語る方法が全くありません。しかし、
単語の終端の添え字を返すことができますね。リスト4-7に示したように、その方法を試してみましょう。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 4-7: The `first_word` function that returns a
byte index value into the `String` parameter</span>
-->
<p><span class="caption">リスト4-7: <code>String</code>引数へのバイト数で表された添え字を返す<code>first_word</code>関数</span></p>
<!--
Because we need to go through the `String` element by element and check whether
a value is a space, we’ll convert our `String` to an array of bytes using the
`as_bytes` method:
-->
<p><code>String</code>の値を要素ごとに見て、空白かどうかを確かめる必要があるので、
<code>as_bytes</code>メソッドを使って、<code>String</code>オブジェクトをバイト配列に変換しています。</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
Next, we create an iterator over the array of bytes using the `iter` method:
-->
<p>次に、そのバイト配列に対して、<code>iter</code>メソッドを使用してイテレータを生成しています:</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
We’ll discuss iterators in more detail in Chapter 13. For now, know that `iter`
is a method that returns each element in a collection and that `enumerate`
wraps the result of `iter` and returns each element as part of a tuple instead.
The first element of the tuple returned from `enumerate` is the index, and the
second element is a reference to the element. This is a bit more convenient
than calculating the index ourselves.
-->
<p>イテレータについて詳しくは、第13章で議論します。今は、<code>iter</code>は、コレクション内の各要素を返すメソッドであること、
<code>enumerate</code>が<code>iter</code>の結果をラップして、（結果をそのまま返す）代わりにタプルの一部として各要素を返すことを知っておいてください。
<code>enumerate</code>から返ってくるタプルの第1要素は、添え字であり、2番目の要素は、(コレクションの）要素への参照になります。
これは、手動で添え字を計算するよりも少しだけ便利です。</p>
<!--
Because the `enumerate` method returns a tuple, we can use patterns to
destructure that tuple, just like everywhere else in Rust. So in the `for`
loop, we specify a pattern that has `i` for the index in the tuple and `&item`
for the single byte in the tuple. Because we get a reference to the element
from `.iter().enumerate()`, we use `&` in the pattern.
-->
<p><code>enumerate</code>メソッドがタプルを返すので、Rustのあらゆる場所同様、パターンを使って、そのタプルを分配できます。
従って、<code>for</code>ループ内で、タプルの添え字に対する<code>i</code>とタプルの1バイトに対応する<code>&amp;item</code>を含むパターンを指定しています。
<code>.iter().enumerate()</code>から要素への参照を取得するので、パターンに<code>&amp;</code>を使っています。</p>
<!--
Inside the `for` loop, we search for the byte that represents the space by
using the byte literal syntax. If we find a space, we return the position.
Otherwise, we return the length of the string by using `s.len()`:
-->
<p><code>for</code>ループ内で、バイトリテラル表記を使用して空白を表すバイトを検索しています。空白が見つかったら、その位置を返します。
それ以外の場合、<code>s.len()</code>を使って文字列の長さを返します。</p>
<pre><code class="language-rust ignore"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<!--
We now have a way to find out the index of the end of the first word in the
string, but there’s a problem. We’re returning a `usize` on its own, but it’s
only a meaningful number in the context of the `&String`. In other words,
because it’s a separate value from the `String`, there’s no guarantee that it
will still be valid in the future. Consider the program in Listing 4-8 that
uses the `first_word` function from Listing 4-7.
-->
<p>さて、文字列内の最初の単語の終端の添え字を見つけ出せるようになりましたが、問題があります。
<code>usize</code>型を単独で返していますが、これは<code>&amp;String</code>の文脈でのみ意味を持つ数値です。
言い換えると、<code>String</code>から切り離された値なので、将来的にも有効である保証がないのです。
リスト4-7の<code>first_word</code>関数を使用するリスト4-8のプログラムを考えてください。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // word will get the value 5
                               // wordの中身は、値5になる

    s.clear(); // this empties the String, making it equal to &quot;&quot;
               // Stringを空にする。つまり、&quot;&quot;と等しくする

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
    // wordはまだ値5を保持しているが、もうこの値を正しい意味で使用できる文字列は存在しない。
    // wordは今や完全に無効なのだ！
}
</code></pre></pre>
<!--
<span class="caption">Listing 4-8: Storing the result from calling the
`first_word` function and then changing the `String` contents</span>
-->
<p><span class="caption">リスト4-8: <code>first_word</code>関数の呼び出し結果を保持し、<code>String</code>の中身を変更する</span></p>
<!--
This program compiles without any errors and would also do so if we used `word`
after calling `s.clear()`. Because `word` isn’t connected to the state of `s`
at all, `word` still contains the value `5`. We could use that value `5` with
the variable `s` to try to extract the first word out, but this would be a bug
because the contents of `s` have changed since we saved `5` in `word`.
-->
<p>このプログラムは何のエラーもなくコンパイルが通り、<code>word</code>を<code>s.clear()</code>の呼び出し後に使用しても、
コンパイルが通ります。<code>word</code>は<code>s</code>の状態に全く関連づけられていないので、その中身はまだ値<code>5</code>のままです。
その値<code>5</code>を変数<code>s</code>に使用し、最初の単語を取り出そうとすることはできますが、これはバグでしょう。
というのも、<code>s</code>の中身は、<code>5</code>を<code>word</code>に保存した後変わってしまったからです。</p>
<!--
Having to worry about the index in `word` getting out of sync with the data in
`s` is tedious and error prone! Managing these indices is even more brittle if
we write a `second_word` function. Its signature would have to look like this:
-->
<p><code>word</code>内の添え字が<code>s</code>に格納されたデータと同期されなくなるのを心配することは、面倒ですし間違いになりやすいです！
これらの添え字の管理は、<code>second_word</code>関数を書いたら、さらに難しくなります。
そのシグニチャは以下のようになるはずです:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<!--
Now we’re tracking a starting *and* an ending index, and we have even more
values that were calculated from data in a particular state but aren’t tied to
that state at all. We now have three unrelated variables floating around that
need to be kept in sync.
-->
<p>今、私たちは開始<em>と</em>終端の添え字を追うようになりました。特定の状態のデータから計算されたが、
その状態に全く紐付けられていない値がさらに増えました。いつの間にか変わってしまうので、同期を取る必要のある、関連性のない変数が3つになってしまいました。</p>
<!--
Luckily, Rust has a solution to this problem: string slices.
-->
<p>運のいいことに、Rustにはこの問題への解決策が用意されています: 文字列スライスです。</p>
<!--
### String Slices
-->
<h3 id="文字列スライス"><a class="header" href="#文字列スライス">文字列スライス</a></h3>
<!--
A *string slice* is a reference to part of a `String`, and it looks like this:
-->
<p><em>文字列スライス</em>とは、<code>String</code>の一部への参照で、こんな見た目をしています:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s = String::from(&quot;hello world&quot;);

    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<!--
This is similar to taking a reference to the whole `String` but with the extra
`[0..5]` bit. Rather than a reference to the entire `String`, it’s a reference
to a portion of the `String`.
-->
<p>これは、<code>String</code>全体への参照を取ることに似ていますが、余計な<code>[0..5]</code>という部分が付いています。
<code>String</code>全体への参照ではなく、<code>String</code>の一部への参照です。</p>
<!--
We can create slices using a range within brackets by specifying
`[starting_index..ending_index]`, where `starting_index` is the first position
in the slice and `ending_index` is one more than the last position in the
slice. Internally, the slice data structure stores the starting position and
the length of the slice, which corresponds to `ending_index` minus
`starting_index`. So in the case of `let world = &s[6..11];`, `world` would be
a slice that contains a pointer to the 7th byte (counting from 1) of `s` with a length value of 5.
-->
<p><code>[starting_index..ending_index]</code>と指定することで、角かっこに範囲を使い、スライスを生成できます。
ここで、<code>starting_index</code>はスライスの最初の位置、<code>ending_index</code>はスライスの終端位置よりも、
1大きい値です。内部的には、スライスデータ構造は、開始地点とスライスの長さを保持しており、
スライスの長さは<code>ending_index</code>から<code>starting_index</code>を引いたものに対応します。以上より、
<code>let world = &amp;s[6..11];</code>の場合には、<code>world</code>は<code>s</code>の添え字6のバイトへのポインタと5という長さを持つスライスになるでしょう。</p>
<!--
Figure 4-6 shows this in a diagram.
-->
<p>図4-6は、これを図解しています。</p>
<!--
<img alt="world containing a pointer to the 6th byte of String s and a length 5" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
-->
<img alt="文字列sの6バイト目へのポインタと長さ5を保持するworld" src="img/trpl04-06.svg" class="center" style="width: 50%;" />
<!--
<span class="caption">Figure 4-6: String slice referring to part of a
`String`</span>
-->
<p><span class="caption">図4-6: <code>String</code>オブジェクトの一部を参照する文字列スライス</span></p>
<!--
With Rust’s `..` range syntax, if you want to start at the first index (zero),
you can drop the value before the two periods. In other words, these are equal:
-->
<p>Rustの<code>..</code>という範囲記法で、最初の番号(ゼロ)から始めたければ、2連ピリオドの前に値を書かなければいいです。
換言すれば、これらは等価です:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<!--
By the same token, if your slice includes the last byte of the `String`, you
can drop the trailing number. That means these are equal:
-->
<p>同様の意味で、<code>String</code>の最後のバイトをスライスが含むのならば、末尾の数値を書かなければいいです。
つまり、これらは等価になります:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<!--
You can also drop both values to take a slice of the entire string. So these
are equal:
-->
<p>さらに、両方の値を省略すると、文字列全体のスライスを得られます。故に、これらは等価です:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<!--
> Note: String slice range indices must occur at valid UTF-8 character
> boundaries. If you attempt to create a string slice in the middle of a
> multibyte character, your program will exit with an error. For the purposes
> of introducing string slices, we are assuming ASCII only in this section; a
> more thorough discussion of UTF-8 handling is in the [“Storing UTF-8 Encoded
> Text with Strings”][strings] section of Chapter 8.
-->
<blockquote>
<p>注釈: 文字列スライスの範囲添え字は、有効なUTF-8文字境界に置かなければなりません。
マルチバイト文字の真ん中で文字列スライスを生成しようとしたら、エラーでプログラムは落ちるでしょう。
この節では文字列スライスを導入することが目的なので、ASCIIのみを想定しています; UTF-8に関するより徹底した議論は、
第8章の<a href="ch08-02-strings.html#%E6%96%87%E5%AD%97%E5%88%97%E3%81%A7utf-8%E3%81%A7%E3%82%A8%E3%83%B3%E3%82%B3%E3%83%BC%E3%83%89%E3%81%95%E3%82%8C%E3%81%9F%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%92%E4%BF%9D%E6%8C%81%E3%81%99%E3%82%8B">「文字列でUTF-8エンコードされたテキストを格納する」</a>節で行います。</p>
</blockquote>
<!--
With all this information in mind, let’s rewrite `first_word` to return a
slice. The type that signifies “string slice” is written as `&str`:
-->
<p>これらの情報を念頭に、<code>first_word</code>を書き直してスライスを返すようにしましょう。
文字列スライスを意味する型は、<code>&amp;str</code>と記述します:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
We get the index for the end of the word in the same way as we did in Listing
4-7, by looking for the first occurrence of a space. When we find a space, we
return a string slice using the start of the string and the index of the space
as the starting and ending indices.
-->
<p>リスト4-7で取った方法と同じように、最初の空白を探すことで単語の終端の添え字を取得しています。
空白を発見したら、文字列の最初を開始地点、空白の添え字を終了地点として使用して文字列スライスを返しています。</p>
<!--
Now when we call `first_word`, we get back a single value that is tied to the
underlying data. The value is made up of a reference to the starting point of
the slice and the number of elements in the slice.
-->
<p>これで、<code>first_word</code>を呼び出すと、元のデータに紐付けられた単独の値を得られるようになりました。
この値は、スライスの開始地点への参照とスライス中の要素数から構成されています。</p>
<!--
Returning a slice would also work for a `second_word` function:
-->
<p><code>second_word</code>関数についても、スライスを返すことでうまくいくでしょう:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!--
We now have a straightforward API that’s much harder to mess up, because the
compiler will ensure the references into the `String` remain valid. Remember
the bug in the program in Listing 4-8, when we got the index to the end of the
first word but then cleared the string so our index was invalid? That code was
logically incorrect but didn’t show any immediate errors. The problems would
show up later if we kept trying to use the first word index with an emptied
string. Slices make this bug impossible and let us know we have a problem with
our code much sooner. Using the slice version of `first_word` will throw a
compile-time error:
-->
<p>これで、ずっと混乱しにくい素直なAPIになりました。なぜなら、<code>String</code>への参照が有効なままであることをコンパイラが、
保証してくれるからです。最初の単語の終端添え字を得た時に、
文字列を空っぽにして先ほどの添え字が無効になってしまったリスト4-8のプログラムのバグを覚えていますか？
そのコードは、論理的に正しくないのですが、即座にエラーにはなりませんでした。問題は後になってから発生し、
それは空の文字列に対して、最初の単語の添え字を使用し続けようとした時でした。スライスならこんなバグはあり得ず、
コードに問題があるなら、もっと迅速に判明します。スライスバージョンの<code>first_word</code>を使用すると、
コンパイルエラーが発生します:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error! （エラー！）

    println!(&quot;the first word is: {}&quot;, word);
}
</code></pre>
<!--
Here’s the compiler error:
-->
<p>こちらがコンパイルエラーです:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
(エラー: 不変として借用されているので、`s`を可変で借用できません)
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
   |                             (不変借用はここで発生しています)
17 | 
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
   |              (可変借用はここで発生しています)
19 | 
20 |     println!(&quot;the first word is: {}&quot;, word);
   |                                       ---- immutable borrow later used here
                                                (不変借用はその後ここで使われています)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
Recall from the borrowing rules that if we have an immutable reference to
something, we cannot also take a mutable reference. Because `clear` needs to
truncate the `String`, it needs to get a mutable reference. Rust disallows
this, and compilation fails. Not only has Rust made our API easier to use, but
it has also eliminated an entire class of errors at compile time!
-->
<p>借用規則から、何かへの不変な参照がある時、さらに可変な参照を得ることはできないことを思い出してください。
<code>clear</code>は<code>String</code>を切り詰める必要があるので、可変な参照を得る必要があります。Rustはこれを認めないので、コンパイルが失敗します。
RustのおかげでAPIが使いやすくなるだけでなく、ある種のエラー全てを完全にコンパイル時に排除してくれるのです！</p>
<!--
#### String Literals Are Slices
-->
<h4 id="文字列リテラルはスライスである"><a class="header" href="#文字列リテラルはスライスである">文字列リテラルはスライスである</a></h4>
<!--
Recall that we talked about string literals being stored inside the binary. Now
that we know about slices, we can properly understand string literals:
-->
<p>文字列は、バイナリに埋め込まれると話したことを思い出してください。今やスライスのことを知ったので、
文字列リテラルを正しく理解することができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The type of `s` here is `&str`: it’s a slice pointing to that specific point of
the binary. This is also why string literals are immutable; `&str` is an
immutable reference.
-->
<p>ここでの<code>s</code>の型は、<code>&amp;str</code>です: バイナリのその特定の位置を指すスライスです。
これは、文字列が不変である理由にもなっています。要するに、<code>&amp;str</code>は不変な参照なのです。</p>
<!--
#### String Slices as Parameters
-->
<h4 id="引数としての文字列スライス"><a class="header" href="#引数としての文字列スライス">引数としての文字列スライス</a></h4>
<!--
Knowing that you can take slices of literals and `String` values leads us to
one more improvement on `first_word`, and that’s its signature:
-->
<p>リテラルや<code>String</code>値のスライスを得ることができると知ると、<code>first_word</code>に対して、もう一つ改善点を見出すことができます。
シグニチャです:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<!--
A more experienced Rustacean would write the signature shown in Listing 4-9
instead because it allows us to use the same function on both `&String` values
and `&str` values.
-->
<p>もっと経験を積んだRustaceanなら、代わりにリスト4-9のようなシグニチャを書くでしょう。というのも、こうすると、
同じ関数を<code>&amp;String</code>値と<code>&amp;str</code>値両方に使えるようになるからです。</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    // first_wordは`String`のスライスに対して機能する
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    // first_wordは文字列リテラルのスライスに対して機能する
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    // 文字列リテラルは「それ自体すでに文字列スライスなので」、
</span><span class="boring">    // スライス記法なしでも機能するのだ！
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 4-9: Improving the `first_word` function by using
a string slice for the type of the `s` parameter</span>
-->
<p><span class="caption">リスト4-9: <code>s</code>引数の型に文字列スライスを使用して<code>first_word</code>関数を改善する</span></p>
<!--
If we have a string slice, we can pass that directly. If we have a `String`, we
can pass a slice of the entire `String`. Defining a function to take a string
slice instead of a reference to a `String` makes our API more general and useful
without losing any functionality:
-->
<p>もし、文字列スライスがあるなら、それを直接渡せます。<code>String</code>があるなら、
その<code>String</code>全体のスライスを渡せます。<code>String</code>への参照の代わりに文字列スライスを取るよう関数を定義すると、
何も機能を失うことなくAPIをより一般的で有益なものにできるのです。</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // first_word works on slices of `String`s
    // first_wordは`String`のスライスに対して機能する
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;hello world&quot;;

    // first_word works on slices of string literals
    // first_wordは文字列リテラルのスライスに対して機能する
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    // 文字列リテラルは「それ自体すでに文字列スライスなので」、
    // スライス記法なしでも機能するのだ！
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<!--
### Other Slices
-->
<h3 id="他のスライス"><a class="header" href="#他のスライス">他のスライス</a></h3>
<!--
String slices, as you might imagine, are specific to strings. But there’s a
more general slice type, too. Consider this array:
-->
<p>文字列リテラルは、ご想像通り、文字列に特化したものです。ですが、もっと一般的なスライス型も存在します。
この配列を考えてください:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<!--
Just as we might want to refer to a part of a string, we might want to refer
to part of an array. We’d do so like this:
-->
<p>文字列の一部を参照したくなる可能性があるのと同様、配列の一部を参照したくなる可能性もあります。
以下のようにすれば、参照することができます:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
<span class="boring">}
</span></code></pre></pre>
<!--
This slice has the type `&[i32]`. It works the same way as string slices do, by
storing a reference to the first element and a length. You’ll use this kind of
slice for all sorts of other collections. We’ll discuss these collections in
detail when we talk about vectors in Chapter 8.
-->
<p>このスライスは、<code>&amp;[i32]</code>という型になります。これも文字列スライスと同じように動作します。
つまり、最初の要素への参照と長さを保持するのです。
この種のスライスは、他のすべての種類のコレクションに対して使用することになるでしょう。
それらのコレクションについて、詳しくは、第8章でベクタについて話すときに議論します。</p>
<!--
## Summary
-->
<h2 id="まとめ-3"><a class="header" href="#まとめ-3">まとめ</a></h2>
<!--
The concepts of ownership, borrowing, and slices ensure memory safety in Rust
programs at compile time. The Rust language gives you control over your memory
usage in the same way as other systems programming languages, but having the
owner of data automatically clean up that data when the owner goes out of scope
means you don’t have to write and debug extra code to get this control.
-->
<p>所有権、借用、スライスの概念は、Rustプログラムにおいて、コンパイル時にメモリ安全性を保証します。
Rust言語も他のシステムプログラミング言語と同じように、メモリの使用法について制御させてくれるわけですが、
データの所有者がスコープを抜けたときに、所有者に自動的にデータを片付けさせることは、この制御をするために、
余計なコードを書いたりデバッグしたりする必要がないことを意味します。</p>
<!--
Ownership affects how lots of other parts of Rust work, so we’ll talk about
these concepts further throughout the rest of the book. Let’s move on to
Chapter 5 and look at grouping pieces of data together in a `struct`.
-->
<p>所有権は、Rustの他のいろんな部分が動作する方法に影響を与えるので、これ以降もこれらの概念についてさらに語っていく予定です。
第5章に移って、<code>struct</code>でデータをグループ化することについて見ていきましょう。</p>
<!--
[strings]: ch08-02-strings.html#storing-utf-8-encoded-text-with-strings
-->
<div style="break-before: page; page-break-before: always;"></div><!--
# Using Structs to Structure Related Data
-->
<h1 id="構造体を使用して関係のあるデータを構造化する"><a class="header" href="#構造体を使用して関係のあるデータを構造化する">構造体を使用して関係のあるデータを構造化する</a></h1>
<!--
A *struct*, or *structure*, is a custom data type that lets us name and
package together multiple related values that make up a meaningful group. If
you're familiar with an object-oriented language, a *struct* is like an
object's data attributes. In this chapter, we’ll compare and contrast tuples
with structs demonstrate how to use structs, and discuss how to define methods
and associated functions to specify behavior associated with a struct’s data.
Structs and enums (discussed in Chapter 6) are the building blocks for creating
new types in your program’s domain to take full advantage of Rust's compile
time type checking.
-->
<p><em>struct</em>または、<em>構造体</em>は、意味のあるグループを形成する複数の関連した値をまとめ、名前付けできる独自のデータ型です。
あなたがオブジェクト指向言語に造詣が深いなら、<em>struct</em>はオブジェクトのデータ属性みたいなものです。
この章では、タプルと構造体を対照的に比較し、構造体の使用法をデモし、メソッドや関連関数を定義して、
構造体のデータに紐付く振る舞いを指定する方法について議論します。構造体と<em>enum</em>(第6章で議論します)は、
自分のプログラム領域で新しい型を定義し、Rustのコンパイル時型精査機能をフル活用する構成要素になります。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Defining and Instantiating Structs
-->
<h2 id="構造体を定義しインスタンス化する"><a class="header" href="#構造体を定義しインスタンス化する">構造体を定義し、インスタンス化する</a></h2>
<!--
Structs are similar to tuples, which were discussed in Chapter 3. Like tuples,
the pieces of a struct can be different types. Unlike with tuples, you'll name
each piece of data so it’s clear what the values mean. As a result of these
names, structs are more flexible than tuples: we don’t have to rely on the
order of the data to specify or access the values of an instance.
-->
<p>構造体は第3章で議論したタプルと似ています。タプル同様、構造体の一部を異なる型にできます。
一方タプルとは違って、各データ片には名前をつけるので、値の意味が明確になります。
この名前のおかげで、構造体はタプルに比して、より柔軟になるわけです: データの順番に頼って、
インスタンスの値を指定したり、アクセスしたりする必要がないのです。</p>
<!--
To define a struct, we enter the keyword `struct` and name the entire struct. A
struct’s name should describe the significance of the pieces of data being
grouped together. Then, inside curly brackets, we define the names and types of
the pieces of data, which we call *fields*. For example, Listing 5-1 shows a
struct that stores information about a user account.
-->
<p>構造体の定義は、<code>struct</code>キーワードを入れ、構造体全体に名前を付けます。構造体名は、
一つにグループ化されるデータ片の意義を表すものであるべきです。そして、波かっこ内に、
データ片の名前と型を定義し、これは<em>フィールド</em>と呼ばれます。例えば、リスト5-1では、
ユーザアカウントに関する情報を保持する構造体を示しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-1: A `User` struct definition</span>
-->
<p><span class="caption">リスト5-1: <code>User</code>構造体定義</span></p>
<!--
To use a struct after we’ve defined it, we create an *instance* of that struct
by specifying concrete values for each of the fields. We create an instance by
stating the name of the struct, and then add curly brackets containing `key:
value` pairs, where the keys are the names of the fields and the values are the
data we want to store in those fields. We don’t have to specify the fields in
the same order in which we declared them in the struct. In other words, the
struct definition is like a general template for the type, and instances fill
in that template with particular data to create values of the type. For
example, we can declare a particular user as shown in Listing 5-2.
-->
<p>構造体を定義した後に使用するには、各フィールドに対して具体的な値を指定して構造体の<em>インスタンス</em>を生成します。
インスタンスは、構造体名を記述し、<code>key: value</code>ペアを含む波かっこを付け加えることで生成します。
ここで、キーはフィールド名、値はそのフィールドに格納したいデータになります。フィールドは、
構造体で宣言した通りの順番に指定する必要はありません。換言すると、構造体定義とは、
型に対する一般的な雛形のようなものであり、インスタンスは、その雛形を特定のデータで埋め、その型の値を生成するわけです。
例えば、リスト5-2で示されたように特定のユーザを宣言することができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>let user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-2: Creating an instance of the `User`
struct</span>
-->
<p><span class="caption">リスト5-2: <code>User</code>構造体のインスタンスを生成する</span></p>
<!--
To get a specific value from a struct, we can use dot notation. If we wanted
just this user’s email address, we can use `user1.email` wherever we wanted
to use this value. If the instance is mutable, we can change a value by using
the dot notation and assigning into a particular field. Listing 5-3 shows how
to change the value in the `email` field of a mutable `User` instance.
-->
<p>構造体から特定の値を得るには、ドット記法が使えます。このユーザのEメールアドレスだけが欲しいなら、
この値を使いたかった場所全部で<code>user1.email</code>が使えます。インスタンスが可変であれば、
ドット記法を使い特定のフィールドに代入することで値を変更できます。リスト5-3では、
可変な<code>User</code>インスタンスの<code>email</code>フィールド値を変更する方法を示しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>let mut user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from(&quot;anotheremail@example.com&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-3: Changing the value in the `email` field of a
`User` instance</span>
-->
<p><span class="caption">リスト5-3: ある<code>User</code>インスタンスの<code>email</code>フィールド値を変更する</span></p>
<!--
Note that the entire instance must be mutable; Rust doesn’t allow us to mark
only certain fields as mutable. As with any expression, we can construct a new
instance of the struct as the last expression in the function body to
implicitly return that new instance.
-->
<p>インスタンス全体が可変でなければならないことに注意してください; Rustでは、一部のフィールドのみを可変にすることはできないのです。
また、あらゆる式同様、構造体の新規インスタンスを関数本体の最後の式として生成して、
そのインスタンスを返すことを暗示できます。</p>
<!--
Listing 5-4 shows a `build_user` function that returns a `User` instance with
the given email and username. The `active` field gets the value of `true`, and
the `sign_in_count` gets a value of `1`.
-->
<p>リスト5-4は、与えられたemailとusernameで<code>User</code>インスタンスを生成する<code>build_user</code>関数を示しています。
<code>active</code>フィールドには<code>true</code>値が入り、<code>sign_in_count</code>には値<code>1</code>が入ります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-4: A `build_user` function that takes an email
and username and returns a `User` instance</span>
-->
<p><span class="caption">リスト5-4: Eメールとユーザ名を取り、<code>User</code>インスタンスを返す<code>build_user</code>関数</span></p>
<!--
It makes sense to name the function parameters with the same name as the struct
fields, but having to repeat the `email` and `username` field names and
variables is a bit tedious. If the struct had more fields, repeating each name
would get even more annoying. Luckily, there's a convenient shorthand!
-->
<p>構造体のフィールドと同じ名前を関数の引数にもつけることは筋が通っていますが、
<code>email</code>と<code>username</code>というフィールド名と変数を繰り返さなきゃいけないのは、ちょっと面倒です。
構造体にもっとフィールドがあれば、名前を繰り返すことはさらに煩わしくなるでしょう。
幸運なことに、便利な省略記法があります！</p>
<!--
### Using the Field Init Shorthand when Variables and Fields Have the Same Name
-->
<h3 id="フィールドと変数が同名の時にフィールド初期化省略記法を使う"><a class="header" href="#フィールドと変数が同名の時にフィールド初期化省略記法を使う">フィールドと変数が同名の時にフィールド初期化省略記法を使う</a></h3>
<!--
Because the parameter names and the struct field names are exactly the same in
Listing 5-4, we can use the *field init shorthand* syntax to rewrite
`build_user` so that it behaves exactly the same but doesn’t have the
repetition of `email` and `username`, as shown in Listing 5-5.
-->
<p>仮引数名と構造体のフィールド名がリスト5-4では、全く一緒なので、<em>フィールド初期化省略</em>記法を使って<code>build_user</code>を書き換えても、
振る舞いは全く同じにしつつ、リスト5-5に示したように<code>email</code>と<code>username</code>を繰り返さなくてもよくなります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-5: A `build_user` function that uses field init
shorthand because the `email` and `username` parameters have the same name as
struct fields</span>
-->
<p><span class="caption">リスト5-5: <code>email</code>と<code>username</code>引数が構造体のフィールドと同名なので、
フィールド初期化省略法を使用する<code>build_user</code>関数</span></p>
<!--
Here, we’re creating a new instance of the `User` struct, which has a field
named `email`. We want to set the `email` field’s value to the value in the
`email` parameter of the `build_user` function. Because the `email` field and
the `email` parameter have the same name, we only need to write `email` rather
than `email: email`.
-->
<p>ここで、<code>email</code>というフィールドを持つ<code>User</code>構造体の新規インスタンスを生成しています。
<code>email</code>フィールドを<code>build_user</code>関数の<code>email</code>引数の値にセットしたいわけです。
<code>email</code>フィールドと<code>email</code>引数は同じ名前なので、<code>email: email</code>と書くのではなく、
<code>email</code>と書くだけで済むのです。</p>
<!--
### Creating Instances From Other Instances With Struct Update Syntax
-->
<h3 id="構造体更新記法で他のインスタンスからインスタンスを生成する"><a class="header" href="#構造体更新記法で他のインスタンスからインスタンスを生成する">構造体更新記法で他のインスタンスからインスタンスを生成する</a></h3>
<!--
It’s often useful to create a new instance of a struct that uses most of an old
instance’s values, but changes some. You'll do this using *struct update syntax*.
-->
<p>多くは前のインスタンスの値を使用しつつ、変更する箇所もある形で新しいインスタンスを生成できるとしばしば有用です。
<em>構造体更新記法</em>でそうすることができます。</p>
<!--
First, Listing 5-6 shows how we create a new `User` instance in `user2` without
the update syntax. We set new values for `email` and `username`, but otherwise
use the same values from `user1` that we created in Listing 5-2.
-->
<p>まず、リスト5-6では、更新記法なしで<code>user2</code>に新しい<code>User</code>インスタンスを生成する方法を示しています。
<code>email</code>と<code>username</code>には新しい値をセットしていますが、それ以外にはリスト5-2で生成した<code>user1</code>の値を使用しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let user1 = User {
</span><span class="boring">    email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">    username: String::from(&quot;someusername123&quot;),
</span><span class="boring">    active: true,
</span><span class="boring">    sign_in_count: 1,
</span><span class="boring">};
</span><span class="boring">
</span>let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-6: Creating a new `User` instance using some of
the values from `user1`</span>
-->
<p><span class="caption">リスト5-6: <code>user1</code>の一部の値を使用しつつ、新しい<code>User</code>インスタンスを生成する</span></p>
<!--
Using struct update syntax, we can achieve the same effect with less code,
shown in Listing 5-7. The syntax `..` specifies that the remaining fields not
explicitly set should have the same value as the fields in the given instance.
-->
<p>構造体更新記法を使用すると、リスト5-7に示したように、コード量を減らしつつ、同じ効果を達成できます。<code>..</code>という記法により、
明示的にセットされていない残りのフィールドが、与えられたインスタンスのフィールドと同じ値になるように指定します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let user1 = User {
</span><span class="boring">    email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">    username: String::from(&quot;someusername123&quot;),
</span><span class="boring">    active: true,
</span><span class="boring">    sign_in_count: 1,
</span><span class="boring">};
</span><span class="boring">
</span>let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    ..user1
};
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-7: Using struct update syntax to set new
`email` and `username` values for a `User` instance but use the rest of the
values from the fields of the instance in the `user1` variable</span>
-->
<p><span class="caption">リスト5-7: 構造体更新記法を使用して、新しい<code>User</code>インスタンス用の値に新しい<code>email</code>と<code>username</code>をセットしつつ、
残りの値は、<code>user1</code>変数のフィールド値を使う</span></p>
<!--
The code in Listing 5-7 also creates an instance in `user2` that has a
different value for `email` and `username` but has the same values for the
`active` and `sign_in_count` fields from `user1`.
-->
<p>リスト5-7のコードも、<code>email</code>と<code>username</code>については異なる値、<code>active</code>と<code>sign_in_count</code>フィールドについては、
<code>user1</code>と同じ値になるインスタンスを<code>user2</code>に生成します。</p>
<!--
### Using Tuple Structs without Named Fields to Create Different Types
-->
<h3 id="異なる型を生成する名前付きフィールドのないタプル構造体を使用する"><a class="header" href="#異なる型を生成する名前付きフィールドのないタプル構造体を使用する">異なる型を生成する名前付きフィールドのないタプル構造体を使用する</a></h3>
<!--
We can also define structs that look similar to tuples, called *tuple
structs*. Tuple structs have the added meaning the struct name provides but
don’t have names associated with their fields; rather, they just have the types
of the fields. Tuple structs are useful when you want to give the whole tuple a
name and make the tuple be a different type than other tuples, and naming each
field as in a regular struct would be verbose or redundant.
-->
<p>構造体名により追加の意味を含むものの、フィールドに紐づけられた名前がなく、むしろフィールドの型だけの<em>タプル構造体</em>と呼ばれる、
タプルに似た構造体を定義することもできます。タプル構造体は、構造体名が提供する追加の意味は含むものの、
フィールドに紐付けられた名前はありません; むしろ、フィールドの型だけが存在します。タプル構造体は、タプル全体に名前をつけ、
そのタプルを他のタプルとは異なる型にしたい場合に有用ですが、普通の構造体のように各フィールド名を与えるのは、
冗長、または余計になるでしょう。</p>
<!--
To define a tuple struct, you start with the `struct` keyword and the struct name
followed by the types in the tuple. For example, here are definitions and
usages of two tuple structs named `Color` and `Point`:
-->
<p>タプル構造体を定義するには、<code>struct</code>キーワードの後に構造体名、さらにタプルに含まれる型を続けます。
例えば、こちらは、<code>Color</code>と<code>Point</code>という2種類のタプル構造体の定義と使用法です:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<!--
Note that the `black` and `origin` values are different types, because they’re
instances of different tuple structs. Each struct we define is its own type,
even though the fields within the struct have the same types. For example, a
function that takes a parameter of type `Color` cannot take a `Point` as an
argument, even though both types are made up of three `i32` values. Otherwise,
tuple struct instances behave like tuples: you destructure them into their
individual pieces, you can use a `.` followed by the index to access an
individual value, and so on.
-->
<p><code>black</code>と<code>origin</code>の値は、違う型であることに注目してください。これらは、異なるタプル構造体のインスタンスだからですね。
定義された各構造体は、構造体内のフィールドが同じ型であっても、それ自身が独自の型になります。
例えば、<code>Color</code>型を引数に取る関数は、<code>Point</code>を引数に取ることはできません。たとえ、両者の型が、
3つの<code>i32</code>値からできていてもです。それ以外については、タプル構造体のインスタンスは、
タプルと同じように振る舞います: 分配して個々の部品にしたり、<code>.</code>と添え字を使用して個々の値にアクセスするなどです。</p>
<!--
### Unit-Like Structs without Any Fields
-->
<h3 id="フィールドのないユニット様よう構造体"><a class="header" href="#フィールドのないユニット様よう構造体">フィールドのないユニット<ruby>様<rp>(</rp><rt>よう</rt><rp>)</rp></ruby>構造体</a></h3>
<!--
We can also define structs that don’t have any fields! These are called
*unit-like structs* because they behave similarly to `()`, the unit type.
Unit-like structs can be useful in situations in which you need to implement a
trait on some type but you don’t have any data that you want to store in the type
itself. We’ll discuss traits in Chapter 10.
-->
<p>また、一切フィールドのない構造体を定義することもできます！これらは、<code>()</code>、ユニット型と似たような振る舞いをすることから、
<em>ユニット様構造体</em>と呼ばれます。ユニット様構造体は、ある型にトレイトを実装するけれども、
型自体に保持させるデータは一切ない場面に有効になります。トレイトについては第10章で議論します。</p>
<!--
以下のパラグラフでは、引用されてるブロックの後に、和訳を示します。こうしないと、意図通りのレイアウトにならないようです
-->
<!--
### Ownership of Struct Data
In the `User` struct definition in Listing 5-1, we used the owned `String`
type rather than the `&str` string slice type. This is a deliberate choice
because we want instances of this struct to own all of its data and for that
data to be valid for as long as the entire struct is valid.

It’s possible for structs to store references to data owned by something else,
but to do so requires the use of *lifetimes*, a Rust feature that we’ll
discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct
is valid for as long as the struct is. Let’s say you try to store a reference
in a struct without specifying lifetimes, like this, which won't work:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
struct User {
username: &str,
email: &str,
sign_in_count: u64,
active: bool,
}

fn main() {
let user1 = User {
email: "someone@example.com",
username: "someusername123",
active: true,
sign_in_count: 1,
};
}
```

The compiler will complain that it needs lifetime specifiers:

```text
error[E0106]: missing lifetime specifier

|
2 |     username: &str,
|               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier

|
3 |     email: &str,
|            ^ expected lifetime parameter
```

In Chapter 10, we’ll discuss how to fix these errors so you can store
references in structs, but for now, we’ll fix errors like these using owned
types like `String` instead of references like `&str`.
-->
<blockquote>
<h3 id="構造体データの所有権"><a class="header" href="#構造体データの所有権">構造体データの所有権</a></h3>
<p>リスト5-1の<code>User</code>構造体定義において、<code>&amp;str</code>文字列スライス型ではなく、所有権のある<code>String</code>型を使用しました。
これは意図的な選択です。というのも、この構造体のインスタンスには全データを所有してもらう必要があり、
このデータは、構造体全体が有効な間はずっと有効である必要があるのです。</p>
<p>構造体に、他の何かに所有されたデータへの参照を保持させることもできますが、
そうするには<em>ライフタイム</em>という第10章で議論するRustの機能を使用しなければなりません。
ライフタイムのおかげで構造体に参照されたデータが、構造体自体が有効な間、ずっと有効であることを保証してくれるのです。
ライフタイムを指定せずに構造体に参照を保持させようとしたとしましょう。以下の通りですが、これは動きません:</p>
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>コンパイラは、ライフタイム指定子が必要だと怒るでしょう:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
(エラー: ライフタイム指定子がありません)
 --&gt;
  | 
2 |     username: &amp;str,
  |               ^ expected lifetime parameter
                   (ライフタイム引数を予期しました)

error[E0106]: missing lifetime specifier
 --&gt;
  | 
3 |     email: &amp;str,
  |            ^ expected lifetime parameter
</code></pre>
<p>第10章で、これらのエラーを解消して構造体に参照を保持する方法について議論しますが、
当面、今回のようなエラーは、<code>&amp;str</code>のような参照の代わりに、<code>String</code>のような所有された型を使うことで修正します。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><!--
## An Example Program Using Structs
-->
<h2 id="構造体を使ったプログラム例"><a class="header" href="#構造体を使ったプログラム例">構造体を使ったプログラム例</a></h2>
<!--
To understand when we might want to use structs, let’s write a program that
calculates the area of a rectangle. We’ll start with single variables, and then
refactor the program until we’re using structs instead.
-->
<p>構造体を使用したくなる可能性のあるケースを理解するために、長方形の面積を求めるプログラムを書きましょう。
単一の変数から始め、代わりに構造体を使うようにプログラムをリファクタリングします。</p>
<!--
Let’s make a new binary project with Cargo called *rectangles* that will take
the width and height of a rectangle specified in pixels and will calculate the area
of the rectangle. Listing 5-8 shows a short program with one way of doing
exactly that in our project’s *src/main.rs*.
-->
<p>Cargoで<em>rectangles</em>という新規バイナリプロジェクトを作成しましょう。このプロジェクトは、
長方形の幅と高さをピクセルで指定し、その面積を求めます。リスト5-8に、プロジェクトの<em>src/main.rs</em>で、
正にそうする一例を短いプログラムとして示しました。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        // 長方形の面積は、{}平方ピクセルです
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-8: Calculating the area of a rectangle
specified by separate width and height variables</span>
-->
<p><span class="caption">リスト5-8: 個別の幅と高さ変数を指定して長方形の面積を求める</span></p>
<!--
Now, run this program using `cargo run`:
-->
<p>では、<code>cargo run</code>でこのプログラムを走らせてください:</p>
<pre><code class="language-text">The area of the rectangle is 1500 square pixels.
(長方形の面積は、1500平方ピクセルです)
</code></pre>
<!--
### Refactoring with Tuples
-->
<h3 id="タプルでリファクタリングする"><a class="header" href="#タプルでリファクタリングする">タプルでリファクタリングする</a></h3>
<!--
Even though Listing 5-8 works and figures out the area of the rectangle by
calling the `area` function with each dimension, we can do better. The width
and the height are related to each other because together they describe one
rectangle.
-->
<p>リスト5-8のコードはうまく動き、各寸法を与えて<code>area</code>関数を呼び出すことで長方形の面積を割り出しますが、
改善点があります。幅と高さは、組み合わせると一つの長方形を表すので、相互に関係があるわけです。</p>
<!--
The issue with this code is evident in the signature of `area`:
-->
<p>このコードの問題点は、<code>area</code>のシグニチャから明らかです:</p>
<pre><code class="language-rust ignore">fn area(width: u32, height: u32) -&gt; u32 {
</code></pre>
<!--
The `area` function is supposed to calculate the area of one rectangle, but the
function we wrote has two parameters. The parameters are related, but that’s
not expressed anywhere in our program. It would be more readable and more
manageable to group width and height together. We’ve already discussed one way
we might do that in the "The Tuple Type" section of Chapter 3: by using tuples.
-->
<p><code>area</code>関数は、1長方形の面積を求めるものと考えられますが、今書いた関数には、引数が2つあります。
引数は関連性があるのに、このプログラム内のどこにもそのことは表現されていません。
幅と高さを一緒にグループ化する方が、より読みやすく、扱いやすくなるでしょう。
それをする一つの方法については、第3章の「タプル型」節ですでに議論しました: タプルを使うのです。</p>
<!--
### Refactoring with Tuples
-->
<h3 id="タプルでリファクタリングする-1"><a class="header" href="#タプルでリファクタリングする-1">タプルでリファクタリングする</a></h3>
<!--
Listing 5-9 shows another version of our program that uses tuples.
-->
<p>リスト5-9は、タプルを使う別バージョンのプログラムを示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-9: Specifying the width and height of the
rectangle with a tuple</span>
-->
<p><span class="caption">リスト5-9: タプルで長方形の幅と高さを指定する</span></p>
<!--
In one way, this program is better. Tuples let us add a bit of structure, and
we’re now passing just one argument. But in another way, this version is less
clear: tuples don’t name their elements, so our calculation has become more
confusing because we have to index into the parts of the tuple.
-->
<p>ある意味では、このプログラムはマシです。タプルのおかげで少し構造的になり、一引数を渡すだけになりました。
しかし別の意味では、このバージョンは明確性を失っています: タプルは要素に名前を付けないので、
計算が不明瞭になったのです。なぜなら、タプルの一部に添え字アクセスする必要があるからです。</p>
<!--
It doesn’t matter if we mix up width and height for the area calculation, but
if we want to draw the rectangle on the screen, it would matter! We would have
to keep in mind that `width` is the tuple index `0` and `height` is the tuple
index `1`. If someone else worked on this code, they would have to figure this
out and keep it in mind as well. It would be easy to forget or mix up these
values and cause errors, because we haven’t conveyed the meaning of our data in
our code.
-->
<p>面積計算で幅と高さを混在させるのなら問題はないのですが、長方形を画面に描画したいとなると、問題になるのです！
タプルの添え字<code>0</code>が<code>幅</code>で、添え字<code>1</code>が<code>高さ</code>であることを肝に銘じておかなければなりません。
他人がこのコードをいじることになったら、このことを割り出し、同様に肝に銘じなければならないでしょう。
容易く、このことを忘れたり、これらの値を混ぜこぜにしたりしてエラーを発生させてしまうでしょう。
データの意味をコードに載せていないからです。</p>
<!--
### Refactoring with Structs: Adding More Meaning
-->
<h3 id="構造体でリファクタリングする-より意味付けする"><a class="header" href="#構造体でリファクタリングする-より意味付けする">構造体でリファクタリングする: より意味付けする</a></h3>
<!--
We use structs to add meaning by labeling the data. We can transform the tuple
we’re using into a data type with a name for the whole as well as names for the
parts, as shown in Listing 5-10.
-->
<p>データのラベル付けで意味を付与するために構造体を使います。現在使用しているタプルを全体と一部に名前のあるデータ型に、
変形することができます。そう、リスト5-10に示したように。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-10: Defining a `Rectangle` struct</span>
-->
<p><span class="caption">リスト5-10: <code>Rectangle</code>構造体を定義する</span></p>
<!--
Here we’ve defined a struct and named it `Rectangle`. Inside the curly
brackets, we defined the fields as `width` and `height`, both of which have
type `u32`. Then in `main`, we create a particular instance of a `Rectangle`
that has a width of 30 and a height of 50.
-->
<p>ここでは、構造体を定義し、<code>Rectangle</code>という名前にしています。波括弧の中で<code>width</code>と<code>height</code>というフィールドを定義し、
<code>u32</code>という型にしました。それから<code>main</code>内で<code>Rectangle</code>の特定のインスタンスを生成し、
幅を30、高さを50にしました。</p>
<!--
Our `area` function is now defined with one parameter, which we’ve named
`rectangle`, whose type is an immutable borrow of a struct `Rectangle`
instance. As mentioned in Chapter 4, we want to borrow the struct rather than
take ownership of it. This way, `main` retains its ownership and can continue
using `rect1`, which is the reason we use the `&` in the function signature and
where we call the function.
-->
<p>これで<code>area</code>関数は引数が一つになり、この引数は名前が<code>rectangle</code>、型は<code>Rectangle</code>構造体インスタンスへの不変借用になりました。
第4章で触れたように、構造体の所有権を奪うよりも借用する必要があります。こうすることで<code>main</code>は所有権を保って、
<code>rect1</code>を使用し続けることができ、そのために関数シグニチャと関数呼び出し時に<code>&amp;</code>を使っているわけです。</p>
<!--
The `area` function accesses the `width` and `height` fields of the `Rectangle`
instance. Our function signature for `area` now indicates exactly what we mean:
calculate the area of a `Rectangle`, using its `width` and `height` fields. This
conveys that the width and height are related to each other, and it gives
descriptive names to the values rather than using the tuple index values of `0`
and `1`. This is a win for clarity.
-->
<p><code>area</code>関数は、<code>Rectangle</code>インスタンスの<code>width</code>と<code>height</code>フィールドにアクセスしています。
これで、<code>area</code>の関数シグニチャは、我々の意図をズバリ示すようになりました: <code>width</code>と<code>height</code>フィールドを使って、
<code>Rectangle</code>の面積を計算します。これにより、幅と高さが相互に関係していることが伝わり、
タプルの<code>0</code>や<code>1</code>という添え字を使うよりも、これらの値に説明的な名前を与えられるのです。プログラムの意図が明瞭になりました。</p>
<!--
### Adding Useful Functionality with Derived Traits
-->
<h3 id="トレイトの導出で有用な機能を追加する"><a class="header" href="#トレイトの導出で有用な機能を追加する">トレイトの導出で有用な機能を追加する</a></h3>
<!--
It’d be nice to be able to print an instance of `Rectangle` while we’re
debugging our program and see the values for all its fields. Listing 5-11 tries
using the `println!` macro as we have used it in previous chapters. This won't
work, however.
-->
<p>プログラムのデバッグをしている間に、<code>Rectangle</code>のインスタンスを出力し、フィールドの値を確認できると、
素晴らしいわけです。リスト5-11では、以前の章のように、<code>println!</code>マクロを試しに使用しようとしていますが、動きません。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    // rect1は{}です
    println!(&quot;rect1 is {}&quot;, rect1);
}
</code></pre>
<!--
<span class="caption">Listing 5-11: Attempting to print a `Rectangle`
instance</span>
-->
<p><span class="caption">リスト5-11: <code>Rectangle</code>のインスタンスを出力しようとする</span></p>
<!--
When we run this code, we get an error with this core message:
-->
<p>このコードを走らせると、こんな感じのエラーが出ます:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Rectangle: std::fmt::Display` is not satisfied
(エラー: トレイト境界`Rectangle: std::fmt::Display`が満たされていません)
</code></pre>
<!--
The `println!` macro can do many kinds of formatting, and by default, the curly
brackets tell `println!` to use formatting known as `Display`: output intended
for direct end user consumption. The primitive types we’ve seen so far
implement `Display` by default, because there’s only one way you’d want to show
a `1` or any other primitive type to a user. But with structs, the way
`println!` should format the output is less clear because there are more
display possibilities: do you want commas or not? Do you want to print the
curly brackets? Should all the fields be shown? Due to this ambiguity, Rust
doesn't try to guess what we want, and structs don’t have a provided
implementation of `Display`.
-->
<p><code>println!</code>マクロには、様々な整形があり、標準では、波括弧は<code>Display</code>として知られる整形をするよう、
<code>println!</code>に指示するのです: 直接エンドユーザ向けの出力です。これまでに見てきた基本型は、
標準で<code>Display</code>を実装しています。というのも、<code>1</code>や他の基本型をユーザに見せる方法は一つしかないからです。
しかし構造体では、<code>println!</code>が出力を整形する方法は自明ではなくなります。出力方法がいくつもあるからです:
カンマは必要なの？波かっこを出力する必要はある？全フィールドが見えるべき？この曖昧性のため、
Rustは必要なものを推測しようとせず、構造体には<code>Display</code>実装が提供されないのです。</p>
<!--
If we continue reading the errors, we’ll find this helpful note:
-->
<p>エラーを読み下すと、こんな有益な注意書きがあります:</p>
<pre><code class="language-text">`Rectangle` cannot be formatted with the default formatter; try using
`:?` instead if you are using a format string
(注釈: `Rectangle`は、デフォルト整形機では、整形できません; フォーマット文字列を使うのなら
代わりに`:?`を試してみてください)
</code></pre>
<!--
Let’s try it! The `println!` macro call will now look like `println!("rect1 is
{:?}", rect1);`. Putting the specifier `:?` inside the curly brackets tells
`println!` we want to use an output format called `Debug`. The `Debug` trait
enables us to print our struct in a way that is useful for developers so we can
see its value while we’re debugging our code.
-->
<p>試してみましょう！<code>pritnln!</code>マクロ呼び出しは、<code>println!(&quot;rect1 is {:?}&quot;, rect1);</code>という見た目になるでしょう。
波括弧内に<code>:?</code>という指定子を書くと、<code>println!</code>に<code>Debug</code>と呼ばれる出力整形を使いたいと指示するのです。
<code>Debug</code>トレイトは、開発者にとって有用な方法で構造体を出力させてくれるので、
コードをデバッグしている最中に、値を確認することができます。</p>
<!--
Run the code with this change. Drat! We still get an error:
-->
<p>変更してコードを走らせてください。なに！まだエラーが出ます:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Rectangle: std::fmt::Debug` is not satisfied
(エラー: トレイト境界`Rectangle: std::fmt::Debug`が満たされていません)
</code></pre>
<!--
But again, the compiler gives us a helpful note:
-->
<p>しかし今回も、コンパイラは有益な注意書きを残してくれています:</p>
<pre><code class="language-text">`Rectangle` cannot be formatted using `:?`; if it is defined in your
crate, add `#[derive(Debug)]` or manually implement it
(注釈: `Rectangle`は`:?`を使って整形できません; 自分のクレートで定義しているのなら
`#[derive(Debug)]`を追加するか、手動で実装してください)
</code></pre>
<!--
Rust *does* include functionality to print out debugging information, but we
have to explicitly opt in to make that functionality available for our struct.
To do that, we add the annotation `#[derive(Debug)]` just before the struct
definition, as shown in Listing 5-12.
-->
<p><em>確かに</em>Rustにはデバッグ用の情報を出力する機能が備わっていますが、この機能を構造体で使えるようにするには、
明示的な選択をしなければならないのです。そうするには、構造体定義の直前に<code>#[derive(Debug)]</code>という注釈を追加します。
そう、リスト5-12で示されている通りです。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-12: Adding the annotation to derive the `Debug`
trait and printing the `Rectangle` instance using debug formatting</span>
-->
<p><span class="caption">リスト5-12: <code>Debug</code>トレイトを導出する注釈を追加し、
<code>Rectangle</code>インスタンスをデバッグ用整形機で出力する</span></p>
<!--
Now when we run the program, we won’t get any errors, and we’ll see the
following output:
-->
<p>これでプログラムを実行すれば、エラーは出ず、以下のような出力が得られるでしょう:</p>
<pre><code class="language-text">rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<!--
Nice! It’s not the prettiest output, but it shows the values of all the fields
for this instance, which would definitely help during debugging. When we have
larger structs, it’s useful to have output that’s a bit easier to read; in
those cases, we can use `{:#?}` instead of `{:?}` in the `println!` string.
When we use the `{:#?}` style in the example, the output will look like this:
-->
<p>素晴らしい！最善の出力ではないものの、このインスタンスの全フィールドの値を出力しているので、
デバッグ中には間違いなく役に立つでしょう。より大きな構造体があるなら、もう少し読みやすい出力の方が有用です;
そのような場合には、<code>println!</code>文字列中の<code>{:?}</code>の代わりに<code>{:#?}</code>を使うことができます。
この例で<code>{:#?}</code>というスタイルを使用したら、出力は以下のようになるでしょう:</p>
<pre><code class="language-text">rect1 is Rectangle {
    width: 30,
    height: 50
}
</code></pre>
<!--
Rust has provided a number of traits for us to use with the `derive` annotation
that can add useful behavior to our custom types. Those traits and their
behaviors are listed in Appendix C. We’ll cover how to implement these traits
with custom behavior as well as how to create your own traits in Chapter 10.
-->
<p>Rustには、<code>derive</code>注釈で使えるトレイトが多く提供されており、独自の型に有用な振る舞いを追加することができます。
そのようなトレイトとその振る舞いは、付録Cで一覧になっています。
これらのトレイトを独自の動作とともに実装する方法だけでなく、独自のトレイトを生成する方法については、第10章で解説します。</p>
<!--
Our `area` function is very specific: it only computes the area of rectangles.
It would be helpful to tie this behavior more closely to our `Rectangle`
struct, because it won’t work with any other type. Let’s look at how we can
continue to refactor this code by turning the `area` function into an `area`
*method* defined on our `Rectangle` type.
-->
<p><code>area</code>関数は、非常に特殊です: 長方形の面積を算出するだけです。<code>Rectangle</code>構造体とこの動作をより緊密に結び付けられると、
役に立つでしょう。なぜなら、他のどんな型でもうまく動作しなくなるからです。
<code>area</code>関数を<code>Rectangle</code>型に定義された<code>area</code><em>メソッド</em>に変形することで、
このコードをリファクタリングし続けられる方法について見ていきましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Method Syntax
-->
<h2 id="メソッド記法"><a class="header" href="#メソッド記法">メソッド記法</a></h2>
<!--
*Methods* are similar to functions: they’re declared with the `fn` keyword and
their name, they can have parameters and a return value, and they contain some
code that is run when they’re called from somewhere else. However, methods are
different from functions in that they’re defined within the context of a struct
(or an enum or a trait object, which we cover in Chapters 6 and 17,
respectively), and their first parameter is always `self`, which represents the
instance of the struct the method is being called on.
-->
<p><em>メソッド</em>は関数に似ています: <code>fn</code>キーワードと名前で宣言されるし、引数と返り値があるし、
どこか別の場所で呼び出された時に実行されるコードを含みます。ところが、
メソッドは構造体の文脈(あるいはenumかトレイトオブジェクトの。これらについては各々第6章と17章で解説します)で定義されるという点で、
関数とは異なり、最初の引数は必ず<code>self</code>になり、これはメソッドが呼び出されている構造体インスタンスを表します。</p>
<!--
### Defining Methods
-->
<h3 id="メソッドを定義する"><a class="header" href="#メソッドを定義する">メソッドを定義する</a></h3>
<!--
Let’s change the `area` function that has a `Rectangle` instance as a parameter
and instead make an `area` method defined on the `Rectangle` struct, as shown
in Listing 5-13.
-->
<p><code>Rectangle</code>インスタンスを引数に取る<code>area</code>関数を変え、代わりに<code>Rectangle</code>構造体上に<code>area</code>メソッドを作りましょう。
リスト5-13に示した通りですね。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 5-13: Defining an `area` method on the
`Rectangle` struct</span>
-->
<p><span class="caption">リスト5-13: <code>Rectangle</code>構造体上に<code>area</code>メソッドを定義する</span></p>
<!--
To define the function within the context of `Rectangle`, we start an `impl`
(implementation) block. Then we move the `area` function within the `impl`
curly brackets and change the first (and in this case, only) parameter to be
`self` in the signature and everywhere within the body. In `main`, where we
called the `area` function and passed `rect1` as an argument, we can instead
use *method syntax* to call the `area` method on our `Rectangle` instance.
The method syntax goes after an instance: we add a dot followed by the method
name, parentheses, and any arguments.
-->
<p><code>Rectangle</code>の文脈内で関数を定義するには、<code>impl</code>(implementation; 実装)ブロックを始めます。
それから<code>area</code>関数を<code>impl</code>の波かっこ内に移動させ、最初の(今回は唯一の)引数をシグニチャ内と本体内全てで<code>self</code>に変えます。
<code>area</code>関数を呼び出し、<code>rect1</code>を引数として渡す<code>main</code>では、代替としてメソッド記法を使用して、
<code>Rectangle</code>インスタンスの<code>area</code>メソッドを呼び出せます。メソッド記法は、インスタンスの後に続きます:
ドット、メソッド名、かっこ、そして引数と続くわけです。</p>
<!--
In the signature for `area`, we use `&self` instead of `rectangle: &Rectangle`
because Rust knows the type of `self` is `Rectangle` due to this method being
inside the `impl Rectangle` context. Note that we still need to use the `&`
before `self`, just like we did in `&Rectangle`. Methods can take ownership of
`self`, borrow `self` immutably as we’ve done here, or borrow `self` mutably,
just as they can any other parameter.
-->
<p><code>area</code>のシグニチャでは、<code>rectangle: &amp;Rectangle</code>の代わりに<code>&amp;self</code>を使用しています。
というのも、コンパイラは、このメソッドが<code>impl Rectangle</code>という文脈内に存在するために、
<code>self</code>の型が<code>Rectangle</code>であると把握しているからです。<code>&amp;Rectangle</code>と同様に、
<code>self</code>の直前に<code>&amp;</code>を使用していることに注意してください。メソッドは、<code>self</code>の所有権を奪ったり、
ここでしているように不変で<code>self</code>を借用したり、可変で<code>self</code>を借用したりできるのです。
他の引数と全く同じですね。</p>
<!--
We’ve chosen `&self` here for the same reason we used `&Rectangle` in the
function version: we don’t want to take ownership, and we just want to read the
data in the struct, not write to it. If we wanted to change the instance that
we’ve called the method on as part of what the method does, we’d use `&mut
self` as the first parameter. Having a method that takes ownership of the
instance by using just `self` as the first parameter is rare; this technique is
usually used when the method transforms `self` into something else and we want
to prevent the caller from using the original instance after the transformation.
-->
<p>ここで<code>&amp;self</code>を選んでいるのは、関数バージョンで<code>&amp;Rectangle</code>を使用していたのと同様の理由です:
所有権はいらず、構造体のデータを読み込みたいだけで、書き込む必要はないわけです。
メソッドの一部でメソッドを呼び出したインスタンスを変更したかったら、第1引数に<code>&amp;mut self</code>を使用するでしょう。
<code>self</code>だけを第1引数にしてインスタンスの所有権を奪うメソッドを定義することは稀です; このテクニックは通常、
メソッドが<code>self</code>を何か別のものに変形し、変形後に呼び出し元が元のインスタンスを使用できないようにしたい場合に使用されます。</p>
<!--
The main benefit of using methods instead of functions, in addition to using
method syntax and not having to repeat the type of `self` in every method’s
signature, is for organization. We’ve put all the things we can do with an
instance of a type in one `impl` block rather than making future users of our
code search for capabilities of `Rectangle` in various places in the library we
provide.
-->
<p>関数の代替としてメソッドを使う主な利点は、メソッド記法を使用して全メソッドのシグニチャで<code>self</code>の型を繰り返す必要がなくなる以外だと、
体系化です。コードの将来的な利用者に<code>Rectangle</code>の機能を提供しているライブラリ内の各所でその機能を探させるのではなく、
この型のインスタンスでできることを一つの<code>impl</code>ブロックにまとめあげています。</p>
<!--
例によって、以下の節では、引用ブロックの後に和訳を示します
-->
<!--
### Where’s the `->` Operator?

In C and C++, two different operators are used for calling methods: you use
`.` if you’re calling a method on the object directly and `->` if you're
calling the method on a pointer to the object and need to dereference the
pointer first. In other words, if `object` is a pointer,
`object->something()` is similar to `(*object).something()`.

Rust doesn’t have an equivalent to the `->` operator; instead, Rust has a
feature called *automatic referencing and dereferencing*. Calling methods is
one of the few places in Rust that has this behavior.

Here’s how it works: when you call a method with `object.something()`, Rust
automatically adds in `&`, `&mut`, or `*` so `object` matches the signature of
the method. In other words, the following are the same:

```rust
# #[derive(Debug,Copy,Clone)]
# struct Point {
#     x: f64,
#     y: f64,
# }
#
# impl Point {
#    fn distance(&self, other: &Point) -> f64 {
#        let x_squared = f64::powi(other.x - self.x, 2);
#        let y_squared = f64::powi(other.y - self.y, 2);
#
#        f64::sqrt(x_squared + y_squared)
#    }
# }
# let p1 = Point { x: 0.0, y: 0.0 };
# let p2 = Point { x: 5.0, y: 6.5 };
p1.distance(&p2);
(&p1).distance(&p2);
```

The first one looks much cleaner. This automatic referencing behavior works
because methods have a clear receiver—the type of `self`. Given the receiver
and name of a method, Rust can figure out definitively whether the method is
reading (`&self`), mutating (`&mut self`), or consuming (`self`). The fact
that Rust makes borrowing implicit for method receivers is a big part of
making ownership ergonomic in practice.
-->
<blockquote>
<h3 id="-演算子はどこに行ったの"><a class="header" href="#-演算子はどこに行ったの"><code>-&gt;</code>演算子はどこに行ったの？</a></h3>
<p>CとC++では、メソッド呼び出しには2種類の異なる演算子が使用されます:
オブジェクトに対して直接メソッドを呼び出すのなら、<code>.</code>を使用するし、オブジェクトのポインタに対してメソッドを呼び出し、
先にポインタを参照外しする必要があるなら、<code>-&gt;</code>を使用するわけです。
言い換えると、<code>object</code>がポインタなら、<code>object-&gt;something()</code>は、<code>(*object).something()</code>と同等なのです。</p>
<p>Rustには<code>-&gt;</code>演算子の代わりとなるようなものはありません; その代わり、Rustには、
<em>自動参照および参照外し</em>という機能があります。Rustにおいてメソッド呼び出しは、
この動作が行われる数少ない箇所なのです。</p>
<p>動作方法はこうです: <code>object.something()</code>とメソッドを呼び出すと、
コンパイラは<code>object</code>がメソッドのシグニチャと合致するように、自動で<code>&amp;</code>か<code>&amp;mut</code>、<code>*</code>を付与するのです。
要するに、以下のコードは同じものです:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>前者の方がずっと明確です。メソッドには自明な受け手(<code>self</code>の型)がいるので、この自動参照機能は動作するのです。
受け手とメソッド名が与えられれば、コンパイラは確実にメソッドが読み込み専用(<code>&amp;self</code>)か、書き込みもする(<code>&amp;mut self</code>)のか、
所有権を奪う(<code>self</code>)のか判断できるわけです。メソッドの受け手に関して借用が明示されないというのが、
所有権を実際に使うのがRustにおいて簡単である大きな理由です。</p>
</blockquote>
<!--
### Methods with More Parameters
-->
<h3 id="より引数の多いメソッド"><a class="header" href="#より引数の多いメソッド">より引数の多いメソッド</a></h3>
<!--
Let’s practice using methods by implementing a second method on the `Rectangle`
struct. This time, we want an instance of `Rectangle` to take another instance
of `Rectangle` and return `true` if the second `Rectangle` can fit completely
within `self`; otherwise it should return `false`. That is, we want to be able
to write the program shown in Listing 5-14, once we’ve defined the `can_hold`
method.
-->
<p><code>Rectangle</code>構造体に2番目のメソッドを実装して、メソッドを使う鍛錬をしましょう。今回は、<code>Rectangle</code>のインスタンスに、
別の<code>Rectangle</code>のインスタンスを取らせ、2番目の<code>Rectangle</code>が<code>self</code>に完全にはめ込まれたら、<code>true</code>を返すようにしたいのです;
そうでなければ、<code>false</code>を返すべきです。つまり、一旦<code>can_hold</code>メソッドを定義したら、
リスト5-14のようなプログラムを書けるようになりたいのです。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    // rect1にrect2ははまり込む？
    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<!--
<span class="caption">Listing 5-14: Using the as-yet-unwritten `can_hold`
method</span>
-->
<p><span class="caption">リスト5-14: まだ書いていない<code>can_hold</code>メソッドを使用する</span></p>
<!--
And the expected output would look like the following, because both dimensions
of `rect2` are smaller than the dimensions of `rect1` but `rect3` is wider than
`rect1`:
-->
<p>そして、予期される出力は以下のようになります。なぜなら、<code>rect2</code>の各寸法は<code>rect1</code>よりも小さいものの、
<code>rect3</code>は<code>rect1</code>より幅が広いからです:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<!--
We know we want to define a method, so it will be within the `impl Rectangle`
block. The method name will be `can_hold`, and it will take an immutable borrow
of another `Rectangle` as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
`rect1.can_hold(&rect2)` passes in `&rect2`, which is an immutable borrow to
`rect2`, an instance of `Rectangle`. This makes sense because we only need to
read `rect2` (rather than write, which would mean we’d need a mutable borrow),
and we want `main` to retain ownership of `rect2` so we can use it again after
calling the `can_hold` method. The return value of `can_hold` will be a
Boolean, and the implementation will check whether the width and height of
`self` are both greater than the width and height of the other `Rectangle`,
respectively. Let’s add the new `can_hold` method to the `impl` block from
Listing 5-13, shown in Listing 5-15.
-->
<p>メソッドを定義したいことはわかっているので、<code>impl Rectangle</code>ブロック内での話になります。
メソッド名は、<code>can_hold</code>になり、引数として別の<code>Rectangle</code>を不変借用で取るでしょう。
メソッドを呼び出すコードを見れば、引数の型が何になるかわかります: <code>rect1.can_hold(&amp;rect2)</code>は、
<code>&amp;rect2</code>、<code>Rectangle</code>のインスタンスである<code>rect2</code>への不変借用を渡しています。
これは道理が通っています。なぜなら、<code>rect2</code>を読み込む(書き込みではなく。この場合、可変借用が必要になります)だけでよく、
<code>can_hold</code>メソッドを呼び出した後にも<code>rect2</code>が使えるよう、所有権を<code>main</code>に残したままにしたいからです。
<code>can_hold</code>の返り値は、booleanになり、メソッドの中身は、<code>self</code>の幅と高さがもう一つの<code>Rectangle</code>の幅と高さよりも、
それぞれ大きいことを確認します。リスト5-13の<code>impl</code>ブロックに新しい<code>can_hold</code>メソッドを追記しましょう。
リスト5-15に示した通りです。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-15: Implementing the `can_hold` method on
`Rectangle` that takes another `Rectangle` instance as a parameter</span>
-->
<p><span class="caption">リスト5-15: 別の<code>Rectangle</code>のインスタンスを引数として取る<code>can_hold</code>メソッドを、
<code>Rectangle</code>に実装する</span></p>
<!--
When we run this code with the `main` function in Listing 5-14, we’ll get our
desired output. Methods can take multiple parameters that we add to the
signature after the `self` parameter, and those parameters work just like
parameters in functions.
-->
<p>このコードをリスト5-14の<code>main</code>関数と合わせて実行すると、望み通りの出力が得られます。
メソッドは、<code>self</code>引数の後にシグニチャに追加した引数を複数取ることができ、
その引数は、関数の引数と同様に動作するのです。</p>
<!--
### Associated Functions
-->
<h3 id="関連関数"><a class="header" href="#関連関数">関連関数</a></h3>
<!--
Another useful feature of `impl` blocks is that we’re allowed to define
functions within `impl` blocks that *don’t* take `self` as a parameter. These
are called *associated functions* because they’re associated with the struct.
They’re still functions, not methods, because they don’t have an instance of
the struct to work with. You’ve already used the `String::from` associated
function.
-->
<p><code>impl</code>ブロックの別の有益な機能は、<code>impl</code>ブロック内に<code>self</code>を引数に取ら<em>ない</em>関数を定義できることです。
これは、構造体に関連付けられているので、<em>関連関数</em>と呼ばれます。それでも、関連関数は関数であり、メソッドではありません。
というのも、対象となる構造体のインスタンスが存在しないからです。もう<code>String::from</code>という関連関数を使用したことがありますね。</p>
<!--
Associated functions are often used for constructors that will return a new
instance of the struct. For example, we could provide an associated function
that would have one dimension parameter and use that as both width and height,
thus making it easier to create a square `Rectangle` rather than having to
specify the same value twice:
-->
<p>関連関数は、構造体の新規インスタンスを返すコンストラクタによく使用されます。例えば、一つの寸法を引数に取り、
長さと幅両方に使用する関連関数を提供することができ、その結果、同じ値を2回指定する必要なく、
正方形の<code>Rectangle</code>を生成しやすくすることができます。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
To call this associated function, we use the `::` syntax with the struct name;
`let sq = Rectangle::square(3);` is an example. This function is namespaced by
the struct: the `::` syntax is used for both associated functions and
namespaces created by modules. We’ll discuss modules in Chapter 7.
-->
<p>この関連関数を呼び出すために、構造体名と一緒に<code>::</code>記法を使用します; 一例は<code>let sq = Rectangle::square(3);</code>です。
この関数は、構造体によって名前空間分けされています: <code>::</code>という記法は、関連関数とモジュールによって作り出される名前空間両方に使用されます。
モジュールについては第7章で議論します。</p>
<!--
### Multiple `impl` Blocks
-->
<h3 id="複数のimplブロック"><a class="header" href="#複数のimplブロック">複数の<code>impl</code>ブロック</a></h3>
<!--
Each struct is allowed to have multiple `impl` blocks. For example, Listing
5-15 is equivalent to the code shown in Listing 5-16, which has each method
in its own `impl` block.
-->
<p>各構造体には、複数の<code>impl</code>ブロックを存在させることができます。例えば、リスト5-15はリスト5-16に示したコードと等価で、
リスト5-16では、各メソッドごとに<code>impl</code>ブロックを用意しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 5-16: Rewriting Listing 5-15 using multiple `impl`
blocks</span>
-->
<p><span class="caption">リスト5-16: 複数の<code>impl</code>ブロックを使用してリスト5-15を書き直す</span></p>
<!--
There’s no reason to separate these methods into multiple `impl` blocks here,
but this is valid syntax. We'll see a case in which multiple `impl` blocks are
useful in Chapter 10, where we discuss generic types and traits.
-->
<p>ここでこれらのメソッドを個々の<code>impl</code>ブロックに分ける理由はないのですが、合法な書き方です。
複数の<code>impl</code>ブロックが有用になるケースは第10章で見ますが、そこではジェネリック型と、トレイトについて議論します。</p>
<!--
## Summary
-->
<h2 id="まとめ-4"><a class="header" href="#まとめ-4">まとめ</a></h2>
<!--
Structs let us create custom types that are meaningful for your domain. By
using structs, we can keep associated pieces of data connected to each other
and name each piece to make our code clear. Methods let us specify the
behavior that instances of our structs have, and associated functions let you
namespace functionality that is particular to our struct without having an
instance available.
-->
<p>構造体により、自分の領域で意味のある独自の型を作成することができます。構造体を使用することで、
関連のあるデータ片を相互に結合させたままにし、各部品に名前を付け、コードを明確にすることができます。
メソッドにより、構造体のインスタンスが行う動作を指定することができ、関連関数により、
構造体に特有の機能をインスタンスを利用することなく、名前空間分けすることができます。</p>
<!--
But structs aren’t the only way we can create custom types: let’s turn to
Rust’s enum feature to add another tool to our toolbox.
-->
<p>しかし、構造体だけが独自の型を作成する手段ではありません: Rustのenum機能に目を向けて、
別の道具を道具箱に追加しましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Enums and Pattern Matching
-->
<h1 id="enumとパターンマッチング"><a class="header" href="#enumとパターンマッチング">Enumとパターンマッチング</a></h1>
<!--
イーナムとカタカナで表記するのも変なので、Enumという表記で統一します
-->
<!--
In this chapter we’ll look at *enumerations*, also referred to as *enums*.
Enums allow you to define a type by enumerating its possible values. First,
we’ll define and use an enum to show how an enum can encode meaning along with
data. Next, we’ll explore a particularly useful enum, called `Option`, which
expresses that a value can be either something or nothing. Then we’ll look at
how pattern matching in the `match` expression makes it easy to run different
code for different values of an enum. Finally, we’ll cover how the `if let`
construct is another convenient and concise idiom available to you to handle
enums in your code.
-->
<p>この章では、<em>列挙型</em>について見ていきます。列挙型は、<em>enum</em>とも称されます。enumは、取りうる値を列挙することで、
型を定義させてくれます。最初に、enumを定義し、使用して、enumがデータとともに意味をコード化する方法を示します。
次に、特別に有用なenumである<code>Option</code>について掘り下げていきましょう。この型は、
値が何かかなんでもないかを表現します。それから、<code>match</code>式のパターンマッチングにより、
どうenumの色々な値に対して異なるコードを走らせやすくなるかを見ます。最後に、<code>if let</code>文法要素も、
<ruby>如何<rp>(</rp><rt>いか</rt><rp>)</rp></ruby>にenumをコードで扱う際に使用可能な便利で簡潔な慣用句であるかを解説します。</p>
<!--
Enums are a feature in many languages, but their capabilities differ in each
language. Rust’s enums are most similar to *algebraic data types* in functional
languages like F#, OCaml, and Haskell.
-->
<p>enumは多くの言語に存在する機能ですが、その能力は言語ごとに異なります。Rustのenumは、F#、OCaml、Haskellなどの、
関数型言語に存在する<em>代数的データ型</em>に最も酷似しています。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Defining an Enum
-->
<h2 id="enumを定義する"><a class="header" href="#enumを定義する">Enumを定義する</a></h2>
<!--
Let’s look at a situation we might want to express in code and see why enums
are useful and more appropriate than structs in this case. Say we need to work
with IP addresses. Currently, two major standards are used for IP addresses:
version four and version six. These are the only possibilities for an IP
address that our program will come across: we can *enumerate* all possible
values, which is where enumeration gets its name.
-->
<p>コードで表現したくなるかもしれない場面に目を向けて、enumが有用でこの場合、構造体よりも適切である理由を確認しましょう。
IPアドレスを扱う必要が出たとしましょう。現在、IPアドレスの規格は二つあります: バージョン4とバージョン6です。
これらは、プログラムが遭遇するIPアドレスのすべての可能性です: 列挙型は、取りうる値をすべて<em>列挙</em>でき、
これが列挙型の名前の由来です。</p>
<!--
Any IP address can be either a version four or a version six address, but not
both at the same time. That property of IP addresses makes the enum data
structure appropriate, because enum values can only be one of the variants.
Both version four and version six addresses are still fundamentally IP
addresses, so they should be treated as the same type when the code is handling
situations that apply to any kind of IP address.
-->
<p>どんなIPアドレスも、バージョン4かバージョン6のどちらかになりますが、同時に両方にはなり得ません。
IPアドレスのその特性により、enumデータ構造が適切なものになります。というのも、
enumの値は、その列挙子のいずれか一つにしかなり得ないからです。バージョン4とバージョン6のアドレスは、
どちらも根源的にはIPアドレスですから、コードがいかなる種類のIPアドレスにも適用される場面を扱う際には、
同じ型として扱われるべきです。</p>
<!--
We can express this concept in code by defining an `IpAddrKind` enumeration and
listing the possible kinds an IP address can be, `V4` and `V6`. These are known
as the *variants* of the enum:
-->
<p>この概念をコードでは、<code>IpAddrKind</code>列挙型を定義し、IPアドレスがなりうる種類、<code>V4</code>と<code>V6</code>を列挙することで、
表現できます。これらは、enumの<em>列挙子</em>として知られています:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">}
</span></code></pre></pre>
<!--
`IpAddrKind` is now a custom data type that we can use elsewhere in our code.
-->
<p>これで、<code>IpAddrKind</code>はコードの他の場所で使用できる独自のデータ型になります。</p>
<!--
### Enum Values
-->
<h3 id="enumの値"><a class="header" href="#enumの値">Enumの値</a></h3>
<!--
We can create instances of each of the two variants of `IpAddrKind` like this:
-->
<p>以下のようにして、<code>IpAddrKind</code>の各列挙子のインスタンスは生成できます:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span>let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
<span class="boring">}
</span></code></pre></pre>
<!--
Note that the variants of the enum are namespaced under its identifier, and we
use a double colon to separate the two. The reason this is useful is that now
both values `IpAddrKind::V4` and `IpAddrKind::V6` are of the same type:
`IpAddrKind`. We can then, for instance, define a function that takes any
`IpAddrKind`:
-->
<p>enumの列挙子は、その識別子の元に名前空間分けされていることと、
2連コロンを使ってその二つを区別していることに注意してください。
これが有効な理由は、こうすることで、値<code>IpAddrKind::V4</code>と<code>IpAddrKind::V6</code>という値は両方とも、
同じ型<code>IpAddrKind</code>になったからです。そうしたら、例えば、どんな<code>IpAddrKind</code>を取る関数も定義できるようになります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_type: IpAddrKind) { }
<span class="boring">}
</span></code></pre></pre>
<!--
And we can call this function with either variant:
-->
<p>そして、この関数をどちらの列挙子に対しても呼び出せます:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_type: IpAddrKind) { }
</span><span class="boring">
</span>route(IpAddrKind::V4);
route(IpAddrKind::V6);
<span class="boring">}
</span></code></pre></pre>
<!--
Using enums has even more advantages. Thinking more about our IP address type,
at the moment we don’t have a way to store the actual IP address *data*; we
only know what *kind* it is. Given that you just learned about structs in
Chapter 5, you might tackle this problem as shown in Listing 6-1.
-->
<p>enumの利用には、さらなる利点さえもあります。このIPアドレス型についてもっと考えてみると、現状では、
実際のIPアドレスの<em>データ</em>を保持する方法がありません。つまり、どんな<em>種類</em>であるかを知っているだけです。
構造体について第5章で学んだばっかりとすると、この問題に対して、あなたはリスト6-1のように対処するかもしれません。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from(&quot;127.0.0.1&quot;),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from(&quot;::1&quot;),
};
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-1: Storing the data and `IpAddrKind` variant of
an IP address using a `struct`</span>
-->
<p><span class="caption">リスト6-1: IPアドレスのデータと<code>IpAddrKind</code>の列挙子を<code>struct</code>を使って保持する</span></p>
<!--
Here, we’ve defined a struct `IpAddr` that has two fields: a `kind` field that
is of type `IpAddrKind` (the enum we defined previously) and an `address` field
of type `String`. We have two instances of this struct. The first, `home`, has
the value `IpAddrKind::V4` as its `kind` with associated address data of
`127.0.0.1`. The second instance, `loopback`, has the other variant of
`IpAddrKind` as its `kind` value, `V6`, and has address `::1` associated with
it. We’ve used a struct to bundle the `kind` and `address` values together, so
now the variant is associated with the value.
-->
<p>ここでは、二つのフィールドを持つ<code>IpAddr</code>という構造体を定義しています: <code>IpAddrKind</code>型(先ほど定義したenumですね)の<code>kind</code>フィールドと、
<code>String</code>型の<code>address</code>フィールドです。この構造体のインスタンスが2つあります。最初のインスタンス、
<code>home</code>には<code>kind</code>として<code>IpAddrKind::V4</code>があり、紐付けられたアドレスデータは<code>127.0.0.1</code>です。
2番目のインスタンス、<code>loopback</code>には、<code>kind</code>の値として、<code>IpAddrKind</code>のもう一つの列挙子、<code>V6</code>があり、
アドレス<code>::1</code>が紐付いています。構造体を使って<code>kind</code>と<code>address</code>値を一緒に包んだので、
もう列挙子は値と紐付けられています。</p>
<!--
We can represent the same concept in a more concise way using just an enum
rather than an enum inside a struct, by putting data directly into each enum
variant. This new definition of the `IpAddr` enum says that both `V4` and `V6`
variants will have associated `String` values:
-->
<p>各enumの列挙子に直接データを格納して、enumを構造体内に使うというよりもenumだけを使って、
同じ概念をもっと簡潔な方法で表現することができます。この新しい<code>IpAddr</code>の定義は、
<code>V4</code>と<code>V6</code>列挙子両方に<code>String</code>値が紐付けられていることを述べています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<!--
We attach data to each variant of the enum directly, so there is no need for an
extra struct.
-->
<p>enumの各列挙子にデータを直接添付できるので、余計な構造体を作る必要は全くありません。</p>
<!--
There’s another advantage to using an enum rather than a struct: each variant
can have different types and amounts of associated data. Version four type IP
addresses will always have four numeric components that will have values
between 0 and 255. If we wanted to store `V4` addresses as four `u8` values but
still express `V6` addresses as one `String` value, we wouldn’t be able to with
a struct. Enums handle this case with ease:
-->
<p>構造体よりもenumを使うことには、別の利点もあります: 各列挙子に紐付けるデータの型と量は、異なってもいいのです。
バージョン4のIPアドレスには、常に0から255の値を持つ4つの数値があります。<code>V4</code>のアドレスは、4つの<code>u8</code>型の値として格納するけれども、
<code>V6</code>のアドレスは引き続き、単独の<code>String</code>型の値で格納したかったとしても、構造体では不可能です。
enumなら、こんな場合も容易に対応できます:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<!--
We’ve shown several different ways to define data structures to store version
four and version six IP addresses. However, as it turns out, wanting to store
IP addresses and encode which kind they are is so common that [the standard
library has a definition we can use!][IpAddr] Let’s look at how
the standard library defines `IpAddr`: it has the exact enum and variants that
we’ve defined and used, but it embeds the address data inside the variants in
the form of two different structs, which are defined differently for each
variant:
-->
<p>バージョン4とバージョン6のIPアドレスを格納するデータ構造を定義する複数の異なる方法を示してきました。
しかしながら、蓋を開けてみれば、IPアドレスを格納してその種類をコード化したくなるということは一般的なので、
<a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">標準ライブラリに使用可能な定義があります！</a> 標準ライブラリでの<code>IpAddr</code>の定義のされ方を見てみましょう:
私たちが定義し、使用したのと全く同じenumと列挙子がありますが、アドレスデータを二種の異なる構造体の形で列挙子に埋め込み、
この構造体は各列挙子用に異なる形で定義されています。</p>
<!--
```rust
struct Ipv4Addr {
// details elided
}
-->
<!--
struct Ipv6Addr {
// details elided
}
-->
<!--
enum IpAddr {
V4(Ipv4Addr),
V6(Ipv6Addr),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // 省略
}

struct Ipv6Addr {
    // 省略
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code illustrates that you can put any kind of data inside an enum variant:
strings, numeric types, or structs, for example. You can even include another
enum! Also, standard library types are often not much more complicated than
what you might come up with.
-->
<p>このコードは、enum列挙子内にいかなる種類のデータでも格納できることを描き出しています:
例を挙げれば、文字列、数値型、構造体などです。他のenumを含むことさえできます！また、
標準ライブラリの型は、あなたの想像するよりも複雑ではないことがしばしばあります。</p>
<!--
Note that even though the standard library contains a definition for `IpAddr`,
we can still create and use our own definition without conflict because we
haven’t brought the standard library’s definition into our scope. We’ll talk
more about bringing types into scope in Chapter 7.
-->
<p>標準ライブラリに<code>IpAddr</code>に対する定義は含まれるものの、標準ライブラリの定義をまだ我々のスコープに導入していないので、
干渉することなく自分自身の定義を生成して使用できることに注意してください。型をスコープに導入することについては、
第7章でもっと詳しく言及します。</p>
<!--
Let’s look at another example of an enum in Listing 6-2: this one has a wide
variety of types embedded in its variants.
-->
<p>リスト6-2でenumの別の例を見てみましょう: 今回のコードは、幅広い種類の型が列挙子に埋め込まれています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-2: A `Message` enum whose variants each store
different amounts and types of values</span>
-->
<p><span class="caption">リスト6-2: 列挙子各々が異なる型と量の値を格納する<code>Message</code> enum</span></p>
<!--
This enum has four variants with different types:
-->
<p>このenumには、異なる型の列挙子が4つあります:</p>
<!--
* `Quit` has no data associated with it at all.
* `Move` includes an anonymous struct inside it.
* `Write` includes a single `String`.
* `ChangeColor` includes three `i32` values.
-->
<ul>
<li><code>Quit</code>には紐付けられたデータは全くなし。</li>
<li><code>Move</code>は、中に匿名構造体を含む。</li>
<li><code>Write</code>は、単独の<code>String</code>オブジェクトを含む。</li>
<li><code>ChangeColor</code>は、3つの<code>i32</code>値を含む。</li>
</ul>
<!--
Defining an enum with variants such as the ones in Listing 6-2 is similar to
defining different kinds of struct definitions, except the enum doesn’t use the
`struct` keyword and all the variants are grouped together under the `Message`
type. The following structs could hold the same data that the preceding enum
variants hold:
-->
<p>リスト6-2のような列挙子を含むenumを定義することは、enumの場合、<code>struct</code>キーワードを使わず、
全部の列挙子が<code>Message</code>型の元に分類される点を除いて、異なる種類の構造体定義を定義するのと類似しています。
以下の構造体も、先ほどのenumの列挙子が保持しているのと同じデータを格納することができるでしょう:</p>
<!--
```rust
struct QuitMessage; // unit struct
struct MoveMessage {
x: i32,
y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct QuitMessage; // ユニット構造体
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // タプル構造体
struct ChangeColorMessage(i32, i32, i32); // タプル構造体
<span class="boring">}
</span></code></pre></pre>
<!--
But if we used the different structs, which each have their own type, we
couldn't as easily define a function to take any of these kinds of messages as
we could with the `Message` enum defined in Listing 6-2, which is a single type.
-->
<!--
ちょっと文意を適切に表せているか怪しいかも
-->
<p>ですが、異なる構造体を使っていたら、各々、それ自身の型があるので、単独の型になるリスト6-2で定義した<code>Message</code> enumほど、
これらの種のメッセージいずれもとる関数を簡単に定義することはできないでしょう。</p>
<!--
There is one more similarity between enums and structs: just as we’re able to
define methods on structs using `impl`, we’re also able to define methods on
enums. Here’s a method named `call` that we could define on our `Message` enum:
-->
<p>enumと構造体にはもう1点似通っているところがあります: <code>impl</code>を使って構造体にメソッドを定義できるのと全く同様に、
enumにもメソッドを定義することができるのです。こちらは、<code>Message</code> enum上に定義できる<code>call</code>という名前のメソッドです:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">    Write(String),
</span><span class="boring">    ChangeColor(i32, i32, i32),
</span><span class="boring">}
</span><span class="boring">
</span>impl Message {
    fn call(&amp;self) {
        // method body would be defined here
        // メソッド本体はここに定義される
    }
}

let m = Message::Write(String::from(&quot;hello&quot;));
m.call();
<span class="boring">}
</span></code></pre></pre>
<!--
The body of the method would use `self` to get the value that we called the
method on. In this example, we’ve created a variable `m` that has the value
`Message::Write(String::from("hello"))`, and that is what `self` will be in the
body of the `call` method when `m.call()` runs.
-->
<p>メソッドの本体では、<code>self</code>を使用して、メソッドを呼び出した相手の値を取得できるでしょう。この例では、
<code>Message::Write(String::from(&quot;hello&quot;))</code>という値を持つ、変数<code>m</code>を生成したので、これが<code>m.call()</code>を走らせた時に、
<code>call</code>メソッドの本体内で<code>self</code>が表す値になります。</p>
<!--
Let’s look at another enum in the standard library that is very common and
useful: `Option`.
-->
<p>非常に一般的で有用な別の標準ライブラリのenumを見てみましょう: <code>Option</code>です。</p>
<!--
### The `Option` Enum and Its Advantages Over Null Values
-->
<h3 id="option-enumとnull値に勝る利点"><a class="header" href="#option-enumとnull値に勝る利点"><code>Option</code> enumとNull値に勝る利点</a></h3>
<!--
In the previous section, we looked at how the `IpAddr` enum let us use Rust’s
type system to encode more information than just the data into our program.
This section explores a case study of `Option`, which is another enum defined
by the standard library. The `Option` type is used in many places because it
encodes the very common scenario in which a value could be something or it
could be nothing. Expressing this concept in terms of the type system means the
compiler can check that you’ve handled all the cases you should be handling;
this functionality can prevent bugs that are extremely common in other
programming languages.
-->
<p>前節で、<code>IpAddr</code> enumがRustの型システムを使用して、プログラムにデータ以上の情報をコード化できる方法を目撃しました。
この節では、<code>Option</code>のケーススタディを掘り下げていきます。この型も標準ライブラリにより定義されているenumです。
この<code>Option</code>型はいろんな箇所で使用されます。なぜなら、値が何かかそうでないかという非常に一般的な筋書きをコード化するからです。
この概念を型システムの観点で表現することは、コンパイラが、プログラマが処理すべき場面全てを処理していることをチェックできることを意味します;
この機能は、他の言語において、究極的にありふれたバグを阻止することができます。</p>
<!--
Programming language design is often thought of in terms of which features you
include, but the features you exclude are important too. Rust doesn’t have the
null feature that many other languages have. *Null* is a value that means there
is no value there. In languages with null, variables can always be in one of
two states: null or not-null.
-->
<p>プログラミング言語のデザインは、しばしばどの機能を入れるかという観点で考えられるが、
除いた機能も重要なのです。Rustには、他の多くの言語にはあるnull機能がありません。
<em>null</em>とはそこに何も値がないことを意味する値です。nullのある言語において、
変数は常に二者択一どちらかの状態になります: nullかそうでないかです。</p>
<!--
In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony
Hoare, the inventor of null, has this to say:
-->
<p>nullの開発者であるトニー・ホーア(Tony Hoare)の2009年のプレゼンテーション、
&quot;Null References: The Billion Dollar Mistake&quot;(Null参照: 10億ドルの間違い)では、こんなことが語られています。</p>
<!--
> I call it my billion-dollar mistake. At that time, I was designing the first
> comprehensive type system for references in an object-oriented language. My
> goal was to ensure that all use of references should be absolutely safe, with
> checking performed automatically by the compiler. But I couldn't resist the
> temptation to put in a null reference, simply because it was so easy to
> implement. This has led to innumerable errors, vulnerabilities, and system
> crashes, which have probably caused a billion dollars of pain and damage in
> the last forty years.
-->
<blockquote>
<p>私はそれを10億ドルの失敗と呼んでいます。その頃、私は、オブジェクト指向言語の参照に対する、
最初のわかりやすい型システムを設計していました。私の目標は、
どんな参照の使用も全て完全に安全であるべきことを、コンパイラにそのチェックを自動で行ってもらって保証することだったのです。
しかし、null参照を入れるという誘惑に打ち勝つことができませんでした。それは、単純に実装が非常に容易だったからです。
これが無数のエラーや脆弱性、システムクラッシュにつながり、過去40年で10億ドルの苦痛や損害を引き起こしたであろうということなのです。</p>
</blockquote>
<!--
The problem with null values is that if you try to use a null value as a
not-null value, you’ll get an error of some kind. Because this null or not-null
property is pervasive, it’s extremely easy to make this kind of error.
-->
<p>null値の問題は、nullの値をnullでない値のように使用しようとしたら、何らかの種類のエラーが出ることです。
このnullかそうでないかという特性は広く存在するので、この種の間違いを大変犯しやすいのです。</p>
<!--
However, the concept that null is trying to express is still a useful one: a
null is a value that is currently invalid or absent for some reason.
-->
<p>しかしながら、nullが表現しようとしている概念は、それでも役に立つものです: nullは、
何らかの理由で現在無効、または存在しない値のことなのです。</p>
<!--
The problem isn’t really with the concept but with the particular
implementation. As such, Rust does not have nulls, but it does have an enum
that can encode the concept of a value being present or absent. This enum is
`Option<T>`, and it is [defined by the standard library][option]
as follows:
-->
<p>問題は、全く概念にあるのではなく、特定の実装にあるのです。そんな感じなので、Rustにはnullがありませんが、
値が存在するか不在かという概念をコード化するenumならあります。このenumが<code>Option&lt;T&gt;</code>で、
以下のように<a href="https://doc.rust-lang.org/std/option/enum.Option.html">標準ライブラリに定義</a>されています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Option<T>` enum is so useful that it’s even included in the prelude; you
don’t need to bring it into scope explicitly. In addition, so are its variants:
you can use `Some` and `None` directly without the `Option::` prefix. The
`Option<T>` is still just a regular enum, and `Some(T)` and `None` are
still variants of type `Option<T>`.
-->
<p><code>Option&lt;T&gt;</code>は有益すぎて、初期化処理(prelude)にさえ含まれています。つまり、明示的にスコープに導入する必要がないのです。
さらに、列挙子もそうなっています: <code>Some</code>と<code>None</code>を<code>Option::</code>の接頭辞なしに直接使えるわけです。
ただ、<code>Option&lt;T&gt;</code>はそうは言っても、普通のenumであり、<code>Some(T)</code>と<code>None</code>も<code>Option&lt;T&gt;</code>型のただの列挙子です。</p>
<!--
The `<T>` syntax is a feature of Rust we haven’t talked about yet. It’s a
generic type parameter, and we’ll cover generics in more detail in Chapter 10.
For now, all you need to know is that `<T>` means the `Some` variant of the
`Option` enum can hold one piece of data of any type. Here are some examples of
using `Option` values to hold number types and string types:
-->
<p><code>&lt;T&gt;</code>という記法は、まだ語っていないRustの機能です。これは、ジェネリック型引数であり、ジェネリクスについて詳しくは、
第10章で解説します。とりあえず、知っておく必要があることは、<code>&lt;T&gt;</code>は、<code>Option</code> enumの<code>Some</code>列挙子が、
あらゆる型のデータを1つだけ持つことができることを意味していることだけです。こちらは、
<code>Option</code>値を使って、数値型や文字列型を保持する例です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<!--
If we use `None` rather than `Some`, we need to tell Rust what type of
`Option<T>` we have, because the compiler can't infer the type that the `Some`
variant will hold by looking only at a `None` value.
-->
<p><code>Some</code>ではなく、<code>None</code>を使ったら、コンパイラに<code>Option&lt;T&gt;</code>の型が何になるかを教えなければいけません。
というのも、<code>None</code>値を見ただけでは、<code>Some</code>列挙子が保持する型をコンパイラが推論できないからです。</p>
<!--
When we have a `Some` value, we know that a value is present and the value is
held within the `Some`. When we have a `None` value, in some sense, it means
the same thing as null: we don’t have a valid value. So why is having
`Option<T>` any better than having null?
-->
<p><code>Some</code>値がある時、値が存在するとわかり、その値は、<code>Some</code>に保持されています。<code>None</code>値がある場合、
ある意味、nullと同じことを意図します: 有効な値がないのです。では、なぜ<code>Option&lt;T&gt;</code>の方が、
nullよりも少しでも好ましいのでしょうか？</p>
<!--
In short, because `Option<T>` and `T` (where `T` can be any type) are different
types, the compiler won’t let us use an `Option<T>` value as if it was
definitely a valid value. For example, this code won’t compile because it’s
trying to add an `i8` to an `Option<i8>`:
-->
<p>簡潔に述べると、<code>Option&lt;T&gt;</code>と<code>T</code>(ここで<code>T</code>はどんな型でもいい)は異なる型なので、
コンパイラが<code>Option&lt;T&gt;</code>値を確実に有効な値かのようには使用させてくれません。
例えば、このコードは<code>i8</code>を<code>Option&lt;i8&gt;</code>に足そうとしているので、コンパイルできません。</p>
<pre><code class="language-rust ignore">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
</code></pre>
<!--
If we run this code, we get an error message like this:
-->
<p>このコードを動かしたら、以下のようなエラーメッセージが出ます。</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
(エラー: `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;`というトレイト境界が満たされていません)
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<!--
Intense! In effect, this error message means that Rust doesn’t understand how
to add an `i8` and an `Option<i8>`, because they’re different types. When we
have a value of a type like `i8` in Rust, the compiler will ensure that we
always have a valid value. We can proceed confidently without having to check
for null before using that value. Only when we have an `Option<i8>` (or
whatever type of value we’re working with) do we have to worry about possibly
not having a value, and the compiler will make sure we handle that case before
using the value.
-->
<p>なんて強烈な！実際に、このエラーメッセージは、<code>i8</code>と<code>Option&lt;i8&gt;</code>が異なる型なので、
足し合わせる方法がコンパイラにはわからないことを意味します。Rustにおいて、<code>i8</code>のような型の値がある場合、
コンパイラが常に有効な値であることを確認してくれます。この値を使う前にnullであることをチェックする必要なく、
自信を持って先に進むことができるのです。<code>Option&lt;i8&gt;</code>がある時(あるいはどんな型を扱おうとしていても)のみ、
値を保持していない可能性を心配する必要があるわけであり、
コンパイラはプログラマが値を使用する前にそのような場面を扱っているか確かめてくれます。</p>
<!--
In other words, you have to convert an `Option<T>` to a `T` before you can
perform `T` operations with it. Generally, this helps catch one of the most
common issues with null: assuming that something isn’t null when it actually
is.
-->
<p>言い換えると、<code>T</code>型の処理を行う前には、<code>Option&lt;T&gt;</code>を<code>T</code>に変換する必要があるわけです。一般的に、
これにより、nullの最もありふれた問題の一つを捕捉する一助になります: 実際にはnullなのに、
そうでないかのように想定することです。</p>
<!--
Not having to worry about incorrectly assuming a not-null value helps you to be
more confident in your code. In order to have a value that can possibly be
null, you must explicitly opt in by making the type of that value `Option<T>`.
Then, when you use that value, you are required to explicitly handle the case
when the value is null. Everywhere that a value has a type that isn’t an
`Option<T>`, you *can* safely assume that the value isn’t null. This was a
deliberate design decision for Rust to limit null’s pervasiveness and increase
the safety of Rust code.
-->
<p>不正確にnullでない値を想定する心配をしなくてもよいということは、コード内でより自信を持てることになります。
nullになる可能性のある値を保持するには、その値の型を<code>Option&lt;T&gt;</code>にすることで明示的に同意しなければなりません。
それからその値を使用する際には、値がnullである場合を明示的に処理する必要があります。
値が<code>Option&lt;T&gt;</code>以外の型であるところ全てにおいて、値がnullでないと安全に想定することが<em>できます</em>。
これは、Rustにとって、意図的な設計上の決定であり、nullの普遍性を制限し、Rustコードの安全性を向上させます。</p>
<!--
So, how do you get the `T` value out of a `Some` variant when you have a value
of type `Option<T>` so you can use that value? The `Option<T>` enum has a large
number of methods that are useful in a variety of situations; you can check
them out in [its documentation][docs]. Becoming familiar with
the methods on `Option<T>` will be extremely useful in your journey with Rust.
-->
<p>では、<code>Option&lt;T&gt;</code>型の値がある時、その値を使えるようにするには、どのように<code>Some</code>列挙子から<code>T</code>型の値を取り出せばいいのでしょうか？
<code>Option&lt;T&gt;</code>には様々な場面で有効に活用できる非常に多くのメソッドが用意されています;
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">ドキュメント</a>でそれらを確認できます。<code>Option&lt;T&gt;</code>のメソッドに馴染むと、
Rustの旅が極めて有益になるでしょう。</p>
<!--
In general, in order to use an `Option<T>` value, you want to have code that
will handle each variant. We want some code that will run only when you have a
`Some(T)` value, and this code is allowed to use the inner `T`. We want some
other code to run if we have a `None` value, and that code doesn’t have a `T`
value available. The `match` expression is a control flow construct that does
just this when used with enums: it will run different code depending on which
variant of the enum it has, and that code can use the data inside the matching
value.
-->
<p>一般的に、<code>Option&lt;T&gt;</code>値を使うには、各列挙子を処理するコードが欲しくなります。
<code>Some(T)</code>値がある時だけ走る何らかのコードが欲しくなり、このコードが内部の<code>T</code>を使用できます。
<code>None</code>値があった場合に走る別のコードが欲しくなり、そちらのコードは<code>T</code>値は使用できない状態になります。
<code>match</code>式が、enumとともに使用した時にこれだけの動作をする制御フロー文法要素になります:
enumの列挙子によって、違うコードが走り、そのコードがマッチした値の中のデータを使用できるのです。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## The `match` Control Flow Operator
-->
<h2 id="match制御フロー演算子"><a class="header" href="#match制御フロー演算子"><code>match</code>制御フロー演算子</a></h2>
<!--
Rust has an extremely powerful control flow operator called `match` that allows
us to compare a value against a series of patterns and then execute code based
on which pattern matches. Patterns can be made up of literal values, variable
names, wildcards, and many other things; Chapter 18 covers all the different
kinds of patterns and what they do. The power of `match` comes from the
expressiveness of the patterns and the fact that the compiler confirms that all
possible cases are handled.
-->
<p>Rustには、一連のパターンに対して値を比較し、マッチしたパターンに応じてコードを実行させてくれる<code>match</code>と呼ばれる、
非常に強力な制御フロー演算子があります。パターンは、リテラル値、変数名、ワイルドカードやその他多数のもので構成することができます;
第18章で、全ての種類のパターンと、その目的については解説します。<code>match</code>のパワーは、
パターンの表現力とコンパイラが全てのありうるパターンを処理しているかを確認してくれるという事実に由来します。</p>
<!--
Think of a `match` expression kind of like a coin sorting machine: coins slide
down a track with variously sized holes along it, and each coin falls through
the first hole it encounters that it fits into. In the same way, values go
through each pattern in a `match`, and at the first pattern the value “fits,”
the value falls into the associated code block to be used during execution.
-->
<p><code>match</code>式をコイン並べ替え装置のようなものと考えてください: コインは、様々なサイズの穴が空いた通路を流れ落ち、
各コインは、サイズのあった最初の穴に落ちます。同様に、値は<code>match</code>の各パターンを通り抜け、値が「適合する」最初のパターンで、
値は紐付けられたコードブロックに落ち、実行中に使用されるわけです。</p>
<!--
Because we just mentioned coins, let’s use them as an example using `match`! We
can write a function that can take an unknown United States coin and, in a
similar way as the counting machine, determine which coin it is and return its
value in cents, as shown here in Listing 6-3.
-->
<p>コインについて話したので、それを<code>match</code>を使用する例にとってみましょう！数え上げ装置と同じ要領で未知のアメリカコインを一枚取り、
どの種類のコインなのか決定し、その価値をセントで返す関数をリスト6-3で示したように記述することができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-3: An enum and a `match` expression that has
the variants of the enum as its patterns.</span>
-->
<p><span class="caption">リスト6-3: enumとそのenumの列挙子をパターンにした<code>match</code>式</span></p>
<!--
Let’s break down the `match` in the `value_in_cents` function. First, we list
the `match` keyword followed by an expression, which in this case is the value
`coin`. This seems very similar to an expression used with `if`, but there’s a
big difference: with `if`, the expression needs to return a Boolean value, but
here, it can be any type. The type of `coin` in this example is the `Coin` enum
that we defined on line 1.
-->
<p><code>value_in_cents</code>関数内の<code>match</code>を噛み砕きましょう。まず、<code>match</code>キーワードに続けて式を並べています。
この式は今回の場合、値<code>coin</code>です。<code>if</code>で使用した式と非常に酷似しているみたいですね。しかし、大きな違いがあります:
<code>if</code>では、式は論理値を返す必要がありますが、ここでは、どんな型でも構いません。この例における<code>coin</code>の型は、
1行目で定義した<code>Coin</code> enumです。</p>
<!--
Next are the `match` arms. An arm has two parts: a pattern and some code. The
first arm here has a pattern that is the value `Coin::Penny` and then the `=>`
operator that separates the pattern and the code to run. The code in this case
is just the value `1`. Each arm is separated from the next with a comma.
-->
<p>次は、<code>match</code>アームです。一本のアームには2つの部品があります: パターンと何らかのコードです。
今回の最初のアームは<code>Coin::Penny</code>という値のパターンであり、パターンと動作するコードを区別する<code>=&gt;</code>演算子が続きます。
この場合のコードは、ただの値<code>1</code>です。各アームは次のアームとカンマで区切られています。</p>
<!--
When the `match` expression executes, it compares the resulting value against
the pattern of each arm, in order. If a pattern matches the value, the code
associated with that pattern is executed. If that pattern doesn’t match the
value, execution continues to the next arm, much as in a coin-sorting machine.
We can have as many arms as we need: in Listing 6-3, our `match` has four arms.
-->
<p>この<code>match</code>式が実行されると、結果の値を各アームのパターンと順番に比較します。パターンに値がマッチしたら、
そのコードに紐付けられたコードが実行されます。パターンが値にマッチしなければ、コイン並べ替え装置と全く同じように、
次のアームが継続して実行されます。必要なだけパターンは存在できます: リスト6-3では、<code>match</code>には4本のアームがあります。</p>
<!--
The code associated with each arm is an expression, and the resulting value of
the expression in the matching arm is the value that gets returned for the
entire `match` expression.
-->
<p>各アームに紐付けられるコードは式であり、マッチしたアームの式の結果が<code>match</code>式全体の戻り値になります。</p>
<!--
Curly brackets typically aren’t used if the match arm code is short, as it is
in Listing 6-3 where each arm just returns a value. If you want to run multiple
lines of code in a match arm, you can use curly brackets. For example, the
following code would print out “Lucky penny!” every time the method was called with
a `Coin::Penny` but would still return the last value of the block, `1`:
-->
<p>典型的に、アームのコードが短い場合、波かっこは使用されません。リスト6-3では、各アームが値を返すだけなので、
これに倣っています。マッチのアームで複数行のコードを走らせたいのなら、波かっこを使用することができます。
例えば、以下のコードは、メソッドが<code>Coin::Penny</code>とともに呼び出されるたびに「Lucky penny!」と表示しつつ、
ブロックの最後の値、<code>1</code>を返すでしょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Coin {
</span><span class="boring">   Penny,
</span><span class="boring">   Nickel,
</span><span class="boring">   Dime,
</span><span class="boring">   Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
### Patterns that Bind to Values
-->
<h3 id="値に束縛されるパターン"><a class="header" href="#値に束縛されるパターン">値に束縛されるパターン</a></h3>
<!--
Another useful feature of match arms is that they can bind to parts of the
values that match the pattern. This is how we can extract values out of enum
variants.
-->
<p>マッチのアームの別の有益な機能は、パターンにマッチした値の一部に束縛できる点です。こうして、
enumの列挙子から値を取り出すことができます。</p>
<!--
As an example, let’s change one of our enum variants to hold data inside it.
From 1999 through 2008, the United States minted quarters with different
designs for each of the 50 states on one side. No other coins got state
designs, so only quarters have this extra value. We can add this information to
our `enum` by changing the `Quarter` variant to include a `UsState` value stored
inside it, which we've done here in Listing 6-4.
-->
<p>例として、enumの列挙子の一つを中にデータを保持するように変えましょう。1999年から2008年まで、
アメリカは、片側に50の州それぞれで異なるデザインをしたクォーターコインを鋳造していました。
他のコインは州のデザインがなされることはなかったので、クォーターだけがこのおまけの値を保持します。
<code>Quarter</code>列挙子を変更して、<code>UsState</code>値が中に保持されるようにすることで<code>enum</code>にこの情報を追加でき、
それをしたのがリスト6-4のコードになります。</p>
<!--
```rust
#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
Alabama,
Alaska,
// ... etc
}
-->
<!--
enum Coin {
Penny,
Nickel,
Dime,
Quarter(UsState),
}
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)] // すぐに州を点検できるように
enum UsState {
    Alabama,
    Alaska,
    // ... などなど
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-4: A `Coin` enum in which the `Quarter` variant
also holds a `UsState` value</span>
-->
<p><span class="caption">リスト6-4: <code>Quarter</code>列挙子が<code>UsState</code>の値も保持する<code>Coin</code> enum</span></p>
<!--
Let’s imagine that a friend of ours is trying to collect all 50 state quarters.
While we sort our loose change by coin type, we’ll also call out the name of
the state associated with each quarter so if it’s one our friend doesn’t have,
they can add it to their collection.
-->
<p>友人の一人が50州全部のクォーターコインを収集しようとしているところを想像しましょう。コインの種類で小銭を並べ替えつつ、
友人が持っていない種類だったら、コレクションに追加できるように、各クォーターに関連した州の名前を出力します。</p>
<!--
In the match expression for this code, we add a variable called `state` to the
pattern that matches values of the variant `Coin::Quarter`. When a
`Coin::Quarter` matches, the `state` variable will bind to the value of that
quarter’s state. Then we can use `state` in the code for that arm, like so:
-->
<p>このコードのmatch式では、<code>Coin::Quarter</code>列挙子の値にマッチする<code>state</code>という名の変数をパターンに追加します。
<code>Coin::Quarter</code>がマッチすると、<code>state</code>変数はそのクォーターのstateの値に束縛されます。それから、
<code>state</code>をそのアームのコードで使用できます。以下のようにですね:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">   Alabama,
</span><span class="boring">   Alaska,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">   Penny,
</span><span class="boring">   Nickel,
</span><span class="boring">   Dime,
</span><span class="boring">   Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u32 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
If we were to call `value_in_cents(Coin::Quarter(UsState::Alaska))`, `coin`
would be `Coin::Quarter(UsState::Alaska)`. When we compare that value with each
of the match arms, none of them match until we reach `Coin::Quarter(state)`. At
that point, the binding for `state` will be the value `UsState::Alaska`. We can
then use that binding in the `println!` expression, thus getting the inner
state value out of the `Coin` enum variant for `Quarter`.
-->
<p><code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>と呼び出すつもりだったなら、<code>coin</code>は
<code>Coin::Quarter(UsState::Alaska)</code>になります。その値をmatchの各アームと比較すると、
<code>Coin::Quarter(state)</code>に到達するまで、どれにもマッチしません。その時に、<code>state</code>に束縛されるのは、
<code>UsState::Alaska</code>という値です。そして、<code>println!</code>式でその束縛を使用することができ、
そのため、<code>Coin</code> enumの列挙子から<code>Quarter</code>に対する中身のstateの値を取得できたわけです。</p>
<!--
### Matching with `Option<T>`
-->
<h3 id="optiontとのマッチ"><a class="header" href="#optiontとのマッチ"><code>Option&lt;T&gt;</code>とのマッチ</a></h3>
<!--
In the previous section we wanted to get the inner `T` value out of the `Some`
case when using `Option<T>`; we can also handle `Option<T>` using `match` as we
did with the `Coin` enum! Instead of comparing coins, we’ll compare the
variants of `Option<T>`, but the way that the `match` expression works remains
the same.
-->
<p>前節では、<code>Option&lt;T&gt;</code>を使用する際に、<code>Some</code>ケースから中身の<code>T</code>の値を取得したくなりました。要するに、
<code>Coin</code> enumに対して行ったように、<code>match</code>を使って<code>Option&lt;T&gt;</code>を扱うこともできるというわけです！
コインを比較する代わりに、<code>Option&lt;T&gt;</code>の列挙子を比較するのですが、<code>match</code>式の動作の仕方は同じままです。</p>
<!--
Let’s say we want to write a function that takes an `Option<i32>` and, if
there’s a value inside, adds 1 to that value. If there isn’t a value inside,
the function should return the `None` value and not attempt to perform any
operations.
-->
<p><code>Option&lt;i32&gt;</code>を取る関数を書きたくなったとし、中に値があったら、その値に1を足すことにしましょう。
中に値がなければ、関数は<code>None</code>値を返し、何も処理を試みるべきではありません。</p>
<!--
This function is very easy to write, thanks to `match`, and will look like
Listing 6-5.
-->
<p><code>match</code>のおかげで、この関数は大変書きやすく、リスト6-5のような見た目になります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-5: A function that uses a `match` expression on
an `Option<i32>`</span>
-->
<p><span class="caption">リスト6-5: <code>Option&lt;i32&gt;</code>に<code>match</code>式を使う関数</span></p>
<!--
Let’s examine the first execution of `plus_one` in more detail. When we call
`plus_one(five)`, the variable `x` in the body of `plus_one` will have the
value `Some(5)`. We then compare that against each match arm.
-->
<p><code>plus_one</code>の最初の実行についてもっと詳しく検証しましょう。<code>plus_one(five)</code>と呼び出した時、
<code>plus_one</code>の本体の変数<code>x</code>は<code>Some(5)</code>になります。そして、これをマッチの各アームと比較します。</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<!--
The `Some(5)` value doesn’t match the pattern `None`, so we continue to the
next arm.
-->
<p><code>Some(5)</code>という値は、<code>None</code>というパターンにはマッチしませんので、次のアームに処理が移ります。</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<!--
Does `Some(5)` match `Some(i)`? Why yes it does! We have the same variant. The
`i` binds to the value contained in `Some`, so `i` takes the value `5`. The
code in the match arm is then executed, so we add one to the value of `i` and
create a new `Some` value with our total `6` inside.
-->
<!--
Why yesが怪しい
-->
<p><code>Some(5)</code>は<code>Some(i)</code>にマッチしますか？なんと、します！列挙子が同じです。<code>i</code>は<code>Some</code>に含まれる値に束縛されるので、
<code>i</code>は値<code>5</code>になります。それから、このマッチのアームのコードが実行されるので、<code>i</code>の値に1を足し、
合計の<code>6</code>を中身にした新しい<code>Some</code>値を生成します。</p>
<!--
Now let’s consider the second call of `plus_one` in Listing 6-5, where `x` is
`None`. We enter the `match` and compare to the first arm.
-->
<p>さて、<code>x</code>が<code>None</code>になるリスト6-5の2回目の<code>plus_one</code>の呼び出しを考えましょう。<code>match</code>に入り、
最初のアームと比較します。</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<!--
It matches! There’s no value to add to, so the program stops and returns the
`None` value on the right side of `=>`. Because the first arm matched, no other
arms are compared.
-->
<p>マッチします！足し算する値がないので、プログラムは停止し、<code>=&gt;</code>の右辺にある<code>None</code>値が返ります。
最初のアームがマッチしたため、他のアームは比較されません。</p>
<!--
Combining `match` and enums is useful in many situations. You’ll see this
pattern a lot in Rust code: `match` against an enum, bind a variable to the
data inside, and then execute code based on it. It’s a bit tricky at first, but
once you get used to it, you’ll wish you had it in all languages. It’s
consistently a user favorite.
-->
<p><code>match</code>とenumの組み合わせは、多くの場面で有効です。Rustコードにおいて、このパターンはよく見かけるでしょう:
enumに対し<code>match</code>し、内部のデータに変数を束縛させ、それに基づいたコードを実行します。最初はちょっと巧妙ですが、
一旦慣れてしまえば、全ての言語にあってほしいと願うことになるでしょう。一貫してユーザのお気に入りなのです。</p>
<!--
### Matches Are Exhaustive
-->
<!--
いい単語を探したい(Exhaustive)
-->
<h3 id="マッチは包括的"><a class="header" href="#マッチは包括的">マッチは包括的</a></h3>
<!--
There’s one other aspect of `match` we need to discuss. Consider this version
of our `plus_one` function that has a bug and won't compile:
-->
<p>もう一つ議論する必要のある<code>match</code>の観点があります。一点バグがありコンパイルできないこんなバージョンの<code>plus_one</code>関数を考えてください:</p>
<pre><code class="language-rust ignore">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<!--
We didn’t handle the `None` case, so this code will cause a bug. Luckily, it’s
a bug Rust knows how to catch. If we try to compile this code, we’ll get this
error:
-->
<p><code>None</code>の場合を扱っていないため、このコードはバグを生みます。幸い、コンパイラが捕捉できるバグです。
このコードのコンパイルを試みると、こんなエラーが出ます:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
(エラー: 包括的でないパターン: `None`がカバーされてません)
 --&gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<!--
Rust knows that we didn’t cover every possible case and even knows which
pattern we forgot! Matches in Rust are *exhaustive*: we must exhaust every last
possibility in order for the code to be valid. Especially in the case of
`Option<T>`, when Rust prevents us from forgetting to explicitly handle the
`None` case, it protects us from assuming that we have a value when we might
have null, thus making the billion dollar mistake discussed earlier.
-->
<p>全可能性を網羅していないことをコンパイラは検知しています。もっと言えば、どのパターンを忘れているかさえ知っているのです。
Rustにおけるマッチは、<em>包括的</em>です: 全てのあらゆる可能性を網羅し尽くさなければ、コードは有効にならないのです。
特に<code>Option&lt;T&gt;</code>の場合には、私達が明示的に<code>None</code>の場合を処理するのを忘れないようにしてくれます。
nullになるかもしれないのに値があると思い込まないよう、すなわち前に議論した10億ドルの失敗を犯さないよう、
コンパイラが保護してくれるわけです。</p>
<!--
### The `_` Placeholder
-->
<h3 id="_というプレースホルダー"><a class="header" href="#_というプレースホルダー"><code>_</code>というプレースホルダー</a></h3>
<!--
Rust also has a pattern we can use when we don’t want to list all possible
values. For example, a `u8` can have valid values of 0 through 255. If we only
care about the values 1, 3, 5, and 7, we don’t want to have to list out 0, 2,
4, 6, 8, 9 all the way up to 255. Fortunately, we don’t have to: we can use the
special pattern `_` instead:
-->
<p>Rustには、全ての可能性を列挙したくない時に使用できるパターンもあります。例えば、<code>u8</code>は、有効な値として、
0から255までを取ります。1、3、5、7の値にだけ興味があったら、0、2、4、6、8、9と255までの数値を列挙する必要に迫られたくはないです。
幸運なことに、する必要はありません: 代わりに特別なパターンの<code>_</code>を使用できます:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `_` pattern will match any value. By putting it after our other arms, the
`_` will match all the possible cases that aren’t specified before it. The `()`
is just the unit value, so nothing will happen in the `_` case. As a result, we
can say that we want to do nothing for all the possible values that we don’t
list before the `_` placeholder.
-->
<p><code>_</code>というパターンは、どんな値にもマッチします。他のアームの後に記述することで、<code>_</code>は、
それまでに指定されていない全ての可能性にマッチします。<code>()</code>は、ただのユニット値なので、<code>_</code>の場合には、
何も起こりません。結果として、<code>_</code>プレースホルダーの前に列挙していない可能性全てに対しては、
何もしたくないと言えるわけです。</p>
<!--
However, the `match` expression can be a bit wordy in a situation in which we
care about only *one* of the cases. For this situation, Rust provides `if let`.
-->
<p>ですが、<em>一つ</em>のケースにしか興味がないような場面では、<code>match</code>式はちょっと長ったらしすぎます。
このような場面用に、Rustには、<code>if let</code>が用意されています。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Concise Control Flow with `if let`
-->
<h2 id="if-letで簡潔な制御フロー"><a class="header" href="#if-letで簡潔な制御フロー"><code>if let</code>で簡潔な制御フロー</a></h2>
<!--
The `if let` syntax lets you combine `if` and `let` into a less verbose way to
handle values that match one pattern while ignoring the rest. Consider the
program in Listing 6-6 that matches on an `Option<u8>` value but only wants to
execute code if the value is 3.
-->
<p><code>if let</code>記法で<code>if</code>と<code>let</code>をより冗長性の少ない方法で組み合わせ、残りを無視しつつ、一つのパターンにマッチする値を扱うことができます。
<code>Option&lt;u8&gt;</code>にマッチするけれど、値が3の時にだけコードを実行したい、リスト6-6のプログラムを考えてください。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 6-6: A `match` that only cares about executing
code when the value is `Some(3)`</span>
-->
<p><span class="caption">リスト6-6: 値が<code>Some(3)</code>の時だけコードを実行する<code>match</code></span></p>
<!--
We want to do something with the `Some(3)` match but do nothing with any other
`Some<u8>` value or the `None` value. To satisfy the `match` expression, we
have to add `_ => ()` after processing just one variant, which is a lot of
boilerplate code to add.
-->
<p><code>Some(3)</code>にマッチした時だけ何かをし、他の<code>Some&lt;u8&gt;</code>値や<code>None</code>値の時には何もしたくありません。
<code>match</code>式を満たすためには、列挙子を一つだけ処理した後に<code>_ =&gt; ()</code>を追加しなければなりません。
これでは、追加すべき定型コードが多すぎます。</p>
<!--
Instead, we could write this in a shorter way using `if let`. The following
code behaves the same as the `match` in Listing 6-6:
-->
<p>その代わり、<code>if let</code>を使用してもっと短く書くことができます。以下のコードは、
リスト6-6の<code>match</code>と同じように振る舞います:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let some_u8_value = Some(0u8);
</span>if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<!--
The syntax `if let` takes a pattern and an expression separated by an equal
sign. It works the same way as a `match`, where the expression is given to the
`match` and the pattern is its first arm.
-->
<p><code>if let</code>という記法は等号記号で区切られたパターンと式を取り、式が<code>match</code>に与えられ、パターンが最初のアームになった<code>match</code>と、
同じ動作をします。</p>
<!--
Using `if let` means less typing, less indentation, and less boilerplate code.
However, you lose the exhaustive checking that `match` enforces. Choosing
between `match` and `if let` depends on what you’re doing in your particular
situation and whether gaining conciseness is an appropriate trade-off for
losing exhaustive checking.
-->
<p><code>if let</code>を使うと、タイプ数が減り、インデントも少なくなり、定型コードも減ります。しかしながら、
<code>match</code>では強制された包括性チェックを失ってしまいます。<code>match</code>か<code>if let</code>かの選択は、
特定の場面でどんなことをしたいかと簡潔性を得ることが包括性チェックを失うのに適切な代償となるかによります。</p>
<!--
In other words, you can think of `if let` as syntax sugar for a `match` that
runs code when the value matches one pattern and then ignores all other values.
-->
<p>言い換えると、<code>if let</code>は値が一つのパターンにマッチした時にコードを走らせ、
他は無視する<code>match</code>への糖衣構文と考えることができます。</p>
<!--
We can include an `else` with an `if let`. The block of code that goes with the
`else` is the same as the block of code that would go with the `_` case in the
`match` expression that is equivalent to the `if let` and `else`. Recall the
`Coin` enum definition in Listing 6-4, where the `Quarter` variant also held a
`UsState` value. If we wanted to count all non-quarter coins we see while also
announcing the state of the quarters, we could do that with a `match`
expression like this:
-->
<p><code>if let</code>では、<code>else</code>を含むこともできます。<code>else</code>に入るコードブロックは、
<code>if let</code>と<code>else</code>に等価な<code>match</code>式の<code>_</code>の場合に入るコードブロックと同じになります。
リスト6-4の<code>Coin</code> enum定義を思い出してください。ここでは、<code>Quarter</code>列挙子は、
<code>UsState</code>の値も保持していましたね。クォーターコインの状態を告げつつ、
見かけたクォーター以外のコインの枚数を数えたいなら、以下のように<code>match</code>式で実現することができるでしょう:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">   Alabama,
</span><span class="boring">   Alaska,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">   Penny,
</span><span class="boring">   Nickel,
</span><span class="boring">   Dime,
</span><span class="boring">   Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">let coin = Coin::Penny;
</span>let mut count = 0;
match coin {
    // {:?}州のクォーターコイン
    Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
    _ =&gt; count += 1,
}
<span class="boring">}
</span></code></pre></pre>
<!--
Or we could use an `if let` and `else` expression like this:
-->
<p>または、以下のように<code>if let</code>と<code>else</code>を使うこともできるでしょう:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">   Alabama,
</span><span class="boring">   Alaska,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">   Penny,
</span><span class="boring">   Nickel,
</span><span class="boring">   Dime,
</span><span class="boring">   Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">let coin = Coin::Penny;
</span>let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!(&quot;State quarter from {:?}!&quot;, state);
} else {
    count += 1;
}
<span class="boring">}
</span></code></pre></pre>
<!--
If you have a situation in which your program has logic that is too verbose to
express using a `match`, remember that `if let` is in your Rust toolbox as well.
-->
<p><code>match</code>を使って表現するには冗長的すぎるロジックがプログラムにあるようなシチュエーションに遭遇したら、
<code>if let</code>もRust道具箱にあることを思い出してください。</p>
<!--
## Summary
-->
<h2 id="まとめ-5"><a class="header" href="#まとめ-5">まとめ</a></h2>
<!--
We’ve now covered how to use enums to create custom types that can be one of a
set of enumerated values. We’ve shown how the standard library’s `Option<T>`
type helps you use the type system to prevent errors. When enum values have
data inside them, you can use `match` or `if let` to extract and use those
values, depending on how many cases you need to handle.
-->
<p>これで、enumを使用してワンセットの列挙された値のどれかになりうる独自の型を生成する方法を講義しました。
標準ライブラリの<code>Option&lt;T&gt;</code>が型システムを使用して、エラーを回避する際に役立つ方法についても示しました。
enumの値がデータを内部に含む場合、処理すべきケースの数に応じて、<code>match</code>か<code>if let</code>を使用して値を取り出し、
使用できます。</p>
<!--
Your Rust programs can now express concepts in your domain using structs and
enums. Creating custom types to use in your API ensures type safety: the
compiler will make certain your functions get only values of the type each
function expects.
-->
<p>もうRustプログラムで構造体とenumを使用して、自分の領域の概念を表現できます。API内で使用するために独自の型を生成することで、
型安全性を保証することができます: コンパイラが、各関数の予期する型の値のみを関数が得ることを確かめてくれるのです。</p>
<!--
In order to provide a well-organized API to your users that is straightforward
to use and only exposes exactly what your users will need, let’s now turn to
Rust’s modules.
-->
<p>使用するのに率直な整理整頓されたAPIをユーザに提供し、ユーザが必要とするものだけを公開するために、
今度は、Rustのモジュールに目を向けてみましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Managing Growing Projects with Packages, Crates, and Modules
-->
<h1 id="肥大化していくプロジェクトをパッケージクレートモジュールを利用して管理する"><a class="header" href="#肥大化していくプロジェクトをパッケージクレートモジュールを利用して管理する">肥大化していくプロジェクトをパッケージ、クレート、モジュールを利用して管理する</a></h1>
<!--
As you write large programs, organizing your code will be important because
keeping track of your entire program in your head will become impossible. By
grouping related functionality and separating code with distinct features,
you’ll clarify where to find code that implements a particular feature and
where to go to change how a feature works.
-->
<p>大きなプログラムを書く時、そのすべてを頭の中に入れておくのは不可能になるため、コードのまとまりを良くすることが重要になります。
関係した機能をまとめ、異なる特徴を持つコードを分割することにより、特定の機能を実装しているコードを見つけたり、機能を変更したりするためにどこを探せば良いのかを明確にできます。</p>
<!--
The programs we’ve written so far have been in one module in one file. As a
project grows, you can organize code by splitting it into multiple modules and
then multiple files. A package can contain multiple binary crates and
optionally one library crate. As a package grows, you can extract parts into
separate crates that become external dependencies. This chapter covers all
these techniques. For very large projects of a set of interrelated packages
that evolve together, Cargo provides workspaces, which we’ll cover in the
[“Cargo Workspaces”][workspaces] section in Chapter 14.
-->
<p>私達がこれまでに書いてきたプログラムは、一つのファイル内の一つのモジュール内にありました。
プロジェクトが大きくなるにつれて、これを複数のモジュールに、ついで複数のファイルに分割することで、プログラムを整理することができます。
パッケージは複数のバイナリクレートからなり、またライブラリクレートを1つもつこともできます。
パッケージが大きくなるにつれて、その一部を抜き出して分離したクレートにし、外部依存とするのもよいでしょう。
この章ではそれらのテクニックすべてを学びます。
相互に関係し合い、同時に成長するパッケージの集まりからなる巨大なプロジェクトには、
Cargoがワークスペースという機能を提供します。これは14章の<a href="ch14-03-cargo-workspaces.html">Cargoワークスペース</a><!-- ignore -->で解説します。</p>
<!--
In addition to grouping functionality, encapsulating implementation details
lets you reuse code at a higher level: once you’ve implemented an operation,
other code can call that code via the code’s public interface without knowing
how the implementation works. The way you write code defines which parts are
public for other code to use and which parts are private implementation details
that you reserve the right to change. This is another way to limit the amount
of detail you have to keep in your head.
-->
<p>機能をグループにまとめられることに加え、実装の詳細がカプセル化されることにより、コードをより高いレベルで再利用できるようになります：
手続きを実装し終えてしまえば、他のコードはそのコードの公開されたインターフェースを通じて、実装の詳細を知ることなくそのコードを呼び出すことができるのです。
コードをどう書くかによって、どの部分が他のコードにも使える公開のものになるのか、それとも自分だけが変更できる非公開のものになるのかが決定されます。
これもまた、記憶しておくべき細部を制限してくれる方法のひとつです。</p>
<!--
A related concept is scope: the nested context in which code is written has a
set of names that are defined as “in scope.” When reading, writing, and
compiling code, programmers and compilers need to know whether a particular
name at a particular spot refers to a variable, function, struct, enum, module,
constant, or other item and what that item means. You can create scopes and
change which names are in or out of scope. You can’t have two items with the
same name in the same scope; tools are available to resolve name conflicts.
-->
<p>関係する概念にスコープがあります：
コードが記述されているネストされた文脈には、「スコープ内」として定義される名前の集合があります。
コードを読んだり書いたりコンパイルしたりする時には、プログラマーやコンパイラは特定の場所にある特定の名前が、変数・関数・構造体・enum・モジュール・定数・その他のどの要素を表すのか、そしてその要素は何を意味するのかを知る必要があります。
そこでスコープを作り、どの名前がスコープ内/スコープ外にあるのかを変更することができます。
同じ名前のものを2つ同じスコープ内に持つことはできません。そこで、名前の衝突を解決するための方法があります。</p>
<!--
Rust has a number of features that allow you to manage your code’s
organization, including which details are exposed, which details are private,
and what names are in each scope in your programs. These features, sometimes
collectively referred to as the *module system*, include:
-->
<p>Rustには、どの詳細を公開するか、どの詳細を非公開にするか、どの名前がプログラムのそれぞれのスコープにあるか、といったコードのまとまりを保つためのたくさんの機能があります。
これらの機能は、まとめて「モジュールシステム」と呼ばれることがあり、以下のようなものが含まれます。</p>
<!--
* **Packages:** A Cargo feature that lets you build, test, and share crates
* **Crates:** A tree of modules that produces a library or executable
* **Modules** and **use:** Let you control the organization, scope, and
  privacy of paths
* **Paths:** A way of naming an item, such as a struct, function, or module
-->
<ul>
<li><strong>パッケージ:</strong> クレートをビルドし、テストし、共有することができるCargoの機能</li>
<li><strong>クレート:</strong> ライブラリか実行可能ファイルを生成する、木構造をしたモジュール群</li>
<li><strong>モジュール</strong> と <strong>use:</strong> これを使うことで、パスの構成、スコープ、公開するか否かを決定できます</li>
<li><strong>パス:</strong> 要素（例えば構造体や関数やモジュール）に名前をつける方法</li>
</ul>
<!--
In this chapter, we’ll cover all these features, discuss how they interact, and
explain how to use them to manage scope. By the end, you should have a solid
understanding of the module system and be able to work with scopes like a pro!
-->
<p>この章では、これらの機能をすべて学び、これらがどう相互作用するかについて議論し、これらをどう使ってスコープを制御するのかについて説明します。
この章を読み終わる頃には、モジュールシステムをしっかりと理解し、熟練者のごとくスコープを扱うことができるようになっているでしょう！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Packages and Crates
-->
<h2 id="パッケージとクレート"><a class="header" href="#パッケージとクレート">パッケージとクレート</a></h2>
<!--
The first parts of the module system we’ll cover are packages and crates. A
crate is a binary or library. The *crate root* is a source file that the Rust
compiler starts from and makes up the root module of your crate (we’ll explain
modules in depth in the [“Defining Modules to Control Scope and
Privacy”][modules] section). A *package* is one or more crates
that provide a set of functionality. A package contains a *Cargo.toml* file
that describes how to build those crates.
-->
<p>最初に学ぶモジュールシステムの要素は、パッケージとクレートです。
クレートはバイナリかライブラリのどちらかです。
<em>クレートルート (crate root)</em> とは、Rustコンパイラの開始点となり、クレートのルートモジュールを作るソースファイルのことです（モジュールについて詳しくは<a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">「モジュールを定義して、スコープとプライバシーを制御する」</a><!-- ignore -->のセクションで説明します）。
<em>パッケージ</em> はある機能群を提供する1つ以上のクレートです。
パッケージは <em>Cargo.toml</em> という、それらのクレートをどのようにビルドするかを説明するファイルを持っています。</p>
<!--
Several rules determine what a package can contain. A package *must* contain
zero or one library crates, and no more. It can contain as many binary crates
as you’d like, but it must contain at least one crate (either library or
binary).
-->
<p>パッケージが何を持ってよいかはいくつかのルールで決まっています。
パッケージは0個か1個のライブラリクレートを持っていないといけません。それ以上は駄目です。
バイナリクレートはいくらでも持って良いですが、少なくとも（ライブラリでもバイナリでも良いですが）1つのクレートを持っていないといけません。</p>
<!--
Let’s walk through what happens when we create a package. First, we enter the
command `cargo new`:
-->
<p>パッケージを作る時に何が起こるか見てみましょう。
まず、<code>cargo new</code>というコマンドを入力します：</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<!--
When we entered the command, Cargo created a *Cargo.toml* file, giving us a
package. Looking at the contents of *Cargo.toml*, there’s no mention of
*src/main.rs* because Cargo follows a convention that *src/main.rs* is the
crate root of a binary crate with the same name as the package. Likewise, Cargo
knows that if the package directory contains *src/lib.rs*, the package contains
a library crate with the same name as the package, and *src/lib.rs* is its
crate root. Cargo passes the crate root files to `rustc` to build the library
or binary.
-->
<p>このコマンドを入力したとき、Cargoは <em>Cargo.toml</em> ファイルを作り、パッケージを作ってくれました。
<em>Cargo.toml</em> の中身を見ても、<em>src/main.rs</em> については何も書いてありません。これは、Cargoは <em>src/main.rs</em> が、パッケージと同じ名前を持つバイナリクレートのクレートルートであるという慣習に従っているためです。
同じように、Cargoはパッケージディレクトリに <em>src/lib.rs</em> が含まれていたら、パッケージにはパッケージと同じ名前のライブラリクレートが含まれており、<em>src/lib.rs</em> がそのクレートルートなのだと判断します。
Cargoはクレートルートファイルを <code>rustc</code>に渡し、ライブラリやバイナリをビルドします。</p>
<!--
Here, we have a package that only contains *src/main.rs*, meaning it only
contains a binary crate named `my-project`. If a package contains *src/main.rs*
and *src/lib.rs*, it has two crates: a library and a binary, both with the same
name as the package. A package can have multiple binary crates by placing files
in the *src/bin* directory: each file will be a separate binary crate.
-->
<p>今、このパッケージには <em>src/main.rs</em> しか含まれておらず、つまりこのパッケージは<code>my-project</code>という名前のバイナリクレートのみを持っているということです。
もしパッケージが <em>src/main.rs</em> と <em>src/lib.rs</em> を持っていたら、クレートは2つになります：どちらもパッケージと同じ名前を持つ、ライブラリクレートとバイナリクレートです。
ファイルを <em>src/bin</em> ディレクトリに置くことで、パッケージは複数のバイナリクレートを持つことができます。それぞれのファイルが別々のバイナリクレートになります。</p>
<!--
A crate will group related functionality together in a scope so the
functionality is easy to share between multiple projects. For example, the
`rand` crate we used in [Chapter 2][rand] provides functionality
that generates random numbers. We can use that functionality in our own
projects by bringing the `rand` crate into our project’s scope. All the
functionality provided by the `rand` crate is accessible through the crate’s
name, `rand`.
-->
<p>クレートは、関連した機能を一つのスコープにまとめることで、その機能が複数のプロジェクト間で共有しやすいようにします。
例えば、<a href="ch02-00-guessing-game-tutorial.html#%E4%B9%B1%E6%95%B0%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B">2章</a>で使った<code>rand</code>クレートは、乱数を生成する機能を提供します。
<code>rand</code>クレートを私達のプロジェクトのスコープに持ち込むことで、この機能を私達のプロジェクトで使うことができます。
<code>rand</code>クレートが提供する機能にはすべて、クレートの名前<code>rand</code>を使ってアクセスできます。</p>
<!--
Keeping a crate’s functionality in its own scope clarifies whether particular
functionality is defined in our crate or the `rand` crate and prevents
potential conflicts. For example, the `rand` crate provides a trait named
`Rng`. We can also define a `struct` named `Rng` in our own crate. Because a
crate’s functionality is namespaced in its own scope, when we add `rand` as a
dependency, the compiler isn’t confused about what the name `Rng` refers to. In
our crate, it refers to the `struct Rng` that we defined. We would access the
`Rng` trait from the `rand` crate as `rand::Rng`.
-->
<p>クレートの機能をそれ自身のスコープの中に入れたままにしておくことは、ある機能が私達のクレートで定義されたのか<code>rand</code>クレートで定義されたのかを明確にし、名前の衝突を予防してくれます。
例えば、<code>rand</code>クレートは<code>Rng</code>という名前のトレイトを提供しています。
更に、私達のクレートで<code>Rng</code>という名前の<code>struct</code>を定義することもできます。
クレートの機能はそのスコープ内の名前空間に位置づけられているので、<code>rand</code>を依存先として追加しても、コンパイラは<code>Rng</code>という名前が何を意味するのかについて混乱することはないのです。
私達のクレートでは、私達の定義した<code>struct Rng</code>のことであり、<code>rand</code>クレートの<code>Rng</code>トレイトには<code>rand::Rng</code>でアクセスするというわけです。</p>
<!--
Let’s move on and talk about the module system!
-->
<p>では、モジュールシステムの話に移りましょう！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Defining Modules to Control Scope and Privacy
-->
<h2 id="モジュールを定義してスコープとプライバシーを制御する"><a class="header" href="#モジュールを定義してスコープとプライバシーを制御する">モジュールを定義して、スコープとプライバシーを制御する</a></h2>
<!--
In this section, we’ll talk about modules and other parts of the module system,
namely *paths* that allow you to name items; the `use` keyword that brings a
path into scope; and the `pub` keyword to make items public. We’ll also discuss
the `as` keyword, external packages, and the glob operator. For now, let’s
focus on modules!
-->
<p>この節では、モジュールと、その他のモジュールシステムの要素
――すなわち、要素に名前をつけるための <em>パス</em> 、パスをスコープに持ち込む<code>use</code>キーワード、要素を公開する<code>pub</code>キーワード――
について学びます。
また、<code>as</code>キーワード、外部パッケージ、glob演算子についても話します。
とりあえず、今はモジュールに集中しましょう！</p>
<!--
*Modules* let us organize code within a crate into groups for readability and
easy reuse. Modules also control the *privacy* of items, which is whether an
item can be used by outside code (*public*) or is an internal implementation
detail and not available for outside use (*private*).
-->
<p><em>モジュール</em> はクレート内のコードをグループ化し、可読性と再利用性を上げるのに役に立ちます。
モジュールは要素の <em>プライバシー</em> も制御できます。プライバシーとは、要素がコードの外側で使える <em>(公開 public)</em> のか、内部の実装の詳細であり外部では使えない <em>(非公開 private)</em> のかです。</p>
<!--
As an example, let’s write a library crate that provides the functionality of a
restaurant. We’ll define the signatures of functions but leave their bodies
empty to concentrate on the organization of the code, rather than actually
implement a restaurant in code.
-->
<p>例えば、レストランの機能を提供するライブラリクレートを書いてみましょう。
実際にレストランを実装することではなく、コードの関係性に注目したいので、関数にシグネチャをつけますが中身は空白のままにします。</p>
<!--
In the restaurant industry, some parts of a restaurant are referred to as
*front of house* and others as *back of house*. Front of house is where
customers are; this is where hosts seat customers, servers take orders and
payment, and bartenders make drinks. Back of house is where the chefs and cooks
work in the kitchen, dishwashers clean up, and managers do administrative work.
-->
<p>レストラン業界では、レストランの一部を <em>接客部門 (front of house)</em> といい、その他を <em>後方部門 (back of house)</em> といいます。
接客部門とはお客さんがいるところです。接客係がお客様を席に案内し、給仕係が注文と支払いを受け付け、バーテンダーが飲み物を作ります。
後方部門とはシェフや料理人がキッチンで働き、皿洗い係が食器を片付け、マネージャが管理業務をする場所です。</p>
<!--
To structure our crate in the same way that a real restaurant works, we can
organize the functions into nested modules. Create a new library named
`restaurant` by running `cargo new --lib restaurant`; then put the code in
Listing 7-1 into *src/lib.rs* to define some modules and function signatures.
-->
<p>私達のクレートを現実のレストランと同じような構造にするために、関数をネストしたモジュールにまとめましょう。
<code>restaurant</code>という名前の新しいライブラリを<code>cargo new --lib restaurant</code>と実行することで作成し、Listing 7-1 のコードを <em>src/lib.rs</em> に書き込み、モジュールと関数のシグネチャを定義してください。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-1: A `front_of_house` module containing other
modules that then contain functions</span>
-->
<p><span class="caption">Listing 7-1: <code>front_of_house</code>モジュールにその他のモジュールが含まれ、さらにそれらが関数を含んでいる</span></p>
<!--
We define a module by starting with the `mod` keyword and then specify the
name of the module (in this case, `front_of_house`) and place curly brackets
around the body of the module. Inside modules, we can have other modules, as in
this case with the modules `hosting` and `serving`. Modules can also hold
definitions for other items, such as structs, enums, constants, traits, or—as
in Listing 7-1—functions.
-->
<p>モジュールは、<code>mod</code>キーワードを書き、次にモジュールの名前（今回の場合、<code>front_of_house</code>）を指定することで定義されます。
モジュールの中には、今回だと<code>hosting</code>と<code>serving</code>のように、他のモジュールをおくこともできます。
モジュールにはその他の要素の定義も置くことができます。例えば、構造体、enum、定数、トレイト、そして（Listing 7-1のように）関数です。</p>
<!--
By using modules, we can group related definitions together and name why
they’re related. Programmers using this code would have an easier time finding
the definitions they wanted to use because they could navigate the code based
on the groups rather than having to read through all the definitions.
Programmers adding new functionality to this code would know where to place the
code to keep the program organized.
-->
<p>モジュールを使うことで、関連する定義を一つにまとめ、関連する理由を名前で示せます。
このコードを使うプログラマーは、定義を全部読むことなく、グループ単位でコードを読み進められるので、欲しい定義を見つけ出すのが簡単になるでしょう。
このコードに新しい機能を付け加えるプログラマーは、プログラムのまとまりを保つために、どこにその機能のコードを置けば良いのかがわかるでしょう。</p>
<!--
Earlier, we mentioned that *src/main.rs* and *src/lib.rs* are called crate
roots. The reason for their name is that the contents of either of these two
files form a module named `crate` at the root of the crate’s module structure,
known as the *module tree*.
-->
<p>以前、 <em>src/main.rs</em> と <em>src/lib.rs</em> はクレートルートと呼ばれていると言いました。
この名前のわけは、 <em>モジュールツリー</em> と呼ばれるクレートのモジュール構造の根っこ （ルート）にこれら2つのファイルの中身が<code>crate</code>というモジュールを形成するからです。</p>
<!--
Listing 7-2 shows the module tree for the structure in Listing 7-1.
-->
<p>Listing 7-2は、Listing 7-1の構造のモジュールツリーを示しています。</p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<!--
<span class="caption">Listing 7-2: The module tree for the code in Listing
7-1</span>
-->
<p><span class="caption">Listing 7-2: Listing 7-1 のコードのモジュールツリー</span></p>
<!--
This tree shows how some of the modules nest inside one another (for example,
`hosting` nests inside `front_of_house`). The tree also shows that some modules
are *siblings* to each other, meaning they’re defined in the same module
(`hosting` and `serving` are defined within `front_of_house`). To continue the
family metaphor, if module A is contained inside module B, we say that module A
is the *child* of module B and that module B is the *parent* of module A.
Notice that the entire module tree is rooted under the implicit module named
`crate`.
-->
<p>このツリーを見ると、どのモジュールがどのモジュールの中にネストしているのかがわかります（例えば、<code>hosting</code>は<code>front_of_house</code>の中にネストしています）。
また、いくつかのモジュールはお互いに <em>兄弟</em> の関係にある、つまり、同じモジュール内で定義されていることもわかります（例えば<code>hosting</code>と<code>serving</code>は<code>front_of_house</code>で定義されています）。
他にも、家族関係の比喩を使って、モジュールAがモジュールBの中に入っている時、AはBの <em>子</em> であるといい、BはAの <em>親</em> であるといいます。
モジュールツリー全体が、暗黙のうちに作られた<code>crate</code>というモジュールの下にあることにも注目してください。</p>
<!--
The module tree might remind you of the filesystem’s directory tree on your
computer; this is a very apt comparison! Just like directories in a filesystem,
you use modules to organize your code. And just like files in a directory, we
need a way to find our modules.
-->
<p>モジュールツリーを見ていると、コンピュータのファイルシステムのディレクトリツリーを思い出すかもしれません。その喩えはとても適切です！
ファイルシステムのディレクトリのように、モジュールはコードをまとめるのに使われるのです。
そしてディレクトリからファイルを見つけるように、目的のモジュールを見つけ出す方法が必要になります。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Paths for Referring to an Item in the Module Tree
-->
<h2 id="モジュールツリーの要素を示すためのパス"><a class="header" href="#モジュールツリーの要素を示すためのパス">モジュールツリーの要素を示すためのパス</a></h2>
<!--
To show Rust where to find an item in a module tree, we use a path in the same
way we use a path when navigating a filesystem. If we want to call a function,
we need to know its path.
-->
<p>ファイルシステムの中を移動する時と同じように、Rustにモジュールツリー内の要素を見つけるためにはどこを探せばいいのか教えるためにパスを使います。
関数を呼び出したいなら、そのパスを知っていなければなりません。</p>
<!--
A path can take two forms:
-->
<p>パスは2つの形を取ることができます：</p>
<!--
* An *absolute path* starts from a crate root by using a crate name or a
  literal `crate`.
* A *relative path* starts from the current module and uses `self`, `super`, or
  an identifier in the current module.
-->
<ul>
<li><em>絶対パス</em> は、クレートの名前か<code>crate</code>という文字列を使うことで、クレートルートからスタートします。</li>
<li><em>相対パス</em> は、<code>self</code>、<code>super</code>または今のモジュール内の識別子を使うことで、現在のモジュールからスタートします。</li>
</ul>
<!--
Both absolute and relative paths are followed by one or more identifiers
separated by double colons (`::`).
-->
<p>絶対パスも相対パスも、その後に一つ以上の識別子がダブルコロン(<code>::</code>)で仕切られて続きます。</p>
<!--
Let’s return to the example in Listing 7-1. How do we call the
`add_to_waitlist` function? This is the same as asking, what’s the path of the
`add_to_waitlist` function? In Listing 7-3, we simplified our code a bit by
removing some of the modules and functions. We’ll show two ways to call the
`add_to_waitlist` function from a new function `eat_at_restaurant` defined in
the crate root. The `eat_at_restaurant` function is part of our library crate’s
public API, so we mark it with the `pub` keyword. In the [”Exposing Paths with
the `pub` Keyword”][pub] section, we’ll go into more detail
about `pub`. Note that this example won’t compile just yet; we’ll explain why
in a bit.
-->
<p>Listing 7-1の例に戻ってみましょう。
<code>add_to_waitlist</code>関数をどうやって呼べばいいでしょうか？
すなわち、<code>add_to_waitlist</code>のパスは何でしょうか？
Listing 7-3 は、モジュールと関数をいくつか取り除いてコードをやや簡潔にしています。
これを使って、クレートルートに定義された新しい<code>eat_at_restaurant</code>という関数から、<code>add_to_waitlist</code>関数を呼びだす2つの方法を示しましょう。
<code>eat_at_restaurant</code>関数はこのライブラリクレートの公開 (public) APIの1つなので、<code>pub</code>キーワードをつけておきます。
<code>pub</code>については、<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#%E3%83%91%E3%82%B9%E3%82%92pub%E3%82%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%89%E3%81%A7%E5%85%AC%E9%96%8B%E3%81%99%E3%82%8B">パスを<code>pub</code>キーワードで公開する</a><!-- ignore -->の節でより詳しく学びます。
この例はまだコンパイルできないことに注意してください。理由はすぐに説明します。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    // 絶対パス
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    // 相対パス
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<!--
<span class="caption">Listing 7-3: Calling the `add_to_waitlist` function using
absolute and relative paths</span>
-->
<p><span class="caption">Listing 7-3: <code>add_to_waitlist</code> 関数を絶対パスと相対パスで呼び出す</span></p>
<!--
The first time we call the `add_to_waitlist` function in `eat_at_restaurant`,
we use an absolute path. The `add_to_waitlist` function is defined in the same
crate as `eat_at_restaurant`, which means we can use the `crate` keyword to
start an absolute path.
-->
<p><code>eat_at_restaurant</code>で最初に<code>add_to_waitlist</code>関数を呼び出す時、絶対パスを使っています。
<code>add_to_waitlist</code>関数は<code>eat_at_restaurant</code>と同じクレートで定義されているので、<code>crate</code>キーワードで絶対パスを始めることができます。</p>
<!--
After `crate`, we include each of the successive modules until we make our way
to `add_to_waitlist`. You can imagine a filesystem with the same structure, and
we’d specify the path `/front_of_house/hosting/add_to_waitlist` to run the
`add_to_waitlist` program; using the `crate` name to start from the crate root
is like using `/` to start from the filesystem root in your shell.
-->
<p><code>crate</code>の後は、<code>add_to_waitlist</code>にたどり着くまで、後に続くモジュールを書き込んでいます。
同じ構造のファイルシステムを想像すれば、<code>/front_of_house/hosting/add_to_waitlist</code>とパスを指定して<code>add_to_waitlist</code>を実行していることに相当します。
<code>crate</code>という名前を使ってクレートルートからスタートするというのは、<code>/</code>を使ってファイルシステムのルートからスタートするようなものです。</p>
<!--
The second time we call `add_to_waitlist` in `eat_at_restaurant`, we use a
relative path. The path starts with `front_of_house`, the name of the module
defined at the same level of the module tree as `eat_at_restaurant`. Here the
filesystem equivalent would be using the path
`front_of_house/hosting/add_to_waitlist`. Starting with a name means that the
path is relative.
-->
<p><code>eat_at_restaurant</code>で2回目に<code>add_to_waitlist</code>関数を呼び出す時、相対パスを使っています。
パスは、モジュールツリーにおいて<code>eat_at_restaurant</code>と同じ階層で定義されているモジュールである<code>front_of_house</code>からスタートします。
これはファイルシステムで<code>front_of_house/hosting/add_to_waitlist</code>というパスを使っているのに相当します。
名前から始めるのは、パスが相対パスであることを意味します。</p>
<!--
Choosing whether to use a relative or absolute path is a decision you’ll make
based on your project. The decision should depend on whether you’re more likely
to move item definition code separately from or together with the code that
uses the item. For example, if we move the `front_of_house` module and the
`eat_at_restaurant` function into a module named `customer_experience`, we’d
need to update the absolute path to `add_to_waitlist`, but the relative path
would still be valid. However, if we moved the `eat_at_restaurant` function
separately into a module named `dining`, the absolute path to the
`add_to_waitlist` call would stay the same, but the relative path would need to
be updated. Our preference is to specify absolute paths because it’s more
likely to move code definitions and item calls independently of each other.
-->
<p>相対パスを使うか絶対パスを使うかは、プロジェクトによって決めましょう。
要素を定義するコードを、その要素を使うコードと別々に動かすか一緒に動かすか、どちらが起こりそうかによって決めるのが良いです。
例えば、<code>front_of_house</code>モジュールと<code>eat_at_restaurant</code>関数を<code>customer_experience</code>というモジュールに移動させると、<code>add_to_waitlist</code>への絶対パスを更新しないといけませんが、相対パスは有効なままです。
しかし、<code>eat_at_restaurant</code>関数だけを<code>dining</code>というモジュールに移動させると、<code>add_to_waitlist</code>への絶対パスは同じままですが、相対パスは更新しないといけないでしょう。
コードの定義と、その要素の呼び出しは独立に動かしそうなので、絶対パスのほうが好ましいです。</p>
<!--
Let’s try to compile Listing 7-3 and find out why it won’t compile yet! The
error we get is shown in Listing 7-4.
-->
<p>では、Listing 7-3 をコンパイルしてみて、どうしてこれはまだコンパイルできないのか考えてみましょう！
エラーをListing 7-4 に示しています。</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
<span class="caption">Listing 7-4: Compiler errors from building the code in
Listing 7-3</span>
-->
<p><span class="caption">Listing 7-4: Listing 7-3のコードをビルドしたときのコンパイルエラー</span></p>
<!--
The error messages say that module `hosting` is private. In other words, we
have the correct paths for the `hosting` module and the `add_to_waitlist`
function, but Rust won’t let us use them because it doesn’t have access to the
private sections.
-->
<p>エラーメッセージは、<code>hosting</code>は非公開 (private) だ、と言っています。
言い換えるなら、<code>hosting</code>モジュールと<code>add_to_waitlist</code>関数へのパスは正しいが、非公開な部分へのアクセスは許可されていないので、Rustがそれを使わせてくれないということです。</p>
<!--
Modules aren’t useful only for organizing your code. They also define Rust’s
*privacy boundary*: the line that encapsulates the implementation details
external code isn’t allowed to know about, call, or rely on. So, if you want to
make an item like a function or struct private, you put it in a module.
-->
<p>モジュールはコードの整理に役立つだけではありません。
モジュールはRustの <em>プライバシー境界</em> も定義します。これは、外部のコードが知ったり、呼び出したり、依存したりしてはいけない実装の詳細をカプセル化する線引きです。
なので、関数や構造体といった要素を非公開にしたければ、モジュールに入れればよいのです。</p>
<!--
The way privacy works in Rust is that all items (functions, methods, structs,
enums, modules, and constants) are private by default. Items in a parent module
can’t use the private items inside child modules, but items in child modules
can use the items in their ancestor modules. The reason is that child modules
wrap and hide their implementation details, but the child modules can see the
context in which they’re defined. To continue with the restaurant metaphor,
think of the privacy rules as being like the back office of a restaurant: what
goes on in there is private to restaurant customers, but office managers can
see and do everything in the restaurant in which they operate.
-->
<p>Rustにおけるプライバシーは、「あらゆる要素（関数、メソッド、構造体、enum、モジュールおよび定数）は標準では非公開」というやり方で動いています。
親モジュールの要素は子モジュールの非公開要素を使えませんが、子モジュールの要素はその祖先モジュールの要素を使えます。
これは、子モジュールは実装の詳細を覆い隠しますが、子モジュールは自分の定義された文脈を見ることができるためです。
レストランの喩えを続けるなら、レストランの後方部門になったつもりでプライバシーのルールを考えてみてください。レストランの顧客にはそこで何が起こっているのかは非公開ですが、そこで働くオフィスマネージャには、レストランのことは何でも見えるし何でもできるのです。</p>
<!--
Rust chose to have the module system function this way so that hiding inner
implementation details is the default. That way, you know which parts of the
inner code you can change without breaking outer code. But you can expose inner
parts of child modules' code to outer ancestor modules by using the `pub`
keyword to make an item public.
-->
<p>Rustは、内部実装の詳細を隠すことが標準であるようにモジュールシステムを機能させることを選択しました。
こうすることで、内部のコードのどの部分が、外部のコードを壊すことなく変更できるのかを知ることができます。
しかし、<code>pub</code>キーワードを使って要素を公開することで、子モジュールの内部部品を外部の祖先モジュールに見せることができます。</p>
<!--
### Exposing Paths with the `pub` Keyword
-->
<h3 id="パスをpubキーワードで公開する"><a class="header" href="#パスをpubキーワードで公開する">パスを<code>pub</code>キーワードで公開する</a></h3>
<!--
Let’s return to the error in Listing 7-4 that told us the `hosting` module is
private. We want the `eat_at_restaurant` function in the parent module to have
access to the `add_to_waitlist` function in the child module, so we mark the
`hosting` module with the `pub` keyword, as shown in Listing 7-5.
-->
<p>Listing 7-4の、<code>hosting</code>モジュールが非公開だと言ってきていたエラーに戻りましょう。
親モジュールの<code>eat_at_restaurant</code>関数が子モジュールの<code>add_to_waitlist</code>関数にアクセスできるようにしたいので、<code>hosting</code>モジュールに<code>pub</code>キーワードをつけます。Listing 7-5のようになります。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    // 絶対パス
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    // 相対パス
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<!--
<span class="caption">Listing 7-5: Declaring the `hosting` module as `pub` to
use it from `eat_at_restaurant`</span>
-->
<p><span class="caption">Listing 7-5: <code>hosting</code> モジュールを <code>pub</code> として宣言することで<code>eat_at_restaurant</code>から使う</span></p>
<!--
Unfortunately, the code in Listing 7-5 still results in an error, as shown in
Listing 7-6.
-->
<p>残念ながら、Listing 7-5 のコードもListing 7-6 に示されるようにエラーとなります。</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
<span class="caption">Listing 7-6: Compiler errors from building the code in
Listing 7-5</span>
-->
<p><span class="caption">Listing 7-6: Listing 7-5 のコードをビルドしたときのコンパイルエラー</span></p>
<!--
What happened? Adding the `pub` keyword in front of `mod hosting` makes the
module public. With this change, if we can access `front_of_house`, we can
access `hosting`. But the *contents* of `hosting` are still private; making the
module public doesn’t make its contents public. The `pub` keyword on a module
only lets code in its ancestor modules refer to it.
-->
<p>何が起きたのでしょう？<code>pub</code>キーワードを<code>mod hosting</code>の前に追加したことで、このモジュールは公開されました。
この変更によって、<code>front_of_house</code>にアクセスできるなら、<code>hosting</code>にもアクセスできるようになりました。
しかし<code>hosting</code>の <em>中身</em> はまだ非公開です。モジュールを公開してもその中身は公開されないのです。
モジュールに<code>pub</code>キーワードがついていても、祖先モジュールのコードはモジュールを参照できるようになるだけです。</p>
<!--
The errors in Listing 7-6 say that the `add_to_waitlist` function is private.
The privacy rules apply to structs, enums, functions, and methods as well as
modules.
-->
<p>Listing 7-6 のエラーは<code>add_to_waitlist</code>関数が非公開だと言っています。
プライバシーのルールは、モジュール同様、構造体、enum、関数、メソッドにも適用されるのです。</p>
<!--
Let’s also make the `add_to_waitlist` function public by adding the `pub`
keyword before its definition, as in Listing 7-7.
-->
<p><code>add_to_waitlist</code>の定義の前に<code>pub</code>キーワードを追加して、これも公開しましょう。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    // 絶対パス
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    // 相対パス
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-7: Adding the `pub` keyword to `mod hosting`
and `fn add_to_waitlist` lets us call the function from
`eat_at_restaurant`</span>
-->
<p><span class="caption">Listing 7-7: <code>pub</code>キーワードを<code>mod hosting</code>と<code>fn add_to_waitlist</code>に追加することで、<code>eat_at_restaurant</code>からこの関数を呼べるようになる</span></p>
<!--
Now the code will compile! Let’s look at the absolute and the relative path and
double-check why adding the `pub` keyword lets us use these paths in
`add_to_waitlist` with respect to the privacy rules.
-->
<p>これでこのコードはコンパイルできます！
絶対パスと相対パスをもう一度確認して、どうして<code>pub</code>キーワードを追加することで<code>add_to_waitlist</code>のそれらのパスを使えるようになるのか、プライバシールールの観点からもう一度確認してみてみましょう。</p>
<!--
In the absolute path, we start with `crate`, the root of our crate’s module
tree. Then the `front_of_house` module is defined in the crate root. The
`front_of_house` module isn’t public, but because the `eat_at_restaurant`
function is defined in the same module as `front_of_house` (that is,
`eat_at_restaurant` and `front_of_house` are siblings), we can refer to
`front_of_house` from `eat_at_restaurant`. Next is the `hosting` module marked
with `pub`. We can access the parent module of `hosting`, so we can access
`hosting`. Finally, the `add_to_waitlist` function is marked with `pub` and we
can access its parent module, so this function call works!
-->
<p>絶対パスは、クレートのモジュールツリーのルートである<code>crate</code>から始まります。
クレートルートの中に<code>front_of_house</code>が定義されています。
<code>front_of_house</code>は公開されていませんが、<code>eat_at_restaurant</code>関数は<code>front_of_house</code>と同じモジュール内で定義されている（つまり、<code>eat_at_restaurant</code>と<code>front_of_house</code>は兄弟な）ので、<code>eat_at_restaurant</code>から<code>front_of_house</code>を参照することができます。
次は<code>pub</code>の付いた<code>hosting</code>モジュールです。
<code>hosting</code>の親モジュールにアクセスできるので、<code>hosting</code>にもアクセスできます。
最後に、<code>add_to_waitlist</code>関数は<code>pub</code>が付いており、私達はその親モジュールにアクセスできるので、この関数呼び出しはうまく行くというわけです。</p>
<!--
In the relative path, the logic is the same as the absolute path except for the
first step: rather than starting from the crate root, the path starts from
`front_of_house`. The `front_of_house` module is defined within the same module
as `eat_at_restaurant`, so the relative path starting from the module in which
`eat_at_restaurant` is defined works. Then, because `hosting` and
`add_to_waitlist` are marked with `pub`, the rest of the path works, and this
function call is valid!
-->
<p>相対パスについても、最初のステップを除けば同じ理屈です。パスをクレートルートから始めるのではなくて、<code>front_of_house</code>から始めるのです。
<code>front_of_house</code>モジュールは<code>eat_at_restaurant</code>と同じモジュールで定義されているので、<code>eat_at_restaurant</code>が定義されている場所からの相対パスが使えます。
そして、<code>hosting</code>と<code>add_to_waitlist</code>は<code>pub</code>が付いていますから、残りのパスについても問題はなく、この関数呼び出しは有効というわけです。</p>
<!--
### Starting Relative Paths with `super`
-->
<h3 id="相対パスをsuperで始める"><a class="header" href="#相対パスをsuperで始める">相対パスを<code>super</code>で始める</a></h3>
<!--
We can also construct relative paths that begin in the parent module by using
`super` at the start of the path. This is like starting a filesystem path with
the `..` syntax. Why would we want to do this?
-->
<p>親モジュールから始まる相対パスなら、<code>super</code>を最初につけることで構成できます。
ファイルシステムパスを<code>..</code>構文で始めるのに似ています。
どのようなときにこの機能が使いたくなるのでしょう？</p>
<!--
Consider the code in Listing 7-8 that models the situation in which a chef
fixes an incorrect order and personally brings it out to the customer. The
function `fix_incorrect_order` calls the function `serve_order` by specifying
the path to `serve_order` starting with `super`:
-->
<p>シェフが間違った注文を修正し、自分でお客さんに持っていくという状況をモデル化している、Listing 7-8 を考えてみてください。
<code>fix_incorrect_order</code>関数は<code>serve_order</code>関数を呼び出すために、<code>super</code>から始まる<code>serve_order</code>関数へのパスを使っています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-8: Calling a function using a relative path
starting with `super`</span>
-->
<p><span class="caption">Listing 7-8: <code>super</code> で始まる相対パスを使って関数を呼び出す</span></p>
<!--
The `fix_incorrect_order` function is in the `back_of_house` module, so we can
use `super` to go to the parent module of `back_of_house`, which in this case
is `crate`, the root. From there, we look for `serve_order` and find it.
Success! We think the `back_of_house` module and the `serve_order` function are
likely to stay in the same relationship to each other and get moved together
should we decide to reorganize the crate’s module tree. Therefore, we used
`super` so we’ll have fewer places to update code in the future if this code
gets moved to a different module.
-->
<p><code>fix_incorrect_order</code>関数は<code>back_of_house</code>モジュールの中にあるので、<code>super</code>を使って<code>back_of_house</code>の親モジュールにいけます。親モジュールは、今回の場合ルートである<code>crate</code>です。
そこから、<code>serve_order</code>を探し、見つけ出します。
成功！
もしクレートのモジュールツリーを再編成することにした場合でも、<code>back_of_house</code>モジュールと<code>serve_order</code>関数は同じ関係性で有り続け、一緒に動くように思われます。
そのため、<code>super</code>を使うことで、将来このコードが別のモジュールに移動するとしても、更新する場所が少なくて済むようにしました。</p>
<!--
### Making Structs and Enums Public
-->
<h3 id="構造体とenumを公開する"><a class="header" href="#構造体とenumを公開する">構造体とenumを公開する</a></h3>
<!--
We can also use `pub` to designate structs and enums as public, but there are a
few extra details. If we use `pub` before a struct definition, we make the
struct public, but the struct’s fields will still be private. We can make each
field public or not on a case-by-case basis. In Listing 7-9, we’ve defined a
public `back_of_house::Breakfast` struct with a public `toast` field but a
private `seasonal_fruit` field. This models the case in a restaurant where the
customer can pick the type of bread that comes with a meal, but the chef
decides which fruit accompanies the meal based on what’s in season and in
stock. The available fruit changes quickly, so customers can’t choose the fruit
or even see which fruit they’ll get.
-->
<p>構造体やenumも<code>pub</code>を使って公開するよう指定できますが、追加の細目がいくつかあります。
構造体定義の前に<code>pub</code>を使うと、構造体は公開されますが、構造体のフィールドは非公開のままなのです。
それぞれのフィールドを公開するか否かを個々に決められます。
Listing 7-9 では、公開の<code>toast</code>フィールドと、非公開の<code>seasonal_fruit</code>フィールドをもつ公開の<code>back_of_house::Breakfast</code>構造体を定義しました。
これは、例えば、レストランで、お客さんが食事についてくるパンの種類は選べるけれど、食事についてくるフルーツは季節と在庫に合わせてシェフが決める、という状況をモデル化しています。
提供できるフルーツはすぐに変わるので、お客さんはフルーツを選ぶどころかどんなフルーツが提供されるのか知ることもできません。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;peaches&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    // 夏 (summer) にライ麦 (Rye) パン付き朝食を注文
    let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);
    // Change our mind about what bread we'd like
    // やっぱり別のパンにする
    meal.toast = String::from(&quot;Wheat&quot;);
    println!(&quot;I'd like {} toast please&quot;, meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // 下の行のコメントを外すとコンパイルできない。食事についてくる
    // 季節のフルーツを知ることも修正することも許されていないので
    // meal.seasonal_fruit = String::from(&quot;blueberries&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-9: A struct with some public fields and some
private fields</span>
-->
<p><span class="caption">Listing 7-9: 公開のフィールドと非公開のフィールドとを持つ構造体</span></p>
<!--
Because the `toast` field in the `back_of_house::Breakfast` struct is public,
in `eat_at_restaurant` we can write and read to the `toast` field using dot
notation. Notice that we can’t use the `seasonal_fruit` field in
`eat_at_restaurant` because `seasonal_fruit` is private. Try uncommenting the
line modifying the `seasonal_fruit` field value to see what error you get!
-->
<p><code>back_of_house::Breakfast</code>の<code>toast</code>フィールドは公開されているので、<code>eat_at_restaurant</code>において<code>toast</code>をドット記法を使って読み書きできます。
<code>seasonal_fruit</code>は非公開なので、<code>eat_at_restaurant</code>において<code>seasonal_fruit</code>は使えないということに注意してください。
<code>seasonal_fruit</code>を修正している行のコメントを外して、どのようなエラーが得られるか試してみてください！</p>
<!--
Also, note that because `back_of_house::Breakfast` has a private field, the
struct needs to provide a public associated function that constructs an
instance of `Breakfast` (we’ve named it `summer` here). If `Breakfast` didn’t
have such a function, we couldn’t create an instance of `Breakfast` in
`eat_at_restaurant` because we couldn’t set the value of the private
`seasonal_fruit` field in `eat_at_restaurant`.
-->
<p>また、<code>back_of_house::Breakfast</code>は非公開のフィールドを持っているので、<code>Breakfast</code>のインスタンスを作成 (construct) する公開された関連関数が構造体によって提供されている必要があります（ここでは<code>summer</code>と名付けました）。
もし<code>Breakfast</code>にそのような関数がなかったら、<code>eat_at_restaurant</code>において非公開である<code>seasonal_fruit</code>の値を設定できないので、<code>Breakfast</code>のインスタンスを作成できません。</p>
<!--
In contrast, if we make an enum public, all of its variants are then public. We
only need the `pub` before the `enum` keyword, as shown in Listing 7-10.
-->
<p>一方で、enumを公開すると、そのヴァリアントはすべて公開されます。
Listing 7-10 に示されているように、<code>pub</code>は<code>enum</code>キーワードの前にだけおけばよいのです。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-10: Designating an enum as public makes all its
variants public</span>
-->
<p><span class="caption">Listing 7-10: enumを公開に指定することはそのヴァリアントをすべて公開にする</span></p>
<!--
Because we made the `Appetizer` enum public, we can use the `Soup` and `Salad`
variants in `eat_at_restaurant`. Enums aren’t very useful unless their variants
are public; it would be annoying to have to annotate all enum variants with
`pub` in every case, so the default for enum variants is to be public. Structs
are often useful without their fields being public, so struct fields follow the
general rule of everything being private by default unless annotated with `pub`.
-->
<p><code>Appetizer</code>というenumを公開したので、<code>Soup</code>と<code>Salad</code>というヴァリアントも<code>eat_at_restaurant</code>で使えます。
enumはヴァリアントが公開されてないとあまり便利ではないのですが、毎回enumのすべてのヴァリアントに<code>pub</code>をつけるのは面倒なので、enumのヴァリアントは標準で公開されるようになっているのです。
構造体はフィールドが公開されていなくても便利なことが多いので、構造体のフィールドは、<code>pub</code>がついてない限り標準で非公開という通常のルールに従うわけです。</p>
<!--
There’s one more situation involving `pub` that we haven’t covered, and that is
our last module system feature: the `use` keyword. We’ll cover `use` by itself
first, and then we’ll show how to combine `pub` and `use`.
-->
<p>まだ勉強していない、<code>pub</code>の関わるシチュエーションがもう一つあります。モジュールシステムの最後の機能、<code>use</code>キーワードです。
<code>use</code>自体の勉強をした後、<code>pub</code>と<code>use</code>を組み合わせる方法についてお見せします。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Bringing Paths into Scope with the `use` Keyword
-->
<h2 id="useキーワードでパスをスコープに持ち込む"><a class="header" href="#useキーワードでパスをスコープに持ち込む"><code>use</code>キーワードでパスをスコープに持ち込む</a></h2>
<!--
It might seem like the paths we’ve written to call functions so far are
inconveniently long and repetitive. For example, in Listing 7-7, whether we
chose the absolute or relative path to the `add_to_waitlist` function, every
time we wanted to call `add_to_waitlist` we had to specify `front_of_house` and
`hosting` too. Fortunately, there’s a way to simplify this process. We can
bring a path into a scope once and then call the items in that path as if
they’re local items with the `use` keyword.
-->
<p>これまで関数呼び出しのために書いてきたパスは、長く、繰り返しも多くて不便なものでした。
例えば、Listing 7-7 においては、絶対パスを使うか相対パスを使うかにかかわらず、<code>add_to_waitlist</code>関数を呼ぼうと思うたびに<code>front_of_house</code>と<code>hosting</code>も指定しないといけませんでした。
ありがたいことに、この手続きを簡単化する方法があります。
<code>use</code>キーワードを使うことで、パスを一度スコープに持ち込んでしまえば、それ以降はパス内の要素がローカルにあるかのように呼び出すことができるのです。</p>
<!--
In Listing 7-11, we bring the `crate::front_of_house::hosting` module into the
scope of the `eat_at_restaurant` function so we only have to specify
`hosting::add_to_waitlist` to call the `add_to_waitlist` function in
`eat_at_restaurant`.
-->
<p>Listing 7-11 では、<code>crate::front_of_house::hosting</code>モジュールを<code>eat_at_restaurant</code>関数のスコープに持ち込むことで、<code>eat_at_restaurant</code>において、<code>hosting::add_to_waitlist</code>と指定するだけで<code>add_to_waitlist</code>関数を呼び出せるようにしています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-11: Bringing a module into scope with
`use`</span>
-->
<p><span class="caption">Listing 7-11: <code>use</code> でモジュールをスコープに持ち込む</span></p>
<!--
Adding `use` and a path in a scope is similar to creating a symbolic link in
the filesystem. By adding `use crate::front_of_house::hosting` in the crate
root, `hosting` is now a valid name in that scope, just as though the `hosting`
module had been defined in the crate root. Paths brought into scope with `use`
also check privacy, like any other paths.
-->
<p><code>use</code>とパスをスコープに追加することは、ファイルシステムにおいてシンボリックリンクを張ることに似ています。
<code>use crate::front_of_house::hosting</code>をクレートルートに追加することで、<code>hosting</code>はこのスコープで有効な名前となり、まるで<code>hosting</code>はクレートルートで定義されていたかのようになります。
スコープに<code>use</code>で持ち込まれたパスも、他のパスと同じようにプライバシーがチェックされます。</p>
<!--
You can also bring an item into scope with `use` and a relative path. Listing
7-12 shows how to specify a relative path to get the same behavior as in
Listing 7-11.
-->
<p><code>use</code>と相対パスで要素をスコープに持ち込むこともできます。
Listing 7-12 はListing 7-11 と同じふるまいを得るためにどう相対パスを書けば良いかを示しています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use self::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-12: Bringing a module into scope with `use` and
a relative path</span>
-->
<p><span class="caption">Listing 7-12: モジュールを<code>use</code>と相対パスを使ってスコープに持ち込む</span></p>
<!--
### Creating Idiomatic `use` Paths
-->
<h3 id="慣例に従ったuseパスを作る"><a class="header" href="#慣例に従ったuseパスを作る">慣例に従った<code>use</code>パスを作る</a></h3>
<!--
In Listing 7-11, you might have wondered why we specified `use
crate::front_of_house::hosting` and then called `hosting::add_to_waitlist` in
`eat_at_restaurant` rather than specifying the `use` path all the way out to
the `add_to_waitlist` function to achieve the same result, as in Listing 7-13.
-->
<p>Listing 7-11 を見て、なぜ<code>use crate::front_of_house::hosting</code>と書いて<code>eat_at_restaurant</code>内で<code>hosting::add_to_waitlist</code>と呼び出したのか不思議に思っているかもしれません。Listing 7-13 のように、<code>use</code>で<code>add_to_waitlist</code>までのパスをすべて指定しても同じ結果が得られるのに、と。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-13: Bringing the `add_to_waitlist` function
into scope with `use`, which is unidiomatic</span>
-->
<p><span class="caption">Listing 7-13: <code>add_to_waitlist</code> 関数を<code>use</code> でスコープに持ち込む。このやりかたは慣例的ではない</span></p>
<!--
Although both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is
the idiomatic way to bring a function into scope with `use`. Bringing the
function’s parent module into scope with `use` so we have to specify the parent
module when calling the function makes it clear that the function isn’t locally
defined while still minimizing repetition of the full path. The code in Listing
7-13 is unclear as to where `add_to_waitlist` is defined.
-->
<p>Listing 7-11 も 7-13 もおなじ仕事をしてくれますが、関数をスコープに<code>use</code>で持ち込む場合、Listing 7-11 のほうが慣例的なやり方です。
関数の親モジュールを<code>use</code>で持ち込むことで、関数を呼び出す際、毎回親モジュールを指定しなければならないようにすれば、フルパスを繰り返して書くことを抑えつつ、関数がローカルで定義されていないことを明らかにできます。
Listing 7-13 のコードではどこで<code>add_to_waitlist</code>が定義されたのかが不明瞭です。</p>
<!--
On the other hand, when bringing in structs, enums, and other items with `use`,
it’s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way
to bring the standard library’s `HashMap` struct into the scope of a binary
crate.
-->
<p>一方で、構造体やenumその他の要素を<code>use</code>で持ち込むときは、フルパスを書くのが慣例的です。
Listing 7-14 は標準ライブラリの<code>HashMap</code>構造体をバイナリクレートのスコープに持ち込む慣例的なやり方を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<!--
<span class="caption">Listing 7-14: Bringing `HashMap` into scope in an
idiomatic way</span>
-->
<p><span class="caption">Listing 7-14: <code>HashMap</code>を慣例的なやり方でスコープに持ち込む</span></p>
<!--
There’s no strong reason behind this idiom: it’s just the convention that has
emerged, and folks have gotten used to reading and writing Rust code this way.
-->
<p>こちらの慣例の背後には、はっきりとした理由はありません。自然に発生した慣習であり、みんなRustのコードをこのやり方で読み書きするのに慣れてしまったというだけです。</p>
<!--
The exception to this idiom is if we’re bringing two items with the same name
into scope with `use` statements, because Rust doesn’t allow that. Listing 7-15
shows how to bring two `Result` types into scope that have the same name but
different parent modules and how to refer to them.
-->
<p>同じ名前の2つの要素を<code>use</code>でスコープに持ち込むのはRustでは許されないので、そのときこの慣例は例外的に不可能です。
Listing 7-15は、同じ名前を持つけれど異なる親モジュールを持つ2つの<code>Result</code>型をスコープに持ち込み、それらを参照するやり方を示しています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
    // （略）
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
    // （略）
<span class="boring">    Ok(())
</span>}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-15: Bringing two types with the same name into
the same scope requires using their parent modules.</span>
-->
<p><span class="caption">Listing 7-15: 同じ名前を持つ2つの型を同じスコープに持ち込むには親モジュールを使わないといけない。</span></p>
<!--
As you can see, using the parent modules distinguishes the two `Result` types.
If instead we specified `use std::fmt::Result` and `use std::io::Result`, we’d
have two `Result` types in the same scope and Rust wouldn’t know which one we
meant when we used `Result`.
-->
<p>このように、親モジュールを使うことで2つの<code>Result</code>型を区別できます。
もし<code>use std::fmt::Result</code> と <code>use std::io::Result</code>と書いていたとしたら、2つの<code>Result</code>型が同じスコープに存在することになり、私達が<code>Result</code>を使ったときにどちらのことを意味しているのかRustはわからなくなってしまいます。</p>
<!--
### Providing New Names with the `as` Keyword
-->
<h3 id="新しい名前をasキーワードで与える"><a class="header" href="#新しい名前をasキーワードで与える">新しい名前を<code>as</code>キーワードで与える</a></h3>
<!--
There’s another solution to the problem of bringing two types of the same name
into the same scope with `use`: after the path, we can specify `as` and a new
local name, or alias, for the type. Listing 7-16 shows another way to write the
code in Listing 7-15 by renaming one of the two `Result` types using `as`.
-->
<p>同じ名前の2つの型を<code>use</code>を使って同じスコープに持ち込むという問題には、もう一つ解決策があります。パスの後に、<code>as</code>と型の新しいローカル名、即ちエイリアスを指定すればよいのです。
Listing 7-16 は、Listing 7-15 のコードを、2つの<code>Result</code>型のうち一つを<code>as</code>を使ってリネームするという別のやり方で書いたものを表しています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-16: Renaming a type when it’s brought into
scope with the `as` keyword</span>
-->
<p><span class="caption">Listing 7-16: 型がスコープに持ち込まれた時、<code>as</code>キーワードを使ってその名前を変えている</span></p>
<!--
In the second `use` statement, we chose the new name `IoResult` for the
`std::io::Result` type, which won’t conflict with the `Result` from `std::fmt`
that we’ve also brought into scope. Listing 7-15 and Listing 7-16 are
considered idiomatic, so the choice is up to you!
-->
<p>2つめの<code>use</code>文では、<code>std::io::Result</code>に、<code>IoResult</code>という新たな名前を選んでやります。<code>std::fmt</code>の<code>Result</code>もスコープに持ち込んでいますが、この名前はこれとは衝突しません。
Listing 7-15もListing 7-16も慣例的とみなされているので、どちらを使っても構いませんよ！</p>
<!--
### Re-exporting Names with `pub use`
-->
<h3 id="pub-useを使って名前を再公開する"><a class="header" href="#pub-useを使って名前を再公開する"><code>pub use</code>を使って名前を再公開する</a></h3>
<!--
When we bring a name into scope with the `use` keyword, the name available in
the new scope is private. To enable the code that calls our code to refer to
that name as if it had been defined in that code’s scope, we can combine `pub`
and `use`. This technique is called *re-exporting* because we’re bringing
an item into scope but also making that item available for others to bring into
their scope.
-->
<p><code>use</code>キーワードで名前をスコープに持ちこんだ時、新しいスコープで使用できるその名前は非公開です。
私達のコードを呼び出すコードが、まるでその名前が私達のコードのスコープで定義されていたかのように参照できるようにするためには、<code>pub</code>と<code>use</code>を組み合わせればいいです。
このテクニックは、要素を自分たちのスコープに持ち込むだけでなく、他の人がその要素をその人のスコープに持ち込むことも可能にすることから、<em>再公開 (re-exporting)</em> と呼ばれています。</p>
<!--
Listing 7-17 shows the code in Listing 7-11 with `use` in the root module
changed to `pub use`.
-->
<p>Listing 7-17 は Listing 7-11 のコードのルートモジュールでの<code>use</code>を<code>pub use</code>に変更したものを示しています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-17: Making a name available for any code to use
from a new scope with `pub use`</span>
-->
<p><span class="caption">Listing 7-17: <code>pub use</code>で、新たなスコープのコードがその名前を使えるようにする</span></p>
<!--
By using `pub use`, external code can now call the `add_to_waitlist` function
using `hosting::add_to_waitlist`. If we hadn’t specified `pub use`, the
`eat_at_restaurant` function could call `hosting::add_to_waitlist` in its
scope, but external code couldn’t take advantage of this new path.
-->
<p><code>pub use</code>を使うことで、外部のコードが<code>hosting::add_to_waitlist</code>を使って<code>add_to_waitlist</code>関数を呼び出せるようになりました。
<code>pub use</code>を使っていなければ、<code>eat_at_restaurant</code>関数は<code>hosting::add_to_waitlist</code>を自らのスコープ内で使えるものの、外部のコードはこの新しいパスを利用することはできないでしょう。</p>
<!--
Re-exporting is useful when the internal structure of your code is different
from how programmers calling your code would think about the domain. For
example, in this restaurant metaphor, the people running the restaurant think
about “front of house” and “back of house.” But customers visiting a restaurant
probably won’t think about the parts of the restaurant in those terms. With
`pub use`, we can write our code with one structure but expose a different
structure. Doing so makes our library well organized for programmers working on
the library and programmers calling the library.
-->
<p>再公開は、あなたのコードの内部構造と、あなたのコードを呼び出すプログラマーたちのその領域に関しての見方が異なるときに有用です。
例えば、レストランの比喩では、レストランを経営している人は「接客部門 (front of house)」と「後方部門 (back of house)」のことについて考えるでしょう。
しかし、レストランを訪れるお客さんは、そのような観点からレストランの部門について考えることはありません。
<code>pub use</code>を使うことで、ある構造でコードを書きつつも、別の構造で公開するということが可能になります。
こうすることで、私達のライブラリを、ライブラリを開発するプログラマにとっても、ライブラリを呼び出すプログラマにとっても、よく整理されたものとすることができます。</p>
<!--
### Using External Packages
-->
<h3 id="外部のパッケージを使う"><a class="header" href="#外部のパッケージを使う">外部のパッケージを使う</a></h3>
<!--
In Chapter 2, we programmed a guessing game project that used an external
package called `rand` to get random numbers. To use `rand` in our project, we
added this line to *Cargo.toml*:
-->
<p>2章で、乱数を得るために<code>rand</code>という外部パッケージを使って、数当てゲームをプログラムしました。
<code>rand</code>を私達のプロジェクトで使うために、次の行を <em>Cargo.toml</em> に書き加えましたね：</p>
<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<!--
Adding `rand` as a dependency in *Cargo.toml* tells Cargo to download the
`rand` package and any dependencies from [crates.io](https://crates.io/) and
make `rand` available to our project.
-->
<p><code>rand</code>を依存 (dependency) として <em>Cargo.toml</em> に追加すると、<code>rand</code>パッケージとそのすべての依存を<a href="https://crates.io/">crates.io</a>からダウンロードして、私達のプロジェクトで<code>rand</code>が使えるようにするようCargoに命令します。</p>
<!--
Then, to bring `rand` definitions into the scope of our package, we added a
`use` line starting with the name of the crate, `rand`, and listed the items
we wanted to bring into scope. Recall that in the [“Generating a Random
Number”][rand] section in Chapter 2, we brought the `Rng` trait
into scope and called the `rand::thread_rng` function:
-->
<p>そして、<code>rand</code>の定義を私達のパッケージのスコープに持ち込むために、クレートの名前である<code>rand</code>から始まる<code>use</code>の行を追加し、そこにスコープに持ち込みたい要素を並べました。
2章の<a href="ch02-00-guessing-game-tutorial.html#%E4%B9%B1%E6%95%B0%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B">乱数を生成する</a>の節で、<code>Rng</code>トレイトをスコープに持ち込み<code>rand::thread_rng</code>関数を呼び出したことを思い出してください。</p>
<pre><code class="language-rust ignore"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1..101);
<span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);    //秘密の数字は次の通り: {}
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span>}
</code></pre>
<!--
Members of the Rust community have made many packages available at
[crates.io](https://crates.io/), and pulling any of them into your package
involves these same steps: listing them in your package’s *Cargo.toml* file and
using `use` to bring items from their crates into scope.
-->
<p>Rustコミュニティに所属する人々が<a href="https://crates.io/">crates.io</a>でたくさんのパッケージを利用できるようにしてくれており、上と同じステップを踏めばそれらをあなたのパッケージに取り込むことができます：あなたのパッケージの <em>Cargo.toml</em> ファイルにそれらを書き並べ、<code>use</code>を使って要素をクレートからスコープへと持ち込めばよいのです。</p>
<!--
Note that the standard library (`std`) is also a crate that’s external to our
package. Because the standard library is shipped with the Rust language, we
don’t need to change *Cargo.toml* to include `std`. But we do need to refer to
it with `use` to bring items from there into our package’s scope. For example,
with `HashMap` we would use this line:
-->
<p>標準ライブラリ (<code>std</code>) も、私達のパッケージの外部にあるクレートだということに注意してください。
標準ライブラリはRust言語に同梱されているので、 <em>Cargo.toml</em> を <code>std</code>を含むように変更する必要はありません。
しかし、その要素をそこから私達のパッケージのスコープに持ち込むためには、<code>use</code>を使って参照する必要はあります。
例えば、<code>HashMap</code>には次の行を使います。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}
</span></code></pre></pre>
<!--
This is an absolute path starting with `std`, the name of the standard library
crate.
-->
<p>これは標準ライブラリクレートの名前<code>std</code>から始まる絶対パスです。</p>
<!--
### Using Nested Paths to Clean Up Large `use` Lists
-->
<h3 id="巨大なuseのリストをネストしたパスを使って整理する"><a class="header" href="#巨大なuseのリストをネストしたパスを使って整理する">巨大な<code>use</code>のリストをネストしたパスを使って整理する</a></h3>
<!--
If we’re using multiple items defined in the same crate or same module,
listing each item on its own line can take up a lot of vertical space in our
files. For example, these two `use` statements we had in the Guessing Game in
Listing 2-4 bring items from `std` into scope:
-->
<p>同じクレートか同じモジュールで定義された複数の要素を使おうとする時、それぞれの要素を一行一行並べると、縦に大量のスペースを取ってしまいます。
例えば、Listing 2-4の数当てゲームで使った次の2つの<code>use</code>文が<code>std</code>からスコープへ要素を持ち込みました。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
// （略）
use std::cmp::Ordering;
use std::io;
// --snip--
// （略）
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
Instead, we can use nested paths to bring the same items into scope in one
line. We do this by specifying the common part of the path, followed by two
colons, and then curly brackets around a list of the parts of the paths that
differ, as shown in Listing 7-18.
-->
<p>代わりに、ネストしたパスを使うことで、同じ一連の要素を1行でスコープに持ち込めます。
これをするには、Listing 7-18 に示されるように、パスの共通部分を書き、2つのコロンを続け、そこで波括弧で互いに異なる部分のパスのリストを囲みます。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use rand::Rng;
</span>// --snip--
// （略）
use std::{cmp::Ordering, io};
// --snip--
// （略）
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;Guess the number!&quot;);
</span><span class="boring">
</span><span class="boring">    let secret_number = rand::thread_rng().gen_range(1, 101);
</span><span class="boring">
</span><span class="boring">    println!(&quot;The secret number is: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Please input your guess.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Failed to read line&quot;);
</span><span class="boring">
</span><span class="boring">    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;You guessed: {}&quot;, guess);
</span><span class="boring">
</span><span class="boring">    match guess.cmp(&amp;secret_number) {
</span><span class="boring">        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
</span><span class="boring">        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
</span><span class="boring">        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 7-18: Specifying a nested path to bring multiple
items with the same prefix into scope</span>
-->
<p><span class="caption">Listing 7-18: 同じプレフィックスをもつ複数の要素をスコープに持ち込むためにネストしたパスを指定する</span></p>
<!--
In bigger programs, bringing many items into scope from the same crate or
module using nested paths can reduce the number of separate `use` statements
needed by a lot!
-->
<p>大きなプログラムにおいては、同じクレートやモジュールからのたくさんの要素をネストしたパスで持ち込むようにすれば、独立した<code>use</code>文の数を大きく減らすことができます！</p>
<!--
We can use a nested path at any level in a path, which is useful when combining
two `use` statements that share a subpath. For example, Listing 7-19 shows two
`use` statements: one that brings `std::io` into scope and one that brings
`std::io::Write` into scope.
-->
<p>ネストしたパスはパスのどの階層においても使うことができます。これはサブパスを共有する2つの<code>use</code>文を合体させるときに有用です。
例えば、Listing 7-19 は2つの<code>use</code>文を示しています：1つは<code>std::io</code>をスコープに持ち込み、もう一つは<code>std::io::Write</code>をスコープに持ち込んでいます。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Write;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-19: Two `use` statements where one is a subpath
of the other</span>
-->
<p><span class="caption">Listing 7-19: 片方がもう片方のサブパスである2つの<code>use</code>文</span></p>
<!--
The common part of these two paths is `std::io`, and that’s the complete first
path. To merge these two paths into one `use` statement, we can use `self` in
the nested path, as shown in Listing 7-20.
-->
<p>これらの2つのパスの共通部分は<code>std::io</code>であり、そしてこれは最初のパスにほかなりません。これらの2つのパスを1つの<code>use</code>文へと合体させるには、Listing 7-20 に示されるように、ネストしたパスに<code>self</code>を使いましょう。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 7-20: Combining the paths in Listing 7-19 into
one `use` statement</span>
-->
<p><span class="caption">Listing 7-20: Listing 7-19 のパスを一つの <code>use</code> 文に合体させる</span></p>
<!--
This line brings `std::io` and `std::io::Write` into scope.
-->
<p>この行は <code>std::io</code> と<code>std::io::Write</code> をスコープに持ち込みます。</p>
<!--
### The Glob Operator
-->
<h3 id="glob演算子"><a class="header" href="#glob演算子">glob演算子</a></h3>
<!--
If we want to bring *all* public items defined in a path into scope, we can
specify that path followed by `*`, the glob operator:
-->
<p>パスにおいて定義されているすべての公開要素をスコープに持ち込みたいときは、glob演算子 <code>*</code> をそのパスの後ろに続けて書きましょう：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<!--
This `use` statement brings all public items defined in `std::collections` into
the current scope. Be careful when using the glob operator! Glob can make it
harder to tell what names are in scope and where a name used in your program
was defined.
-->
<p>この<code>use</code>文は<code>std::collections</code>のすべての公開要素を現在のスコープに持ち込みます。
glob演算子を使う際にはご注意を！
globをすると、どの名前がスコープ内にあり、プログラムで使われている名前がどこで定義されたのか分かりづらくなります。</p>
<!--
The glob operator is often used when testing to bring everything under test
into the `tests` module; we’ll talk about that in the [“How to Write
Tests”][writing-tests] section in Chapter 11. The glob operator
is also sometimes used as part of the prelude pattern: see [the standard
library documentation](../std/prelude/index.html#other-preludes)
for more information on that pattern.
-->
<p>glob演算子はしばしば、テストの際、テストされるあらゆるものを<code>tests</code>モジュールに持ち込むために使われます。これについては11章<a href="ch11-01-writing-tests.html#%E3%83%86%E3%82%B9%E3%83%88%E3%81%AE%E8%A8%98%E8%BF%B0%E6%B3%95">テストの書き方</a>の節で話します。
glob演算子はプレリュードパターンの一部としても使われることがあります：そのようなパターンについて、より詳しくは<a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">標準ライブラリのドキュメント</a>をご覧ください。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Separating Modules into Different Files
-->
<h2 id="モジュールを複数のファイルに分割する"><a class="header" href="#モジュールを複数のファイルに分割する">モジュールを複数のファイルに分割する</a></h2>
<!--
So far, all the examples in this chapter defined multiple modules in one file.
When modules get large, you might want to move their definitions to a separate
file to make the code easier to navigate.
-->
<p>この章のすべての例において、今までのところ、複数のモジュールを一つのファイルに定義していました。
モジュールが大きくなる時、コードを読み進めやすくするため、それらの定義を別のファイルへ移動させたくなるかもしれません。</p>
<!--
For example, let’s start from the code in Listing 7-17 and move the
`front_of_house` module to its own file *src/front_of_house.rs* by changing the
crate root file so it contains the code shown in Listing 7-21. In this case,
the crate root file is *src/lib.rs*, but this procedure also works with binary
crates whose crate root file is *src/main.rs*.
-->
<p>例えば、Listing 7-17 のコードからはじめましょう。クレートルートのファイルをListing 7-21 のコードを持つように変更して、<code>front_of_house</code>モジュールをそれ専用のファイル<code>src/front_of_house.rs</code>に動かしましょう。
今回、クレートルートファイルは<code>src/lib.rs</code>ですが、この手続きはクレートルートファイルが<code>src/main.rs</code>であるバイナリクレートでもうまく行きます。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre>
<!--
<span class="caption">Listing 7-21: Declaring the `front_of_house` module whose
body will be in *src/front_of_house.rs*</span>
-->
<p><span class="caption">Listing 7-21: <code>front_of_house</code>モジュールを宣言する。その中身は<code>src/front_of_house.rs</code>内にある</span></p>
<!--
And *src/front_of_house.rs* gets the definitions from the body of the
`front_of_house` module, as shown in Listing 7-22.
-->
<p>そして、 Listing 7-22 のように、<em>src/front_of_house.rs</em> には<code>front_of_house</code> モジュールの中身の定義を与えます。</p>
<!--
<span class="filename">Filename: src/front_of_house.rs</span>
-->
<p><span class="filename">ファイル名: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre>
<!--
<span class="caption">Listing 7-22: Definitions inside the `front_of_house`
module in *src/front_of_house.rs*</span>
-->
<p><span class="caption">Listing 7-22: <em>src/front_of_house.rs</em>における、<code>front_of_house</code>モジュール内部の定義</span></p>
<!--
Using a semicolon after `mod front_of_house` rather than using a block tells
Rust to load the contents of the module from another file with the same name as
the module. To continue with our example and extract the `hosting` module to
its own file as well, we change *src/front_of_house.rs* to contain only the
declaration of the `hosting` module:
-->
<p><code>mod front_of_house</code>の後にブロックではなくセミコロンを使うと、Rustにモジュールの中身をモジュールと同じ名前をした別のファイルから読み込むように命令します。
私達の例で、つづけて<code>hosting</code>モジュールをそれ専用のファイルに抽出するには、<code>src/front_of_house.rs</code>が<code>hosting</code>モジュールの宣言のみを含むように変更します：</p>
<!--
<span class="filename">Filename: src/front_of_house.rs</span>
-->
<p><span class="filename">ファイル名: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting;
</code></pre>
<!--
Then we create a *src/front_of_house* directory and a file
*src/front_of_house/hosting.rs* to contain the definitions made in the
`hosting` module:
-->
<p>さらに<em>src/front_of_house</em> ディレクトリと<em>src/front_of_house/hosting.rs</em> ファイルを作って、<code>hosting</code>モジュール内でなされていた定義を持つようにします。</p>
<!--
<span class="filename">Filename: src/front_of_house/hosting.rs</span>
-->
<p><span class="filename">ファイル名: src/front_of_house/hosting.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_to_waitlist() {}
<span class="boring">}
</span></code></pre></pre>
<!--
The module tree remains the same, and the function calls in `eat_at_restaurant`
will work without any modification, even though the definitions live in
different files. This technique lets you move modules to new files as they grow
in size.
-->
<p>定義は別のファイルにあるにもかかわらず、モジュールツリーは同じままであり、<code>eat_at_restaurant</code>内での関数呼び出しもなんの変更もなくうまく行きます。
このテクニックのおかげで、モジュールが大きくなってきた段階で新しいファイルへ動かす、ということができます。</p>
<!--
Note that the `pub use crate::front_of_house::hosting` statement in
*src/lib.rs* also hasn’t changed, nor does `use` have any impact on what files
are compiled as part of the crate. The `mod` keyword declares modules, and Rust
looks in a file with the same name as the module for the code that goes into
that module.
-->
<p><em>src/lib.rs</em> における<code>pub use crate::front_of_house::hosting</code> という文も変わっていないし、<code>use</code>はどのファイルがクレートの一部としてコンパイルされるかになんの影響も与えないということに注意してください。
<code>mod</code>キーワードがモジュールを宣言したなら、Rustはそのモジュールに挿入するためのコードを求めて、モジュールと同じ名前のファイルの中を探すというわけです。</p>
<!--
## Summary
-->
<h2 id="まとめ-6"><a class="header" href="#まとめ-6">まとめ</a></h2>
<!--
Rust lets you split a package into multiple crates and a crate into modules
so you can refer to items defined in one module from another module. You can do
this by specifying absolute or relative paths. These paths can be brought into
scope with a `use` statement so you can use a shorter path for multiple uses of
the item in that scope. Module code is private by default, but you can make
definitions public by adding the `pub` keyword.
-->
<p>Rustでは、パッケージを複数のクレートに、そしてクレートを複数のモジュールに分割して、あるモジュールで定義された要素を他のモジュールから参照することができます。
これは絶対パスか相対パスを指定することで行なえます。
これらのパスは<code>use</code>文でスコープに持ち込むことができ、こうすると、そのスコープで要素を複数回使う時に、より短いパスで済むようになります。
モジュールのコードは標準では非公開ですが、<code>pub</code>キーワードを追加することで定義を公開することができます。</p>
<!--
In the next chapter, we’ll look at some collection data structures in the
standard library that you can use in your neatly organized code.
-->
<p>次の章では、きちんと整理されたあなたのコードで使うことができる、標準ライブラリのいくつかのコレクションデータ構造を見ていきます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Common Collections
-->
<h1 id="一般的なコレクション"><a class="header" href="#一般的なコレクション">一般的なコレクション</a></h1>
<!--
Rust’s standard library includes a number of very useful data structures called
*collections*. Most other data types represent one specific value, but
collections can contain multiple values. Unlike the built-in array and tuple
types, the data these collections point to is stored on the heap, which means
the amount of data does not need to be known at compile time and can grow or
shrink as the program runs. Each kind of collection has different capabilities
and costs, and choosing an appropriate one for your current situation is a
skill you’ll develop over time. In this chapter, we’ll discuss three
collections that are used very often in Rust programs:
-->
<p>Rustの標準ライブラリは、<em>コレクション</em>と呼ばれる多くの非常に有益なデータ構造を含んでいます。他の多くのデータ型は、
ある一つの値を表しますが、コレクションは複数の値を含むことができます。組み込みの配列とタプル型とは異なり、
これらのコレクションが指すデータはヒープに確保され、データ量はコンパイル時にわかる必要はなく、
プログラムの実行にあわせて、伸縮可能であることになります。各種のコレクションには異なる能力とコストが存在し、
自分の現在の状況に最適なものを選び取るスキルは、時間とともに育っていきます。この章では、
Rustのプログラムにおいて、非常に頻繁に使用される3つのコレクションについて議論しましょう。</p>
<!--
* A *vector* allows us to store a variable number of values next to each other.
* A *string* is a collection of characters. We’ve mentioned the `String` type
previously, but in this chapter we’ll talk about it in depth.
* A *hash map* allows us to associate a value with a particular key. It’s a
particular implementation of the more general data structure called a *map*.
-->
<ul>
<li><em>ベクタ型</em>は、可変長の値を並べて保持できる。</li>
<li><em>文字列</em>は、文字のコレクションである。以前、<code>String</code>型について触れたが、
この章ではより掘り下げていく。</li>
<li><em>ハッシュマップ</em>は、値を特定のキーと紐付けさせてくれる。より一般的なデータ構造である、
<em>マップ</em>の特定の実装である。</li>
</ul>
<!--
To learn about the other kinds of collections provided by the standard library,
see [the documentation][collections].
-->
<p>標準ライブラリで提供されている他の種のコレクションについて学ぶには、
<a href="https://doc.rust-lang.org/std/collections/index.html">ドキュメント</a>を参照されたし。</p>
<!--
We’ll discuss how to create and update vectors, strings, and hash maps, as well
as what makes each special.
-->
<p>ベクタ型、文字列、ハッシュマップの生成と更新方法や、各々が特別な点について議論していきましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Storing Lists of Values with Vectors
-->
<h2 id="ベクタで値のリストを保持する"><a class="header" href="#ベクタで値のリストを保持する">ベクタで値のリストを保持する</a></h2>
<!--
The first collection type we’ll look at is `Vec<T>`, also known as a *vector*.
Vectors allow you to store more than one value in a single data structure that
puts all the values next to each other in memory. Vectors can only store values
of the same type. They are useful when you have a list of items, such as the
lines of text in a file or the prices of items in a shopping cart.
-->
<p>最初に見るコレクション型は<code>Vec&lt;T&gt;</code>であり、これは<em>ベクタ</em>としても知られています。
ベクタは単体のデータ構造でありながら複数の値を保持でき、それらの値をメモリ上に隣り合わせに並べます。
ベクタには同じ型の値しか保持できません。
要素のリストがある場合にベクタは有用です。
例えば、テキストファイルの各行とか、ショッピングカートのアイテムの価格などです。</p>
<!--
### Creating a New Vector
-->
<h3 id="新しいベクタを生成する"><a class="header" href="#新しいベクタを生成する">新しいベクタを生成する</a></h3>
<!--
To create a new, empty vector, we can call the `Vec::new` function, as shown in
Listing 8-1.
-->
<p>空のベクタを新たに作るには、リスト8-1に示すように<code>Vec::new</code>関数を呼びます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-1: Creating a new, empty vector to hold values
of type `i32`</span>
-->
<p><span class="caption">リスト8-1：新しい空のベクタを生成して<code>i32</code>型の値を保持する</span></p>
<!--
Note that we added a type annotation here. Because we aren’t inserting any
values into this vector, Rust doesn’t know what kind of elements we intend to
store. This is an important point. Vectors are implemented using generics;
we’ll cover how to use generics with your own types in Chapter 10. For now,
know that the `Vec<T>` type provided by the standard library can hold any type,
and when a specific vector holds a specific type, the type is specified within
angle brackets. In Listing 8-1, we’ve told Rust that the `Vec<T>` in `v` will
hold elements of the `i32` type.
-->
<p>ここで、型注釈を付けていることに注目してください。
なぜなら、このベクタに対して何も値を挿入していないので、コンパイラには私たちがどんなデータを保持させるつもりか推測できないからです。
これは重要な点です。
ベクタはジェネリクスを使用して実装されています。
あなた自身の型でどうジェネリクスを使用するかついては第10章で解説します。
現時点では標準ライブラリで提供される<code>Vec&lt;T&gt;</code>型は、どんな型でも保持でき、ある特定のベクタがある型を保持するとき、その型は山かっこ内に指定されることを知っておいてください。
リスト8-1では、コンパイラに<code>v</code>の<code>Vec&lt;T&gt;</code>は<code>i32</code>型の要素を保持すると指示しました。</p>
<!--
In more realistic code, Rust can often infer the type of value you want to
store once you insert values, so you rarely need to do this type annotation.
It’s more common to create a `Vec<T>` that has initial values, and Rust
provides the `vec!` macro for convenience. The macro will create a new vector
that holds the values you give it. Listing 8-2 creates a new `Vec<i32>` that
holds the values `1`, `2`, and `3`. The integer type is `i32` because that’s
the default integer type, as we discussed in the [“Data Types”][data-types]
section of Chapter 3.
-->
<p>いったん値を挿入すると、多くの場合、コンパイラは保持させたい値の型を推論できるようになります。
ですから、より現実的なコードでは、型注釈を付ける必要はあまりないでしょう。
また、初期値を持つ<code>Vec&lt;T&gt;</code>を生成する方が一般的ですし、Rustには<code>vec!</code>という便利なマクロも用意されています。
このマクロは与えた値を保持する新しいベクタを生成します。
リスト8-2では、<code>1</code>、<code>2</code>、<code>3</code>という値を持つ新しい<code>Vec&lt;i32&gt;</code>を生成しています。
整数型を<code>i32</code>にしているのは、3章の<a href="ch03-02-data-types.html#%E3%83%87%E3%83%BC%E3%82%BF%E5%9E%8B">「データ型」</a>節で学んだように、これが標準の整数型だからです。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-2: Creating a new vector containing
values</span>
-->
<p><span class="caption">リスト8-2: 値を含む新しいベクタを生成する</span></p>
<!--
Because we’ve given initial `i32` values, Rust can infer that the type of `v`
is `Vec<i32>`, and the type annotation isn’t necessary. Next, we’ll look at how
to modify a vector.
-->
<p>初期値の<code>i32</code>値を与えたので、コンパイラは<code>v</code>の型が<code>Vec&lt;i32&gt;</code>であると推論でき、型注釈は不要になりました。
次はベクタを変更する方法を見ましょう。</p>
<!--
### Updating a Vector
-->
<h3 id="ベクタを更新する"><a class="header" href="#ベクタを更新する">ベクタを更新する</a></h3>
<!--
To create a vector and then add elements to it, we can use the `push` method,
as shown in Listing 8-3.
-->
<p>ベクタを生成し、それから要素を追加するには、リスト8-3に示すように<code>push</code>メソッドを使います。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = Vec::new();

    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-3: Using the `push` method to add values to a
vector</span>
-->
<p><span class="caption">リスト8-3：<code>push</code>メソッドを使用してベクタに値を追加する</span></p>
<!--
As with any variable, if we want to be able to change its value, we need to
make it mutable using the `mut` keyword, as discussed in Chapter 3. The numbers
we place inside are all of type `i32`, and Rust infers this from the data, so
we don’t need the `Vec<i32>` annotation.
-->
<p>第3章で説明したとおり、どんな変数でも、その値を変更したかったら<code>mut</code>キーワードで可変にする必要があります。
中に配置する数値は全て<code>i32</code>型であり、Rustはこのことをデータから推論するので、<code>Vec&lt;i32&gt;</code>という注釈は不要です。</p>
<!--
### Dropping a Vector Drops Its Elements
-->
<h3 id="ベクタをドロップすれば要素もドロップする"><a class="header" href="#ベクタをドロップすれば要素もドロップする">ベクタをドロップすれば、要素もドロップする</a></h3>
<!--
Like any other `struct`, a vector is freed when it goes out of scope, as
annotated in Listing 8-4.
-->
<p>他のあらゆる<code>struct</code>（構造体）と同様に、ベクタもスコープを抜ければ解放されます。
その様子をリスト8-4に示します。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let v = vec![1, 2, 3, 4];

        // vで作業をする
    } // &lt;- vはここでスコープを抜け、解放される
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-4: Showing where the vector and its elements
are dropped</span>
-->
<p><span class="caption">リスト8-4：ベクタとその要素がドロップされる箇所を示す</span></p>
<!--
When the vector gets dropped, all of its contents are also dropped, meaning
those integers it holds will be cleaned up. This may seem like a
straightforward point but can get a bit more complicated when you start to
introduce references to the elements of the vector. Let’s tackle that next!
-->
<p>ベクタがドロップされると、その中身もドロップされます。
つまり、保持されていた整数値が片付けられるということです。
これは一見単純そうですが、ベクタの要素に対する参照を使い始めると少し複雑になり得ます。
次はそれに挑戦しましょう！</p>
<!--
### Reading Elements of Vectors
-->
<h3 id="ベクタの要素を読む"><a class="header" href="#ベクタの要素を読む">ベクタの要素を読む</a></h3>
<!--
Now that you know how to create, update, and destroy vectors, knowing how to
read their contents is a good next step. There are two ways to reference a
value stored in a vector. In the examples, we’ve annotated the types of the
values that are returned from these functions for extra clarity.
-->
<p>ベクタを生成し、更新し、破棄する方法がわかったので、次のステップでは中身を読む方法について学ぶのが良いでしょう。
ベクタに保持された値を参照する方法は2つあります。
これから示す例では、理解を助けるために、それらの関数からの戻り値型を注釈しています。</p>
<!--
Listing 8-5 shows both methods of accessing a value in a vector, either with
indexing syntax or the `get` method.
-->
<p>リスト8-5はベクタの値にアクセスする両方の方法として、添え字記法と<code>get</code>メソッドが示されています。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let third: &amp;i32 = &amp;v[2];
    println!(&quot;The third element is {}&quot;, third);

    match v.get(2) {
        //                      &quot;3つ目の要素は{}です&quot;
        Some(third) =&gt; println!(&quot;The third element is {}&quot;, third),
        //               &quot;3つ目の要素はありません。&quot;
        None =&gt; println!(&quot;There is no third element.&quot;),
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-5: Using indexing syntax or the `get` method to
access an item in a vector</span>
-->
<p><span class="caption">リスト8-5：添え字記法か<code>get</code>メソッドを使用してベクタの要素にアクセスする</span></p>
<!--
Note two details here. First, we use the index value of `2` to get the third
element: vectors are indexed by number, starting at zero. Second, the two ways
to get the third element are by using `&` and `[]`, which gives us a reference,
or by using the `get` method with the index passed as an argument, which gives
us an `Option<&T>`.
-->
<p>ここでは2つのことに注目してください。
1つ目は、3番目の要素を得るのに<code>2</code>という添え字の値を使用していることです。
ベクタは番号で索引化されますが、その番号は0から始まります。
2つ目は、3番目の要素を得る2つの方法とは、<code>&amp;</code>と<code>[]</code>を使用して参照を得るものと、<code>get</code>メソッドに引数として添え字を渡して<code>Option&lt;&amp;T&gt;</code>を得るものだということです。</p>
<!--
Rust has two ways to reference an element so you can choose how the program
behaves when you try to use an index value that the vector doesn’t have an
element for. As an example, let’s see what a program will do if it has a vector
that holds five elements and then tries to access an element at index 100, as
shown in Listing 8-6.
-->
<p>Rustのベクタには要素を参照する方法が2通りあるので、ベクタに含まれない要素の添え字を使おうとしたときのプログラムの振る舞いを選択できます。
例として、ベクタに5つ要素があるとして、添え字100の要素にアクセスを試みた場合、プログラムがどうなるのか確認しましょう。
リスト8-6に示します。</p>
<pre><pre class="playground"><code class="language-rust should_panic panics"><span class="boring">fn main() {
</span>    let v = vec![1, 2, 3, 4, 5];

    let does_not_exist = &amp;v[100];
    let does_not_exist = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-6: Attempting to access the element at index
100 in a vector containing five elements</span>
-->
<p><span class="caption">リスト8-6：5つの要素を含むベクタの添え字100の要素にアクセスしようとする</span></p>
<!--
When we run this code, the first `[]` method will cause the program to panic
because it references a nonexistent element. This method is best used when you
want your program to crash if there’s an attempt to access an element past the
end of the vector.
-->
<p>このコードを走らせると、最初の<code>[]</code>メソッドはプログラムをパニックさせます。
なぜなら存在しない要素を参照しているからです。
このメソッドは、ベクタの終端を超えて要素にアクセスしようとしたときにプログラムをクラッシュさせたい場合に最適です。</p>
<!--
When the `get` method is passed an index that is outside the vector, it returns
`None` without panicking. You would use this method if accessing an element
beyond the range of the vector happens occasionally under normal circumstances.
Your code will then have logic to handle having either `Some(&element)` or
`None`, as discussed in Chapter 6. For example, the index could be coming from
a person entering a number. If they accidentally enter a number that’s too
large and the program gets a `None` value, you could tell the user how many
items are in the current vector and give them another chance to enter a valid
value. That would be more user-friendly than crashing the program due to a typo!
-->
<p><code>get</code>メソッドにベクタ外の添え字を渡すと、パニックすることなく<code>None</code>を返します。
普通の状況でもベクタの範囲外にアクセスする可能性があるなら、このメソッドを使用することになるでしょう。
その場合、第6章で説明したように、コードは<code>Some(&amp;element)</code>か<code>None</code>を扱うロジックを持つことになります。
例えば、誰かが入力した数値が添え字になるかもしれません。
もし誤って大きすぎる値を入力し、プログラムが<code>None</code>値を得たなら、いまベクタに何要素あるかをユーザに教え、正しい値を再入力してもらうこともできます。
その方が、ただのタイプミスでプログラムをクラッシュさせるより、ユーザに優しいといえそうです。</p>
<!--
When the program has a valid reference, the borrow checker enforces the
ownership and borrowing rules (covered in Chapter 4) to ensure this reference
and any other references to the contents of the vector remain valid. Recall the
rule that states you can’t have mutable and immutable references in the same
scope. That rule applies in Listing 8-7, where we hold an immutable reference to
the first element in a vector and try to add an element to the end, which won’t
work if we also try to refer to that element later in the function:
-->
<p>プログラムに有効な参照がある場合、借用チェッカー (borrow checker) は、（第4章で解説しましたが）所有権と借用規則を強制し、ベクタの中身へのこの参照や他のいかなる参照も有効であり続けることを保証してくれます。
同一スコープ上では、可変と不変な参照を同時には存在させられないというルールを思い出してください。
このルールはリスト8-7でも適用されています。
リスト8-7ではベクタの最初の要素への不変参照を保持しつつ、終端に要素を追加しようとしています。
関数内のここ以降で、この要素（訳注：<code>first</code>のこと）を参照しようとすると失敗します。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!(&quot;The first element is: {}&quot;, first);
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 8-7: Attempting to add an element to a vector
while holding a reference to an item</span>
-->
<p><span class="caption">リスト8-7：要素への参照を保持しつつ、ベクタに要素を追加しようとする</span></p>
<!--
Compiling this code will result in this error:
-->
<p>このコードをコンパイルすると、こんなエラーになります。</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
(エラー: 不変としても借用されているので、`v`を可変で借用できません)
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
  |                   (不変借用はここで発生しています)
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
  |              (可変借用はここで発生しています)
7 | 
8 |     println!(&quot;The first element is: {}&quot;, first);
  |                                          ----- immutable borrow later used here
  |                                               (その後、不変借用はここで使われています)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The code in Listing 8-7 might look like it should work: why should a reference
to the first element care about what changes at the end of the vector? This
error is due to the way vectors work: adding a new element onto the end of the
vector might require allocating new memory and copying the old elements to the
new space, if there isn’t enough room to put all the elements next to each
other where the vector currently is. In that case, the reference to the first
element would be pointing to deallocated memory. The borrowing rules prevent
programs from ending up in that situation.
-->
<p>リスト8-7のコードは、一見動きそうに見えるかもしれません。
なぜ最初の要素への参照が、ベクタの終端への変更を気にかける必要があるのでしょうか？
このエラーはベクタが動作するしくみによるものです。
新たな要素をベクタの終端に追加するとき、いまベクタのある場所に全要素を隣り合わせに配置するだけのスペースがないなら、新しいメモリを割り当て、古い要素を新しいスペースにコピーする必要があります。
その場合、最初の要素を指す参照は、解放されたメモリを指すことになるでしょう。
借用規則がそのような状況に陥らないよう防いでくれるのです。</p>
<!--
> Note: For more on the implementation details of the `Vec<T>` type, see [“The
> Rustonomicon”][nomicon].
-->
<blockquote>
<p>注釈: <code>Vec&lt;T&gt;</code>の実装に関する詳細については、<a href="../nomicon/vec.html">“The Rustonomicon”</a>を参照してください （訳注：日本語版は<a href="https://doc.rust-jp.rs/rust-nomicon-ja/vec.html">こちら</a>です）。</p>
</blockquote>
<!--
### Iterating over the Values in a Vector
-->
<h3 id="ベクタ内の値を順に処理する"><a class="header" href="#ベクタ内の値を順に処理する">ベクタ内の値を順に処理する</a></h3>
<!--
If we want to access each element in a vector in turn, we can iterate through
all of the elements rather than use indices to access one at a time. Listing
8-8 shows how to use a `for` loop to get immutable references to each element
in a vector of `i32` values and print them.
-->
<p>ベクタの要素に順番にアクセスしたいなら、添え字で1要素ごとにアクセスするのではなく、全要素を走査することができます。
リスト8-8で<code>for</code>ループを使い、<code>i32</code>のベクタの各要素に対する不変な参照を得て、それらを表示する方法を示します。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let v = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{}&quot;, i);
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-8: Printing each element in a vector by
iterating over the elements using a `for` loop</span>
-->
<p><span class="caption">リスト8-8：<code>for</code>ループで要素を走査し、ベクタの各要素を表示する</span></p>
<!--
We can also iterate over mutable references to each element in a mutable vector
in order to make changes to all the elements. The `for` loop in Listing 8-9
will add `50` to each element.
-->
<p>また、全要素に変更を加えるために、可変なベクタの各要素への可変な参照を走査することもできます。
リスト8-9の<code>for</code>ループでは各要素に<code>50</code>を足しています。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50;
    }
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-9: Iterating over mutable references to
elements in a vector</span>
-->
<p><span class="caption">リスト8-9：ベクタの要素への可変な参照を走査する</span></p>
<!--
To change the value that the mutable reference refers to, we have to use the
dereference operator (`*`) to get to the value in `i` before we can use the
`+=` operator. We’ll talk more about the dereference operator in the
[“Following the Pointer to the Value with the Dereference Operator”][deref]
section of Chapter 15.
-->
<p>可変参照が参照している値を変更するには、<code>+=</code>演算子を使用する前に、参照外し演算子(<code>*</code>)を使用して<code>i</code>の値にたどり着かないといけません。
参照外し演算子については、第15章の<a href="ch15-02-deref.html#%E5%8F%82%E7%85%A7%E5%A4%96%E3%81%97%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%A7%E5%80%A4%E3%81%BE%E3%81%A7%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%82%92%E8%BF%BD%E3%81%84%E3%81%8B%E3%81%91%E3%82%8B">「参照外し演算子で値までポインタを追いかける」</a>節でより詳しく扱います。</p>
<!--
### Using an Enum to Store Multiple Types
-->
<h3 id="enumを使って複数の型を保持する"><a class="header" href="#enumを使って複数の型を保持する">Enumを使って複数の型を保持する</a></h3>
<!--
At the beginning of this chapter, we said that vectors can only store values
that are the same type. This can be inconvenient; there are definitely use
cases for needing to store a list of items of different types. Fortunately, the
variants of an enum are defined under the same enum type, so when we need to
store elements of a different type in a vector, we can define and use an enum!
-->
<p>この章の冒頭で、ベクタは同じ型の値しか保持できないと述べました。
これは不便なこともあります。
異なる型の要素を保持する必要のあるユースケースは必ず存在します。
幸運なことに、enumの列挙子は同じenumの型の中に定義されるので、ベクタに異なる型の要素を保持する必要が出たら、enumを定義して使用すればよいのです！</p>
<!--
For example, say we want to get values from a row in a spreadsheet in which
some of the columns in the row contain integers, some floating-point numbers,
and some strings. We can define an enum whose variants will hold the different
value types, and then all the enum variants will be considered the same type:
that of the enum. Then we can create a vector that holds that enum and so,
ultimately, holds different types. We’ve demonstrated this in Listing 8-10.
-->
<p>例えば、スプレッドシートのある行から値を得ることを考えます。
ここで、その行の中の列には、整数を含むもの、浮動小数点数を含むもの、文字列を含むものがあるとします。
列挙子ごとに異なる値の型を保持するenumが定義できます。
そして、このenumの列挙子は全て同じ型、つまりenumの型、と考えられるわけです。
ですから、そのenumを保持するベクタを作成でき、結果的に異なる型を保持できるようになるわけです。
リスト8-10でこれを実演しています。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
        SpreadsheetCell::Float(10.12),
    ];
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-10: Defining an `enum` to store values of
different types in one vector</span>
-->
<p><span class="caption">リスト8-10：<code>enum</code>を定義して、一つのベクタに異なる型の値を保持する</span></p>
<!--
Rust needs to know what types will be in the vector at compile time so it knows
exactly how much memory on the heap will be needed to store each element. A
secondary advantage is that we can be explicit about what types are allowed in
this vector. If Rust allowed a vector to hold any type, there would be a chance
that one or more of the types would cause errors with the operations performed
on the elements of the vector. Using an enum plus a `match` expression means
that Rust will ensure at compile time that every possible case is handled, as
discussed in Chapter 6.
-->
<p>個々の要素を格納するのにヒープ上で必要となるメモリの量を正確に把握するめに、Rustコンパイラはコンパイル時にベクタに入る型を知る必要があります。
また、このベクタではどんな型が許容されるのか明示できるという副次的な利点があります。
もしRustが、ベクタにどんな型でも保持できることを許していたら、ベクタの要素に対して行われる処理に対して、いくつかの型がエラーを引き起こすかもしれません。
enumに加えて<code>match</code>式を使うことで、第6章で説明したとおり、あらゆるケースが処理できることを、Rustがコンパイル時に保証することになります。</p>
<!--
When you’re writing a program, if you don’t know the exhaustive set of types
the program will get at runtime to store in a vector, the enum technique won’t
work. Instead, you can use a trait object, which we’ll cover in Chapter 17.
-->
<p>プログラムを書いている時点で、プログラムが実行時に取得し、ベクタに格納し得る全ての型を網羅できない場合には、このenumを使ったテクニックはうまくいかないでしょう。
代わりにトレイトオブジェクトを使用できます。
こちらは第17章で取り上げます。</p>
<!--
Now that we’ve discussed some of the most common ways to use vectors, be sure
to review [the API documentation][vec-api] for all the many useful methods defined on
`Vec<T>` by the standard library. For example, in addition to `push`, a `pop`
method removes and returns the last element. Let’s move on to the next
collection type: `String`!
-->
<p>これまでにベクタの代表的な使い方をいくつか紹介しました。
標準ライブラリで<code>Vec&lt;T&gt;</code>に定義されている多くの有益なメソッドについて、<a href="../std/vec/struct.Vec.html">APIドキュメント</a>を必ず確認するようにしてください。
例えば、<code>push</code>に加えて、<code>pop</code>というメソッドがあり、これは最後の要素を削除して返します。
それでは次のコレクション型である<code>String</code>に移りましょう！</p>
<!--
[data-types]: ch03-02-data-types.html#data-types
[nomicon]: ../nomicon/vec.html
[vec-api]: ../std/vec/struct.Vec.html
[deref]: ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Storing UTF-8 Encoded Text with Strings
-->
<h2 id="文字列でutf-8でエンコードされたテキストを保持する"><a class="header" href="#文字列でutf-8でエンコードされたテキストを保持する">文字列でUTF-8でエンコードされたテキストを保持する</a></h2>
<!--
We talked about strings in Chapter 4, but we’ll look at them in more depth now.
New Rustaceans commonly get stuck on strings for a combination of three
concepts: Rust’s propensity for exposing possible errors, strings being a more
complicated data structure than many programmers give them credit for, and
UTF-8. These factors combine in a way that can seem difficult when you’re
coming from other programming languages.
-->
<p>第4章で文字列について語りましたが、今度はより掘り下げていきましょう。新参者のRustaceanは、
3つの概念の組み合わせにより、文字列でよく行き詰まります: Rustのありうるエラーを晒す性質、
多くのプログラマが思っている以上に文字列が複雑なデータ構造であること、そしてUTF-8です。
これらの要因が、他のプログラミング言語から移ってきた場合、一見困難に見えるように絡み合うわけです。</p>
<!--
It's useful to discuss strings in the context of collections because strings
are implemented as a collection of bytes, plus some methods to provide useful
functionality when those bytes are interpreted as text. In this section, we’ll
talk about the operations on `String` that every collection type has, such as
creating, updating, and reading. We’ll also discuss the ways in which `String`
is different from the other collections, namely how indexing into a `String` is
complicated by the differences between how people and computers interpret
`String` data.
-->
<p>コレクションの文脈で文字列を議論することは、有用なことです。なぜなら、文字列はテキストとして解釈された時に有用になる機能を提供するメソッドと、
バイトのコレクションで実装されているからです。この節では、生成、更新、読み込みのような全コレクションが持つ<code>String</code>の処理について語ります。
また、<code>String</code>が他のコレクションと異なる点についても議論します。具体的には、人間とコンピュータが<code>String</code>データを解釈する方法の差異により、
<code>String</code>に添え字アクセスする方法がどう複雑なのかということです。</p>
<!--
### What Is a String?
-->
<h3 id="文字列とは"><a class="header" href="#文字列とは">文字列とは？</a></h3>
<!--
We’ll first define what we mean by the term *string*. Rust has only one string
type in the core language, which is the string slice `str` that is usually seen
in its borrowed form `&str`. In Chapter 4, we talked about *string slices*,
which are references to some UTF-8 encoded string data stored elsewhere. String
literals, for example, are stored in the binary output of the program and are
therefore string slices.
-->
<p>まずは、<em>文字列</em>という用語の意味を定義しましょう。Rustには、言語の核として1種類しか文字列型が存在しません。
文字列スライスの<code>str</code>で、通常借用された形態<code>&amp;str</code>で見かけます。第4章で、<em>文字列スライス</em>について語りました。
これは、別の場所に格納されたUTF-8エンコードされた文字列データへの参照です。例えば、文字列リテラルは、
プログラムのバイナリ出力に格納されるので、文字列スライスになります。</p>
<!--
The `String` type, which is provided in Rust’s standard library rather than
coded into the core language, is a growable, mutable, owned, UTF-8 encoded
string type. When Rustaceans refer to “strings” in Rust, they usually mean the
`String` and the string slice `&str` types, not just one of those types.
Although this section is largely about `String`, both types are used heavily in
Rust's standard library, and both `String` and string slices are UTF-8 encoded.
-->
<p><code>String</code>型は、言語の核として組み込まれるのではなく、Rustの標準ライブラリで提供されますが、伸長可能、
可変、所有権のあるUTF-8エンコードされた文字列型です。RustaceanがRustにおいて「文字列」を指したら、
どちらかではなく、<code>String</code>と文字列スライスの<code>&amp;str</code>のことを通常意味します。この節は、大方、
<code>String</code>についてですが、どちらの型もRustの標準ライブラリで重宝されており、
どちらもUTF-8エンコードされています。</p>
<!--
Rust’s standard library also includes a number of other string types, such as
`OsString`, `OsStr`, `CString`, and `CStr`. Library crates can provide even
more options for storing string data. See how those names all end in `String`
or `Str`? They refer to owned and borrowed variant, just like the `String` and
`str` types you've seen previously. These string types can store text in
different encodings or be represented in memory in a different way, for
example. We won’t discuss these other string types in this chapter; see their
API documentation for more about how to use them and when each is appropriate.
-->
<p>また、Rustの標準ライブラリには、他の文字列型も含まれています。<code>OsString</code>、<code>OsStr</code>、<code>CString</code>、<code>CStr</code>などです。
ライブラリクレートにより、文字列データを格納する選択肢はさらに増えます。
それらの名前が全て<code>String</code>か<code>Str</code>で終わっているのがわかりますか？所有権ありと借用されたバージョンを指しているのです。
ちょうど以前見かけた<code>String</code>と<code>&amp;str</code>のようですね。例えば、これらの文字列型は、異なるエンコード方法でテキストを格納していたり、
メモリ上の表現が異なったりします。この章では、これらの他の種類の文字列については議論しません;
使用方法やどれが最適かについては、APIドキュメントを参照してください。</p>
<!--
### Creating a New String
-->
<h3 id="新規文字列を生成する"><a class="header" href="#新規文字列を生成する">新規文字列を生成する</a></h3>
<!--
Many of the same operations available with `Vec<T>` are available with `String`
as well, starting with the `new` function to create a string, shown in Listing
8-11.
-->
<p><code>Vec&lt;T&gt;</code>で使用可能な処理の多くが<code>String</code>でも使用できます。文字列を生成する<code>new</code>関数から始めましょうか。
リスト8-11に示したようにですね。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-11: Creating a new, empty `String`</span>
-->
<p><span class="caption">リスト8-11: 新しい空の<code>String</code>を生成する</span></p>
<!--
This line creates a new empty string called `s`, which we can then load data
into. Often, we’ll have some initial data that we want to start the string
with. For that, we use the `to_string` method, which is available on any type
that implements the `Display` trait, as string literals do. Listing 8-12 shows
two examples.
-->
<p>この行は、新しい空の<code>s</code>という文字列を生成しています。それからここにデータを読み込むことができるわけです。
だいたい、文字列の初期値を決めるデータがあるでしょう。そのために、<code>to_string</code>メソッドを使用します。
このメソッドは、文字列リテラルのように、<code>Display</code>トレイトを実装する型ならなんでも使用できます。
リスト8-12に2例、示しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let data = &quot;initial contents&quot;;

let s = data.to_string();

// the method also works on a literal directly:
let s = &quot;initial contents&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-12: Using the `to_string` method to create a
`String` from a string literal</span>
-->
<p><span class="caption">リスト8-12: <code>to_string</code>メソッドを使用して文字列リテラルから<code>String</code>を生成する</span></p>
<!--
This code creates a string containing `initial contents`.
-->
<p>このコードは、<code>initial contents</code>(初期値)を含む文字列を生成します。</p>
<!--
We can also use the function `String::from` to create a `String` from a string
literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12
that uses `to_string`.
-->
<p>さらに、<code>String::from</code>関数を使っても、文字列リテラルから<code>String</code>を生成することができます。
リスト8-13のコードは、<code>to_string</code>を使用するリスト8-12のコードと等価です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;initial contents&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-13: Using the `String::from` function to create
a `String` from a string literal</span>
-->
<p><span class="caption">リスト8-13: <code>String::from</code>関数を使って文字列リテラルから<code>String</code>を作る</span></p>
<!--
Because strings are used for so many things, we can use many different generic
APIs for strings, providing us with a lot of options. Some of them can seem
redundant, but they all have their place! In this case, `String::from` and
`to_string` do the same thing, so which you choose is a matter of style.
-->
<p>文字列は、非常に多くのものに使用されるので、多くの異なる一般的なAPIを使用でき、たくさんの選択肢があるわけです。
冗長に思われるものもありますが、適材適所です！今回の場合、<code>String::from</code>と<code>to_string</code>は全く同じことをします。
従って、どちらを選ぶかは、スタイル次第です。</p>
<!--
Remember that strings are UTF-8 encoded, so we can include any properly encoded
data in them, as shown in Listing 8-14.
-->
<p>文字列はUTF-8エンコードされていることを覚えていますか？要するに文字列には、適切にエンコードされていればどんなものでも含めます。
リスト8-14に示したように。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;السلام عليكم&quot;);
let hello = String::from(&quot;Dobrý den&quot;);
let hello = String::from(&quot;Hello&quot;);
let hello = String::from(&quot;שָׁלוֹם&quot;);
let hello = String::from(&quot;नमस्ते&quot;);
let hello = String::from(&quot;こんにちは&quot;);
let hello = String::from(&quot;안녕하세요&quot;);
let hello = String::from(&quot;你好&quot;);
let hello = String::from(&quot;Olá&quot;);
let hello = String::from(&quot;Здравствуйте&quot;);
let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-14: Storing greetings in different languages in
strings</span>
-->
<p><span class="caption">リスト8-14: いろんな言語の挨拶を文字列に保持する</span></p>
<!--
All of these are valid `String` values.
-->
<p>これらは全て、有効な<code>String</code>の値です。</p>
<!--
### Updating a String
-->
<h3 id="文字列を更新する"><a class="header" href="#文字列を更新する">文字列を更新する</a></h3>
<!--
A `String` can grow in size and its contents can change, just like the contents
of a `Vec<T>`, if you push more data into it. In addition, we can conveniently
use the `+` operator or the `format!` macro to concatenate `String` values.
-->
<p><code>String</code>は、サイズを伸ばすことができ、<code>Vec&lt;T&gt;</code>の中身のように、追加のデータをプッシュすれば、中身も変化します。
付け加えると、<code>String</code>値を連結する<code>+</code>演算子や、<code>format!</code>マクロを便利に使用することができます。</p>
<!--
#### Appending to a String with `push_str` and `push`
-->
<h4 id="push_strとpushで文字列に追加する"><a class="header" href="#push_strとpushで文字列に追加する"><code>push_str</code>と<code>push</code>で文字列に追加する</a></h4>
<!--
We can grow a `String` by using the `push_str` method to append a string slice,
as shown in Listing 8-15.
-->
<p><code>push_str</code>メソッドで文字列スライスを追記することで、<code>String</code>を伸ばすことができます。
リスト8-15の通りです。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-15: Appending a string slice to a `String`
using the `push_str` method</span>
-->
<p><span class="caption">リスト8-15: <code>push_str</code>メソッドで<code>String</code>に文字列スライスを追記する</span></p>
<!--
After these two lines, `s` will contain `foobar`. The `push_str` method takes a
string slice because we don’t necessarily want to take ownership of the
parameter. For example, the code in Listing 8-16 shows that it would be
unfortunate if we weren’t able to use `s2` after appending its contents to `s1`.
-->
<p>この2行の後、<code>s</code>は<code>foobar</code>を含むことになります。<code>push_str</code>メソッドは、必ずしも引数の所有権を得なくていいので、
文字列スライスを取ります。例えば、リスト8-16のコードは、中身を<code>s1</code>に追加した後、
<code>s2</code>を使えなかったら残念だということを示しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s1 = String::from(&quot;foo&quot;);
let s2 = &quot;bar&quot;;
s1.push_str(s2);
println!(&quot;s2 is {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-16: Using a string slice after appending its
contents to a `String`</span>
-->
<p><span class="caption">リスト8-16: 中身を<code>String</code>に追加した後に、文字列スライスを使用する</span></p>
<!--
If the `push_str` method took ownership of `s2`, we wouldn’t be able to print
its value on the last line. However, this code works as we’d expect!
-->
<p>もし、<code>push_str</code>メソッドが<code>s2</code>の所有権を奪っていたら、最後の行でその値を出力することは不可能でしょう。
ところが、このコードは予想通りに動きます！</p>
<!--
The `push` method takes a single character as a parameter and adds it to the
`String`. Listing 8-17 shows code that adds the letter *l* to a `String` using
the `push` method.
-->
<p><code>push</code>メソッドは、1文字を引数として取り、<code>String</code>に追加します。リスト8-15は、
<code>push</code>メソッドで<em>l</em>を<code>String</code>に追加するコードを呈示しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;lo&quot;);
s.push('l');
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-17: Adding one character to a `String` value
using `push`</span>
-->
<p><span class="caption">リスト8-17: <code>push</code>で<code>String</code>値に1文字を追加する</span></p>
<!--
As a result of this code, `s` will contain `lol`.
-->
<p>このコードの結果、<code>s</code>は<code>lol</code>を含むことになるでしょう。</p>
<blockquote>
<p>編者注: <code>lol</code>は<code>laughing out loud</code>(大笑いする)の頭文字からできたスラングです。
日本語の<code>www</code>みたいなものですね。</p>
</blockquote>
<!--
#### Concatenation with the `+` Operator or the `format!` Macro
-->
<h4 id="演算子またはformatマクロで連結"><a class="header" href="#演算子またはformatマクロで連結"><code>+</code>演算子、または<code>format!</code>マクロで連結</a></h4>
<!--
Often, you’ll want to combine two existing strings. One way is to use the `+`
operator, as shown in Listing 8-18.
-->
<p>2つのすでにある文字列を組み合わせたくなることがよくあります。リスト8-18に示したように、
一つ目の方法は、<code>+</code>演算子を使用することです。</p>
<!--
```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note that s1 has been moved here and can no longer be used
```
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // s1はムーブされ、もう使用できないことに注意
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-18: Using the `+` operator to combine two
`String` values into a new `String` value</span>
-->
<p><span class="caption">リスト8-18: <code>+</code>演算子を使用して二つの<code>String</code>値を新しい<code>String</code>値にする</span></p>
<!--
The string `s3` will contain `Hello, world!` as a result of this code. The
reason `s1` is no longer valid after the addition and the reason we used a
reference to `s2` has to do with the signature of the method that gets called
when we use the `+` operator. The `+` operator uses the `add` method, whose
signature looks something like this:
-->
<p>このコードの結果、<code>s3</code>という文字列は、<code>Hello, world!</code>を含むことになるでしょう。
追記の後、<code>s1</code>がもう有効でなくなった理由と、<code>s2</code>への参照を使用した理由は、
<code>+</code>演算子を使用した時に呼ばれるメソッドのシグニチャと関係があります。<code>+</code>演算子は、<code>add</code>メソッドを使用し、
そのシグニチャは以下のような感じです:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<!--
This isn’t the exact signature that’s in the standard library: in the standard
library, `add` is defined using generics. Here, we’re looking at the signature
of `add` with concrete types substituted for the generic ones, which is what
happens when we call this method with `String` values. We’ll discuss generics
in Chapter 10. This signature gives us the clues we need to understand the
tricky bits of the `+` operator.
-->
<p>これは、標準ライブラリにあるシグニチャそのものではありません: 標準ライブラリでは、<code>add</code>はジェネリクスで定義されています。
ここでは、ジェネリックな型を具体的な型に置き換えた<code>add</code>のシグニチャを見ており、これは、
このメソッドを<code>String</code>値とともに呼び出した時に起こることです。ジェネリクスについては、第10章で議論します。
このシグニチャが、<code>+</code>演算子の巧妙な部分を理解するのに必要な手がかりになるのです。</p>
<!--
First, `s2` has an `&`, meaning that we’re adding a *reference* of the second
string to the first string because of the `s` parameter in the `add` function:
we can only add a `&str` to a `String`; we can’t add two `String` values
together. But wait-the type of `&s2` is `&String`, not `&str`, as specified in
the second parameter to `add`. So why does Listing 8-18 compile?
-->
<p>まず、<code>s2</code>には<code>&amp;</code>がついてます。つまり、<code>add</code>関数の<code>s</code>引数のために最初の文字列に2番目の文字列の参照を追加するということです:
<code>String</code>には<code>&amp;str</code>を追加することしかできません。要するに2つの<code>String</code>値を追加することはできないのです。
でも待ってください。<code>add</code>の第2引数で指定されているように、<code>&amp;s2</code>の型は、<code>&amp;str</code>ではなく、
<code>&amp;String</code>ではないですか。では、なぜ、リスト8-18は、コンパイルできるのでしょうか？</p>
<!--
The reason we’re able to use `&s2` in the call to `add` is that the compiler
can *coerce* the `&String` argument into a `&str`. When we call the `add`
method, Rust uses a *deref coercion*, which here turns `&s2` into `&s2[..]`.
We’ll discuss deref coercion in more depth in Chapter 15. Because `add` does
not take ownership of the `s` parameter, `s2` will still be a valid `String`
after this operation.
-->
<p><code>add</code>呼び出しで<code>&amp;s2</code>を使える理由は、コンパイラが<code>&amp;String</code>引数を<code>&amp;str</code>に<em>型強制</em>してくれるためです。
<code>add</code>メソッド呼び出しの際、コンパイラは、<em>参照外し型強制</em>というものを使用し、ここでは、
<code>&amp;s2</code>を<code>&amp;s2[..]</code>に変えるものと考えることができます。参照外し型強制について詳しくは、第15章で議論します。
<code>add</code>が<code>s</code>引数の所有権を奪わないので、この処理後も<code>s2</code>が有効な<code>String</code>になるわけです。</p>
<!--
Second, we can see in the signature that `add` takes ownership of `self`,
because `self` does *not* have an `&`. This means `s1` in Listing 8-18 will be
moved into the `add` call and no longer be valid after that. So although `let
s3 = s1 + &s2;` looks like it will copy both strings and create a new one, this
statement actually takes ownership of `s1`, appends a copy of the contents of
`s2`, and then returns ownership of the result. In other words, it looks like
it’s making a lot of copies but isn’t; the implementation is more efficient
than copying.
-->
<p>2番目に、シグニチャから<code>add</code>は<code>self</code>の所有権をもらうことがわかります。<code>self</code>には<code>&amp;</code>がついてい<em>ない</em>からです。
これはつまり、リスト8-18において<code>s1</code>は<code>add</code>呼び出しにムーブされ、その後は有効ではなくなるということです。
故に、<code>s3 = s1 + &amp;s2;</code>は両文字列をコピーして新しいものを作るように見えますが、
この文は実際には<code>s1</code>の所有権を奪い、<code>s2</code>の中身のコピーを追記し、結果の所有権を返すのです。言い換えると、
たくさんのコピーをしているように見えますが、違います; 実装は、コピーよりも効率的です。</p>
<!--
If we need to concatenate multiple strings, the behavior of `+` operator
gets unwieldy:
-->
<p>複数の文字列を連結する必要が出ると、<code>+</code>演算子の振る舞いは扱いにくくなります:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<!--
At this point, `s` will be `tic-tac-toe`. With all of the `+` and `"`
characters, it’s difficult to see what’s going on. For more complicated string
combining, we can use the `format!` macro:
-->
<p>ここで、<code>s</code>は<code>tic-tac-toe</code>になるでしょう。<code>+</code>と<code>&quot;</code>文字のせいで何が起きているのかわかりにくいです。
もっと複雑な文字列の連結には、<code>format!</code>マクロを使用することができます:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<!--
This code also sets `s` to `tic-tac-toe`. The `format!` macro works in the same
way as `println!`, but instead of printing the output to the screen, it returns
a `String` with the contents. The version of the code using `format!` is much
easier to read and doesn’t take ownership of any of its parameters.
-->
<p>このコードでも、<code>s</code>は<code>tic-tac-toe</code>になります。<code>format!</code>マクロは、<code>println!</code>と同様の動作をしますが、
出力をスクリーンに行う代わりに、中身を<code>String</code>で返すのです。<code>format!</code>を使用したコードの方がはるかに読みやすく、
引数の所有権を奪いません。</p>
<!--
### Indexing into Strings
-->
<h3 id="文字列に添え字アクセスする"><a class="header" href="#文字列に添え字アクセスする">文字列に添え字アクセスする</a></h3>
<!--
In many other programming languages, accessing individual characters in a
string by referencing them by index is a valid and common operation. However,
if you try to access parts of a `String` using indexing syntax in Rust, you’ll
get an error. Consider the invalid code in Listing 8-19.
-->
<p>他の多くのプログラミング言語では、文字列中の文字に、添え字で参照してアクセスすることは、有効なコードであり、
一般的な処理です。しかしながら、Rustにおいて、添え字記法で<code>String</code>の一部にアクセスしようとすると、
エラーが発生するでしょう。リスト8-19の非合法なコードを考えてください。</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<!--
<span class="caption">Listing 8-19: Attempting to use indexing syntax with a
String</span>
-->
<p><span class="caption">リスト8-19: 文字列に対して添え字記法を試みる</span></p>
<!--
This code will result in the following error:
-->
<p>このコードは、以下のようなエラーに落ち着きます:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: std::ops::Index&lt;{Integer}&gt;` is not satisfied
(エラー: トレイト境界`std::string::String: std::ops::Index&lt;{Integer}&gt;`が満たされていません)
  |&gt;
3 |&gt;     let h = s1[0];
  |&gt;             ^^^^^ the type `std::string::String` cannot be indexed by `{Integer}`
  |&gt;                   (型`std::string::String`は`{Integer}`で添え字アクセスできません)
  = help: the trait `std::ops::Index&lt;{Integer}&gt;` is not implemented for `std::string::String`
  (ヘルプ: `std::ops::Index&lt;{Integer}&gt;`というトレイトが`std::string::String`に対して実装されていません)
</code></pre>
<!--
The error and the note tell the story: Rust strings don’t support indexing. But
why not? To answer that question, we need to discuss how Rust stores strings in
memory.
-->
<p>エラーと注釈が全てを物語っています: Rustの文字列は、添え字アクセスをサポートしていないのです。
でも、なぜでしょうか？その疑問に答えるには、Rustがメモリにどのように文字列を保持しているかについて議論する必要があります。</p>
<!--
#### Internal Representation
-->
<h4 id="内部表現"><a class="header" href="#内部表現">内部表現</a></h4>
<!--
A `String` is a wrapper over a `Vec<u8>`. Let’s look at some of our properly
encoded UTF-8 example strings from Listing 8-14. First, this one:
-->
<p><code>String</code>は<code>Vec&lt;u8&gt;</code>のラッパです。リスト8-14から適切にUTF-8でエンコードされた文字列の例をご覧ください。
まずは、これ:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let len = String::from(&quot;Hola&quot;).len();
<span class="boring">}
</span></code></pre></pre>
<!--
In this case, `len` will be 4, which means the vector storing the string “Hola”
is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But
what about the following line? (Note that this string begins with the capital
Cyrillic letter Ze, not the Arabic number 3.)
-->
<p>この場合、<code>len</code>は4になり、これは、文字列&quot;Hola&quot;を保持するベクタの長さが4バイトであることを意味します。
これらの各文字は、UTF-8でエンコードすると、1バイトになるのです。しかし、以下の行ではどうでしょうか？
(この文字列は大文字のキリル文字Zeで始まり、アラビア数字の3では始まっていないことに注意してください)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let len = String::from(&quot;Здравствуйте&quot;).len();
<span class="boring">}
</span></code></pre></pre>
<!--
Asked how long the string is, you might say 12. However, Rust’s answer is 24:
that’s the number of bytes it takes to encode “Здравствуйте” in UTF-8, because
each Unicode scalar value takes two bytes of storage. Therefore, an index into
the string’s bytes will not always correlate to a valid Unicode scalar value.
To demonstrate, consider this invalid Rust code:
-->
<p>文字列の長さはと問われたら、あなたは12と答えるかもしれません。ところが、Rustの答えは、24です:
“Здравствуйте”をUTF-8でエンコードすると、この長さになります。各Unicodeスカラー値は、2バイトの領域を取るからです。
それ故に、文字列のバイトの添え字は、必ずしも有効なUnicodeのスカラー値とは相互に関係しないのです。
デモ用に、こんな非合法なRustコードを考えてください:</p>
<pre><code class="language-rust ignore">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<!--
What should the value of `answer` be? Should it be `З`, the first letter? When
encoded in UTF-8, the first byte of `З` is `208`, and the second is `151`, so
`answer` should in fact be `208`, but `208` is not a valid character on its
own. Returning `208` is likely not what a user would want if they asked for the
first letter of this string; however, that’s the only data that Rust has at
byte index 0. Users generally don't want the byte value returned, even if
the string contains only Latin letters: if `&"hello"[0]` was valid code that
returned the byte value, it would return `104`, not `h`. To avoid returning an
unexpected value and causing bugs that might not be discovered immediately,
Rust doesn’t compile this code at all and prevents misunderstandings early in
the development process.
-->
<p><code>answer</code>の値は何になるべきでしょうか？最初の文字の<code>З</code>になるべきでしょうか？UTF-8エンコードされた時、
<code>З</code>の最初のバイトは<code>208</code>、2番目は<code>151</code>になるので、<code>answer</code>は実際、<code>208</code>になるべきですが、
<code>208</code>は単独では有効な文字ではありません。この文字列の最初の文字を求めている場合、<code>208</code>を返すことは、
ユーザの望んでいるものではないでしょう; しかしながら、Rustには、バイト添え字0の位置には、そのデータしかないのです。
文字列がラテン文字のみを含む場合でも、ユーザは一般的にバイト値が返ることを望みません:
<code>&amp;&quot;hello&quot;[0]</code>がバイト値を返す有効なコードだったら、<code>h</code>ではなく、<code>104</code>を返すでしょう。
予期しない値を返し、すぐには判明しないバグを引き起こさないために、Rustはこのコードを全くコンパイルせず、
開発過程の早い段階で誤解を防いでくれるのです。</p>
<!--
#### Bytes and Scalar Values and Grapheme Clusters! Oh My!
-->
<h4 id="バイトとスカラー値と書記素クラスタなんてこった"><a class="header" href="#バイトとスカラー値と書記素クラスタなんてこった">バイトとスカラー値と書記素クラスタ！なんてこった！</a></h4>
<!--
Another point about UTF-8 is that there are actually three relevant ways to
look at strings from Rust’s perspective: as bytes, scalar values, and grapheme
clusters (the closest thing to what we would call *letters*).
-->
<p>UTF-8について別の要点は、実際Rustの観点から文字列を見るには3つの関連した方法があるということです:
バイトとして、スカラー値として、そして、書記素クラスタ(人間が<em>文字</em>と呼ぶものに一番近い)としてです。</p>
<!--
If we look at the Hindi word “नमस्ते” written in the Devanagari script, it is
stored as a vector of `u8` values that looks like this:
-->
<p>ヒンディー語の単語、“नमस्ते”をデーヴァナーガリー(<code>訳注</code>: サンスクリット語とヒンディー語を書くときに使われる書記法)で表記したものを見たら、
以下のような見た目の<code>u8</code>値のベクタとして保持されます:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<!--
That’s 18 bytes and is how computers ultimately store this data. If we look at
them as Unicode scalar values, which are what Rust’s `char` type is, those
bytes look like this:
-->
<p>18バイトになり、このようにしてコンピュータは最終的にこのデータを保持しているわけです。これをUnicodeスカラー値として見たら
（Rustの<code>char</code>型はこれなのですが）このバイトは以下のような見た目になります:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<!--
There are six `char` values here, but the fourth and sixth are not letters:
they’re diacritics that don’t make sense on their own. Finally, if we look at
them as grapheme clusters, we’d get what a person would call the four letters
that make up the Hindi word:
-->
<p>ここでは、6つ<code>char</code>値がありますが、4番目と6番目は文字ではありません: 単独では意味をなさないダイアクリティックです。
最後に、書記素クラスタとして見たら、このヒンディー語の単語を作り上げる人間が4文字と呼ぶであろうものが得られます:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<!--
Rust provides different ways of interpreting the raw string data that computers
store so that each program can choose the interpretation it needs, no matter
what human language the data is in.
-->
<p>Rustには、データが表す自然言語に関わらず、各プログラムが必要な解釈方法を選択できるように、
コンピュータが保持する生の文字列データを解釈する方法がいろいろ用意されています。</p>
<!--
A final reason Rust doesn’t allow us to index into a `String` to get a
character is that indexing operations are expected to always take constant time
(O(1)). But it isn’t possible to guarantee that performance with a `String`,
because Rust would have to walk through the contents from the beginning to the
index to determine how many valid characters there were.
-->
<p>Rustで文字を得るのに<code>String</code>に添え字アクセスすることが許されない最後の理由は、
添え字アクセスという処理が常に定数時間(O(1))になると期待されるからです。
しかし、<code>String</code>でそのパフォーマンスを保証することはできません。というのも、
合法な文字がいくつあるか決定するのに、最初から添え字まで中身を走査する必要があるからです。</p>
<!--
### Slicing Strings
-->
<h3 id="文字列をスライスする"><a class="header" href="#文字列をスライスする">文字列をスライスする</a></h3>
<!--
Indexing into a string is often a bad idea because it’s not clear what the
return type of the string indexing operation should be: a byte value, a
character, a grapheme cluster, or a string slice. Therefore, Rust asks you to
be more specific if you really need to use indices to create string slices. To
be more specific in your indexing and indicate that you want a string slice,
rather than indexing using `[]` with a single number, you can use `[]` with a
range to create a string slice containing particular bytes:
-->
<p>文字列に添え字アクセスするのは、しばしば悪い考えです。文字列添え字処理の戻り値の型が明瞭ではないからです:
バイト値、文字、書記素クラスタ、あるいは文字列スライスにもなります。故に、文字列スライスを生成するのに、
添え字を使う必要が本当に出た場合にコンパイラは、もっと特定するよう求めてきます。添え字アクセスを特定し、
文字列スライスが欲しいと示唆するためには、<code>[]</code>で1つの数値により添え字アクセスするのではなく、
範囲とともに<code>[]</code>を使って、特定のバイトを含む文字列スライスを作ることができます:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
<span class="boring">}
</span></code></pre></pre>
<!--
Here, `s` will be a `&str` that contains the first 4 bytes of the string.
Earlier, we mentioned that each of these characters was 2 bytes, which means
`s` will be `Зд`.
-->
<p>ここで、<code>s</code>は文字列の最初の4バイトを含む<code>&amp;str</code>になります。先ほど、これらの文字は各々2バイトになると指摘しましたから、
<code>s</code>は<code>Зд</code>になります。</p>
<!--
What would happen if we used `&hello[0..1]`? The answer: Rust would panic at
runtime in the same way as if an invalid index were accessed in a vector:
-->
<p><code>&amp;hello[0..1]</code>と使用したら、何が起きるでしょうか？答え: Rustはベクタの非合法な添え字にアクセスしたかのように、
実行時にパニックするでしょう:</p>
<pre><code class="language-text">thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2188:4
('main'スレッドは「バイト添え字1は文字の境界ではありません; `Здравствуйте`の'З'(バイト番号0から2)の中です」でパニックしました)
</code></pre>
<!--
You should use ranges to create string slices with caution, because doing so
can crash your program.
-->
<p>範囲を使用して文字列スライスを作る際にはプログラムをクラッシュさせることがあるので、気をつけるべきです。</p>
<!--
### Methods for Iterating Over Strings
-->
<h3 id="文字列を走査するメソッド群"><a class="header" href="#文字列を走査するメソッド群">文字列を走査するメソッド群</a></h3>
<!--
Fortunately, you can access elements in a string in other ways.
-->
<p>幸いなことに、他の方法でも文字列の要素にアクセスすることができます。</p>
<!--
If you need to perform operations on individual Unicode scalar values, the best
way to do so is to use the `chars` method. Calling `chars` on “नमस्ते” separates
out and returns six values of type `char`, and you can iterate over the result
to access each element:
-->
<p>もし、個々のUnicodeスカラー値に対して処理を行う必要があったら、最適な方法は<code>chars</code>メソッドを使用するものです。
“नमस्ते”に対して<code>chars</code>を呼び出したら、分解して6つの<code>char</code>型の値を返すので、各要素にアクセスするには、
その結果を走査すればいいわけです:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print the following:
-->
<p>このコードは、以下のように出力します:</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<!--
The `bytes` method returns each raw byte, which might be appropriate for your
domain:
-->
<p><code>bytes</code>メソッドは、各バイトをそのまま返すので、最適になることもあるかもしれません:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print the 18 bytes that make up this `String`:
-->
<p>このコードは、<code>String</code>をなす18バイトを出力します:</p>
<pre><code class="language-text">224
164
// --snip--
165
135
</code></pre>
<!--
But be sure to remember that valid Unicode scalar values may be made up of more
than 1 byte.
-->
<p>ですが、合法なUnicodeスカラー値は、2バイト以上からなる場合もあることは心得ておいてください。</p>
<!--
Getting grapheme clusters from strings is complex, so this functionality is not
provided by the standard library. Crates are available on
[crates.io](https://crates.io) if this is the functionality you need.
-->
<p>書記素クラスタを文字列から得る方法は複雑なので、この機能は標準ライブラリでは提供されていません。
この機能が必要なら、<a href="https://crates.io">crates.io</a>でクレートを入手可能です。</p>
<!--
### Strings Are Not So Simple
-->
<h3 id="文字列はそう単純じゃない"><a class="header" href="#文字列はそう単純じゃない">文字列はそう単純じゃない</a></h3>
<!--
To summarize, strings are complicated. Different programming languages make
different choices about how to present this complexity to the programmer. Rust
has chosen to make the correct handling of `String` data the default behavior
for all Rust programs, which means programmers have to put more thought into
handling UTF-8 data upfront. This trade-off exposes more of the complexity of
strings than is apparent in other programming languages, but it prevents you
from having to handle errors involving non-ASCII characters later in your
development life cycle.
-->
<p>まとめると、文字列は込み入っています。プログラミング言語ごとにこの複雑性をプログラマに提示する方法は違います。
Rustでは、<code>String</code>データを正しく扱うことが、全てのRustプログラムにとっての既定動作になっているわけであり、
これは、プログラマがUTF-8データを素直に扱う際に、よりしっかり考えないといけないことを意味します。
このトレードオフにより、他のプログラミング言語で見えるよりも文字列の複雑性がより露出していますが、
ASCII以外の文字に関するエラーを開発の後半で扱わなければならない可能性が排除されているのです。</p>
<!--
Let’s switch to something a bit less complex: hash maps!
-->
<p>もう少し複雑でないものに切り替えていきましょう: ハッシュマップです！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Storing Keys Associated with Values in Hash Maps
-->
<h2 id="キーとそれに紐づいた値をハッシュマップに格納する"><a class="header" href="#キーとそれに紐づいた値をハッシュマップに格納する">キーとそれに紐づいた値をハッシュマップに格納する</a></h2>
<!--
The last of our common collections is the *hash map*. The type `HashMap<K, V>`
stores a mapping of keys of type `K` to values of type `V`. It does this via a
*hashing function*, which determines how it places these keys and values into
memory. Many programming languages support this kind of data structure, but
often use a different name, such as hash, map, object, hash table, or
associative array, just to name a few.
-->
<p>一般的なコレクションのトリを飾るのは、<em>ハッシュマップ</em>です。型<code>HashMap&lt;K, V&gt;</code>は、
<code>K</code>型のキーと<code>V</code>型の値の対応関係を保持します。これを<em>ハッシュ関数</em>を介して行います。
ハッシュ関数は、キーと値のメモリ配置方法を決めるものです。多くのプログラミング言語でもこの種のデータ構造はサポートされていますが、
しばしば名前が違います。hash、map、object、ハッシュテーブル、連想配列など、枚挙に<ruby>暇<rp>(</rp><rt>いとま</rt><rp>)</rp></ruby>はありません。</p>
<!--
Hash maps are useful when you want to look up data not by an index, as
you can with vectors, but by using a key that can be of any type. For example,
in a game, you could keep track of each team’s score in a hash map in which
each key is a team’s name and the values are each team’s score. Given a team
name, you can retrieve its score.
-->
<p>ハッシュマップは、ベクタのように番号ではなく、どんな型にもなりうるキーを使ってデータを参照したいときに有用です。
例えば、ゲームにおいて、各チームのスコアをハッシュマップで追いかけることができます。ここで、各キーはチーム名、
値が各チームのスコアになります。チーム名が与えられれば、スコアを扱うことができるわけです。</p>
<!--
We’ll go over the basic API of hash maps in this section, but many more goodies
are hiding in the functions defined on `HashMap<K, V>` by the standard library.
As always, check the standard library documentation for more information.
-->
<p>この節でハッシュマップの基礎的なAPIを見ていきますが、より多くのグッズが標準ライブラリにより、
<code>HashMap&lt;K, V&gt;</code>上に定義された関数に隠されています。いつものように、
もっと情報が欲しければ、標準ライブラリのドキュメントをチェックしてください。</p>
<!--
### Creating a New Hash Map
-->
<h3 id="新規ハッシュマップを生成する"><a class="header" href="#新規ハッシュマップを生成する">新規ハッシュマップを生成する</a></h3>
<!--
You can create an empty hash map with `new` and add elements with `insert`. In
Listing 8-20, we’re keeping track of the scores of two teams whose names are
Blue and Yellow. The Blue team starts with 10 points, and the Yellow team
starts with 50.
-->
<p>空のハッシュマップを<code>new</code>で作り、要素を<code>insert</code>で追加することができます。リスト8-20では、
名前がブルーとイエローの2チームのスコアを追いかけています。ブルーチームは10点から、イエローチームは50点から始まります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-20: Creating a new hash map and inserting some
keys and values</span>
-->
<p><span class="caption">リスト8-20: ハッシュマップを生成してキーと値を挿入する</span></p>
<!--
Note that we need to first `use` the `HashMap` from the collections portion of
the standard library. Of our three common collections, this one is the least
often used, so it’s not included in the features brought into scope
automatically in the prelude. Hash maps also have less support from the
standard library; there's no built-in macro to construct them, for example.
-->
<p>最初に標準ライブラリのコレクション部分から<code>HashMap</code>を<code>use</code>する必要があることに注意してください。
今までの3つの一般的なコレクションの内、これが最も使用頻度が低いので、初期化処理で自動的にスコープに導入される機能には含まれていません。
また、標準ライブラリからのサポートもハッシュマップは少ないです; 例えば、生成するための組み込みマクロがありません。</p>
<!--
Just like vectors, hash maps store their data on the heap. This `HashMap` has
keys of type `String` and values of type `i32`. Like vectors, hash maps are
homogeneous: all of the keys must have the same type, and all of the values
must have the same type.
-->
<p>ベクタと全く同様に、ハッシュマップはデータをヒープに保持します。この<code>HashMap</code>はキーが<code>String</code>型、
値は<code>i32</code>型です。ベクタのように、ハッシュマップは均質です: キーは全て同じ型でなければならず、
値も全て同じ型でなければなりません。</p>
<!--
Another way of constructing a hash map is by using the `collect` method on a
vector of tuples, where each tuple consists of a key and its value. The
`collect` method gathers data into a number of collection types, including
`HashMap`. For example, if we had the team names and initial scores in two
separate vectors, we can use the `zip` method to create a vector of tuples
where “Blue” is paired with 10, and so forth. Then we can use the `collect`
method to turn that vector of tuples into a hash map, as shown in Listing 8-21.
-->
<p>ハッシュマップを生成する別の方法は、タプルのベクタに対して<code>collect</code>メソッドを使用するものです。
ここで、各タプルは、キーと値から構成されています。<code>collect</code>メソッドはいろんなコレクション型にデータをまとめ上げ、
そこには<code>HashMap</code>も含まれています。例として、チーム名と初期スコアが別々のベクタに含まれていたら、
<code>zip</code>メソッドを使ってタプルのベクタを作り上げることができ、そこでは「ブルー」は10とペアになるなどします。
リスト8-21に示したように、それから<code>collect</code>メソッドを使って、そのタプルのベクタをハッシュマップに変換することができるわけです。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-21: Creating a hash map from a list of teams
and a list of scores</span>
-->
<p><span class="caption">リスト8-21: チームのリストとスコアのリストからハッシュマップを作る</span></p>
<!--
The type annotation `HashMap<_, _>` is needed here because it’s possible to
`collect` into many different data structures and Rust doesn’t know which you
want unless you specify. For the type parameters for the key and value types,
however, we use underscores, and Rust can infer the types that the hash map
contains based on the types of the data in the vectors.
-->
<p>ここでは、<code>HashMap&lt;_, _&gt;</code>という型注釈が必要になります。なぜなら、いろんなデータ構造に<code>まとめ上げる</code>ことができ、
コンパイラは指定しない限り、どれを所望なのかわからないからです。ところが、キーと値の型引数については、
アンダースコアを使用しており、コンパイラはベクタのデータ型に基づいてハッシュマップが含む型を推論することができるのです。</p>
<!--
### Hash Maps and Ownership
-->
<h3 id="ハッシュマップと所有権"><a class="header" href="#ハッシュマップと所有権">ハッシュマップと所有権</a></h3>
<!--
For types that implement the `Copy` trait, like `i32`, the values are copied
into the hash map. For owned values like `String`, the values will be moved and
the hash map will be the owner of those values, as demonstrated in Listing 8-22.
-->
<p><code>i32</code>のような<code>Copy</code>トレイトを実装する型について、値はハッシュマップにコピーされます。
<code>String</code>のような所有権のある値なら、値はムーブされ、リスト8-22でデモされているように、
ハッシュマップはそれらの値の所有者になるでしょう。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
// field_nameとfield_valueはこの時点で無効になる。試しに使ってみて
// どんなコンパイルエラーが出るか確認してみて！
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-22: Showing that keys and values are owned by
the hash map once they’re inserted</span>
-->
<p><span class="caption">リスト8-22: 一旦挿入されたら、キーと値はハッシュマップに所有されることを示す</span></p>
<!--
We aren’t able to use the variables `field_name` and `field_value` after
they’ve been moved into the hash map with the call to `insert`.
-->
<p><code>insert</code>を呼び出して<code>field_name</code>と<code>field_value</code>がハッシュマップにムーブされた後は、
これらの変数を使用することは叶いません。</p>
<!--
If we insert references to values into the hash map, the values won’t be moved
into the hash map. The values that the references point to must be valid for at
least as long as the hash map is valid. We’ll talk more about these issues in
the “Validating References with Lifetimes” section in Chapter 10.
-->
<p>値への参照をハッシュマップに挿入したら、値はハッシュマップにムーブされません。参照が指している値は、
最低でもハッシュマップが有効な間は、有効でなければなりません。これらの問題について詳細には、
第10章の「ライフタイムで参照を有効化する」節で語ります。</p>
<!--
### Accessing Values in a Hash Map
-->
<h3 id="ハッシュマップの値にアクセスする"><a class="header" href="#ハッシュマップの値にアクセスする">ハッシュマップの値にアクセスする</a></h3>
<!--
We can get a value out of the hash map by providing its key to the `get`
method, as shown in Listing 8-23.
-->
<p>リスト8-23に示したように、キーを<code>get</code>メソッドに提供することで、ハッシュマップから値を取り出すことができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-23: Accessing the score for the Blue team
stored in the hash map</span>
-->
<p><span class="caption">リスト8-23: ハッシュマップに保持されたブルーチームのスコアにアクセスする</span></p>
<!--
Here, `score` will have the value that’s associated with the Blue team, and the
result will be `Some(&10)`. The result is wrapped in `Some` because `get`
returns an `Option<&V>`; if there’s no value for that key in the hash map,
`get` will return `None`. The program will need to handle the `Option` in one
of the ways that we covered in Chapter 6.
-->
<p>ここで、<code>score</code>はブルーチームに紐づけられた値になり、結果は<code>Some(&amp;10)</code>となるでしょう。
結果は<code>Some</code>に包まれます。というのも、<code>get</code>は<code>Option&lt;&amp;V&gt;</code>を返すからです; キーに対応する値がハッシュマップになかったら、
<code>get</code>は<code>None</code>を返すでしょう。プログラムは、この<code>Option</code>を第6章で講義した方法のどれかで扱う必要があるでしょう。</p>
<!--
We can iterate over each key/value pair in a hash map in a similar manner as we
do with vectors, using a `for` loop:
-->
<p>ベクタのように、<code>for</code>ループでハッシュマップのキーと値のペアを走査することができます:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will print each pair in an arbitrary order:
-->
<p>このコードは、各ペアを任意の順番で出力します:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<!--
### Updating a Hash Map
-->
<h3 id="ハッシュマップを更新する"><a class="header" href="#ハッシュマップを更新する">ハッシュマップを更新する</a></h3>
<!--
Although the number of keys and values is growable, each key can only have one
value associated with it at a time. When we want to change the data in a hash
map, we have to decide how to handle the case when a key already has a value
assigned. We could replace the old value with the new value, completely
disregarding the old value. We could keep the old value and ignore the new
value, only adding the new value if the key *doesn’t* already have a value. Or
we could combine the old value and the new value. Let’s look at how to do each
of these!
-->
<p>キーと値の数は伸長可能なものの、各キーには1回に1つの値しか紐づけることができません。
ハッシュマップ内のデータを変えたい時は、すでにキーに値が紐づいている場合の扱い方を決めなければなりません。
古い値を新しい値で置き換えて、古い値を完全に無視することもできます。古い値を保持して、
新しい値を無視し、キーにまだ値が<em>ない</em>場合に新しい値を追加するだけにすることもできます。
あるいは、古い値と新しい値を組み合わせることもできます。各方法について見ていきましょう！</p>
<!--
#### Overwriting a Value
-->
<h4 id="値を上書きする"><a class="header" href="#値を上書きする">値を上書きする</a></h4>
<!--
If we insert a key and a value into a hash map and then insert that same key
with a different value, the value associated with that key will be replaced.
Even though the code in Listing 8-24 calls `insert` twice, the hash map will
only contain one key/value pair because we’re inserting the value for the Blue
team’s key both times.
-->
<p>キーと値をハッシュマップに挿入し、同じキーを異なる値で挿入したら、そのキーに紐づけられている値は置換されます。
リスト8-24のコードは、<code>insert</code>を二度呼んでいるものの、ハッシュマップには一つのキーと値の組しか含まれません。
なぜなら、ブルーチームキーに対する値を2回とも挿入しているからです。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-24: Replacing a value stored with a particular
key</span>
-->
<p><span class="caption">リスト8-24: 特定のキーで保持された値を置き換える</span></p>
<!--
This code will print `{"Blue": 25}`. The original value of `10` has been
overwritten.
-->
<p>このコードは、<code>{&quot;Blue&quot;: 25}</code>と出力するでしょう。<code>10</code>という元の値は上書きされたのです。</p>
<!--
#### Only Inserting a Value If the Key Has No Value
-->
<h4 id="キーに値がなかった時のみ値を挿入する"><a class="header" href="#キーに値がなかった時のみ値を挿入する">キーに値がなかった時のみ値を挿入する</a></h4>
<!--
It’s common to check whether a particular key has a value and if it doesn’t,
insert a value for it. Hash maps have a special API for this called `entry`
that takes the key we want to check as a parameter. The return value of the
`entry` method is an enum called `Entry` that represents a value that might or
might not exist. Let’s say we want to check whether the key for the Yellow team
has a value associated with it. If it doesn’t, we want to insert the value 50,
and the same for the Blue team. Using the `entry` API, the code looks like
Listing 8-25.
-->
<p>特定のキーに値があるか確認することは一般的であり、存在しない時に値を挿入することも一般的です。
ハッシュマップには、これを行う<code>entry</code>と呼ばれる特別なAPIがあり、これは、引数としてチェックしたいキーを取ります。
この<code>entry</code>メソッドの戻り値は、<code>Entry</code>と呼ばれるenumであり、これは存在したりしなかったりする可能性のある値を表します。
イエローチームに対するキーに値が紐づけられているか否か確認したくなったとしましょう。存在しなかったら、
50という値を挿入したく、ブルーチームに対しても同様です。<code>entry</code>APIを使用すれば、コードはリスト8-25のようになります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-25: Using the `entry` method to only insert if
the key does not already have a value</span>
-->
<p><span class="caption">リスト8-25: <code>entry</code>メソッドを使ってキーに値がない場合だけ挿入する</span></p>
<!--
The `or_insert` method on `Entry` is defined to return a mutable reference to
the value for the corresponding `Entry` key if that key exists, and if not,
inserts the parameter as the new value for this key and returns a mutable
reference to the new value. This technique is much cleaner than writing the
logic ourselves, and in addition, plays more nicely with the borrow checker.
-->
<p><code>Entry</code>上の<code>or_insert</code>メソッドは、対応する<code>Entry</code>キーが存在した時にそのキーに対する値への可変参照を返すために定義されており、
もしなかったら、引数をこのキーの新しい値として挿入し、新しい値への可変参照を返します。このテクニックの方が、
そのロジックを自分で書くよりもはるかに綺麗な上に、borrow checkerとも親和性が高くなります。</p>
<!--
Running the code in Listing 8-25 will print `{"Yellow": 50, "Blue": 10}`. The
first call to `entry` will insert the key for the Yellow team with the value
50 because the Yellow team doesn’t have a value already. The second call to
`entry` will not change the hash map because the Blue team already has the
value 10.
-->
<p>リスト8-25のコードを実行すると、<code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>と出力するでしょう。
最初の<code>entry</code>呼び出しは、まだイエローチームに対する値がないので、値50でイエローチームのキーを挿入します。
<code>entry</code>の2回目の呼び出しはハッシュマップを変更しません。なぜなら、ブルーチームには既に10という値があるからです。</p>
<!--
#### Updating a Value Based on the Old Value
-->
<h4 id="古い値に基づいて値を更新する"><a class="header" href="#古い値に基づいて値を更新する">古い値に基づいて値を更新する</a></h4>
<!--
Another common use case for hash maps is to look up a key’s value and then
update it based on the old value. For instance, Listing 8-26 shows code that
counts how many times each word appears in some text. We use a hash map with
the words as keys and increment the value to keep track of how many times we’ve
seen that word. If it’s the first time we’ve seen a word, we’ll first insert
the value 0:
-->
<p>ハッシュマップの別の一般的なユースケースは、キーの値を探し、古い値に基づいてそれを更新することです。
例えば、リスト8-26は、各単語があるテキストに何回出現するかを数え上げるコードを示しています。
キーに単語を入れたハッシュマップを使用し、その単語を何回見かけたか追いかけるために値を増やします。
ある単語を見かけたのが最初だったら、まず0という値を挿入します:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 8-26: Counting occurrences of words using a hash
map that stores words and counts</span>
-->
<p><span class="caption">リスト8-26: 単語とカウントを保持するハッシュマップを使って単語の出現数をカウントする</span></p>
<!--
This code will print `{"world": 2, "hello": 1, "wonderful": 1}`. The
`or_insert` method actually returns a mutable reference (`&mut V`) to the value
for this key. Here we store that mutable reference in the `count` variable, so
in order to assign to that value, we must first dereference `count` using the
asterisk (`*`). The mutable reference goes out of scope at the end of the `for`
loop, so all of these changes are safe and allowed by the borrowing rules.
-->
<p>このコードは、<code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>と出力するでしょう。
<code>or_insert</code>関数は実際、このキーに対する値への可変参照(<code>&amp;mut V</code>)を返すのです。
ここでその可変参照を<code>count</code>変数に保持しているので、その値に代入するには、
まずアスタリスク(<code>*</code>)で<code>count</code>を参照外ししなければならないのです。この可変参照は、
<code>for</code>ループの終端でスコープを抜けるので、これらの変更は全て安全であり、借用規則により許可されるのです。</p>
<!--
### Hashing Function
-->
<h3 id="ハッシュ関数"><a class="header" href="#ハッシュ関数">ハッシュ関数</a></h3>
<!--
By default, `HashMap` uses a cryptographically secure hashing function that can
provide resistance to Denial of Service (DoS) attacks. This is not the fastest
hashing algorithm available, but the trade-off for better security that comes
with the drop in performance is worth it. If you profile your code and find
that the default hash function is too slow for your purposes, you can switch to
another function by specifying a different *hasher*. A hasher is a type that
implements the `BuildHasher` trait. We’ll talk about traits and how to
implement them in Chapter 10. You don’t necessarily have to implement your own
hasher from scratch; [crates.io](https://crates.io) has libraries shared by
other Rust users that provide hashers implementing many common hashing
algorithms.
-->
<p>標準では、<code>HashMap</code>はサービス拒否(DoS)アタックに対して抵抗を示す暗号学的に安全なハッシュ関数を使用します。
これは、利用可能な最速のハッシュアルゴリズムではありませんが、パフォーマンスの欠落と引き換えに安全性を得るというトレードオフは、
価値があります。自分のコードをプロファイリングして、自分の目的では標準のハッシュ関数は遅すぎると判明したら、
異なる<em>hasher</em>を指定することで別の関数に切り替えることができます。hasherとは、
<code>BuildHasher</code>トレイトを実装する型のことです。トレイトについてとその実装方法については、第10章で語ります。
必ずしも独自のhasherを1から作り上げる必要はありません; <a href="https://crates.io">crates.io</a>には、
他のRustユーザによって共有された多くの一般的なハッシュアルゴリズムを実装したhasherを提供するライブラリがあります。</p>
<!--
## Summary
-->
<h2 id="まとめ-7"><a class="header" href="#まとめ-7">まとめ</a></h2>
<!--
Vectors, strings, and hash maps will provide a large amount of functionality
necessary in programs when you need to store, access, and modify data. Here are
some exercises you should now be equipped to solve:
-->
<p>ベクタ、文字列、ハッシュマップはデータを保持し、アクセスし、変更する必要のあるプログラムで必要になる、
多くの機能を提供してくれるでしょう。今なら解決可能なはずの練習問題を用意しました:</p>
<!--
* Given a list of integers, use a vector and return the mean (the average
value), median (when sorted, the value in the middle position), and mode (the
value that occurs most often; a hash map will be helpful here) of the list.
* Convert strings to pig latin. The first consonant of each word is moved to
the end of the word and “ay” is added, so “first” becomes “irst-fay.” Words
that start with a vowel have “hay” added to the end instead (“apple” becomes
“apple-hay”). Keep in mind the details about UTF-8 encoding!
* Using a hash map and vectors, create a text interface to allow a user to add
employee names to a department in a company. For example, “Add Sally to
Engineering” or “Add Amir to Sales.” Then let the user retrieve a list of all
people in a department or all people in the company by department, sorted
alphabetically.
-->
<ul>
<li>整数のリストが与えられ、ベクタを使ってmean(平均値)、median(ソートされた時に真ん中に来る値)、
mode(最も頻繁に出現する値; ハッシュマップがここでは有効活用できるでしょう)を返してください。</li>
<li>文字列をピッグ・ラテン(<code>訳注</code>: 英語の言葉遊びの一つ)に変換してください。各単語の最初の子音は、
単語の終端に移り、&quot;ay&quot;が足されます。従って、&quot;first&quot;は&quot;irst-fay&quot;になります。ただし、
母音で始まる単語には、お尻に&quot;hay&quot;が付け足されます(&quot;apple&quot;は&quot;apple-hay&quot;になります)。
UTF-8エンコードに関する詳細を心に留めておいてください！</li>
<li>ハッシュマップとベクタを使用して、ユーザに会社の部署に雇用者の名前を追加させられるテキストインターフェイスを作ってください。
例えば、&quot;Add Sally to Engineering&quot;(開発部門にサリーを追加)や&quot;Add Amir to Sales&quot;(販売部門にアミールを追加)などです。
それからユーザに、ある部署にいる人間の一覧や部署ごとにアルファベット順で並べ替えられた会社の全人間の一覧を扱わせてあげてください。</li>
</ul>
<!--
The standard library API documentation describes methods that vectors, strings,
and hash maps have that will be helpful for these exercises!
-->
<p>標準ライブラリのAPIドキュメントには、この練習問題に有用な、ベクタ、文字列、ハッシュマップのメソッドが解説されています。</p>
<!--
We’re getting into more complex programs in which operations can fail; so, it’s
a perfect time to discuss error handling. We'll do that next!
-->
<p>処理が失敗することもあるような、より複雑なプログラムに入り込んできています; ということは、
エラーの処理法について議論するのにぴったりということです。次はそれをします！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Error Handling
-->
<h1 id="エラー処理"><a class="header" href="#エラー処理">エラー処理</a></h1>
<!--
Rust’s commitment to reliability extends to error handling. Errors are a fact
of life in software, so Rust has a number of features for handling situations
in which something goes wrong. In many cases, Rust requires you to acknowledge
the possibility of an error and take some action before your code will compile.
This requirement makes your program more robust by ensuring that you'll
discover errors and handle them appropriately before you’ve deployed your code
to production!
-->
<p>Rustの信頼性への傾倒は、エラー処理にも及びます。ソフトウェアにおいて、エラーは生きている証しです。
従って、Rustには何かがおかしくなる場面を扱う機能がたくさんあります。多くの場面で、
コンパイラは、プログラマにエラーの可能性を知り、コードのコンパイルが通るまでに何かしら対応を行うことを要求してきます。
この要求により、エラーを発見し、コードを実用に供する前に適切に対処していることを確認することでプログラムを頑健なものにしてくれるのです！</p>
<!--
Rust groups errors into two major categories: *recoverable* and *unrecoverable*
errors. For a recoverable errors, such as a file not found error, it’s
reasonable to report the problem to the user and retry the operation.
Unrecoverable errors are always symptoms of bugs, like trying to access a
location beyond the end of an array.
-->
<p>Rustでは、エラーは大きく二つに分類されます: <em>回復可能</em>と<em>回復不能</em>なエラーです。
ファイルが見つからないなどの回復可能なエラーには、問題をユーザに報告し、処理を再試行することが合理的になります。
回復不能なエラーは、常にバグの兆候です。例えば、配列の境界を超えた箇所にアクセスしようとすることなどです。</p>
<!--
Most languages don’t distinguish between these two kinds of errors and handle
both in the same way, using mechanisms like exceptions. Rust doesn’t have
exceptions. Instead, it has the value `Result<T, E>` for recoverable errors and
the `panic!` macro that stops execution when the program encounters an
unrecoverable error. This chapter covers calling `panic!` first and then talks
about returning `Result<T, E>` values. Additionally, we’ll explore
considerrations when deciding whether to try to recover from an error or to
stop execution.
-->
<p>多くの言語では、この2種のエラーを区別することはなく、例外などの機構を使用して同様に扱います。
Rustには例外が存在しません。代わりに、回復可能なエラーには<code>Result&lt;T, E&gt;</code>値があり、
プログラムが回復不能なエラーに遭遇した時には、実行を中止する<code>panic!</code>マクロがあります。
この章では、まず<code>panic!</code>の呼び出しを講義し、それから<code>Result&lt;T, E&gt;</code>を戻り値にする話をします。
加えて、エラーからの回復を試みるか、実行を中止するか決定する際に考慮すべき事項についても、探究しましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Unrecoverable Errors with `panic!`
-->
<h2 id="panicで回復不能なエラー"><a class="header" href="#panicで回復不能なエラー"><code>panic!</code>で回復不能なエラー</a></h2>
<!--
Sometimes, bad things happen in your code, and there’s nothing you can do about
it. In these cases, Rust has the `panic!` macro. When the `panic!` macro
executes, your program will print a failure message, unwind and clean up the
stack, and then quit. This most commonly occurs when a bug of some kind has
been detected, and it’s not clear to the programmer how to handle the error.
-->
<p>時として、コードで悪いことが起きるものです。そして、それに対してできることは何もありません。
このような場面で、Rustには<code>panic!</code>マクロが用意されています。<code>panic!</code>マクロが実行されると、
プログラムは失敗のメッセージを表示し、スタックを巻き戻し掃除して、終了します。これが最もありふれて起こるのは、
何らかのバグが検出された時であり、プログラマには、どうエラーを処理すればいいか明確ではありません。</p>
<!--
> ### Unwinding the Stack or Aborting in Response to a Panic
>
> By default, when a panic occurs, the program starts *unwinding*, which
> means Rust walks back up the stack and cleans up the data from each function
> it encounters. But this walking back and cleanup is a lot of work. The
> alternative is to immediately *abort*, which ends the program without
> cleaning up. Memory that the program was using will then need to be cleaned
> up by the operating system. If in your project you need to make the resulting
> binary as small as possible, you can switch from unwinding to aborting upon a
> panic by adding `panic = 'abort'` to the appropriate `[profile]` sections in
> your *Cargo.toml* file. For example, if you want to abort on panic in release
> mode, add this:
>
> ```toml
> [profile.release]
> panic = 'abort'
> ```
-->
<blockquote>
<h3 id="パニックに対してスタックを巻き戻すか異常終了するか"><a class="header" href="#パニックに対してスタックを巻き戻すか異常終了するか">パニックに対してスタックを巻き戻すか異常終了するか</a></h3>
<p>標準では、パニックが発生すると、プログラムは<em>巻き戻し</em>を始めます。つまり、言語がスタックを遡り、
遭遇した各関数のデータを片付けるということです。しかし、この遡りと片付けはすべきことが多くなります。
対立案は、即座に異常終了し、片付けをせずにプログラムを終了させることです。そうなると、プログラムが使用していたメモリは、
OSが片付ける必要があります。プロジェクトにおいて、実行可能ファイルを極力小さくする必要があれば、
<em>Cargo.toml</em>ファイルの適切な<code>[profile]</code>欄に<code>panic = 'abort'</code>を追記することで、
パニック時に巻き戻しから異常終了するように切り替えることができます。例として、
リリースモード時に異常終了するようにしたければ、以下を追記してください:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<!--
Let’s try calling `panic!` in a simple program:
-->
<p>単純なプログラムで<code>panic!</code>の呼び出しを試してみましょう:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">fn main() {
    panic!(&quot;crash and burn&quot;);  //クラッシュして炎上
}
</code></pre></pre>
<!--
When you run the program, you’ll see something like this:
-->
<p>このプログラムを実行すると、以下のような出力を目の当たりにするでしょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25 secs
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:4
('main'スレッドはsrc/main.rs:2:4の「クラッシュして炎上」でパニックしました)
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!--
The call to `panic!` causes the error message contained in the last two lines.
The first line shows our panic message and the place in our source code where
the panic occurred: *src/main.rs:2:4* indicates that it’s the second line,
fourth character of our *src/main.rs* file.
-->
<p><code>panic!</code>の呼び出しが、最後の2行に含まれるエラーメッセージを発生させているのです。
1行目にパニックメッセージとソースコード中でパニックが発生した箇所を示唆しています:
<em>src/main.rs:2:4</em>は、<em>src/main.rs</em>ファイルの2行目4文字目であることを示しています。</p>
<!--
In this case, the line indicated is part of our code, and if we go to that
line, we see the `panic!` macro call. In other cases, the `panic!` call might
be in code that our code calls, and the filename and line number reported by
the error message will be someone else’s code where the `panic!` macro is
called, not the line of our code that eventually led to the `panic!` call. We
can use the backtrace of the functions the `panic!` call came from to figure
out the part of our code that is causing the problem. We’ll discuss what a
backtrace is in more detail next.
-->
<p>この場合、示唆される行は、自分のコードの一部で、その箇所を見に行けば、<code>panic!</code>マクロ呼び出しがあるわけです。
それ以外では、<code>panic!</code>呼び出しが、自分のコードが呼び出しているコードの一部になっている可能性もあるわけです。
エラーメッセージで報告されるファイル名と行番号が、結果的に<code>panic!</code>呼び出しに導いた自分のコードの行ではなく、
<code>panic!</code>マクロが呼び出されている他人のコードになるでしょう。<code>panic!</code>呼び出しの発生元である関数のバックトレースを使用して、
問題を起こしている自分のコードの箇所を割り出すことができます。バックトレースがどんなものか、次に議論しましょう。</p>
<!--
### Using a `panic!` Backtrace
-->
<h3 id="panicバックトレースを使用する"><a class="header" href="#panicバックトレースを使用する"><code>panic!</code>バックトレースを使用する</a></h3>
<!--
Let’s look at another example to see what it’s like when a `panic!` call comes
from a library because of a bug in our code instead of from our code calling
the macro directly. Listing 9-1 has some code that attempts to access an
element by index in a vector.
-->
<p>別の例を眺めて、自分のコードでマクロを直接呼び出す代わりに、コードに存在するバグにより、
ライブラリで<code>panic!</code>呼び出しが発生するとどんな感じなのか確かめてみましょう。リスト9-1は、
添え字でベクタの要素にアクセスを試みる何らかのコードです。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<!--
<span class="caption">Listing 9-1: Attempting to access an element beyond the
end of a vector, which will cause a call to `panic!`</span>
-->
<p><span class="caption">リスト9-1: ベクタの境界を超えて要素へのアクセスを試み、<code>panic!</code>の呼び出しを発生させる</span></p>
<!--
Here, we’re attempting to access the 100th element of our vector (which is at
index 99 because indexing starts at zero), but it has only 3 elements. In this
situation, Rust will panic. Using `[]` is supposed to return an element, but if
you pass an invalid index, there’s no element that Rust could return here that
would be correct.
-->
<p>ここでは、ベクタの100番目の要素(添え字は0始まりなので添え字99)にアクセスを試みていますが、ベクタには3つしか要素がありません。
この場面では、Rustはパニックします。<code>[]</code>の使用は、要素を返すと想定されるものの、
無効な添え字を渡せば、ここでRustが返せて正しいと思われる要素は何もないわけです。</p>
<!--
Other languages, like C, will attempt to give you exactly what you asked for in
this situation, even though it isn’t what you want: you’ll get whatever is at
the location in memory that would correspond to that element in the vector,
even though the memory doesn’t belong to the vector. This is called a *buffer
overread* and can lead to security vulnerabilities if an attacker is able to
manipulate the index in such a way as to read data they shouldn’t be allowed to
that is stored after the array.
-->
<p>他の言語(Cなど)では、この場面で欲しいものではないにもかかわらず、まさしく要求したものを返そうとしてきます:
メモリがベクタに属していないにもかかわらず、ベクタ内のその要素に対応するメモリ上の箇所にあるものを何か返してくるのです。
これは、<em>バッファー外読み出し</em>(buffer overread; <code>訳注</code>: バッファー読みすぎとも解釈できるか)と呼ばれ、
攻撃者が、配列の後に格納された読めるべきでないデータを読み出せるように添え字を操作できたら、
セキュリティ脆弱性につながる可能性があります。</p>
<!--
To protect your program from this sort of vulnerability, if you try to read an
element at an index that doesn’t exist, Rust will stop execution and refuse to
continue. Let’s try it and see:
-->
<p>この種の脆弱性からプログラムを保護するために、存在しない添え字の要素を読もうとしたら、
Rustは実行を中止し、継続を拒みます。試して確認してみましょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is
99', /checkout/src/liballoc/vec.rs:1555:10
('main'スレッドは、/checkout/src/liballoc/vec.rs:1555:10の
「境界外番号: 長さは3なのに、添え字は99です」でパニックしました)
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!--
This error points at a file we didn’t write, *vec.rs*. That’s the
implementation of `Vec<T>` in the standard library. The code that gets run when
we use `[]` on our vector `v` is in *vec.rs*, and that is where the `panic!` is
actually happening.
-->
<p>このエラーは、自分のファイルではない<em>vec.rs</em>ファイルを指しています。
標準ライブラリの<code>Vec&lt;T&gt;</code>の実装です。ベクタ<code>v</code>に対して<code>[]</code>を使った時に走るコードは、
<em>vec.rs</em>に存在し、ここで実際に<code>panic!</code>が発生しているのです。</p>
<!--
The next note line tells us that we can set the `RUST_BACKTRACE` environment
variable to get a backtrace of exactly what happened to cause the error. A
*backtrace* is a list of all the functions that have been called to get to this
point. Backtraces in Rust work like they do in other languages: the key to
reading the backtrace is to start from the top and read until you see files you
wrote. That’s the spot where the problem originated. The lines above the lines
mentioning your files are code that your code called; the lines below are code
that called your code. These lines might include core Rust code, standard
library code, or crates that you’re using. Let’s try getting a backtrace by
setting the `RUST_BACKTRACE` environment variable to any value except 0.
Listing 9-2 shows output similar to what you’ll see.
-->
<p>その次の注釈行は、<code>RUST_BACKTRACE</code>環境変数をセットして、まさしく何が起き、
エラーが発生したのかのバックトレースを得られることを教えてくれています。
<em>バックトレース</em>とは、ここに至るまでに呼び出された全関数の一覧です。Rustのバックトレースも、
他の言語同様に動作します: バックトレースを読むコツは、頭からスタートして自分のファイルを見つけるまで読むことです。
そこが、問題の根源になるのです。自分のファイルを言及している箇所以前は、自分のコードで呼び出したコードになります;
以後は、自分のコードを呼び出しているコードになります。これらの行には、Rustの核となるコード、標準ライブラリのコード、
使用しているクレートなどが含まれるかもしれません。<code>RUST_BACKTRACE</code>環境変数を0以外の値にセットして、
バックトレースを出力してみましょう。リスト9-2のような出力が得られるでしょう。</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /checkout/src/liballoc/vec.rs:1555:10
stack backtrace:
   0: std::sys::imp::backtrace::tracing::imp::unwind_backtrace
             at /checkout/src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:49
   1: std::sys_common::backtrace::_print
             at /checkout/src/libstd/sys_common/backtrace.rs:71
   2: std::panicking::default_hook::{{closure}}
             at /checkout/src/libstd/sys_common/backtrace.rs:60
             at /checkout/src/libstd/panicking.rs:381
   3: std::panicking::default_hook
             at /checkout/src/libstd/panicking.rs:397
   4: std::panicking::rust_panic_with_hook
             at /checkout/src/libstd/panicking.rs:611
   5: std::panicking::begin_panic
             at /checkout/src/libstd/panicking.rs:572
   6: std::panicking::begin_panic_fmt
             at /checkout/src/libstd/panicking.rs:522
   7: rust_begin_unwind
             at /checkout/src/libstd/panicking.rs:498
   8: core::panicking::panic_fmt
             at /checkout/src/libcore/panicking.rs:71
   9: core::panicking::panic_bounds_check
             at /checkout/src/libcore/panicking.rs:58
  10: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;usize&gt;&gt;::index
             at /checkout/src/liballoc/vec.rs:1555
  11: panic::main
             at src/main.rs:4
  12: __rust_maybe_catch_panic
             at /checkout/src/libpanic_unwind/lib.rs:99
  13: std::rt::lang_start
             at /checkout/src/libstd/panicking.rs:459
             at /checkout/src/libstd/panic.rs:361
             at /checkout/src/libstd/rt.rs:61
  14: main
  15: __libc_start_main
  16: &lt;unknown&gt;
</code></pre>
<!--
<span class="caption">Listing 9-2: The backtrace generated by a call to
`panic!` displayed when the environment variable `RUST_BACKTRACE` is set</span>
-->
<p><span class="caption">リスト9-2: <code>RUST_BACKTRACE</code>環境変数をセットした時に表示される、
<code>panic!</code>呼び出しが生成するバックトレース</span></p>
<!--
That’s a lot of output! The exact output you see might be different depending
on your operating system and Rust version. In order to get backtraces with this
information, debug symbols must be enabled. Debug symbols are enabled by
default when using `cargo build` or `cargo run` without the `--release` flag,
as we have here.
-->
<p>出力が多いですね！OSやRustのバージョンによって、出力の詳細は変わる可能性があります。この情報とともに、
バックトレースを得るには、デバッグシンボルを有効にしなければなりません。デバッグシンボルは、
<code>--release</code>オプションなしで<code>cargo build</code>や<code>cargo run</code>を使用していれば、標準で有効になり、
ここではそうなっています。</p>
<!--
In the output in Listing 9-2, line 11 of the backtrace points to the line in
our project that’s causing the problem: line 4 of *src/main.rs*. If we don’t
want our program to panic, the location pointed to by the first line mentioning
a file we wrote is where we should start investigating to figure out how we got
to this location with values that caused the panic. In Listing 9-1, where
we deliberately wrote code that would panic in order to demonstrate how to use
backtraces, the way to fix the panic is to not request an element at index 99
from a vector that only contains 3 items. When your code panics in the future,
you’ll need to figure out what action the code is taking with what values to
cause the panic and what the code should do instead.
-->
<p>リスト9-2の出力で、バックトレースの11行目が問題発生箇所を指し示しています: <em>src/main.rs</em>の4行目です。
プログラムにパニックしてほしくなければ、自分のファイルについて言及している最初の行で示されている箇所が、
どのようにパニックを引き起こす値でこの箇所にたどり着いたか割り出すために調査を開始すべき箇所になります。
バックトレースの使用法を模擬するためにわざとパニックするコードを書いたリスト9-1において、
パニックを解消する方法は、3つしか要素のないベクタの添え字99の要素を要求しないことです。
将来コードがパニックしたら、パニックを引き起こすどんな値でコードがどんな動作をしているのかと、
代わりにコードは何をすべきなのかを算出する必要があるでしょう。</p>
<!--
We’ll come back to `panic!` and when we should and should not use `panic!` to
handle error conditions in “To `panic!` or Not to `panic!`” section later
in this chapter. Next, we’ll look at how to recover from an error using
`Result`.
-->
<p>この章の後ほど、「<code>panic!</code>するか<code>panic!</code>するまいか」節で<code>panic!</code>とエラー状態を扱うのに<code>panic!</code>を使うべき時と使わぬべき時に戻ってきます。
次は、<code>Result</code>を使用してエラーから回復する方法を見ましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Recoverable Errors with `Result`
-->
<h2 id="resultで回復可能なエラー"><a class="header" href="#resultで回復可能なエラー"><code>Result</code>で回復可能なエラー</a></h2>
<!--
Most errors aren’t serious enough to require the program to stop entirely.
Sometimes, when a function fails, it’s for a reason that we can easily
interpret and respond to. For example, if you try to open a file and that
operation fails because the file doesn’t exist, we might want to create the
file instead of terminating the process.
-->
<p>多くのエラーは、プログラムを完全にストップさせるほど深刻ではありません。時々、関数が失敗した時に、
容易に解釈し、対応できる理由によることがあります。例えば、ファイルを開こうとして、
ファイルが存在しないために処理が失敗したら、プロセスを停止するのではなく、ファイルを作成したいことがあります。</p>
<!--
Recall from “[Handling Potential Failure with the `Result`
Type][handle_failure]” in Chapter 2 that the `Result` enum is
defined as having two variants, `Ok` and `Err`, as follows:
-->
<p>第2章の<a href="ch02-00-guessing-game-tutorial.html#result%E5%9E%8B%E3%81%A7%E5%A4%B1%E6%95%97%E3%81%AE%E5%8F%AF%E8%83%BD%E6%80%A7%E3%82%92%E6%89%B1%E3%81%86">「<code>Result</code>型で失敗する可能性に対処する」</a>で<code>Result</code> enumが以下のように、
<code>Ok</code>と<code>Err</code>の2列挙子からなるよう定義されていることを思い出してください:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `T` and `E` are generic type parameters: we’ll discuss generics in more
detail in Chapter 10. What you need to know right now is that `T` represents
the type of the value that will be returned in a success case within the `Ok`
variant, and `E` represents the type of the error that will be returned in a
failure case within the `Err` variant. Because `Result` has these generic type
parameters, we can use the `Result` type and the functions that the standard
library has defined on it in many different situations where the successful
value and error value we want to return may differ.
-->
<p><code>T</code>と<code>E</code>は、ジェネリックな型引数です: ジェネリクスについて詳しくは、第10章で議論します。
たった今知っておく必要があることは、<code>T</code>が成功した時に<code>Ok</code>列挙子に含まれて返される値の型を表すことと、
<code>E</code>が失敗した時に<code>Err</code>列挙子に含まれて返されるエラーの型を表すことです。<code>Result</code>はこのようなジェネリックな型引数を含むので、
標準ライブラリ上に定義されている<code>Result</code>型や関数などを、成功した時とエラーの時に返したい値が異なるような様々な場面で使用できるのです。</p>
<!--
Let’s call a function that returns a `Result` value because the function could
fail. In Listing 9-3 we try to open a file.
-->
<p>関数が失敗する可能性があるために<code>Result</code>値を返す関数を呼び出しましょう: リスト9-3では、
ファイルを開こうとしています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 9-3: Opening a file</span>
-->
<p><span class="caption">リスト9-3: ファイルを開く</span></p>
<!--
How do we know `File::open` returns a `Result`? We could look at the standard
library API documentation, or we could ask the compiler! If we give `f` a type
annotation that we know is *not* the return type of the function and then try
to compile the code, the compiler will tell us that the types don’t match. The
error message will then tell us what the type of `f` *is*. Let’s try it! We
know that the return type of `File::open` isn’t of type `u32`, so let’s change
the `let f` statement to this:
-->
<p><code>File::open</code>が<code>Result</code>を返すとどう知るのでしょうか？標準ライブラリのAPIドキュメントを参照することもできますし、
コンパイラに尋ねることもできます！<code>f</code>に関数の戻り値では<em>ない</em>と判明している型注釈を与えて、
コードのコンパイルを試みれば、コンパイラは型が合わないと教えてくれるでしょう。そして、エラーメッセージは、
<code>f</code>の<em>実際の</em>型を教えてくれるでしょう。試してみましょう！<code>File::open</code>の戻り値の型は<code>u32</code>ではないと判明しているので、
<code>let f</code>文を以下のように変更しましょう:</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);
</code></pre>
<!--
Attempting to compile now gives us the following output:
-->
<p>これでコンパイルしようとすると、以下のような出力が得られます:</p>
<pre><code class="language-text">error[E0308]: mismatched types
(エラー: 型が合いません)
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
  (注釈: 予期した型は`u32`です)
             found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
  (実際の型は`std::result::Result&lt;std::fs::File, std::io::Error&gt;`です)
</code></pre>
<!--
This tells us the return type of the `File::open` function is a `Result<T, E>`.
The generic parameter `T` has been filled in here with the type of the success
value, `std::fs::File`, which is a file handle. The type of `E` used in the
error value is `std::io::Error`.
-->
<p>これにより、<code>File::open</code>関数の戻り値の型は、<code>Result&lt;T, E&gt;</code>であることがわかります。ジェネリック引数の<code>T</code>は、
ここでは成功値の型<code>std::fs::File</code>で埋められていて、これはファイルハンドルです。
エラー値で使用されている<code>E</code>の型は、<code>std::io::Error</code>です。</p>
<!--
This return type means the call to `File::open` might succeed and return a file
handle that we can read from or write to. The function call also might fail:
for example, the file might not exist, or we might not have permission to
access the file. The `File::open` function needs to have a way to tell us
whether it succeeded or failed and at the same time give us either the file
handle or error information. This information is exactly what the `Result` enum
conveys.
-->
<p>この戻り値型は、<code>File::open</code>の呼び出しが成功し、読み込みと書き込みを行えるファイルハンドルを返す可能性があることを意味します。
また、関数呼び出しは失敗もする可能性があります: 例えば、ファイルが存在しない可能性、ファイルへのアクセス権限がない可能性です。
<code>File::open</code>には成功したか失敗したかを知らせる方法とファイルハンドルまたは、エラー情報を与える方法が必要なのです。
この情報こそが<code>Result</code> enumが伝達するものなのです。</p>
<!--
In the case where `File::open` succeeds, the value in the variable `f` will be
an instance of `Ok` that contains a file handle. In the case where it fails,
the value in `f` will be an instance of `Err` that contains more information
about the kind of error that happened.
-->
<p><code>File::open</code>が成功した場合、変数<code>f</code>の値はファイルハンドルを含む<code>Ok</code>インスタンスになります。
失敗した場合には、発生したエラーの種類に関する情報をより多く含む<code>Err</code>インスタンスが<code>f</code>の値になります。</p>
<!--
We need to add to the code in Listing 9-3 to take different actions depending
on the value `File::open` returns. Listing 9-4 shows one way to handle the
`Result` using a basic tool, the `match` expression that we discussed in
Chapter 6.
-->
<p>リスト9-3のコードに追記をして<code>File::open</code>が返す値に応じて異なる動作をする必要があります。
リスト9-4に基礎的な道具を使って<code>Result</code>を扱う方法を一つ示しています。第6章で議論した<code>match</code>式です。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            // ファイルを開く際に問題がありました
            panic!(&quot;There was a problem opening the file: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<!--
<span class="caption">Listing 9-4: Using a `match` expression to handle the
`Result` variants that might be returned</span>
-->
<p><span class="caption">リスト9-4: <code>match</code>式を使用して返却される可能性のある<code>Result</code>列挙子を処理する</span></p>
<!--
Note that, like the `Option` enum, the `Result` enum and its variants have been
imported in the prelude, so we don’t need to specify `Result::` before the `Ok`
and `Err` variants in the `match` arms.
-->
<p><code>Option</code> enumのように、<code>Result</code> enumとその列挙子は、初期化処理でインポートされているので、
<code>match</code>アーム内で<code>Ok</code>と<code>Err</code>列挙子の前に<code>Result::</code>を指定する必要がないことに注目してください。</p>
<!--
Here we tell Rust that when the result is `Ok`, return the inner `file` value
out of the `Ok` variant, and we then assign that file handle value to the
variable `f`. After the `match`, we can use the file handle for reading or
writing.
-->
<p>ここでは、結果が<code>Ok</code>の時に、<code>Ok</code>列挙子から中身の<code>file</code>値を返すように指示し、
それからそのファイルハンドル値を変数<code>f</code>に代入しています。<code>match</code>の後には、
ファイルハンドルを使用して読み込んだり書き込むことができるわけです。</p>
<!--
The other arm of the `match` handles the case where we get an `Err` value from
`File::open`. In this example, we’ve chosen to call the `panic!` macro. If
there’s no file named *hello.txt* in our current directory and we run this
code, we’ll see the following output from the `panic!` macro:
-->
<p><code>match</code>のもう一つのアームは、<code>File::open</code>から<code>Err</code>値が得られたケースを処理しています。
この例では、<code>panic!</code>マクロを呼び出すことを選択しています。カレントディレクトリに<em>hello.txt</em>というファイルがなく、
このコードを走らせたら、<code>panic!</code>マクロからの以下のような出力を目の当たりにするでしょう:</p>
<pre><code class="language-text">thread 'main' panicked at 'There was a problem opening the file: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:9:12
('main'スレッドは、src/main.rs:9:12の「ファイルを開く際に問題がありました: Error{ repr:
Os { code: 2, message: &quot;そのような名前のファイルまたはディレクトリはありません&quot;}}」でパニックしました)
</code></pre>
<!--
As usual, this output tells us exactly what has gone wrong.
-->
<p>通常通り、この出力は、一体何がおかしくなったのかを物語っています。</p>
<!--
### Matching on Different Errors
-->
<h3 id="色々なエラーにマッチする"><a class="header" href="#色々なエラーにマッチする">色々なエラーにマッチする</a></h3>
<!--
The code in Listing 9-4 will `panic!` no matter why `File::open` failed. What
we want to do instead is take different actions for different failure reasons:
if `File::open` failed because the file doesn’t exist, we want to create the
file and return the handle to the new file. If `File::open` failed for any
other reason-for example, because we didn’t have permission to open the file-we
still want the code to `panic!` in the same way as it did in Listing 9-4. Look
at Listing 9-5, which adds another arm to the `match`.
-->
<p>リスト9-4のコードは、<code>File::open</code>が失敗した理由にかかわらず<code>panic!</code>します。代わりにしたいことは、
失敗理由によって動作を変えることです: ファイルが存在しないために<code>File::open</code>が失敗したら、
ファイルを作成し、その新しいファイルへのハンドルを返したいです。他の理由(例えばファイルを開く権限がなかったなど)で、
<code>File::open</code>が失敗したら、リスト9-4のようにコードには<code>panic!</code>してほしいのです。
リスト9-5を眺めてください。ここでは<code>match</code>に別のアームを追加しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(ref error) if error.kind() == ErrorKind::NotFound =&gt; {
            match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; {
                    panic!(
                        //ファイルを作成しようとしましたが、問題がありました
                        &quot;Tried to create file but there was a problem: {:?}&quot;,
                        e
                    )
                },
            }
        },
        Err(error) =&gt; {
            panic!(
                &quot;There was a problem opening the file: {:?}&quot;,
                error
            )
        },
    };
}
</code></pre>
<!--
<span class="caption">Listing 9-5: Handling different kinds of errors in
different ways</span>
-->
<p><span class="caption">リスト9-5: 色々な種類のエラーを異なる方法で扱う</span></p>
<!--
The type of the value that `File::open` returns inside the `Err` variant is
`io::Error`, which is a struct provided by the standard library. This struct
has a method `kind` that we can call to get an `io::ErrorKind` value. The enum
`io::ErrorKind` is provided by the standard library and has variants
representing the different kinds of errors that might result from an `io`
operation. The variant we want to use is `ErrorKind::NotFound`, which indicates
the file we’re trying to open doesn’t exist yet.
-->
<p><code>File::open</code>が<code>Err</code>列挙子に含めて返す値の型は、<code>io::Error</code>であり、これは標準ライブラリで提供されている構造体です。
この構造体には、呼び出すと<code>io::ErrorKind</code>値が得られる<code>kind</code>メソッドがあります。<code>io::ErrorKind</code>というenumは、
標準ライブラリで提供されていて、<code>io</code>処理の結果発生する可能性のある色々な種類のエラーを表す列挙子があります。
使用したい列挙子は、<code>ErrorKind::NotFound</code>で、これは開こうとしているファイルがまだ存在しないことを示唆します。</p>
<!--
The condition `if error.kind() == ErrorKind::NotFound` is called a *match
guard*: it’s an extra condition on a `match` arm that further refines the arm’s
pattern. This condition must be true for that arm’s code to be run; otherwise,
the pattern matching will move on to consider the next arm in the `match`. The
`ref` in the pattern is needed so `error` is not moved into the guard condition
but is merely referenced by it. The reason you use `ref` to create a reference
in a pattern instead of `&` will be covered in detail in Chapter 18. In short,
in the context of a pattern, `&` matches a reference and gives you its value,
but `ref` matches a value and gives you a reference to it.
-->
<p><code>if error.kind() == ErrorKind::Notfound</code>という条件式は、<em>マッチガード</em>と呼ばれます:
アームのパターンをさらに洗練する<code>match</code>アーム上のおまけの条件式です。この条件式は、
そのアームのコードが実行されるには真でなければいけないのです; そうでなければ、
パターンマッチングは継続し、<code>match</code>の次のアームを考慮します。パターンの<code>ref</code>は、
<code>error</code>がガード条件式にムーブされないように必要ですが、ただ単にガード式に参照されます。
<code>ref</code>を使用して<code>&amp;</code>の代わりにパターン内で参照を作っている理由は、第18章で詳しく講義します。
手短に言えば、パターンの文脈において、<code>&amp;</code>は参照にマッチし、その値を返しますが、
<code>ref</code>は値にマッチし、それへの参照を返すということなのです。</p>
<!--
The condition we want to check in the match guard is whether the value returned
by `error.kind()` is the `NotFound` variant of the `ErrorKind` enum. If it is,
we try to create the file with `File::create`. However, because `File::create`
could also fail, we need to add an inner `match` expression as well. When the
file can’t be opened, a different error message will be printed. The last arm
of the outer `match` stays the same so the program panics on any error besides
the missing file error.
-->
<p>マッチガードで精査したい条件は、<code>error.kind()</code>により返る値が、<code>ErrorKind</code> enumの<code>NotFound</code>列挙子であるかということです。
もしそうなら、<code>File::create</code>でファイル作成を試みます。ところが、<code>File::create</code>も失敗する可能性があるので、
内部にも<code>match</code>式を追加する必要があるのです。ファイルが開けないなら、異なるエラーメッセージが出力されるでしょう。
外側の<code>match</code>の最後のアームは同じままなので、ファイルが存在しないエラー以外ならプログラムはパニックします。</p>
<!--
### Shortcuts for Panic on Error: `unwrap` and `expect`
-->
<h3 id="エラー時にパニックするショートカット-unwrapとexpect"><a class="header" href="#エラー時にパニックするショートカット-unwrapとexpect">エラー時にパニックするショートカット: <code>unwrap</code>と<code>expect</code></a></h3>
<!--
Using `match` works well enough, but it can be a bit verbose and doesn’t always
communicate intent well. The `Result<T, E>` type has many helper methods
defined on it to do various tasks. One of those methods, called `unwrap`, is a
shortcut method that is implemented just like the `match` expression we wrote
in Listing 9-4. If the `Result` value is the `Ok` variant, `unwrap` will return
the value inside the `Ok`. If the `Result` is the `Err` variant, `unwrap` will
call the `panic!` macro for us. Here is an example of `unwrap` in action:
-->
<p><code>match</code>の使用は、十分に仕事をしてくれますが、いささか冗長になり得る上、必ずしも意図をよく伝えるとは限りません。
<code>Result&lt;T, E&gt;</code>型には、色々な作業をするヘルパーメソッドが多く定義されています。それらの関数の一つは、
<code>unwrap</code>と呼ばれますが、リスト9-4で書いた<code>match</code>式と同じように実装された短絡メソッドです。
<code>Result</code>値が<code>Ok</code>列挙子なら、<code>unwrap</code>は<code>Ok</code>の中身を返します。<code>Result</code>が<code>Err</code>列挙子なら、
<code>unwrap</code>は<code>panic!</code>マクロを呼んでくれます。こちらが実際に動作している<code>unwrap</code>の例です:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<!--
If we run this code without a *hello.txt* file, we’ll see an error message from
the `panic!` call that the `unwrap` method makes:
-->
<p>このコードを<em>hello.txt</em>ファイルなしで走らせたら、<code>unwrap</code>メソッドが行う<code>panic!</code>呼び出しからのエラーメッセージを目の当たりにするでしょう:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
('main'スレッドは、src/libcore/result.rs:906:4の
「`Err`値に対して`Result::unwrap()`が呼び出されました: Error{
repr: Os { code: 2, message: &quot;そのようなファイルまたはディレクトリはありません&quot; } }」でパニックしました)
</code></pre>
<!--
Another method, `expect`, which is similar to `unwrap`, lets us also choose the
`panic!` error message. Using `expect` instead of `unwrap` and providing good
error messages can convey your intent and make tracking down the source of a
panic easier. The syntax of `expect` looks like this:
-->
<p>別のメソッド<code>expect</code>は、<code>unwrap</code>に似ていますが、<code>panic!</code>のエラーメッセージも選択させてくれます。
<code>unwrap</code>の代わりに<code>expect</code>を使用して、いいエラーメッセージを提供すると、意図を伝え、
パニックの原因をたどりやすくしてくれます。<code>expect</code>の表記はこんな感じです:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    // hello.txtを開くのに失敗しました
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}
</code></pre></pre>
<!--
We use `expect` in the same way as `unwrap`: to return the file handle or call
the `panic!` macro. The error message used by `expect` in its call to `panic!`
will be the parameter that we pass to `expect`, rather than the default
`panic!` message that `unwrap` uses. Here’s what it looks like:
-->
<p><code>expect</code>を<code>unwrap</code>と同じように使用してます: ファイルハンドルを返したり、<code>panic!</code>マクロを呼び出しています。
<code>expect</code>が<code>panic!</code>呼び出しで使用するエラーメッセージは、<code>unwrap</code>が使用するデフォルトの<code>panic!</code>メッセージではなく、
<code>expect</code>に渡した引数になります。以下のようになります:</p>
<pre><code class="language-text">thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }', src/libcore/result.rs:906:4
</code></pre>
<!--
Because this error message starts with the text we specified, `Failed to open
hello.txt`, it will be easier to find where in the code this error message is
coming from. If we use `unwrap` in multiple places, it can take more time to
figure out exactly which `unwrap` is causing the panic because all `unwrap`
calls that panic print the same message.
-->
<p>このエラーメッセージは、指定したテキストの<code>hello.txtを開くのに失敗しました</code>で始まっているので、
コード内のどこでエラーメッセージが出力されたのかより見つけやすくなるでしょう。複数箇所で<code>unwrap</code>を使用していたら、
ズバリどの<code>unwrap</code>がパニックを引き起こしているのか理解するのは、より時間がかかる可能性があります。
パニックする<code>unwrap</code>呼び出しは全て、同じメッセージを出力するからです。</p>
<!--
### Propagating Errors
-->
<h3 id="エラーを委譲する"><a class="header" href="#エラーを委譲する">エラーを委譲する</a></h3>
<!--
When you’re writing a function whose implementation calls something that might
fail, instead of handling the error within this function, you can return the
error to the calling code so that it can decide what to do. This is known as
*propagating* the error and gives more control to the calling code, where there
might be more information or logic that dictates how the error should be
handled than what you have available in the context of your code.
-->
<p>失敗する可能性のある何かを呼び出す実装をした関数を書く際、関数内でエラーを処理する代わりに、
呼び出し元がどうするかを決められるようにエラーを返すことができます。これはエラーの<em>委譲</em>として認知され、
自分のコードの文脈で利用可能なものよりも、
エラーの処理法を規定する情報やロジックがより多くある呼び出し元のコードに制御を明け渡します。</p>
<!--
For example, Listing 9-6 shows a function that reads a username from a file. If
the file doesn’t exist or can’t be read, this function will return those errors
to the code that called this function.
-->
<p>例えば、リスト9-6の関数は、ファイルからユーザ名を読み取ります。ファイルが存在しなかったり、読み込みできなければ、
この関数はそのようなエラーを呼び出し元のコードに返します。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-6: A function that returns errors to the
calling code using `match`</span>
-->
<p><span class="caption">リスト9-6: <code>match</code>でエラーを呼び出し元のコードに返す関数</span></p>
<!--
Look at the return type of the function first: `Result<String, io::Error>`.
This means the function is returning a value of the type `Result<T, E>` where
the generic parameter `T` has been filled in with the concrete type `String`
and the generic type `E` has been filled in with the concrete type `io::Error`.
If this function succeeds without any problems, the code that calls this
function will receive an `Ok` value that holds a `String`—the username that
this function read from the file. If this function encounters any problems, the
code that calls this function will receive an `Err` value that holds an
instance of `io::Error` that contains more information about what the problems
were. We chose `io::Error` as the return type of this function because that
happens to be the type of the error value returned from both of the operations
we’re calling in this function’s body that might fail: the `File::open`
function and the `read_to_string` method.
-->
<p>まずは、関数の戻り値型に注目してください: <code>Result&lt;String, io::Error&gt;</code>です。つまり、この関数は、
<code>Result&lt;T, E&gt;</code>型の値を返しているということです。ここでジェネリック引数の<code>T</code>は、具体型<code>String</code>で埋められ、
ジェネリック引数の<code>E</code>は具体型<code>io::Error</code>で埋められています。この関数が何の問題もなく成功すれば、
この関数を呼び出したコードは、<code>String</code>(関数がファイルから読み取ったユーザ名)を保持する<code>Ok</code>値を受け取ります。
この関数が何か問題に行き当たったら、呼び出し元のコードは<code>io::Error</code>のインスタンスを保持する<code>Err</code>値を受け取り、
この<code>io::Error</code>は問題の内容に関する情報をより多く含んでいます。関数の戻り値の型に<code>io::Error</code>を選んだのは、
この関数本体で呼び出している失敗する可能性のある処理が両方とも偶然この型をエラー値として返すからです:
<code>File::open</code>関数と<code>read_to_string</code>メソッドです。</p>
<!--
The body of the function starts by calling the `File::open` function. Then we
handle the `Result` value returned with a `match` similar to the `match` in
Listing 9-4, only instead of calling `panic!` in the `Err` case, we return
early from this function and pass the error value from `File::open` back to the
calling code as this function’s error value. If `File::open` succeeds, we store
the file handle in the variable `f` and continue.
-->
<p>関数の本体は、<code>File::open</code>関数を呼び出すところから始まります。そして、リスト9-4の<code>match</code>に似た<code>match</code>で返ってくる<code>Result</code>値を扱い、
<code>Err</code>ケースに<code>panic!</code>を呼び出すだけの代わりに、この関数から早期リターンしてこの関数のエラー値として、
<code>File::open</code>から得たエラー値を呼び出し元に渡し戻します。<code>File::open</code>が成功すれば、
ファイルハンドルを変数<code>f</code>に保管して継続します。</p>
<!--
Then we create a new `String` in variable `s` and call the `read_to_string`
method on the file handle in `f` to read the contents of the file into `s`. The
`read_to_string` method also returns a `Result` because it might fail, even
though `File::open` succeeded. So we need another `match` to handle that
`Result`: if `read_to_string` succeeds, then our function has succeeded, and we
return the username from the file that’s now in `s` wrapped in an `Ok`. If
`read_to_string` fails, we return the error value in the same way that we
returned the error value in the `match` that handled the return value of
`File::open`. However, we don’t need to explicitly say `return`, because this
is the last expression in the function.
-->
<p>さらに、変数<code>s</code>に新規<code>String</code>を生成し、<code>f</code>のファイルハンドルに対して<code>read_to_string</code>を呼び出して、
ファイルの中身を<code>s</code>に読み出します。<code>File::open</code>が成功しても、失敗する可能性があるので、<code>read_to_string</code>メソッドも、
<code>Result</code>を返却します。その<code>Result</code>を処理するために別の<code>match</code>が必要になります: <code>read_to_string</code>が成功したら、
関数は成功し、今は<code>Ok</code>に包まれた<code>s</code>に入っているファイルのユーザ名を返却します。<code>read_to_string</code>が失敗したら、
<code>File::open</code>の戻り値を扱った<code>match</code>でエラー値を返したように、エラー値を返します。
しかし、明示的に<code>return</code>を述べる必要はありません。これが関数の最後の式だからです。</p>
<!--
The code that calls this code will then handle getting either an `Ok` value
that contains a username or an `Err` value that contains an `io::Error`. We
don’t know what the calling code will do with those values. If the calling code
gets an `Err` value, it could call `panic!` and crash the program, use a
default username, or look up the username from somewhere other than a file, for
example. We don’t have enough information on what the calling code is actually
trying to do, so we propagate all the success or error information upwards for
it to handle appropriately.
-->
<p>そうしたら、呼び出し元のコードは、ユーザ名を含む<code>Ok</code>値か、<code>io::Error</code>を含む<code>Err</code>値を得て扱います。
呼び出し元のコードがそれらの値をどうするかはわかりません。呼び出しコードが<code>Err</code>値を得たら、
例えば、<code>panic!</code>を呼び出してプログラムをクラッシュさせたり、デフォルトのユーザ名を使ったり、
ファイル以外の場所からユーザ名を検索したりできるでしょう。呼び出し元のコードが実際に何をしようとするかについて、
十分な情報がないので、成功や失敗情報を全て委譲して適切に扱えるようにするのです。</p>
<!--
This pattern of propagating errors is so common in Rust that Rust provides the
question mark operator `?` to make this easier.
-->
<p>Rustにおいて、この種のエラー委譲は非常に一般的なので、Rustにはこれをしやすくする<code>?</code>演算子が用意されています。</p>
<!--
#### A Shortcut for Propagating Errors: the `?` operator
-->
<h4 id="エラー委譲のショートカット-演算子"><a class="header" href="#エラー委譲のショートカット-演算子">エラー委譲のショートカット: <code>?</code>演算子</a></h4>
<!--
Listing 9-7 shows an implementation of `read_username_from_file` that has the
same functionality as it had in Listing 9-6, but this implementation uses the
`?` operator:
-->
<p>リスト9-7もリスト9-6と同じ機能を有する<code>read_username_from_file</code>の実装ですが、
こちらは<code>?</code>演算子を使用しています:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-7: A function that returns errors to the
calling code using the `?` operator</span>
-->
<p><span class="caption">リスト9-7: <code>?</code>演算子でエラーを呼び出し元に返す関数</span></p>
<!--
The `?` placed after a `Result` value is defined to work in almost the same way
as the `match` expressions we defined to handle the `Result` values in Listing
9-6. If the value of the `Result` is an `Ok`, the value inside the `Ok` will
get returned from this expression, and the program will continue. If the value
is an `Err`, the value inside the `Err` will be returned from the whole
function as if we had used the `return` keyword so the error value gets
propagated to the calling code.
-->
<p><code>Result</code>値の直後に置かれた<code>?</code>は、リスト9-6で<code>Result</code>値を処理するために定義した<code>match</code>式とほぼ同じように動作します。
<code>Result</code>の値が<code>Ok</code>なら、<code>Ok</code>の中身がこの式から返ってきて、プログラムは継続します。値が<code>Err</code>なら、
<code>return</code>キーワードを使ったかのように関数全体から<code>Err</code>の中身が返ってくるので、
エラー値は呼び出し元のコードに委譲されます。</p>
<!--
There is a difference between what the `match` expression from Listing 9-6 and
the `?` operator do: error values used with `?` go through the `from` function,
defined in the `From` trait in the standard library, which is used to convert
errors from one type into another. When the `?` operator calls the `from`
function, the error type received is converted into the error type defined in
the return type of the current function. This is useful when a function returns
one error type to represent all the ways a function might fail, even if parts
might fail for many different reasons. As long as each error type implements
the `from` function to define how to convert itself to the returned error type,
the `?` operator takes care of the conversion automatically.
-->
<p>リスト9-6の<code>match</code>式と<code>?</code>演算子には違いがあります: <code>?</code>を使ったエラー値は、
標準ライブラリの<code>From</code>トレイトで定義され、エラーの型を別のものに変換する<code>from</code>関数を通ることです。
<code>?</code>演算子が<code>from</code>関数を呼び出すと、受け取ったエラー型が現在の関数の戻り値型で定義されているエラー型に変換されます。これは、
個々がいろんな理由で失敗する可能性があるのにも関わらず、関数が失敗する可能性を全て一つのエラー型で表現して返す時に有用です。
各エラー型が<code>from</code>関数を実装して返り値のエラー型への変換を定義している限り、
<code>?</code>演算子が変換の面倒を自動的に見てくれます。</p>
<!--
In the context of Listing 9-7, the `?` at the end of the `File::open` call will
return the value inside an `Ok` to the variable `f`. If an error occurs, the
`?` operator will return early out of the whole function and give any `Err`
value to the calling code. The same thing applies to the `?` at the end of the
`read_to_string` call.
-->
<p>リスト9-7の文脈では、<code>File::open</code>呼び出し末尾の<code>?</code>は<code>Ok</code>の中身を変数<code>f</code>に返します。
エラーが発生したら、<code>?</code>演算子により関数全体から早期リターンし、あらゆる<code>Err</code>値を呼び出し元に与えます。
同じ法則が<code>read_to_string</code>呼び出し末尾の<code>?</code>にも適用されます。</p>
<!--
The `?` operator eliminates a lot of boilerplate and makes this function’s
implementation simpler. We could even shorten this code further by chaining
method calls immediately after the `?`, as shown in Listing 9-8.
-->
<p><code>?</code>演算子により定型コードの多くが排除され、この関数の実装を単純にしてくれます。
リスト9-8で示したように、<code>?</code>の直後のメソッド呼び出しを連結することでさらにこのコードを短くすることさえもできます。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-8: Chaining method calls after the `?`
operator</span>
-->
<p><span class="caption">リスト9-8: <code>?</code>演算子の後のメソッド呼び出しを連結する</span></p>
<!--
We’ve moved the creation of the new `String` in `s` to the beginning of the
function; that part hasn’t changed. Instead of creating a variable `f`, we’ve
chained the call to `read_to_string` directly onto the result of
`File::open("hello.txt")?`. We still have a `?` at the end of the
`read_to_string` call, and we still return an `Ok` value containing the
username in `s` when both `File::open` and `read_to_string` succeed rather than
returning errors. The functionality is again the same as in Listing 9-6 and
Listing 9-7; this is just a different, more ergonomic way to write it.
-->
<p><code>s</code>の新規<code>String</code>の生成を関数の冒頭に移動しました; その部分は変化していません。変数<code>f</code>を生成する代わりに、
<code>read_to_string</code>の呼び出しを直接<code>File::open(&quot;hello.txt&quot;)?</code>の結果に連結させました。
それでも、<code>read_to_string</code>呼び出しの末尾には<code>?</code>があり、<code>File::open</code>と<code>read_to_string</code>両方が成功したら、
エラーを返すというよりもそれでも、<code>s</code>にユーザ名を含む<code>Ok</code>値を返します。機能もまたリスト9-6及び、9-7と同じです;
ただ単に異なるバージョンのよりエルゴノミックな書き方なのです。</p>
<!--
#### `?` Operator Can Only Be Used in Functions That Return `Result`
-->
<h4 id="演算子はresultを返す関数でしか使用できない"><a class="header" href="#演算子はresultを返す関数でしか使用できない"><code>?</code>演算子は、<code>Result</code>を返す関数でしか使用できない</a></h4>
<!--
The `?` operator can only be used in functions that have a return type of
`Result`, because it is defined to work in the same way as the `match`
expression we defined in Listing 9-6. The part of the `match` that requires a
return type of `Result` is `return Err(e)`, so the return type of the function
must be a `Result` to be compatible with this `return`.
-->
<p><code>?</code>演算子は戻り値に<code>Result</code>を持つ関数でしか使用できません。というのも、リスト9-6で定義した<code>match</code>式と同様に動作するよう、
定義されているからです。<code>Result</code>の戻り値型を要求する<code>match</code>の部品は、<code>return Err(e)</code>なので、
関数の戻り値はこの<code>return</code>と互換性を保つために<code>Result</code>でなければならないのです。</p>
<!--
Let’s look at what happens if we use the `?` operator in the `main` function,
which you’ll recall has a return type of `()`:
-->
<p><code>main</code>関数で<code>?</code>演算子を使用したらどうなるか見てみましょう。<code>main</code>関数は、戻り値が<code>()</code>でしたね:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<!--
When we compile this code, we get the following error message:
-->
<p>このコードをコンパイルすると、以下のようなエラーメッセージが得られます:</p>
<pre><code class="language-text">error[E0277]: the trait bound `(): std::ops::Try` is not satisfied
(エラー: `(): std::ops::Try`というトレイト境界が満たされていません)
 --&gt; src/main.rs:4:13
  |
4 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ------------------------
  |             |
  |             the `?` operator can only be used in a function that returns
  `Result` (or another type that implements `std::ops::Try`)
  |             in this macro invocation
  |             (このマクロ呼び出しの`Result`(かまたは`std::ops::Try`を実装する他の型)を返す関数でしか`?`演算子は使用できません)
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  (助言: `std::ops::Try`トレイトは`()`には実装されていません)
  = note: required by `std::ops::Try::from_error`
  (注釈: `std::ops::Try::from_error`で要求されています)
</code></pre>
<!--
This error points out that we’re only allowed to use the `?` operator in a
function that returns `Result`. In functions that don’t return `Result`, when
you call other functions that return `Result`, you’ll need to use a `match` or
one of the `Result` methods to handle the `Result` instead of using the `?`
operator to potentially propagate the error to the calling code.
-->
<p>このエラーは、<code>?</code>演算子は<code>Result</code>を返す関数でしか使用が許可されないと指摘しています。
<code>Result</code>を返さない関数では、<code>Result</code>を返す別の関数を呼び出した時、
<code>?</code>演算子を使用してエラーを呼び出し元に委譲する可能性を生み出す代わりに、<code>match</code>か<code>Result</code>のメソッドのどれかを使う必要があるでしょう。</p>
<!--
Now that we’ve discussed the details of calling `panic!` or returning `Result`,
let’s return to the topic of how to decide which is appropriate to use in which
cases.
-->
<p>さて、<code>panic!</code>呼び出しや<code>Result</code>を返す詳細について議論し終えたので、
どんな場合にどちらを使うのが適切か決める方法についての話に戻りましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## To `panic!` or Not to `panic!`
-->
<h2 id="panicすべきかするまいか"><a class="header" href="#panicすべきかするまいか"><code>panic!</code>すべきかするまいか</a></h2>
<!--
So how do you decide when you should `panic!` and when you should return
`Result`? When code panics, there’s no way to recover. You could call `panic!`
for any error situation, whether there’s a possible way to recover or not, but
then you’re making the decision on behalf of the code calling your code that a
situation is unrecoverable. When you choose to return a `Result` value, you
give the calling code options rather than making the decision for it. The
calling code could choose to attempt to recover in a way that’s appropriate for
its situation, or it could decide that an `Err` value in this case is
unrecoverable, so it can call `panic!` and turn your recoverable error into an
unrecoverable one. Therefore, returning `Result` is a good default choice when
you’re defining a function that might fail.
-->
<p>では、<code>panic!</code>すべき時と<code>Result</code>を返すべき時はどう決定すればいいのでしょうか？コードがパニックしたら、
回復する手段はありません。回復する可能性のある手段の有る無しに関わらず、どんなエラー場面でも<code>panic!</code>を呼ぶことはできますが、
そうすると、呼び出す側のコードの立場に立ってこの場面は回復不能だという決定を下すことになります。
<code>Result</code>値を返す決定をすると、決断を下すのではなく、呼び出し側に選択肢を与えることになります。
呼び出し側は、場面に合わせて回復を試みることを決定したり、この場合の<code>Err</code>値は回復不能と断定して、
<code>panic!</code>を呼び出し、回復可能だったエラーを回復不能に変換することもできます。故に、<code>Result</code>を返却することは、
失敗する可能性のある関数を定義する際には、いい第一選択肢になります。</p>
<!--
In rare situations, it’s more appropriate to write code that panics instead of
returning a `Result`. Let’s explore why it’s appropriate to panic in examples,
prototype code, and tests. Then we'll discuss situations in which the compiler
can’t tell that failure is impossible, but you as a human can. The chpater will
conclude with some general guidelines on how to decide whether to panic in
library code.
-->
<p>稀な場面では、<code>Result</code>を返すよりもパニックするコードを書く方がより適切になることもあります。
例やプロトタイプコード、テストでパニックするのが適切な理由を探ってみましょう。
それからコンパイラではありえない失敗だと気づけなくとも、人間なら気づける場面を議論しましょう。
そして、ライブラリコードでパニックするか決定する方法についての一般的なガイドラインで結論づけましょう。</p>
<!--
### Examples, Prototype Code, and Tests
-->
<h3 id="例プロトタイプコードテスト"><a class="header" href="#例プロトタイプコードテスト">例、プロトタイプコード、テスト</a></h3>
<!--
When you’re writing an example to illustrate some concept, having robust
error-handling code in the example as well can make the example less clear. In
examples, it’s understood that a call to a method like `unwrap` that could
panic is meant as a placeholder for the way that you’d want your application to
handle errors, which can differ based on what the rest of your code is doing.
-->
<p>例を記述して何らかの概念を具体化している時、頑健なエラー処理コードも例に含むことは、例の明瞭さを欠くことになりかねません。
例において、<code>unwrap</code>などのパニックする可能性のあるメソッド呼び出しは、
アプリケーションにエラーを処理してほしい方法へのプレースホルダーを意味していると理解され、
これは残りのコードがしていることによって異なる可能性があります。</p>
<!--
Similarly, the `unwrap` and `expect` methods are very handy when prototyping,
before you’re ready to decide how to handle errors. They leave clear markers in
your code for when you’re ready to make your program more robust.
-->
<p>同様に、<code>unwrap</code>や<code>expect</code>メソッドは、エラーの処理法を決定する準備ができる前、プロトタイプの段階では、
非常に便利です。それらにより、コードにプログラムをより頑健にする時の明らかなマーカーが残されるわけです。</p>
<!--
If a method call fails in a test, we’d want the whole test to fail, even if
that method isn’t the functionality under test. Because `panic!` is how a test
is marked as a failure, calling `unwrap` or `expect` is exactly what should
happen.
-->
<p>メソッド呼び出しがテスト内で失敗したら、そのメソッドがテスト下に置かれた機能ではなかったとしても、
テスト全体が失敗してほしいでしょう。<code>panic!</code>が、テストが失敗と印づけられる手段なので、
<code>unwrap</code>や<code>expect</code>の呼び出しはズバリ起こるべきことです。</p>
<!--
### Cases in Which You Have More Information Than the Compiler
-->
<h3 id="コンパイラよりもプログラマがより情報を持っている場合"><a class="header" href="#コンパイラよりもプログラマがより情報を持っている場合">コンパイラよりもプログラマがより情報を持っている場合</a></h3>
<!--
It would also be appropriate to call `unwrap` when you have some other logic
that ensures the `Result` will have an `Ok` value, but the logic isn’t
something the compiler understands. You’ll still have a `Result` value that you
need to handle: whatever operation you’re calling still has the possibility of
failing in general, even though it’s logically impossible in your particular
situation. If you can ensure by manually inspecting the code that you’ll never
have an `Err` variant, it’s perfectly acceptable to call `unwrap`. Here’s an
example:
-->
<p><code>Result</code>が<code>Ok</code>値であると確認する何らかの別のロジックがある場合、<code>unwrap</code>を呼び出すことは適切でしょうが、
コンパイラは、そのロジックを理解はしません。それでも、処理する必要のある<code>Result</code>は存在するでしょう:
呼び出している処理が何であれ、自分の特定の場面では論理的に起こり得なくても、一般的にまだ失敗する可能性はあるわけです。
手動でコードを調査して<code>Err</code>列挙子は存在しないと確認できたら、<code>unwrap</code>を呼び出すことは完全に受容できることです。
こちらが例です:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::net::IpAddr;

let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<!--
We’re creating an `IpAddr` instance by parsing a hardcoded string. We can see
that `127.0.0.1` is a valid IP address, so it’s acceptable to use `unwrap`
here. However, having a hardcoded, valid string doesn’t change the return type
of the `parse` method: we still get a `Result` value, and the compiler will
still make us handle the `Result` as if the `Err` variant is still a possibility
because the compiler isn’t smart enough to see that this string is always a
valid IP address. If the IP address string came from a user rather than being
hardcoded into the program, and therefore *did* have a possibility of failure,
we’d definitely want to handle the `Result` in a more robust way instead.
-->
<p>ハードコードされた文字列を構文解析することで<code>IpAddr</code>インスタンスを生成しています。
プログラマには<code>127.0.0.1</code>が合法なIPアドレスであることがわかるので、ここで<code>unwrap</code>を使用することは、
受容可能なことです。しかしながら、ハードコードされた合法な文字列が存在することは、
<code>parse</code>メソッドの戻り値型を変えることにはなりません: それでも得られるのは、<code>Result</code>値であり、
コンパイラはまだ<code>Err</code>列挙子になる可能性があるかのように<code>Result</code>を処理することを強制してきます。
コンパイラは、この文字列が常に合法なIPアドレスであると把握できるほど利口ではないからです。
プログラムにハードコードされるのではなく、IPアドレス文字列がユーザ起源でそれ故に<em>確かに</em>失敗する可能性がある場合、
<code>Result</code>をもっと頑健な方法で処理したほうが絶対にいいでしょう。</p>
<!--
### Guidelines for Error Handling
-->
<h3 id="エラー処理のガイドライン"><a class="header" href="#エラー処理のガイドライン">エラー処理のガイドライン</a></h3>
<!--
It’s advisable to have your code panic when it’s possible that your code
could end up in a bad state. In this context, a *bad state* is when some
assumption, guarantee, contract, or invariant has been broken, such as when
invalid values, contradictory values, or missing values are passed to your
code—plus one or more of the following:
-->
<p>コードが悪い状態に陥る可能性があるときにパニックさせるのは、推奨されることです。この文脈において、
<em>悪い状態</em>とは、何らかの前提、保証、契約、不変性が破られたことを言い、例を挙げれば、無効な値、
矛盾する値、行方不明な値がコードに渡されることと、さらに以下のいずれか一つ以上の状態であります:</p>
<!--
* The bad state is not something that’s *expected* to happen occasionally.
* Your code after this point needs to rely on not being in this bad state.
* There’s not a good way to encode this information in the types you use.
-->
<ul>
<li>悪い状態がときに起こるとは<em>予想</em>されないとき。</li>
<li>この時点以降、この悪い状態にないことを頼りにコードが書かれているとき。</li>
<li>使用している型にこの情報をコード化するいい手段がないとき。</li>
</ul>
<!--
If someone calls your code and passes in values that don’t make sense, the best
choice might be to `panic!` and alert the person using your library to the
bug in their code so they can fix it during development. Similarly, `panic!` is
often appropriate if you’re calling external code that is out of your control
and it returns an invalid state that you have no way of fixing.
-->
<p>誰かが自分のコードを呼び出して筋の通らない値を渡してきたら、最善の選択肢は<code>panic!</code>し、
開発段階で修正できるように自分たちのコードにバグがあることをライブラリ使用者に通知することかもしれません。
同様に自分の制御下にない外部コードを呼び出し、修正しようのない無効な状態を返すときに<code>panic!</code>はしばしば適切です。</p>
<!--
When a bad state is reached, but it’s expected to happen no matter how well you
write your code, it’s still more appropriate to return a `Result` rather than
making a `panic!` call. Examples include a parser being given malformed data
or an HTTP request returning a status that indicates you have hit a rate limit.
In these cases, you should indicate that failure is an expected possibility by
returning a `Result` to propagate these bad states upwards so the calling code
can decide how to handle the problem. To call `panic!` wouldn’t be the best way
to handle these cases.
-->
<p>しかし、どんなにコードをうまく書いても起こると予想されますが、悪い状態に達したとき、それでも<code>panic!</code>呼び出しをするよりも、
<code>Result</code>を返すほうがより適切です。例には、不正なデータを渡されたパーサとか、
訪問制限に引っかかったことを示唆するステータスを返すHTTPリクエストなどが挙げられます。
このような場合には、呼び出し側が問題の処理方法を決定できるように<code>Result</code>を返してこの悪い状態を委譲して、
失敗が予想される可能性であることを示唆するべきです。<code>panic!</code>を呼び出すことは、
これらのケースでは最善策ではないでしょう。</p>
<!--
When your code performs operations on values, your code should verify the
values are valid first and panic if the values aren’t valid. This is mostly for
safety reasons: attempting to operate on invalid data can expose your code to
vulnerabilities. This is the main reason the standard library will call
`panic!` if you attempt an out-of-bounds memory access: trying to access memory
that doesn’t belong to the current data structure is a common security problem.
Functions often have *contracts*: their behavior is only guaranteed if the
inputs meet particular requirements. Panicking when the contract is violated
makes sense because a contract violation always indicates a caller-side bug,
and it’s not a kind of error you want the calling code to have to explicitly
handle. In fact, there’s no reasonable way for calling code to recover; the
calling *programmers* need to fix the code. Contracts for a function,
especially when a violation will cause a panic, should be explained in the API
documentation for the function.
-->
<p>コードが値に対して処理を行う場合、コードはまず値が合法であることを確認し、
値が合法でなければパニックするべきです。これはほぼ安全性上の理由によるものです: 不正なデータの処理を試みると、
コードを脆弱性に晒す可能性があります。これが、境界外へのメモリアクセスを試みたときに標準ライブラリが<code>panic!</code>を呼び出す主な理由です:
現在のデータ構造に属しないメモリにアクセスを試みることは、ありふれたセキュリティ問題なのです。
関数にはしばしば<em>契約</em>が伴います: 入力が特定の条件を満たすときのみ、振る舞いが保証されるのです。
契約が侵されたときにパニックすることは、道理が通っています。なぜなら、契約侵害は常に呼び出し側のバグを示唆し、
呼び出し側に明示的に処理してもらう必要のある種類のエラーではないからです。実際に、
呼び出し側が回復する合理的な手段はありません; 呼び出し側の<em>プログラマ</em>がコードを修正する必要があるのです。
関数の契約は、特に侵害がパニックを引き起こす際には、関数のAPIドキュメント内で説明されているべきです。</p>
<!--
However, having lots of error checks in all of your functions would be verbose
and annoying. Fortunately, you can use Rust’s type system (and thus the type
checking the compiler does) to do many of the checks for you. If your function
has a particular type as a parameter, you can proceed with your code’s logic
knowing that the compiler has already ensured you have a valid value. For
example, if you have a type rather than an `Option`, your program expects to
have *something* rather than *nothing*. Your code then doesn’t have to handle
two cases for the `Some` and `None` variants: it will only have one case for
definitely having a value. Code trying to pass nothing to your function won’t
even compile, so your function doesn’t have to check for that case at runtime.
Another example is using an unsigned integer type like `u32`, which ensures
the parameter is never negative.
-->
<p>ですが、全ての関数でたくさんのエラーチェックを行うことは冗長で煩わしいことでしょう。幸運にも、
Rustの型システム(故にコンパイラが行う型精査)を使用して多くの検査を行ってもらうことができます。
関数の引数に特定の型があるなら、合法な値があるとコンパイラがすでに確認していることを把握して、
コードのロジックに進むことができます。例えば、<code>Option</code>以外の型がある場合、プログラムは、
<em>何もない</em>ではなく<em>何かある</em>と想定します。そうしたらコードは、
<code>Some</code>と<code>None</code>列挙子の2つの場合を処理する必要がなくなるわけです:
確実に値があるという可能性しかありません。関数に何もないことを渡そうとしてくるコードは、
コンパイルが通りもしませんので、その場合を実行時に検査する必要はないわけです。
別の例は、<code>u32</code>のような符号なし整数を使うことであり、この場合、引数は負には絶対にならないことが確認されます。</p>
<!--
### Creating Custom Types for Validation
-->
<h3 id="検証のために独自の型を作る"><a class="header" href="#検証のために独自の型を作る">検証のために独自の型を作る</a></h3>
<!--
Let’s take the idea of using Rust’s type system to ensure we have a valid value
one step further and look at creating a custom type for validation. Recall the
guessing game in Chapter 2 in which our code asked the user to guess a number
between 1 and 100. We never validated that the user’s guess was between those
numbers before checking it against our secret number; we only validated that
the guess was positive. In this case, the consequences were not very dire: our
output of “Too high” or “Too low” would still be correct. It would be a
useful enhancement to guide the user toward valid guesses and have different
behavior when a user guesses a number that’s out of range versus when a user
types, for example, letters instead.
-->
<p>Rustの型システムを使用して合法な値があると確認するというアイディアを一歩先に進め、
検証のために独自の型を作ることに目を向けましょう。第2章の数当てゲームで、
コードがユーザに1から100までの数字を推測するよう求めたことを思い出してください。
秘密の数字と照合する前にユーザの推測がそれらの値の範囲にあることを全く確認しませんでした;
推測が正であることしか確認しませんでした。この場合、結果はそれほど悲惨なものではありませんでした:
「大きすぎ」、「小さすぎ」という出力は、それでも正しかったでしょう。ユーザを合法な推測に導き、
ユーザが範囲外の数字を推測したり、例えばユーザが文字を代わりに入力したりしたときに別の挙動をするようにしたら、
有益な改善になるでしょう。</p>
<!--
One way to do this would be to parse the guess as an `i32` instead of only a
`u32` to allow potentially negative numbers, and then add a check for the
number being in range, like so:
-->
<p>これをする一つの方法は、ただの<code>u32</code>の代わりに<code>i32</code>として推測をパースし、負の数になる可能性を許可し、
それから数字が範囲に収まっているというチェックを追加することでしょう。そう、以下のように:</p>
<pre><code class="language-rust ignore">loop {
    // --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };

    if guess &lt; 1 || guess &gt; 100 {
        println!(&quot;The secret number will be between 1 and 100.&quot;);
        continue;
    }

    match guess.cmp(&amp;secret_number) {
    // --snip--
}
</code></pre>
<!--
The `if` expression checks whether our value is out of range, tells the user
about the problem, and calls `continue` to start the next iteration of the loop
and ask for another guess. After the `if` expression, we can proceed with the
comparisons between `guess` and the secret number knowing that `guess` is
between 1 and 100.
-->
<p>この<code>if</code>式が、値が範囲外かどうかをチェックし、ユーザに問題を告知し、<code>continue</code>を呼び出してループの次の繰り返しを始め、
別の推測を求めます。<code>if</code>式の後、<code>guess</code>は1から100の範囲にあると把握して、<code>guess</code>と秘密の数字の比較に進むことができます。</p>
<!--
However, this is not an ideal solution: if it was absolutely critical that the
program only operated on values between 1 and 100, and it had many functions
with this requirement, having a check like this in every function would be
tedious (and might impact performance).
-->
<p>ところが、これは理想的な解決策ではありません: プログラムが1から100の範囲の値しか処理しないことが間違いなく、
肝要であり、この要求がある関数の数が多ければ、このようなチェックを全関数で行うことは、
面倒でパフォーマンスにも影響を及ぼす可能性があるでしょう。</p>
<!--
Instead, we can make a new type and put the validations in a function to create
an instance of the type rather than repeating the validations everywhere. That
way, it’s safe for functions to use the new type in their signatures and
confidently use the values they receive. Listing 9-9 shows one way to define a
`Guess` type that will only create an instance of `Guess` if the `new` function
receives a value between 1 and 100.
-->
<p>代わりに、新しい型を作って検証を関数内に閉じ込め、検証を全箇所で繰り返すのではなく、
その型のインスタンスを生成することができます。そうすれば、関数がその新しい型をシグニチャに用い、
受け取った値を自信を持って使用することは安全になります。リスト9-9に、<code>new</code>関数が1から100までの値を受け取った時のみ、
<code>Guess</code>のインスタンスを生成する<code>Guess</code>型を定義する一つの方法を示しました。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: u32,
}

impl Guess {
    pub fn new(value: u32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            // 予想の値は1から100の範囲でなければなりませんが、{}でした
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }

    pub fn value(&amp;self) -&gt; u32 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 9-9: A `Guess` type that will only continue with
values between 1 and 100</span>
-->
<p><span class="caption">リスト9-9: 値が1から100の場合のみ処理を継続する<code>Guess</code>型</span></p>
<!--
First, we define a struct named `Guess` that has a field named `value` that
holds a `u32`. This is where the number will be stored.
-->
<p>まず、<code>u32</code>型の<code>value</code>をフィールドに持つ<code>Guess</code>という名前の構造体を定義しています。
ここに数値が保管されます。</p>
<!--
Then we implement an associated function named `new` on `Guess` that creates
instances of `Guess` values. The `new` function is defined to have one
parameter named `value` of type `u32` and to return a `Guess`. The code in the
body of the `new` function tests `value` to make sure it’s between 1 and 100.
If `value` doesn’t pass this test, we make a `panic!` call, which will alert
the programmer who is writing the calling code that they have a bug they need
to fix, because creating a `Guess` with a `value` outside this range would
violate the contract that `Guess::new` is relying on. The conditions in which
`Guess::new` might panic should be discussed in its public-facing API
documentation; we’ll cover documentation conventions indicating the possibility
of a `panic!` in the API documentation that you create in Chapter 14. If
`value` does pass the test, we create a new `Guess` with its `value` field set
to the `value` parameter and return the `Guess`.
-->
<p>それから<code>Guess</code>に<code>Guess</code>値のインスタンスを生成する<code>new</code>という名前の関連関数を実装しています。
<code>new</code>関数は、<code>u32</code>型の<code>value</code>という引数を取り、<code>Guess</code>を返すように定義されています。
<code>new</code>関数の本体のコードは、<code>value</code>をふるいにかけ、1から100の範囲であることを確かめます。
<code>value</code>がふるいに引っかかったら、<code>panic!</code>呼び出しを行います。これにより、呼び出しコードを書いているプログラマに、
修正すべきバグがあると警告します。というのも、この範囲外の<code>value</code>で<code>Guess</code>を生成することは、
<code>Guess::new</code>が頼りにしている契約を侵害するからです。<code>Guess::new</code>がパニックするかもしれない条件は、
公開されているAPIドキュメントで議論されるべきでしょう; あなたが作成するAPIドキュメントで<code>panic!</code>の可能性を示唆する、
ドキュメントの規約は、第14章で講義します。<code>value</code>が確かにふるいを通ったら、
<code>value</code>フィールドが<code>value</code>引数にセットされた新しい<code>Guess</code>を作成して返します。</p>
<!--
Next, we implement a method named `value` that borrows `self`, doesn’t have any
other parameters, and returns a `u32`. This kind of method is sometimes called
a *getter*, because its purpose is to get some data from its fields and return
it. This public method is necessary because the `value` field of the `Guess`
struct is private. It’s important that the `value` field is private so code
using the `Guess` struct is not allowed to set `value` directly: code outside
the module *must* use the `Guess::new` function to create an instance of
`Guess`, thereby ensuring there’s no way for a `Guess` to have a `value` that
hasn’t been checked by the conditions in the `Guess::new` function.
-->
<p>次に、<code>self</code>を借用し、他に引数はなく、<code>u32</code>を返す<code>value</code>というメソッドを実装します。
この類のメソッドは時に<em>ゲッター</em>と呼ばれます。目的がフィールドから何らかのデータを得て返すことだからです。
この公開メソッドは、<code>Guess</code>構造体の<code>value</code>フィールドが非公開なので、必要になります。
<code>value</code>フィールドが非公開なことは重要であり、そのために<code>Guess</code>構造体を使用するコードは、
直接<code>value</code>をセットすることが叶わないのです: モジュール外のコードは、
<code>Guess::new</code>関数を使用して<code>Guess</code>のインスタンスを生成し<em>なければならず</em>、
それにより、<code>Guess::new</code>関数の条件式でチェックされていない<code>value</code>が<code>Guess</code>に存在する手段はないことが保証されるわけです。</p>
<!--
A function that has a parameter or returns only numbers between 1 and 100 could
then declare in its signature that it takes or returns a `Guess` rather than a
`u32` and wouldn’t need to do any additional checks in its body.
-->
<p>そうしたら、引数を一つ持つか、1から100の範囲の数値のみを返す関数は、シグニチャで<code>u32</code>ではなく、
<code>Guess</code>を取るか返し、本体内で追加の確認を行う必要はなくなると宣言できるでしょう。</p>
<!--
## Summary
-->
<h2 id="まとめ-8"><a class="header" href="#まとめ-8">まとめ</a></h2>
<!--
Rust’s error handling features are designed to help you write more robust code.
The `panic!` macro signals that your program is in a state it can’t handle and
lets you tell the process to stop instead of trying to proceed with invalid or
incorrect values. The `Result` enum uses Rust’s type system to indicate that
operations might fail in a way that your code could recover from. You can use
`Result` to tell code that calls your code that it needs to handle potential
success or failure as well. Using `panic!` and `Result` in the appropriate
situations will make your code more reliable in the face of inevitable problems.
-->
<p>Rustのエラー処理機能は、プログラマがより頑健なコードを書く手助けをするように設計されています。
<code>panic!</code>マクロは、プログラムが処理できない状態にあり、無効だったり不正な値で処理を継続するのではなく、
プロセスに処理を中止するよう指示することを通知します。<code>Result</code> enumは、Rustの型システムを使用して、
コードが回復可能な方法で処理が失敗するかもしれないことを示唆します。<code>Result</code>を使用して、
呼び出し側のコードに成功や失敗する可能性を処理する必要があることも教えます。
適切な場面で<code>panic!</code>や<code>Result</code>を使用することで、必然的な問題の眼前でコードの信頼性を上げてくれます。</p>
<!--
Now that you’ve seen useful ways that the standard library uses generics with
the `Option` and `Result` enums, we’ll talk about how generics work and how you
can use them in your code.
-->
<p>今や、標準ライブラリが<code>Option</code>や<code>Result</code> enumなどでジェネリクスを有効活用するところを目の当たりにしたので、
ジェネリクスの動作法と自分のコードでの使用方法について語りましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Generic Types, Traits, and Lifetimes
-->
<h1 id="ジェネリック型トレイトライフタイム"><a class="header" href="#ジェネリック型トレイトライフタイム">ジェネリック型、トレイト、ライフタイム</a></h1>
<!--
Every programming language has tools for effectively handling the duplication
of concepts. In Rust, one such tool is *generics*. Generics are abstract
stand-ins for concrete types or other properties. When we’re writing code, we
can express the behavior of generics or how they relate to other generics
without knowing what will be in their place when compiling and running the code.
-->
<p>全てのプログラミング言語には、概念の重複を効率的に扱う道具があります。Rustにおいて、そのような道具の一つが<em>ジェネリクス</em>です。
ジェネリクスは、具体型や他のプロパティの抽象的な代役です。コード記述の際、コンパイルやコード実行時に、
ジェネリクスの位置に何が入るかを知ることなく、ジェネリクスの振る舞いや他のジェネリクスとの関係を表現できるのです。</p>
<!--
Similar to the way a function takes parameters with unknown values to run the
same code on multiple concrete values, functions can take parameters of some
generic type instead of a concrete type, like `i32` or `String`. In fact, we’ve
already used generics in Chapter 6 with `Option<T>`, Chapter 8 with `Vec<T>`
and `HashMap<K, V>`, and Chapter 9 with `Result<T, E>`. In this chapter, you’ll
explore how to define your own types, functions, and methods with generics!
-->
<p>関数が未知の値の引数を取り、同じコードを複数の具体的な値に対して走らせるように、
<code>i32</code>や<code>String</code>などの具体的な型の代わりに何かジェネリックな型の引数を取ることができます。
実際、第6章で<code>Option&lt;T&gt;</code>、第8章で<code>Vec&lt;T&gt;</code>と<code>HashMap&lt;K, V&gt;</code>、第9章で<code>Result&lt;T, E&gt;</code>を既に使用しました。
この章では、独自の型、関数、メソッドをジェネリクスとともに定義する方法を探究します！</p>
<!--
First, we’ll review how to extract a function to reduce code duplication. Next,
we’ll use the same technique to make a generic function from two functions that
differ only in the types of their parameters. We’ll also explain how to use
generic types in struct and enum definitions.
-->
<p>まず、関数を抽出して、コードの重複を減らす方法を確認しましょう。次に同じテクニックを活用して、
引数の型のみが異なる2つの関数からジェネリックな関数を生成します。また、
ジェネリックな型を構造体やenum定義で使用する方法も説明します。</p>
<!--
Then you’ll learn how to use *traits* to define behavior in a generic way. You
can combine traits with generic types to constrain a generic type to only
those types that have a particular behavior, as opposed to just any type.
-->
<p>それから、トレイトを使用して、ジェネリックな方法で振る舞いを定義する方法を学びます。
ジェネリックな型にトレイトを組み合わせることで、ジェネリックな型を、単にあらゆる型に対してではなく、特定の振る舞いのある型のみに制限できます。</p>
<!--
Finally, we’ll discuss *lifetimes*, a variety of generics that give the
compiler information about how references relate to each other. Lifetimes allow
us to borrow values in many situations while still enabling the compiler to
check that the references are valid.
-->
<p>最後に、ライフタイムを議論します。ライフタイムとは、コンパイラに参照がお互いにどう関係しているかの情報を与える一種のジェネリクスです。
ライフタイムのおかげでコンパイラに参照が有効であることを確認してもらうことを可能にしつつ、多くの場面で値を借用できます。</p>
<!--
## Removing Duplication by Extracting a Function
-->
<h2 id="関数を抽出することで重複を取り除く"><a class="header" href="#関数を抽出することで重複を取り除く">関数を抽出することで重複を取り除く</a></h2>
<!--
Before diving into generics syntax, let’s first look at how to remove
duplication that doesn’t involve generic types by extracting a function. Then
we’ll apply this technique to extract a generic function! In the same way that
you recognize duplicated code to extract into a function, you’ll start to
recognize duplicated code that can use generics.
-->
<p>ジェネリクスの記法に飛び込む前にまずは、関数を抽出することでジェネリックな型が関わらない重複を取り除く方法を見ましょう。
そして、このテクニックを適用してジェネリックな関数を抽出するのです！重複したコードを認識して関数に抽出できるのと同じように、
ジェネリクスを使用できる重複コードも認識し始めるでしょう。</p>
<!--
Consider a short program that finds the largest number in a list, as shown in
Listing 10-1.
-->
<p>リスト10-1に示したように、リスト内の最大値を求める短いプログラムを考えてください。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    // 最大値は{}です
    println!(&quot;The largest number is {}&quot;, largest);
<span class="boring"> assert_eq!(largest, 100);
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 10-1: Code to find the largest number in a list
of numbers</span>
-->
<p><span class="caption">リスト10-1: 数字のリストから最大値を求めるコード</span></p>
<!--
This code stores a list of integers in the variable `number_list` and places
the first number in the list in a variable named `largest`. Then it iterates
through all the numbers in the list, and if the current number is greater than
the number stored in `largest`, it replaces the number in that variable.
However, if the current number is less than the largest number seen so far, the
variable doesn’t change, and the code moves on to the next number in the list.
After considering all the numbers in the list, `largest` should hold the
largest number, which in this case is 100.
-->
<p>このコードは、整数のリストを変数<code>number_list</code>に格納し、リストの最初の数字を<code>largest</code>という変数に配置しています。
それからリストの数字全部を走査し、現在の数字が<code>largest</code>に格納された数値よりも大きければ、
その変数の値を置き換えます。ですが、現在の数値が今まで見た最大値よりも小さければ、
変数は変わらず、コードはリストの次の数値に移っていきます。リストの数値全てを吟味した後、
<code>largest</code>は最大値を保持しているはずで、今回は100になります。</p>
<!--
To find the largest number in two different lists of numbers, we can duplicate
the code in Listing 10-1 and use the same logic at two different places in the
program, as shown in Listing 10-2.
-->
<p>2つの異なる数値のリストから最大値を発見するには、リスト10-1のコードを複製し、
プログラムの異なる2箇所で同じロジックを使用できます。リスト10-2のようにですね。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-2: Code to find the largest number in *two*
lists of numbers</span>
-->
<p><span class="caption">リスト10-2: <em>2つ</em>の数値のリストから最大値を探すコード</span></p>
<!--
Although this code works, duplicating code is tedious and error prone. We also
have to update the code in multiple places when we want to change it.
-->
<p>このコードは動くものの、コードを複製することは退屈ですし、間違いも起きやすいです。また、
コードを変更したい時に複数箇所、更新しなければなりません。</p>
<!--
To eliminate this duplication, we can create an abstraction by defining a
function that operates on any list of integers given to it in a parameter. This
solution makes our code clearer and lets us express the concept of finding the
largest number in a list abstractly.
-->
<p>この重複を排除するには、引数で与えられた整数のどんなリストに対しても処理が行える関数を定義して抽象化できます。
この解決策によりコードがより明確になり、リストの最大値を探すという概念を抽象的に表現させてくれます。</p>
<!--
In Listing 10-3, we extracted the code that finds the largest number into a
function named `largest`. Unlike the code in Listing 10-1, which can find the
largest number in only one particular list, this program can find the largest
number in two different lists.
-->
<p>リスト10-3では、最大値を探すコードを<code>largest</code>という関数に抽出しました。リスト10-1のコードは、
たった1つの特定のリストからだけ最大値を探せますが、それとは異なり、このプログラムは2つの異なるリストから最大値を探せます。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">   assert_eq!(result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">   assert_eq!(result, 6000);
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 10-3: Abstracted code to find the largest number
in two lists</span>
-->
<p><span class="caption">リスト10-3: 2つのリストから最大値を探す抽象化されたコード</span></p>
<!--
The `largest` function has a parameter called `list`, which represents any
concrete slice of `i32` values that we might pass into the function. As a
result, when we call the function, the code runs on the specific values that we
pass in.
-->
<p><code>largest</code>関数には<code>list</code>と呼ばれる引数があり、これは、関数に渡す可能性のある、あらゆる<code>i32</code>値の具体的なスライスを示します。
結果的に、関数呼び出しの際、コードは渡した特定の値に対して走るのです。</p>
<!--
In sum, here are the steps we took to change the code from Listing 10-2 to
Listing 10-3:
-->
<p>まとめとして、こちらがリスト10-2のコードからリスト10-3に変更するのに要したステップです:</p>
<!--
1. Identify duplicate code.
2. Extract the duplicate code into the body of the function and specify the
inputs and return values of that code in the function signature.
3. Update the two instances of duplicated code to call the function instead.
-->
<ol>
<li>重複したコードを見分ける。</li>
<li>重複コードを関数本体に抽出し、コードの入力と戻り値を関数シグニチャで指定する。</li>
<li>重複したコードの2つの実体を代わりに関数を呼び出すように更新する。</li>
</ol>
<!--
Next, we’ll use these same steps with generics to reduce code duplication in
different ways. In the same way that the function body can operate on an
abstract `list` instead of specific values, generics allow code to operate on
abstract types.
-->
<p>次は、この同じ手順をジェネリクスでも踏んで異なる方法でコードの重複を減らします。
関数本体が特定の値ではなく抽象的な<code>list</code>に対して処理できたのと同様に、
ジェネリクスは抽象的な型に対して処理するコードを可能にしてくれます。</p>
<!--
For example, say we had two functions: one that finds the largest item in a
slice of `i32` values and one that finds the largest item in a slice of `char`
values. How would we eliminate that duplication? Let’s find out!
-->
<p>例えば、関数が2つあるとしましょう: 1つは<code>i32</code>値のスライスから最大の要素を探し、1つは<code>char</code>値のスライスから最大要素を探します。
この重複はどう排除するのでしょうか？答えを見つけましょう！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Generic Data Types
-->
<h2 id="ジェネリックなデータ型"><a class="header" href="#ジェネリックなデータ型">ジェネリックなデータ型</a></h2>
<!--
We can use generics to create definitions for items like function signatures or
structs, which we can then use with many different concrete data types. Let’s
first look at how to define functions, structs, enums, and methods using
generics. Then we’ll discuss how generics affect code performance.
-->
<p>関数シグニチャや構造体などの要素の定義を生成するのにジェネリクスを使用することができ、
それはさらに他の多くの具体的なデータ型と使用することもできます。まずは、
ジェネリクスで関数、構造体、enum、メソッドを定義する方法を見ましょう。それから、
ジェネリクスがコードのパフォーマンスに与える影響を議論します。</p>
<!--
### In Function Definitions
-->
<h3 id="関数定義では"><a class="header" href="#関数定義では">関数定義では</a></h3>
<!--
When defining a function that uses generics, we place the generics in the
signature of the function where we would usually specify the data types of the
parameters and return value. Doing so makes our code more flexible and provides
more functionality to callers of our function while preventing code duplication.
-->
<p>ジェネリクスを使用する関数を定義する時、通常、引数や戻り値のデータ型を指定する関数のシグニチャにジェネリクスを配置します。
そうすることでコードがより柔軟になり、コードの重複を阻止しつつ、関数の呼び出し元により多くの機能を提供します。</p>
<!--
Continuing with our `largest` function, Listing 10-4 shows two functions that
both find the largest value in a slice.
-->
<p><code>largest</code>関数を続けます。リスト10-4はどちらもスライスから最大値を探す2つの関数を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">   assert_eq!(result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
<span class="boring">   assert_eq!(result, 'y');
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 10-4: Two functions that differ only in their
names and the types in their signatures</span>
-->
<p><span class="caption">リスト10-4: 名前とシグニチャの型のみが異なる2つの関数</span></p>
<!--
The `largest_i32` function is the one we extracted in Listing 10-3 that finds
the largest `i32` in a slice. The `largest_char` function finds the largest
`char` in a slice. The function bodies have the same code, so let’s eliminate
the duplication by introducing a generic type parameter in a single function.
-->
<p><code>largest_i32</code>関数は、リスト10-3で抽出したスライスから最大の<code>i32</code>を探す関数です。
<code>largest_char</code>関数は、スライスから最大の<code>char</code>を探します。関数本体には同じコードがあるので、
単独の関数にジェネリックな型引数を導入してこの重複を排除しましょう。</p>
<!--
To parameterize the types in the new function we’ll define, we need to name the
type parameter, just as we do for the value parameters to a function. You can
use any identifier as a type parameter name. But we’ll use `T` because, by
convention, parameter names in Rust are short, often just a letter, and Rust’s
type-naming convention is CamelCase. Short for “type,” `T` is the default
choice of most Rust programmers.
-->
<p>これから定義する新しい関数の型を引数にするには、ちょうど関数の値引数のように型引数に名前をつける必要があります。
型引数の名前にはどんな識別子も使用できますが、<code>T</code>を使用します。というのも、慣習では、
Rustの引数名は短く(しばしばたった1文字になります)、Rustの型の命名規則がキャメルケースだからです。
&quot;type&quot;の省略形なので、<code>T</code>が多くのRustプログラマの既定の選択なのです。</p>
<!--
When we use a parameter in the body of the function, we have to declare the
parameter name in the signature so the compiler knows what that name means.
Similarly, when we use a type parameter name in a function signature, we have
to declare the type parameter name before we use it. To define the generic
`largest` function, place type name declarations inside angle brackets, `<>`,
between the name of the function and the parameter list, like this:
-->
<p>関数の本体で引数を使用するとき、コンパイラがその名前の意味を把握できるようにシグニチャでその引数名を宣言しなければなりません。
同様に、型引数名を関数シグニチャで使用する際には、使用する前に型引数名を宣言しなければなりません。
ジェネリックな<code>largest</code>関数を定義するために、型名宣言を山カッコ(<code>&lt;&gt;</code>)内、関数名と引数リストの間に配置してください。
こんな感じに:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<!--
We read this definition as: the function `largest` is generic over some type
`T`. This function has one parameter named `list`, which is a slice of values
of type `T`. The `largest` function will return a value of the same type `T`.
-->
<p>この定義は以下のように解読します: 関数<code>largest</code>は、なんらかの型<code>T</code>に関してジェネリックであると。
この関数には<code>list</code>という引数が1つあり、これは型<code>T</code>の値のスライスです。
<code>largest</code>関数は同じ<code>T</code>型の値を返します。</p>
<!--
Listing 10-5 shows the combined `largest` function definition using the generic
data type in its signature. The listing also shows how we can call the function
with either a slice of `i32` values or `char` values. Note that this code won’t
compile yet, but we’ll fix it later in this chapter.
-->
<p>リスト10-5は、シグニチャにジェネリックなデータ型を使用して<code>largest</code>関数定義を組み合わせたものを示しています。
このリストはさらに、この関数を<code>i32</code>値か<code>char</code>値のどちらかで呼べる方法も表示しています。
このコードはまだコンパイルできないことに注意してください。ですが、この章の後ほど修正します。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<!--
<span class="caption">Listing 10-5: A definition of the `largest` function that
uses generic type parameters but doesn’t compile yet</span>
-->
<p><span class="caption">リスト10-5: ジェネリックな型引数を使用するものの、まだコンパイルできない<code>largest</code>関数の定義</span></p>
<!--
If we compile this code right now, we’ll get this error:
-->
<p>直ちにこのコードをコンパイルしたら、以下のようなエラーが出ます:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
(エラー: 2項演算`&gt;`は、型`T`に適用できません)
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
  (注釈: `std::cmp::PartialOrd`の実装が`T`に対して存在しない可能性があります)
</code></pre>
<!--
The note mentions `std::cmp::PartialOrd`, which is a *trait*. We’ll talk about
traits in the next section. For now, this error states that the body of
`largest` won’t work for all possible types that `T` could be. Because we want
to compare values of type `T` in the body, we can only use types whose values
can be ordered. To enable comparisons, the standard library has the
`std::cmp::PartialOrd` trait that you can implement on types (see Appendix C
for more on this trait). You’ll learn how to specify that a generic type has a
particular trait in the “Trait Bounds” section, but let’s first explore other
ways of using generic type parameters.
-->
<p>注釈が<code>std::cmp::PartialOrd</code>に触れています。これは、<em>トレイト</em>です。トレイトについては、次の節で語ります。
とりあえず、このエラーは、<code>largest</code>の本体は、<code>T</code>がなりうる全ての可能性のある型に対して動作しないと述べています。
本体で型<code>T</code>の値を比較したいので、値が順序付け可能な型のみしか使用できないのです。比較を可能にするために、
標準ライブラリには型に実装できる<code>std::cmp::PartialOrd</code>トレイトがあります(このトレイトについて詳しくは付録Cを参照されたし)。
ジェネリックな型が特定のトレイトを持つと指定する方法は「トレイト境界」節で習うでしょうが、
先にジェネリックな型引数を使用する他の方法を探究しましょう。</p>
<!--
### In Struct Definitions
-->
<h3 id="構造体定義では"><a class="header" href="#構造体定義では">構造体定義では</a></h3>
<!--
We can also define structs to use a generic type parameter in one or more
fields using the `<>` syntax. Listing 10-6 shows how to define a `Point<T>`
struct to hold `x` and `y` coordinate values of any type.
-->
<p>構造体を定義して<code>&lt;&gt;</code>記法で1つ以上のフィールドにジェネリックな型引数を使用することもできます。
リスト10-6は、<code>Point&lt;T&gt;</code>構造体を定義してあらゆる型の<code>x</code>と<code>y</code>座標を保持する方法を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-6: A `Point<T>` struct that holds `x` and `y`
values of type `T`</span>
-->
<p><span class="caption">リスト10-6: 型<code>T</code>の<code>x</code>と<code>y</code>値を保持する<code>Point&lt;T&gt;</code>構造体</span></p>
<!--
The syntax for using generics in struct definitions is similar to that used in
function definitions. First, we declare the name of the type parameter inside
angle brackets just after the name of the struct. Then we can use the generic
type in the struct definition where we would otherwise specify concrete data
types.
-->
<p>構造体定義でジェネリクスを使用する記法は、関数定義のものと似ています。まず、山カッコ内に型引数の名前を構造体名の直後に宣言します。
そうすると、本来具体的なデータ型を記述する構造体定義の箇所に、ジェネリックな型を使用できます。</p>
<!--
Note that because we’ve used only one generic type to define `Point<T>`, this
definition says that the `Point<T>` struct is generic over some type `T`, and
the fields `x` and `y` are *both* that same type, whatever that type may be. If
we create an instance of a `Point<T>` that has values of different types, as in
Listing 10-7, our code won’t compile.
-->
<p>ジェネリックな型を1つだけ使用して<code>Point&lt;T&gt;</code>を定義したので、この定義は、<code>Point&lt;T&gt;</code>構造体がなんらかの型<code>T</code>に関して、
ジェネリックであると述べていて、その型がなんであれ、<code>x</code>と<code>y</code>のフィールドは<em>両方</em>その同じ型になっていることに注意してください。
リスト10-7のように、異なる型の値のある<code>Point&lt;T&gt;</code>のインスタンスを生成すれば、コードはコンパイルできません。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<!--
<span class="caption">Listing 10-7: The fields `x` and `y` must be the same
type because both have the same generic data type `T`.</span>
-->
<p><span class="caption">リスト10-7: どちらも同じジェネリックなデータ型<code>T</code>なので、<code>x</code>と<code>y</code>というフィールドは同じ型でなければならない</span></p>
<!--
In this example, when we assign the integer value 5 to `x`, we let the
compiler know that the generic type `T` will be an integer for this instance of
`Point<T>`. Then when we specify 4.0 for `y`, which we’ve defined to have the
same type as `x`, we’ll get a type mismatch error like this:
-->
<p>この例で、<code>x</code>に整数値5を代入すると、この<code>Point&lt;T&gt;</code>のインスタンスに対するジェネリックな型<code>T</code>は整数になるとコンパイラに知らせます。
それから<code>y</code>に4.0を指定する時に、このフィールドは<code>x</code>と同じ型と定義したはずなので、このように型不一致エラーが出ます:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integral variable, found
floating-point variable
  |
  = note: expected type `{integer}`
             found type `{float}`
</code></pre>
<!--
To define a `Point` struct where `x` and `y` are both generics but could have
different types, we can use multiple generic type parameters. For example, in
Listing 10-8, we can change the definition of `Point` to be generic over types
`T` and `U` where `x` is of type `T` and `y` is of type `U`.
-->
<p><code>x</code>と<code>y</code>が両方ジェネリックだけれども、異なる型になり得る<code>Point</code>構造体を定義するには、
複数のジェネリックな型引数を使用できます。例えば、リスト10-8では、<code>Point</code>の定義を変更して、
型<code>T</code>と<code>U</code>に関してジェネリックにし、<code>x</code>が型<code>T</code>で、<code>y</code>が型<code>U</code>になります。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-8: A `Point<T, U>` generic over two types so
that `x` and `y` can be values of different types</span>
-->
<p><span class="caption">リスト10-8: <code>Point&lt;T, U&gt;</code>は2つの型に関してジェネリックなので、<code>x</code>と<code>y</code>は異なる型の値になり得る</span></p>
<!--
Now all the instances of `Point` shown are allowed! You can use as many generic
type parameters in a definition as you want, but using more than a few makes
your code hard to read. When you need lots of generic types in your code, it
could indicate that your code needs restructuring into smaller pieces.
-->
<p>これで、示された<code>Point</code>インスタンスは全部使用可能です！所望の数だけ定義でジェネリックな型引数を使用できますが、
数個以上使用すると、コードが読みづらくなります。コードで多くのジェネリックな型が必要な時は、
コードの小分けが必要なサインかもしれません。</p>
<!--
### In Enum Definitions
-->
<h3 id="enum定義では"><a class="header" href="#enum定義では">enum定義では</a></h3>
<!--
As we did with structs, we can define enums to hold generic data types in their
variants. Let’s take another look at the `Option<T>` enum that the standard
library provides, which we used in Chapter 6:
-->
<p>構造体のように、列挙子にジェネリックなデータ型を保持するenumを定義することができます。
標準ライブラリが提供している<code>Option&lt;T&gt;</code> enumをもう一度見ましょう。このenumは第6章で使用しました:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<!--
This definition should now make more sense to you. As you can see, `Option<T>`
is an enum that is generic over type `T` and has two variants: `Some`, which
holds one value of type `T`, and a `None` variant that doesn’t hold any value.
By using the `Option<T>` enum, we can express the abstract concept of having an
optional value, and because `Option<T>` is generic, we can use this abstraction
no matter what the type of the optional value is.
-->
<p>この定義はもう、あなたにとってより道理が通っているはずです。ご覧の通り、<code>Option&lt;T&gt;</code>は、
型<code>T</code>に関してジェネリックで2つの列挙子のあるenumです: その列挙子は、型<code>T</code>の値を保持する<code>Some</code>と、
値を何も保持しない<code>None</code>です。<code>Option&lt;T&gt;</code> enumを使用することで、オプショナルな値があるという抽象的な概念を表現でき、
<code>Option&lt;T&gt;</code>はジェネリックなので、オプショナルな値の型に関わらず、この抽象を使用できます。</p>
<!--
Enums can use multiple generic types as well. The definition of the `Result`
enum that we used in Chapter 9 is one example:
-->
<p>enumも複数のジェネリックな型を使用できます。第9章で使用した<code>Result</code> enumの定義が一例です:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Result` enum is generic over two types, `T` and `E`, and has two variants:
`Ok`, which holds a value of type `T`, and `Err`, which holds a value of type
`E`. This definition makes it convenient to use the `Result` enum anywhere we
have an operation that might succeed (return a value of some type `T`) or fail
(return an error of some type `E`). In fact, this is what we used to open a
file in Listing 9-3, where `T` was filled in with the type `std::fs::File` when
the file was opened successfully and `E` was filled in with the type
`std::io::Error` when there were problems opening the file.
-->
<p><code>Result</code> enumは2つの型<code>T</code>、<code>E</code>に関してジェネリックで、2つの列挙子があります: 型<code>T</code>の値を保持する<code>Ok</code>と、
型<code>E</code>の値を保持する<code>Err</code>です。この定義により、<code>Result</code> enumを、成功する(なんらかの型<code>T</code>の値を返す)か、
失敗する(なんらかの型<code>E</code>のエラーを返す)可能性のある処理がある、あらゆる箇所に使用するのが便利になります。
事実、ファイルを開くのに成功した時に<code>T</code>に型<code>std::fs::File</code>が入り、ファイルを開く際に問題があった時に<code>E</code>に型<code>std::io::Error</code>が入ったものが、
リスト9-3でファイルを開くのに使用したものです。</p>
<!--
When you recognize situations in your code with multiple struct or enum
definitions that differ only in the types of the values they hold, you can
avoid duplication by using generic types instead.
-->
<p>自分のコード内で、保持している値の型のみが異なる構造体やenum定義の場面を認識したら、
代わりにジェネリックな型を使用することで重複を避けることができます。</p>
<!--
### In Method Definitions
-->
<h3 id="メソッド定義では"><a class="header" href="#メソッド定義では">メソッド定義では</a></h3>
<!--
We can implement methods on structs and enums (as we did in Chapter 5) and use
generic types in their definitions, too. Listing 10-9 shows the `Point<T>`
struct we defined in Listing 10-6 with a method named `x` implemented on it.
-->
<p>(第5章のように、)定義にジェネリックな型を使うメソッドを構造体やenumに実装することもできます。リスト10-9は、
リスト10-6で定義した<code>Point&lt;T&gt;</code>構造体に<code>x</code>というメソッドを実装したものを示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-9: Implementing a method named `x` on the
`Point<T>` struct that will return a reference to the `x` field of type
`T`</span>
-->
<p><span class="caption">リスト10-9: 型<code>T</code>の<code>x</code>フィールドへの参照を返す<code>x</code>というメソッドを<code>Point&lt;T&gt;</code>構造体に実装する</span></p>
<!--
Here, we’ve defined a method named `x` on `Point<T>` that returns a reference
to the data in the field `x`.
-->
<p>ここで、フィールド<code>x</code>のデータへの参照を返す<code>x</code>というメソッドを<code>Point&lt;T&gt;</code>に定義しました。</p>
<!--
Note that we have to declare `T` just after `impl` so we can use it to specify
that we’re implementing methods on the type `Point<T>`. By declaring `T` as a
generic type after `impl`, Rust can identify that the type in the angle
brackets in `Point` is a generic type rather than a concrete type.
-->
<p><code>impl</code>の直後に<code>T</code>を宣言しなければならないことに注意してください。こうすることで、型<code>Point&lt;T&gt;</code>にメソッドを実装していることを指定するために、<code>T</code>を使用することができます。
<code>impl</code>の後に<code>T</code>をジェネリックな型として宣言することで、コンパイラは、<code>Point</code>の山カッコ内の型が、
具体的な型ではなくジェネリックな型であることを認識できるのです。</p>
<!--
We could, for example, implement methods only on `Point<f32>` instances rather
than on `Point<T>` instances with any generic type. In Listing 10-10 we use the
concrete type `f32`, meaning we don’t declare any types after `impl`.
-->
<p>例えば、ジェネリックな型を持つ<code>Point&lt;T&gt;</code>インスタンスではなく、<code>Point&lt;f32&gt;</code>だけにメソッドを実装することもできるでしょう。
リスト10-10では、具体的な型<code>f32</code>を使用しています。つまり、<code>impl</code>の後に型を宣言しません。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-10: An `impl` block that only applies to a
struct with a particular concrete type for the generic type parameter `T`</span>
-->
<p><span class="caption">リスト10-10: ジェネリックな型引数<code>T</code>に対して特定の具体的な型がある構造体にのみ適用される<code>impl</code>ブロック</span></p>
<!--
This code means the type `Point<f32>` will have a method named
`distance_from_origin` and other instances of `Point<T>` where `T` is not of
type `f32` will not have this method defined. The method measures how far our
point is from the point at coordinates (0.0, 0.0) and uses mathematical
operations that are available only for floating point types.
-->
<p>このコードは、<code>Point&lt;f32&gt;</code>には<code>distance_from_origin</code>というメソッドが存在するが、
<code>T</code>が<code>f32</code>ではない<code>Point&lt;T&gt;</code>の他のインスタンスにはこのメソッドが定義されないことを意味します。
このメソッドは、この点が座標(0.0, 0.0)の点からどれだけ離れているかを測定し、
浮動小数点数にのみ利用可能な数学的処理を使用します。</p>
<!--
Generic type parameters in a struct definition aren’t always the same as those
you use in that struct’s method signatures. For example, Listing 10-11 defines
the method `mixup` on the `Point<T, U>` struct from Listing 10-8. The method
takes another `Point` as a parameter, which might have different types than the
`self` `Point` we’re calling `mixup` on. The method creates a new `Point`
instance with the `x` value from the `self` `Point` (of type `T`) and the `y`
value from the passed-in `Point` (of type `W`).
-->
<p>構造体定義のジェネリックな型引数は、必ずしもその構造体のメソッドシグニチャで使用するものと同じにはなりません。
例を挙げれば、リスト10-11は、リスト10-8の<code>Point&lt;T, U&gt;</code>にメソッド<code>mixup</code>を定義しています。
このメソッドは、他の<code>Point</code>を引数として取り、この引数は<code>mixup</code>を呼び出している<code>self</code>の<code>Point</code>とは異なる型の可能性があります。
このメソッドは、(型<code>T</code>の)<code>self</code>の<code>Point</code>の<code>x</code>値と渡した(型<code>W</code>の)<code>Point</code>の<code>y</code>値から新しい<code>Point</code>インスタンスを生成します。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-11: A method that uses different generic types
than its struct’s definition</span>
-->
<p><span class="caption">リスト10-11: 構造体定義とは異なるジェネリックな型を使用するメソッド</span></p>
<!--
In `main`, we’ve defined a `Point` that has an `i32` for `x` (with value `5`)
and an `f64` for `y` (with value `10.4`). The `p2` variable is a `Point` struct
that has a string slice for `x` (with value `"Hello"`) and a `char` for `y`
(with value `c`). Calling `mixup` on `p1` with the argument `p2` gives us `p3`,
which will have an `i32` for `x`, because `x` came from `p1`. The `p3` variable
will have a `char` for `y`, because `y` came from `p2`. The `println!` macro
call will print `p3.x = 5, p3.y = c`.
-->
<p><code>main</code>で、<code>x</code>(値は<code>5</code>)に<code>i32</code>、<code>y</code>(値は<code>10.4</code>)に<code>f64</code>を持つ<code>Point</code>を定義しました。<code>p2</code>変数は、
<code>x</code>(値は<code>&quot;Hello&quot;</code>)に文字列スライス、<code>y</code>(値は<code>c</code>)に<code>char</code>を持つ<code>Point</code>構造体です。
引数<code>p2</code>で<code>p1</code>に<code>mixup</code>を呼び出すと、<code>p3</code>が得られ、<code>x</code>は<code>i32</code>になります。<code>x</code>は<code>p1</code>由来だからです。
<code>p3</code>変数の<code>y</code>は、<code>char</code>になります。<code>y</code>は<code>p2</code>由来だからです。<code>println!</code>マクロの呼び出しは、
<code>p3.x = 5, p3.y = c</code>と出力するでしょう。</p>
<!--
The purpose of this example is to demonstrate a situation in which some generic
parameters are declared with `impl` and some are declared with the method
definition. Here, the generic parameters `T` and `U` are declared after `impl`,
because they go with the struct definition. The generic parameters `V` and `W`
are declared after `fn mixup`, because they’re only relevant to the method.
-->
<p>この例の目的は、一部のジェネリックな引数は<code>impl</code>で宣言され、他の一部はメソッド定義で宣言される場面をデモすることです。
ここで、ジェネリックな引数<code>T</code>と<code>U</code>は<code>impl</code>の後に宣言されています。構造体定義にはまるからです。
ジェネリックな引数<code>V</code>と<code>W</code>は<code>fn mixup</code>の後に宣言されています。何故なら、このメソッドにしか関係ないからです。</p>
<!--
### Performance of Code Using Generics
-->
<h3 id="ジェネリクスを使用したコードのパフォーマンス"><a class="header" href="#ジェネリクスを使用したコードのパフォーマンス">ジェネリクスを使用したコードのパフォーマンス</a></h3>
<!--
You might be wondering whether there is a runtime cost when you’re using
generic type parameters. The good news is that Rust implements generics in such
a way that your code doesn’t run any slower using generic types than it would
with concrete types.
-->
<p>ジェネリックな型引数を使用すると、実行時にコストが発生するのかな、と思うかもしれません。
嬉しいことにRustでは、ジェネリクスを、具体的な型があるコードよりもジェネリックな型を使用したコードを実行するのが遅くならないように実装しています。</p>
<!--
Rust accomplishes this by performing monomorphization of the code that is using
generics at compile time. *Monomorphization* is the process of turning generic
code into specific code by filling in the concrete types that are used when
compiled.
-->
<p>コンパイラはこれを、ジェネリクスを使用しているコードの単相化をコンパイル時に行うことで達成しています。
<em>単相化</em>(monomorphization)は、コンパイル時に使用されている具体的な型を入れることで、
ジェネリックなコードを特定のコードに変換する過程のことです。</p>
<!--
In this process, the compiler does the opposite of the steps we used to create
the generic function in Listing 10-5: the compiler looks at all the places
where generic code is called and generates code for the concrete types the
generic code is called with.
-->
<p>この過程において、コンパイラは、リスト10-5でジェネリックな関数を生成するために使用した手順と真逆のことをしています:
コンパイラは、ジェネリックなコードが呼び出されている箇所全部を見て、
ジェネリックなコードが呼び出されている具体的な型のコードを生成するのです。</p>
<!--
Let’s look at how this works with an example that uses the standard library’s
`Option<T>` enum:
-->
<p>標準ライブラリの<code>Option&lt;T&gt;</code> enumを使用する例でこれが動作する方法を見ましょう:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<!--
When Rust compiles this code, it performs monomorphization. During that
process, the compiler reads the values that have been used in `Option<T>`
instances and identifies two kinds of `Option<T>`: one is `i32` and the other
is `f64`. As such, it expands the generic definition of `Option<T>` into
`Option_i32` and `Option_f64`, thereby replacing the generic definition with
the specific ones.
-->
<p>コンパイラがこのコードをコンパイルすると、単相化を行います。その過程で、コンパイラは<code>Option&lt;T&gt;</code>のインスタンスに使用された値を読み取り、
2種類の<code>Option&lt;T&gt;</code>を識別します: 一方は<code>i32</code>で、もう片方は<code>f64</code>です。そのように、
コンパイラは、<code>Option&lt;T&gt;</code>のジェネリックな定義を<code>Option_i32</code>と<code>Option_f64</code>に展開し、
それにより、ジェネリックな定義を特定の定義と置き換えます。</p>
<!--
The monomorphized version of the code looks like the following. The generic
`Option<T>` is replaced with the specific definitions created by the compiler:
-->
<p>単相化されたバージョンのコードは、以下のようになります。ジェネリックな<code>Option&lt;T&gt;</code>が、
コンパイラが生成した特定の定義に置き換えられています:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<!--
Because Rust compiles generic code into code that specifies the type in each
instance, we pay no runtime cost for using generics. When the code runs, it
performs just as it would if we had duplicated each definition by hand. The
process of monomorphization makes Rust’s generics extremely efficient at
runtime.
-->
<p>Rustでは、ジェネリックなコードを各インスタンスで型を指定したコードにコンパイルするので、
ジェネリクスを使用することに対して実行時コストを払うことはありません。コードを実行すると、
それぞれの定義を手作業で複製した時のように振る舞います。単相化の過程により、
Rustのジェネリクスは実行時に究極的に効率的になるのです。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Traits: Defining Shared Behavior
-->
<h2 id="トレイト-共通の振る舞いを定義する"><a class="header" href="#トレイト-共通の振る舞いを定義する">トレイト: 共通の振る舞いを定義する</a></h2>
<!--
A *trait* tells the Rust compiler about functionality a particular type has and
can share with other types. We can use traits to define shared behavior in an
abstract way. We can use trait bounds to specify that a generic can be any type
that has certain behavior.
-->
<p><em>トレイト</em>は、Rustコンパイラに、特定の型に存在し、他の型と共有できる機能について知らせます。
トレイトを使用すると、共通の振る舞いを抽象的に定義できます。トレイト境界を使用すると、
あるジェネリックが、特定の振る舞いをもつあらゆる型になり得ることを指定できます。</p>
<!--
> Note: Traits are similar to a feature often called *interfaces* in other
> languages, although with some differences.
-->
<blockquote>
<p>注釈: 違いはあるものの、トレイトは他の言語でよくインターフェイスと呼ばれる機能に類似しています。</p>
</blockquote>
<!--
### Defining a Trait
-->
<h3 id="トレイトを定義する"><a class="header" href="#トレイトを定義する">トレイトを定義する</a></h3>
<!--
A type’s behavior consists of the methods we can call on that type. Different
types share the same behavior if we can call the same methods on all of those
types. Trait definitions are a way to group method signatures together to
define a set of behaviors necessary to accomplish some purpose.
-->
<p>型の振る舞いは、その型に対して呼び出せるメソッドから構成されます。異なる型は、それらの型全てに対して同じメソッドを呼び出せるなら、
同じ振る舞いを共有することになります。トレイト定義は、メソッドシグニチャをあるグループにまとめ、なんらかの目的を達成するのに必要な一連の振る舞いを定義する手段です。</p>
<!--
For example, let’s say we have multiple structs that hold various kinds and
amounts of text: a `NewsArticle` struct that holds a news story filed in a
particular location and a `Tweet` that can have at most 280 characters along
with metadata that indicates whether it was a new tweet, a retweet, or a reply
to another tweet.
-->
<p>例えば、いろんな種類や量のテキストを保持する複数の構造体があるとしましょう: 特定の場所から送られる新しいニュースを保持する<code>NewsArticle</code>と、
新規ツイートか、リツイートか、はたまた他のツイートへのリプライなのかを示すメタデータを伴う最大で280文字までの<code>Tweet</code>です。</p>
<!--
We want to make a media aggregator library that can display summaries of data
that might be stored in a `NewsArticle` or `Tweet` instance. To do this, we
need a summary from each type, and we need to request that summary by calling a
`summarize` method on an instance. Listing 10-12 shows the definition of a
`Summary` trait that expresses this behavior.
-->
<p><code>NewsArticle</code> または <code>Tweet</code> インスタンスに保存されているデータのサマリーを表示できるメディア アグリゲータ ライブラリを作成します。
これをするには、各型のサマリーが必要で、インスタンスで <code>summarize</code> メソッドを呼び出してサマリーを要求する必要があります。
リスト10-12は、この振る舞いを表現する<code>Summary</code>トレイトの定義を表示しています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-12: A `Summary` trait that consists of the
behavior provided by a `summarize` method</span>
-->
<p><span class="caption">リスト10-12: <code>summarize</code>メソッドで提供される振る舞いからなる<code>Summary</code>トレイト</span></p>
<!--
Here, we declare a trait using the `trait` keyword and then the trait’s name,
which is `Summary` in this case. Inside the curly brackets, we declare the
method signatures that describe the behaviors of the types that implement this
trait, which in this case is `fn summarize(&self) -> String`.
-->
<p>ここでは、<code>trait</code>キーワード、それからトレイト名を使用してトレイトを定義していて、その名前は今回の場合、
<code>Summary</code>です。波括弧の中にこのトレイトを実装する型の振る舞いを記述するメソッドシグニチャを定義し、
今回の場合は、<code>fn summarize(&amp;self) -&gt; String</code>です。</p>
<!--
After the method signature, instead of providing an implementation within curly
brackets, we use a semicolon. Each type implementing this trait must provide
its own custom behavior for the body of the method. The compiler will enforce
that any type that has the `Summary` trait will have the method `summarize`
defined with this signature exactly.
-->
<p>メソッドシグニチャの後に、波括弧内に実装を提供する代わりに、セミコロンを使用しています。
このトレイトを実装する型はそれぞれ、メソッドの本体に独自の振る舞いを提供しなければなりません。
コンパイラにより、<code>Summary</code>トレイトを保持するあらゆる型に、このシグニチャと全く同じメソッド<code>summarize</code>が定義されていることが
強制されます。</p>
<!--
A trait can have multiple methods in its body: the method signatures are listed
one per line and each line ends in a semicolon.
-->
<p>トレイトには、本体に複数のメソッドを含むことができます: メソッドシグニチャは行ごとに並べられ、
各行はセミコロンで終わります。</p>
<!--
### Implementing a Trait on a Type
-->
<h3 id="トレイトを型に実装する"><a class="header" href="#トレイトを型に実装する">トレイトを型に実装する</a></h3>
<!--
Now that we’ve defined the desired behavior using the `Summary` trait, we can
implement it on the types in our media aggregator. Listing 10-13 shows an
implementation of the `Summary` trait on the `NewsArticle` struct that uses the
headline, the author, and the location to create the return value of
`summarize`. For the `Tweet` struct, we define `summarize` as the username
followed by the entire text of the tweet, assuming that tweet content is
already limited to 280 characters.
-->
<p>今や <code>Summary</code> トレイトを使用して目的の動作を定義できたので、メディア アグリゲータでこれを型に実装できます。
リスト10-13は、 <code>Summary</code> トレイトを <code>NewsArticle</code> 構造体上に実装したもので、ヘッドライン、著者、そして地域情報を使って<code>summarize</code> の戻り値を作っています。
<code>Tweet</code> 構造体に関しては、ツイートの内容が既に280文字に制限されていると仮定して、ユーザー名の後にツイートのテキスト全体が続くものとして <code>summarize</code> を定義します。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-13: Implementing the `Summary` trait on the
`NewsArticle` and `Tweet` types</span>
-->
<p><span class="caption">リスト10-13: <code>Summary</code>トレイトを<code>NewsArticle</code>と<code>Tweet</code>型に実装する</span></p>
<!--
Implementing a trait on a type is similar to implementing regular methods. The
difference is that after `impl`, we put the trait name that we want to
implement, then use the `for` keyword, and then specify the name of the type we
want to implement the trait for. Within the `impl` block, we put the method
signatures that the trait definition has defined. Instead of adding a semicolon
after each signature, we use curly brackets and fill in the method body with
the specific behavior that we want the methods of the trait to have for the
particular type.
-->
<p>型にトレイトを実装することは、普通のメソッドを実装することに似ています。違いは、<code>impl</code>の後に、
実装したいトレイトの名前を置き、それから<code>for</code>キーワード、さらにトレイトの実装対象の型の名前を指定することです。
<code>impl</code>ブロック内に、トレイト定義で定義したメソッドシグニチャを置きます。各シグニチャの後にセミコロンを追記するのではなく、
波括弧を使用し、メソッド本体に特定の型のトレイトのメソッドに欲しい特定の振る舞いを入れます。</p>
<!--
After implementing the trait, we can call the methods on instances of
`NewsArticle` and `Tweet` in the same way we call regular methods, like this:
-->
<p>トレイトを実装後、普通のメソッド同様に<code>NewsArticle</code>や<code>Tweet</code>のインスタンスに対してこのメソッドを呼び出せます。
こんな感じで:</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            // もちろん、ご存知かもしれませんがね、みなさん
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<!--
This code prints `1 new tweet: horse_ebooks: of course, as you probably already
know, people`.
-->
<p>このコードは、<code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>と出力します。</p>
<!--
Note that because we defined the `Summary` trait and the `NewsArticle` and
`Tweet` types in the same *lib.rs* in Listing 10-13, they’re all in the same
scope. Let’s say this *lib.rs* is for a crate we’ve called `aggregator` and
someone else wants to use our crate’s functionality to implement the `Summary`
trait on a struct defined within their library’s scope. They would need to
bring the trait into their scope first. They would do so by specifying `use
aggregator::Summary;`, which then would enable them to implement `Summary` for
their type. The `Summary` trait would also need to be a public trait for
another crate to implement it, which it is because we put the `pub` keyword
before `trait` in Listing 10-12.
-->
<p>リスト10-13で<code>Summary</code>トレイトと<code>NewArticle</code>、<code>Tweet</code>型を同じ<em>lib.rs</em>に定義したので、
全部同じスコープにあることに注目してください。この<em>lib.rs</em>を<code>aggregator</code>と呼ばれるクレート専用にして、
誰か他の人が私たちのクレートの機能を活用して自分のライブラリのスコープに定義された構造体に<code>Summary</code>トレイトを実装したいとしましょう。
まず、トレイトをスコープに取り込む必要があるでしょう。<code>use aggregator::Summary;</code>と指定してそれを行えば、
これにより、自分の型に<code>Summary</code>を実装することが可能になるでしょう。<code>Summary</code>トレイトは、
他のクレートが実装するためには、公開トレイトである必要があり、ここでは、リスト10-12の<code>trait</code>の前に、
<code>pub</code>キーワードを置いたのでそうなっています。</p>
<!--
One restriction to note with trait implementations is that we can implement a
trait on a type only if either the trait or the type is local to our crate.
For example, we can implement standard library traits like `Display` on a
custom type like `Tweet` as part of our `aggregator` crate functionality,
because the type `Tweet` is local to our `aggregator` crate. We can also
implement `Summary` on `Vec<T>` in our `aggregator` crate, because the
trait `Summary` is local to our `aggregator` crate.
-->
<p>トレイト実装で注意すべき制限の1つは、トレイトか対象の型が自分のクレートに固有(local)である時のみ、
型に対してトレイトを実装できるということです。例えば、<code>Display</code>のような標準ライブラリのトレイトを<code>aggregator</code>クレートの機能の一部として、
<code>Tweet</code>のような独自の型に実装できます。型<code>Tweet</code>が<code>aggregator</code>クレートに固有だからです。
また、<code>Summary</code>を<code>aggregator</code>クレートで<code>Vec&lt;T&gt;</code>に対して実装することもできます。
トレイト<code>Summary</code>は、<code>aggregator</code>クレートに固有だからです。</p>
<!--
But we can’t implement external traits on external types. For example, we can’t
implement the `Display` trait on `Vec<T>` within our `aggregator` crate,
because `Display` and `Vec<T>` are defined in the standard library and aren’t
local to our `aggregator` crate. This restriction is part of a property of
programs called *coherence*, and more specifically the *orphan rule*, so named
because the parent type is not present. This rule ensures that other people’s
code can’t break your code and vice versa. Without the rule, two crates could
implement the same trait for the same type, and Rust wouldn’t know which
implementation to use.
-->
<p>しかし、外部のトレイトを外部の型に対して実装することはできません。例として、
<code>aggregator</code>クレート内で<code>Vec&lt;T&gt;</code>に対して<code>Display</code>トレイトを実装することはできません。
<code>Display</code>と<code>Vec&lt;T&gt;</code>は標準ライブラリで定義され、<code>aggregator</code>クレートに固有ではないからです。
この制限は、<em>コヒーレンス</em>(coherence)、特に<em>孤児のルール</em>(orphan rule)と呼ばれるプログラムの特性の一部で、
親の型が存在しないためにそう命名されました。この規則により、他の人のコードが自分のコードを壊したり、
その逆が起きないことを保証してくれます。この規則がなければ、2つのクレートが同じ型に対して同じトレイトを実装できてしまい、
コンパイラはどちらの実装を使うべきかわからなくなってしまうでしょう。</p>
<!--
### Default Implementations
-->
<h3 id="デフォルト実装"><a class="header" href="#デフォルト実装">デフォルト実装</a></h3>
<!--
Sometimes it’s useful to have default behavior for some or all of the methods
in a trait instead of requiring implementations for all methods on every type.
Then, as we implement the trait on a particular type, we can keep or override
each method’s default behavior.
-->
<p>時として、全ての型の全メソッドに対して実装を要求するのではなく、トレイトの全てあるいは一部のメソッドに対してデフォルトの振る舞いがあると有用です。
そうすれば、特定の型にトレイトを実装する際、各メソッドのデフォルト実装を保持するかオーバーライドするか選べるわけです。</p>
<!--
Listing 10-14 shows how to specify a default string for the `summarize` method
of the `Summary` trait instead of only defining the method signature, as we did
in Listing 10-12.
-->
<p>リスト10-14は、リスト10-12のように、メソッドシグニチャだけを定義するのではなく、
<code>Summary</code>トレイトの<code>summarize</code>メソッドにデフォルトの文字列を指定する方法を示しています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        // &quot;（もっと読む）&quot;
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-14: Definition of a `Summary` trait with a
default implementation of the `summarize` method</span>
-->
<p><span class="caption">リスト10-14: <code>summarize</code>メソッドのデフォルト実装がある<code>Summary</code>トレイトの定義</span></p>
<!--
To use a default implementation to summarize instances of `NewsArticle` instead
of defining a custom implementation, we specify an empty `impl` block with
`impl Summary for NewsArticle {}`.
-->
<p>独自の実装を定義するのではなく、デフォルト実装を利用して<code>NewsArticle</code>のインスタンスをまとめるには、
<code>impl Summary for NewsArticle {}</code>と空の<code>impl</code>ブロックを指定します。</p>
<!--
Even though we’re no longer defining the `summarize` method on `NewsArticle`
directly, we’ve provided a default implementation and specified that
`NewsArticle` implements the `Summary` trait. As a result, we can still call
the `summarize` method on an instance of `NewsArticle`, like this:
-->
<p>もはや<code>NewsArticle</code>に直接<code>summarize</code>メソッドを定義してはいませんが、私達はデフォルト実装を提供しており、
<code>NewsArticle</code>は<code>Summary</code>トレイトを実装すると指定しました。そのため、
<code>NewsArticle</code>のインスタンスに対して<code>summarize</code>メソッドを同じように呼び出すことができます。
このように:</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        // ペンギンチームがスタンレーカップチャンピオンシップを勝ち取る！
        headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
        // アメリカ、ペンシルベニア州、ピッツバーグ
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        // アイスバーグ
        author: String::from(&quot;Iceburgh&quot;),
        // ピッツバーグ・ペンギンが再度NHL(National Hockey League)で最強のホッケーチームになった
        content: String::from(
            &quot;The Pittsburgh Penguins once again are the best \
             hockey team in the NHL.&quot;,
        ),
    };

    println!(&quot;New article available! {}&quot;, article.summarize());
<span class="boring">}
</span></code></pre>
<!--
This code prints `New article available! (Read more...)`.
-->
<p>このコードは、<code>New article available! (Read more...)</code>（<code>新しい記事があります！（もっと読む）</code>）と出力します。</p>
<!--
Creating a default implementation for `summarize` doesn’t require us to change
anything about the implementation of `Summary` on `Tweet` in Listing 10-13. The
reason is that the syntax for overriding a default implementation is the same
as the syntax for implementing a trait method that doesn’t have a default
implementation.
-->
<p><code>summarize</code>にデフォルト実装を用意しても、リスト10-13の<code>Tweet</code>の<code>Summary</code>実装を変える必要はありません。
理由は、デフォルト実装をオーバーライドする記法はデフォルト実装のないトレイトメソッドを実装する記法と同じだからです。</p>
<!--
Default implementations can call other methods in the same trait, even if those
other methods don’t have a default implementation. In this way, a trait can
provide a lot of useful functionality and only require implementors to specify
a small part of it. For example, we could define the `Summary` trait to have a
`summarize_author` method whose implementation is required, and then define a
`summarize` method that has a default implementation that calls the
`summarize_author` method:
-->
<p>デフォルト実装は、自らのトレイトのデフォルト実装を持たない他のメソッドを呼び出すことができます。
このようにすれば、トレイトは多くの有用な機能を提供しつつ、実装者は僅かな部分しか指定しなくて済むようになります。
例えば、<code>Summary</code>トレイトを、（実装者が）内容を実装しなければならない<code>summarize_author</code>メソッドを持つように定義し、
それから<code>summarize_author</code>メソッドを呼び出すデフォルト実装を持つ<code>summarize</code>メソッドを定義することもできます:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        // &quot;（{}さんの文章をもっと読む）&quot;
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;@{}&quot;, self.username)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<!--
To use this version of `Summary`, we only need to define `summarize_author`
when we implement the trait on a type:
-->
<p>このバージョンの<code>Summary</code>を使用するために、型にトレイトを実装する際、実装する必要があるのは<code>summarize_author</code>だけです:</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        // &quot;（{}さんの文章をもっと読む）&quot;
</span><span class="boring">        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<!--
After we define `summarize_author`, we can call `summarize` on instances of the
`Tweet` struct, and the default implementation of `summarize` will call the
definition of `summarize_author` that we’ve provided. Because we’ve implemented
`summarize_author`, the `Summary` trait has given us the behavior of the
`summarize` method without requiring us to write any more code.
-->
<p><code>summarize_author</code>定義後、<code>Tweet</code>構造体のインスタンスに対して<code>summarize</code>を呼び出せ、
<code>summarize</code>のデフォルト実装は、私達が提供した<code>summarize_author</code>の定義を呼び出すでしょう。
<code>summarize_author</code>を実装したので、追加のコードを書く必要なく、<code>Summary</code>トレイトは、
<code>summarize</code>メソッドの振る舞いを与えてくれました。</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<!--
This code prints `1 new tweet: (Read more from @horse_ebooks...)`.
-->
<p>このコードは、<code>1 new tweet: (Read more from @horse_ebooks...)</code>（<code>1つの新しいツイート：（@horse_ebooksさんの文章をもっと読む）</code>）と出力します。</p>
<!--
Note that it isn’t possible to call the default implementation from an
overriding implementation of that same method.
-->
<p>デフォルト実装を、そのメソッドをオーバーライドしている実装から呼び出すことはできないことに注意してください。</p>
<!--
### Traits as Parameters
-->
<h3 id="引数としてのトレイト"><a class="header" href="#引数としてのトレイト">引数としてのトレイト</a></h3>
<!--
Now that you know how to define and implement traits, we can explore how to use
traits to define functions that accept many different types.
-->
<p>トレイトを定義し実装する方法はわかったので、トレイトを使っていろんな種類の型を受け付ける関数を定義する方法を学んでいきましょう。</p>
<!--
For example, in Listing 10-13, we implemented the `Summary` trait on the
`NewsArticle` and `Tweet` types. We can define a `notify` function that calls
the `summarize` method on its `item` parameter, which is of some type that
implements the `Summary` trait. To do this, we can use the `impl Trait`
syntax, like this:
-->
<p>たとえば、Listing 10-13では、<code>NewsArticle</code>と<code>Tweet</code>型に<code>Summary</code>トレイトを実装しました。
ここで、引数の<code>item</code>の<code>summarize</code>メソッドを呼ぶ関数<code>notify</code>を定義することができます。ただし、引数<code>item</code>は<code>Summary</code>トレイトを実装しているような何らかの型であるとします。
このようなことをするためには、<code>impl Trait</code>構文を使うことができます。</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<!--
Instead of a concrete type for the `item` parameter, we specify the `impl`
keyword and the trait name. This parameter accepts any type that implements the
specified trait. In the body of `notify`, we can call any methods on `item`
that come from the `Summary` trait, such as `summarize`. We can call `notify`
and pass in any instance of `NewsArticle` or `Tweet`. Code that calls the
function with any other type, such as a `String` or an `i32`, won’t compile
because those types don’t implement `Summary`.
-->
<p>引数の<code>item</code>には、具体的な型の代わりに、<code>impl</code>キーワードとトレイト名を指定します。
この引数は、指定されたトレイトを実装しているあらゆる型を受け付けます。
<code>notify</code>の中身では、<code>summarize</code>のような、<code>Summary</code>トレイトに由来する<code>item</code>のあらゆるメソッドを呼び出すことができます。
私達は、<code>notify</code>を呼びだし、<code>NewsArticle</code>か<code>Tweet</code>のどんなインスタンスでも渡すことができます。
この関数を呼び出すときに、<code>String</code>や<code>i32</code>のような他の型を渡すようなコードはコンパイルできません。
なぜなら、これらの型は<code>Summary</code>を実装していないからです。</p>
<!--
#### Trait Bound Syntax
-->
<h4 id="トレイト境界構文"><a class="header" href="#トレイト境界構文">トレイト境界構文</a></h4>
<!--
The `impl Trait` syntax works for straightforward cases but is actually
syntax sugar for a longer form, which is called a *trait bound*; it looks like
this:
-->
<p><code>impl Trait</code>構文は単純なケースを解決しますが、実はより長い<em>トレイト境界 (trait bound)</em> と呼ばれる姿の糖衣構文 (syntax sugar) なのです。
それは以下のようなものです：</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
	// 速報！ {}
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<!--
This longer form is equivalent to the example in the previous section but is
more verbose. We place trait bounds with the declaration of the generic type
parameter after a colon and inside angle brackets.
-->
<p>この「より長い」姿は前節の例と等価ですが、より冗長です。
山カッコの中にジェネリックな型引数の宣言を書き、型引数の後ろにコロンを挟んでトレイト境界を置いています。</p>
<!--
The `impl Trait` syntax is convenient and makes for more concise code in simple
cases. The trait bound syntax can express more complexity in other cases. For
example, we can have two parameters that implement `Summary`. Using the `impl
Trait` syntax looks like this:
-->
<p>簡単なケースに対し、<code>impl Trait</code>構文は便利で、コードを簡潔にしてくれます。
そうでないケースの場合、トレイト境界構文を使えば複雑な状態を表現できます。
たとえば、<code>Summary</code>を実装する2つのパラメータを持つような関数を考えることができます。
<code>impl Trait</code>構文を使うとこのようになるでしょう：</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
</code></pre>
<!--
If we wanted this function to allow `item1` and `item2` to have different
types, using `impl Trait` would be appropriate (as long as both types implement
`Summary`). If we wanted to force both parameters to have the same type, that’s
only possible to express using a trait bound, like this:
-->
<p>この関数が受け取る<code>item1</code>と<code>item2</code>の型が（どちらも<code>Summary</code>を実装する限り）異なっても良いとするならば、<code>impl Trait</code>は適切でしょう。
両方の引数が同じ型であることを強制することは、以下のようにトレイト境界を使ってのみ表現可能です：</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
</code></pre>
<!--
The generic type `T` specified as the type of the `item1` and `item2`
parameters constrains the function such that the concrete type of the value
passed as an argument for `item1` and `item2` must be the same.
-->
<p>引数である<code>item1</code>と<code>item2</code>の型としてジェネリックな型<code>T</code>を指定しました。
これにより、<code>item1</code>と<code>item2</code>として関数に渡される値の具体的な型が同一でなければならない、という制約を与えています。</p>
<!--
#### Specifying Multiple Trait Bounds with the `+` Syntax
-->
<h4 id="複数のトレイト境界を構文で指定する"><a class="header" href="#複数のトレイト境界を構文で指定する">複数のトレイト境界を<code>+</code>構文で指定する</a></h4>
<!--
We can also specify more than one trait bound. Say we wanted `notify` to use
display formatting on `item` as well as the `summarize` method: we specify in
the `notify` definition that `item` must implement both `Display` and
`Summary`. We can do so using the `+` syntax:
-->
<p>複数のトレイト境界も指定できます。
たとえば、<code>notify</code>に<code>summarize</code>メソッドに加えて<code>item</code>の画面出力形式（ディスプレイフォーマット）を使わせたいとします。
その場合は、<code>notify</code>の定義に<code>item</code>は<code>Display</code>と<code>Summary</code>の両方を実装していなくてはならないと指定することになります。
これは、以下のように<code>+</code>構文で行うことができます：</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {
</code></pre>
<!--
The `+` syntax is also valid with trait bounds on generic types:
-->
<p><code>+</code>構文はジェネリック型につけたトレイト境界に対しても使えます：</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
</code></pre>
<!--
With the two trait bounds specified, the body of `notify` can call `summarize`
and use `{}` to format `item`.
-->
<p>これら2つのトレイト境界が指定されていれば、<code>notify</code>の中では<code>summarize</code>を呼び出すことと、<code>{}</code>を使って<code>item</code>をフォーマットすることの両方が行なえます。</p>
<!--
#### Clearer Trait Bounds with `where` Clauses
-->
<h4 id="where句を使ったより明確なトレイト境界"><a class="header" href="#where句を使ったより明確なトレイト境界"><code>where</code>句を使ったより明確なトレイト境界</a></h4>
<!--
Using too many trait bounds has its downsides. Each generic has its own trait
bounds, so functions with multiple generic type parameters can contain lots of
trait bound information between the function’s name and its parameter list,
making the function signature hard to read. For this reason, Rust has alternate
syntax for specifying trait bounds inside a `where` clause after the function
signature. So instead of writing this:
-->
<p>あまりたくさんのトレイト境界を使うことには欠点もあります。
それぞれのジェネリック（な型）がそれぞれのトレイト境界をもつので、複数のジェネリック型の引数をもつ関数は、関数名と引数リストの間に大量のトレイト境界に関する情報を含むことがあります。
これでは関数のシグネチャが読みにくくなってしまいます。
このため、Rustはトレイト境界を関数シグネチャの後の<code>where</code>句の中で指定するという別の構文を用意しています。
なので、このように書く：</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<!--
we can use a `where` clause, like this:
-->
<p>代わりに、<code>where</code>句を使い、このように書くことができます：</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<!--
This function’s signature is less cluttered: the function name, parameter list,
and return type are close together, similar to a function without lots of trait
bounds.
-->
<p>この関数シグニチャは、よりさっぱりとしています。トレイト境界を多く持たない関数と同じように、関数名、引数リスト、戻り値の型が一緒になって近くにあるからですね。</p>
<!--
### Returning Types that Implement Traits
-->
<h3 id="トレイトを実装している型を返す"><a class="header" href="#トレイトを実装している型を返す">トレイトを実装している型を返す</a></h3>
<!--
We can also use the `impl Trait` syntax in the return position to return a
value of some type that implements a trait, as shown here:
-->
<p>以下のように、<code>impl Trait</code>構文を戻り値型のところで使うことにより、あるトレイトを実装する何らかの型を返すことができます。</p>
<pre><code class="language-rust ignore"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;of course, as you probably already know, people&quot;,
        ),
        reply: false,
        retweet: false,
    }
}
</code></pre>
<!--
By using `impl Summary` for the return type, we specify that the
`returns_summarizable` function returns some type that implements the `Summary`
trait without naming the concrete type. In this case, `returns_summarizable`
returns a `Tweet`, but the code calling this function doesn’t know that.
-->
<p>戻り値の型として<code>impl Summary</code>を使うことにより、具体的な型が何かを言うことなく、<code>returns_summarizable</code>関数は<code>Summary</code>トレイトを実装している何らかの型を返すのだ、と指定することができます。
今回<code>returns_summarizable</code>は<code>Tweet</code>を返しますが、この関数を呼び出すコードはそのことを知りません。</p>
<!--
The ability to return a type that is only specified by the trait it implements
is especially useful in the context of closures and iterators, which we cover
in Chapter 13. Closures and iterators create types that only the compiler knows
or types that are very long to specify. The `impl Trait` syntax lets you
concisely specify that a function returns some type that implements the
`Iterator` trait without needing to write out a very long type.
-->
<p>実装しているトレイトだけで戻り値型を指定できることは、13章で学ぶ、クロージャとイテレータを扱うときに特に便利です。
クロージャとイテレータの作り出す型は、コンパイラだけが知っているものであったり、指定するには長すぎるものであったりします。
<code>impl Trait</code>構文を使えば、非常に長い型を書くことなく、ある関数は<code>Iterator</code>トレイトを実装するある型を返すのだ、と簡潔に指定することができます。</p>
<!--
However, you can only use `impl Trait` if you’re returning a single type. For
example, this code that returns either a `NewsArticle` or a `Tweet` with the
return type specified as `impl Summary` wouldn’t work:
-->
<p>ただし、<code>impl Trait</code>は一種類の型を返す場合にのみ使えます。
たとえば、以下のように、戻り値の型は<code>impl Summary</code>で指定しつつ、<code>NewsArticle</code>か<code>Tweet</code>を返すようなコードは失敗します：</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Penguins win the Stanley Cup Championship!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;of course, as you probably already know, people&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
</code></pre>
<!--
Returning either a `NewsArticle` or a `Tweet` isn’t allowed due to restrictions
around how the `impl Trait` syntax is implemented in the compiler. We’ll cover
how to write a function with this behavior in the [“Using Trait Objects That
Allow for Values of Different
Types”][using-trait-objects-that-allow-for-values-of-different-types] section of Chapter 17.
-->
<p><code>NewsArticle</code>か<code>Tweet</code>を返すというのは、コンパイラの<code>impl Trait</code>構文の実装まわりの制約により許されていません。
このような振る舞いをする関数を書く方法は、17章の<a href="ch17-02-trait-objects.html#%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%A7%E7%95%B0%E3%81%AA%E3%82%8B%E5%9E%8B%E3%81%AE%E5%80%A4%E3%82%92%E8%A8%B1%E5%AE%B9%E3%81%99%E3%82%8B">トレイトオブジェクトで異なる型の値を許容する</a>節で学びます。</p>
<!--
### Fixing the `largest` Function with Trait Bounds
-->
<h3 id="トレイト境界でlargest関数を修正する"><a class="header" href="#トレイト境界でlargest関数を修正する">トレイト境界で<code>largest</code>関数を修正する</a></h3>
<!--
Now that you know how to specify the behavior you want to use using the generic
type parameter’s bounds, let’s return to Listing 10-5 to fix the definition of
the `largest` function that uses a generic type parameter! Last time we tried
to run that code, we received this error:
-->
<p>ジェネリックな型引数の境界で使用したい振る舞いを指定する方法がわかったので、リスト10-5に戻って、
ジェネリックな型引数を使用する<code>largest</code>関数の定義を修正しましょう！最後にそのコードを実行しようとした時、
こんなエラーが出ていました:</p>
<pre><code class="language-text">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
In the body of `largest` we wanted to compare two values of type `T` using the
greater than (`>`) operator. Because that operator is defined as a default
method on the standard library trait `std::cmp::PartialOrd`, we need to specify
`PartialOrd` in the trait bounds for `T` so the `largest` function can work on
slices of any type that we can compare. We don’t need to bring `PartialOrd`
into scope because it’s in the prelude. Change the signature of `largest` to
look like this:
-->
<p><code>largest</code>の本体で、大なり演算子(<code>&gt;</code>)を使用して型<code>T</code>の2つの値を比較しようとしていました。この演算子は、
標準ライブラリトレイトの<code>std::cmp::PartialOrd</code>でデフォルトメソッドとして定義されているので、
<code>largest</code>関数が、比較できるあらゆる型のスライスに対して動くようにするためには、<code>T</code>のトレイト境界に<code>PartialOrd</code>を指定する必要があります。
<code>PartialOrd</code>はpreludeに含まれているので、これをスコープに導入する必要はありません。
<code>largest</code>のシグニチャを以下のように変えてください:</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
<span class="boring">    let mut largest = list[0];
</span><span class="boring">
</span><span class="boring">    for &amp;item in list {
</span><span class="boring">        if item &gt; largest {
</span><span class="boring">            largest = item;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    largest
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let number_list = vec![34, 50, 25, 100, 65];
</span><span class="boring">
</span><span class="boring">    let result = largest(&amp;number_list);
</span><span class="boring">    println!(&quot;The largest number is {}&quot;, result);
</span><span class="boring">
</span><span class="boring">    let char_list = vec!['y', 'm', 'a', 'q'];
</span><span class="boring">
</span><span class="boring">    let result = largest(&amp;char_list);
</span><span class="boring">    println!(&quot;The largest char is {}&quot;, result);
</span><span class="boring">}
</span></code></pre>
<!--
This time when we compile the code, we get a different set of errors:
-->
<p>今回のコンパイルでは、別のエラーが出てきます：</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
（エラー[E0508]： 型`[T]`をもつ、非コピーのスライスからのムーブはできません）
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       （ここからムーブすることはできません）
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       （ムーブが発生するのは、`list[_]`は`T`という、`Copy`トレイトを実装しない型であるためです）
  |                       help: consider borrowing here: `&amp;list[0]`
  |                       （助言：借用するようにしてみてはいかがですか： `&amp;list[0]`）

error[E0507]: cannot move out of a shared reference
（エラー[E0507]：共有の参照からムーブはできません）
 --&gt; src/main.rs:4:18
  |
4 |     for &amp;item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |（データがここでムーブされています）
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         |（ムーブが発生するのは、`item`は`T`という、`Copy`トレイトを実装しない型であるためです）
  |         help: consider removing the `&amp;`: `item`
  |         （助言：`&amp;`を取り除いてみてはいかがですか： `item`）

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The key line in this error is `cannot move out of type [T], a non-copy slice`.
With our non-generic versions of the `largest` function, we were only trying to
find the largest `i32` or `char`. As discussed in the [“Stack-Only Data:
Copy”][stack-only-data-copy] section in Chapter 4, types like
`i32` and `char` that have a known size can be stored on the stack, so they
implement the `Copy` trait. But when we made the `largest` function generic,
it became possible for the `list` parameter to have types in it that don’t
implement the `Copy` trait. Consequently, we wouldn’t be able to move the
value out of `list[0]` and into the `largest` variable, resulting in this
error.
-->
<p>このエラーの鍵となる行は、<code>cannot move out of type [T], a non-copy slice</code>です。
ジェネリックでないバージョンの<code>largest</code>関数では、最大の<code>i32</code>か<code>char</code>を探そうとするだけでした。
第4章の<a href="ch04-01-what-is-ownership.html#%E3%82%B9%E3%82%BF%E3%83%83%E3%82%AF%E3%81%AE%E3%81%BF%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF-%E3%82%B3%E3%83%94%E3%83%BC">スタックのみのデータ: コピー</a>節で議論したように、<code>i32</code>や<code>char</code>のようなサイズが既知の型は
スタックに格納できるので、<code>Copy</code>トレイトを実装しています。しかし、<code>largest</code>関数をジェネリックにすると、
<code>list</code>引数が<code>Copy</code>トレイトを実装しない型を含む可能性も出てきたのです。結果として、
<code>list[0]</code>から値を<code>largest</code>にムーブできず、このエラーに陥ったのです。</p>
<!--
To call this code with only those types that implement the `Copy` trait, we can
add `Copy` to the trait bounds of `T`! Listing 10-15 shows the complete code of
a generic `largest` function that will compile as long as the types of the
values in the slice that we pass into the function implement the `PartialOrd`
*and* `Copy` traits, like `i32` and `char` do.
-->
<p>このコードを<code>Copy</code>トレイトを実装する型だけを使って呼び出すようにしたいなら、<code>T</code>のトレイト境界に<code>Copy</code>を追加すればよいです！
リスト10-15は、関数に渡したスライスの値の型が、<code>i32</code>や<code>char</code>などのように<code>PartialOrd</code><em>と</em><code>Copy</code>を実装する限りコンパイルできる、ジェネリックな<code>largest</code>関数の完全なコードを示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-15: A working definition of the `largest`
function that works on any generic type that implements the `PartialOrd` and
`Copy` traits</span>
-->
<p><span class="caption">リスト10-15: <code>PartialOrd</code>と<code>Copy</code>トレイトを実装するあらゆるジェネリックな型に対して動く、
<code>largest</code>関数の実際の定義</span></p>
<!--
If we don’t want to restrict the `largest` function to the types that implement
the `Copy` trait, we could specify that `T` has the trait bound `Clone` instead
of `Copy`. Then we could clone each value in the slice when we want the
`largest` function to have ownership. Using the `clone` function means we’re
potentially making more heap allocations in the case of types that own heap
data like `String`, and heap allocations can be slow if we’re working with
large amounts of data.
-->
<p>もし<code>largest</code>関数を<code>Copy</code>を実装する型だけに制限したくなかったら、<code>T</code>が<code>Copy</code>ではなく<code>Clone</code>というトレイト境界を持つと指定することもできます。そうしたら、
<code>largest</code>関数に所有権が欲しい時にスライスの各値をクローンできます。<code>clone</code>関数を使用するということは、
<code>String</code>のようなヒープデータを持つ型の場合により多くのヒープ確保が発生する可能性があることを意味します。
そして、大量のデータを取り扱っていたら、ヒープ確保には時間がかかることもあります。</p>
<!--
Another way we could implement `largest` is for the function to return a
reference to a `T` value in the slice. If we change the return type to `&T`
instead of `T`, thereby changing the body of the function to return a
reference, we wouldn’t need the `Clone` or `Copy` trait bounds and we could
avoid heap allocations. Try implementing these alternate solutions on your own!
-->
<p><code>largest</code>の別の実装方法は、関数がスライスの<code>T</code>値への参照を返すようにすることです。
戻り値の型を<code>T</code>ではなく<code>&amp;T</code>に変え、それにより関数の本体を参照を返すように変更したら、
<code>Clone</code>や<code>Copy</code>トレイト境界は必要なくなり、ヒープ確保も避けられるでしょう。
これらの代替策をご自身で実装してみましょう！</p>
<!--
### Using Trait Bounds to Conditionally Implement Methods
-->
<h3 id="トレイト境界を使用してメソッド実装を条件分けする"><a class="header" href="#トレイト境界を使用してメソッド実装を条件分けする">トレイト境界を使用して、メソッド実装を条件分けする</a></h3>
<!--
By using a trait bound with an `impl` block that uses generic type parameters,
we can implement methods conditionally for types that implement the specified
traits. For example, the type `Pair<T>` in Listing 10-16 always implements the
`new` function. But `Pair<T>` only implements the `cmp_display` method if its
inner type `T` implements the `PartialOrd` trait that enables comparison *and*
the `Display` trait that enables printing.
-->
<p>ジェネリックな型引数を持つ<code>impl</code>ブロックにトレイト境界を与えることで、
特定のトレイトを実装する型に対するメソッド実装を条件分けできます。例えば、
リスト10-16の型<code>Pair&lt;T&gt;</code>は、常に<code>new</code>関数を実装します。しかし、<code>Pair&lt;T&gt;</code>は、
内部の型<code>T</code>が比較を可能にする<code>PartialOrd</code>トレイト<em>と</em>出力を可能にする<code>Display</code>トレイトを実装している時のみ、
<code>cmp_display</code>メソッドを実装します。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-16: Conditionally implement methods on a
generic type depending on trait bounds</span>
-->
<p><span class="caption">リスト10-16: トレイト境界によってジェネリックな型に対するメソッド実装を条件分けする</span></p>
<!--
We can also conditionally implement a trait for any type that implements
another trait. Implementations of a trait on any type that satisfies the trait
bounds are called *blanket implementations* and are extensively used in the
Rust standard library. For example, the standard library implements the
`ToString` trait on any type that implements the `Display` trait. The `impl`
block in the standard library looks similar to this code:
-->
<p>また、別のトレイトを実装するあらゆる型に対するトレイト実装を条件分けすることもできます。
トレイト境界を満たすあらゆる型にトレイトを実装することは、<em>ブランケット実装</em>(blanket implementation)と呼ばれ、
Rustの標準ライブラリで広く使用されています。例を挙げれば、標準ライブラリは、
<code>Display</code>トレイトを実装するあらゆる型に<code>ToString</code>トレイトを実装しています。
標準ライブラリの<code>impl</code>ブロックは以下のような見た目です:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<!--
Because the standard library has this blanket implementation, we can call the
`to_string` method defined by the `ToString` trait on any type that implements
the `Display` trait. For example, we can turn integers into their corresponding
`String` values like this because integers implement `Display`:
-->
<p>標準ライブラリにはこのブランケット実装があるので、<code>Display</code>トレイトを実装する任意の型に対して、
<code>ToString</code>トレイトで定義された<code>to_string</code>メソッドを呼び出せるのです。
例えば、整数は<code>Display</code>を実装するので、このように整数値を対応する<code>String</code>値に変換できます:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<!--
Blanket implementations appear in the documentation for the trait in the
“Implementors” section.
-->
<p>ブランケット実装は、トレイトのドキュメンテーションの「実装したもの」節に出現します。</p>
<!--
Traits and trait bounds let us write code that uses generic type parameters to
reduce duplication but also specify to the compiler that we want the generic
type to have particular behavior. The compiler can then use the trait bound
information to check that all the concrete types used with our code provide the
correct behavior. In dynamically typed languages, we would get an error at
runtime if we called a method on a type which didn’t define the method. But Rust
moves these errors to compile time so we’re forced to fix the problems before
our code is even able to run. Additionally, we don’t have to write code that
checks for behavior at runtime because we’ve already checked at compile time.
Doing so improves performance without having to give up the flexibility of
generics.
-->
<p>トレイトとトレイト境界により、ジェネリックな型引数を使用して重複を減らしつつ、コンパイラに対して、
そのジェネリックな型に特定の振る舞いが欲しいことを指定するコードを書くことができます。
それからコンパイラは、トレイト境界の情報を活用してコードに使用された具体的な型が正しい振る舞いを提供しているか確認できます。
動的型付き言語では、その型に定義されていないメソッドを呼び出せば、実行時 (runtime) にエラーが出るでしょう。
しかし、Rustはこの種のエラーをコンパイル時に移したので、コードが動かせるようになる以前に問題を修正することを強制されるのです。
加えて、コンパイル時に既に確認したので、実行時の振る舞いを確認するコードを書かなくても済みます。
そうすることで、ジェネリクスの柔軟性を諦めることなくパフォーマンスを向上させます。</p>
<!--
Another kind of generic that we’ve already been using is called *lifetimes*.
Rather than ensuring that a type has the behavior we want, lifetimes ensure
that references are valid as long as we need them to be. Let’s look at how
lifetimes do that.
-->
<p>すでに使っている他のジェネリクスに、ライフタイムと呼ばれるものがあります。
ライフタイムは、型が欲しい振る舞いを保持していることではなく、必要な間だけ参照が有効であることを保証します。
ライフタイムがどうやってそれを行うかを見てみましょう。</p>
<!--
[stack-only-data-copy]:
ch04-01-what-is-ownership.html#stack-only-data-copy
[using-trait-objects-that-allow-for-values-of-different-types]:
ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
-->
<div style="break-before: page; page-break-before: always;"></div><!--
## Validating References with Lifetimes
-->
<h2 id="ライフタイムで参照を検証する"><a class="header" href="#ライフタイムで参照を検証する">ライフタイムで参照を検証する</a></h2>
<!--
One detail we didn’t discuss in the [“References and
Borrowing”][references-and-borrowing] section in Chapter 4 is
that every reference in Rust has a *lifetime*, which is the scope for which
that reference is valid. Most of the time, lifetimes are implicit and
inferred, just like most of the time, types are inferred. We must annotate
types when multiple types are possible. In a similar way, we must annotate
lifetimes when the lifetimes of references could be related in a few different
ways. Rust requires us to annotate the relationships using generic lifetime
parameters to ensure the actual references used at runtime will definitely be
valid.
-->
<p>第4章の<a href="ch04-02-references-and-borrowing.html#%E5%8F%82%E7%85%A7%E3%81%A8%E5%80%9F%E7%94%A8">「参照と借用」</a>節で議論しなかった詳細の一つに、Rustにおいて参照は全てライフタイムを保持するということがあります。
ライフタイムとは、その参照が有効になるスコープのことです。多くの場合、型が推論されるように、
大体の場合、ライフタイムも暗黙的に推論されます。複数の型の可能性があるときには、型を注釈しなければなりません。
同様に、参照のライフタイムがいくつか異なる方法で関係することがある場合には注釈しなければなりません。
コンパイラは、ジェネリックライフタイム引数を使用して関係を注釈し、実行時に実際の参照が確かに有効であることを保証することを要求するのです。</p>
<!--
The concept of lifetimes is somewhat different from tools in other programming
languages, arguably making lifetimes Rust’s most distinctive feature. Although
we won’t cover lifetimes in their entirety in this chapter, we’ll discuss
common ways you might encounter lifetime syntax so you can become familiar with
the concepts.
-->
<p>ライフタイムの概念は、他のプログラミング言語の道具とはどこか異なり、間違いなくRustで一番際立った機能になっています。
この章では、ライフタイムの全体を解説することはしませんが、
ライフタイム記法が必要となる最も一般的な場合について議論しますので、ライフタイムの概念について馴染むことができるでしょう。</p>
<!--
### Preventing Dangling References with Lifetimes
-->
<h3 id="ライフタイムでダングリング参照を回避する"><a class="header" href="#ライフタイムでダングリング参照を回避する">ライフタイムでダングリング参照を回避する</a></h3>
<!--
The main aim of lifetimes is to prevent dangling references, which cause a
program to reference data other than the data it’s intended to reference.
Consider the program in Listing 10-17, which has an outer scope and an inner
scope.
-->
<p>ライフタイムの主な目的は、ダングリング参照を回避することです。ダングリング参照によりプログラムは、
参照するつもりだったデータ以外のデータを参照してしまいます。リスト10-17のプログラムを考えてください。
これには、外側のスコープと内側のスコープが含まれています。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;

        {
            let x = 5;
            r = &amp;x;
        }

        println!(&quot;r: {}&quot;, r);
    }
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-17: An attempt to use a reference whose value
has gone out of scope</span>
-->
<p><span class="caption">リスト10-17: 値がスコープを抜けてしまった参照を使用しようとする</span></p>
<!--
> Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables
> without giving them an initial value, so the variable name exists in the
> outer scope. At first glance, this might appear to be in conflict with Rust’s
> having no null values. However, if we try to use a variable before giving it
> a value, we’ll get a compile-time error, which shows that Rust indeed does
> not allow null values.
-->
<blockquote>
<p>注釈: リスト10-17や10-18、10-24では、変数に初期値を与えずに宣言しているので、変数名は外側のスコープに存在します。
初見では、これはRustにはnull値が存在しないということと衝突しているように見えるかもしれません。
しかしながら、値を与える前に変数を使用しようとすれば、コンパイルエラーになり、
確かにRustではnull値は許可されていないことがわかります。</p>
</blockquote>
<!--
The outer scope declares a variable named `r` with no initial value, and the
inner scope declares a variable named `x` with the initial value of 5. Inside
the inner scope, we attempt to set the value of `r` as a reference to `x`. Then
the inner scope ends, and we attempt to print the value in `r`. This code won’t
compile because the value `r` is referring to has gone out of scope before we
try to use it. Here is the error message:
-->
<p>外側のスコープで初期値なしの<code>r</code>という変数を宣言し、内側のスコープで初期値5の<code>x</code>という変数を宣言しています。
内側のスコープ内で、<code>r</code>の値を<code>x</code>への参照にセットしようとしています。それから内側のスコープが終わり、
<code>r</code>の値を出力しようとしています。<code>r</code>が参照している値が使おうとする前にスコープを抜けるので、
このコードはコンパイルできません。こちらがエラーメッセージです:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
（エラー[E0597]: `x`の生存期間が短すぎます）
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough
   |                   (借用された値の生存期間が短すぎます)
8  |         }
   |         - `x` dropped here while still borrowed
   |          (`x`は借用されている間にここでドロップされました)
9  | 
10 |         println!(&quot;r: {}&quot;, r);
   |                           - borrow later used here
   |                            (その後、借用はここで使われています)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The variable `x` doesn’t “live long enough.” The reason is that `x` will be out
of scope when the inner scope ends on line 7. But `r` is still valid for the
outer scope; because its scope is larger, we say that it “lives longer.” If
Rust allowed this code to work, `r` would be referencing memory that was
deallocated when `x` went out of scope, and anything we tried to do with `r`
wouldn’t work correctly. So how does Rust determine that this code is invalid?
It uses a borrow checker.
-->
<p>変数<code>x</code>の「生存期間が短すぎます」。原因は、内側のスコープが7行目で終わった時点で<code>x</code>がスコープを抜けるからです。
ですが、<code>r</code>はまだ、外側のスコープに対して有効です; スコープが大きいので、「長生きする」と言います。
Rustで、このコードが動くことを許可していたら、<code>r</code>は<code>x</code>がスコープを抜けた時に解放されるメモリを参照していることになり、
<code>r</code>で行おうとするいかなることもちゃんと動作しないでしょう。では、どうやってコンパイラはこのコードが無効であると決定しているのでしょうか？
それは、借用チェッカーを使用しているのです。</p>
<!--
### The Borrow Checker
-->
<h3 id="借用精査機"><a class="header" href="#借用精査機">借用精査機</a></h3>
<!--
The Rust compiler has a *borrow checker* that compares scopes to determine
whether all borrows are valid. Listing 10-18 shows the same code as Listing
10-17 but with annotations showing the lifetimes of the variables.
-->
<p>Rustコンパイラには、スコープを比較して全ての借用が有効であるかを決定する<em>借用チェッカー</em>があります。
リスト10-18は、リスト10-17と同じコードを示していますが、変数のライフタイムを表示する注釈が付いています。</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!(&quot;r: {}&quot;, r); //          |
    }                         // ---------+
<span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-18: Annotations of the lifetimes of `r` and
`x`, named `'a` and `'b`, respectively</span>
-->
<p><span class="caption">リスト10-18: それぞれ<code>'a</code>と<code>'b</code>と名付けられた<code>r</code>と<code>x</code>のライフタイムの注釈</span></p>
<!--
Here, we’ve annotated the lifetime of `r` with `'a` and the lifetime of `x`
with `'b`. As you can see, the inner `'b` block is much smaller than the outer
`'a` lifetime block. At compile time, Rust compares the size of the two
lifetimes and sees that `r` has a lifetime of `'a` but that it refers to memory
with a lifetime of `'b`. The program is rejected because `'b` is shorter than
`'a`: the subject of the reference doesn’t live as long as the reference.
-->
<p>ここで、<code>r</code>のライフタイムは<code>'a</code>、<code>x</code>のライフタイムは<code>'b</code>で注釈しました。ご覧の通り、
内側の<code>'b</code>ブロックの方が、外側の<code>'a</code>ライフタイムブロックよりはるかに小さいです。
コンパイル時に、コンパイラは2つのライフタイムのサイズを比較し、<code>r</code>は<code>'a</code>のライフタイムだけれども、
<code>'b</code>のライフタイムのメモリを参照していると確認します。<code>'b</code>は<code>'a</code>よりも短いので、プログラムは拒否されます:
参照の対象が参照ほど長生きしないのです。</p>
<!--
Listing 10-19 fixes the code so it doesn’t have a dangling reference and
compiles without any errors.
-->
<p>リスト10-19でコードを修正したので、ダングリング参照はなくなり、エラーなくコンパイルできます。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &amp;x;           // --+-- 'a  |
                              //   |       |
        println!(&quot;r: {}&quot;, r); //   |       |
                              // --+       |
    }                         // ----------+
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-19: A valid reference because the data has a
longer lifetime than the reference</span>
-->
<p><span class="caption">リスト10-19: データのライフタイムが参照より長いので、有効な参照</span></p>
<!--
Here, `x` has the lifetime `'b`, which in this case is larger than `'a`. This
means `r` can reference `x` because Rust knows that the reference in `r` will
always be valid while `x` is valid.
-->
<p>ここで<code>x</code>のライフタイムは<code>'b</code>になり、今回の場合<code>'a</code>よりも大きいです。つまり、
コンパイラは<code>x</code>が有効な間、<code>r</code>の参照も常に有効になることを把握しているので、<code>r</code>は<code>x</code>を参照できます。</p>
<!--
Now that you know where the lifetimes of references are and how Rust analyzes
lifetimes to ensure references will always be valid, let’s explore generic
lifetimes of parameters and return values in the context of functions.
-->
<p>今や、参照のライフタイムがどれだけであるかと、コンパイラがライフタイムを解析して参照が常に有効であることを保証する仕組みがわかったので、
関数における引数と戻り値のジェネリックなライフタイムを探究しましょう。</p>
<!--
### Generic Lifetimes in Functions
-->
<h3 id="関数のジェネリックなライフタイム"><a class="header" href="#関数のジェネリックなライフタイム">関数のジェネリックなライフタイム</a></h3>
<!--
Let’s write a function that returns the longer of two string slices. This
function will take two string slices and return a string slice. After we’ve
implemented the `longest` function, the code in Listing 10-20 should print `The
longest string is abcd`.
-->
<p>2つの文字列スライスのうち、長い方を返す関数を書きましょう。この関数は、
2つの文字列スライスを取り、1つの文字列スライスを返します。<code>longest</code>関数の実装完了後、
リスト10-20のコードは、<code>The longest string is abcd</code>と出力するはずです。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    // 最長の文字列は、{}です
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<!--
<span class="caption">Listing 10-20: A `main` function that calls the `longest`
function to find the longer of two string slices</span>
-->
<p><span class="caption">リスト10-20: <code>longest</code>関数を呼び出して2つの文字列スライスのうち長い方を探す<code>main</code>関数</span></p>
<!--
Note that we want the function to take string slices, which are references,
because we don’t want the `longest` function to take ownership of its
parameters. Refer to the [“String Slices as
Parameters”][string-slices-as-parameters] section in Chapter 4
for more discussion about why the parameters we use in Listing 10-20 are the
ones we want.
-->
<p>関数に取ってほしい引数が文字列スライス、つまり参照であることに注意してください。
何故なら、<code>longest</code>関数に引数の所有権を奪ってほしくないからです。
リスト10-20で使用している引数が、我々が必要としているものである理由についてもっと詳しい議論は、
第4章の<a href="ch04-03-slices.html#%E5%BC%95%E6%95%B0%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE%E6%96%87%E5%AD%97%E5%88%97%E3%82%B9%E3%83%A9%E3%82%A4%E3%82%B9">「引数としての文字列スライス」</a>節をご参照ください。</p>
<!--
If we try to implement the `longest` function as shown in Listing 10-21, it
won’t compile.
-->
<p>リスト10-21に示すように<code>longest</code>関数を実装しようとしたら、コンパイルできないでしょう。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<!--
<span class="caption">Listing 10-21: An implementation of the `longest`
function that returns the longer of two string slices but does not yet
compile</span>
-->
<p><span class="caption">リスト10-21: 2つの文字列スライスのうち長い方を返すけれども、コンパイルできない<code>longest</code>関数の実装</span></p>
<!--
Instead, we get the following error that talks about lifetimes:
-->
<p>代わりに、以下のようなライフタイムに言及するエラーが出ます:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
(エラー[E0106]: ライフタイム指定子が不足しています)
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                 ^ expected lifetime parameter
  |                                   (ライフタイム引数があるべきです)
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
  (助言: この関数の戻り値型は借用された値を含んでいますが、
   シグニチャは、それが`x`と`y`どちらから借用されたものなのか宣言していません)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The help text reveals that the return type needs a generic lifetime parameter
on it because Rust can’t tell whether the reference being returned refers to
`x` or `y`. Actually, we don’t know either, because the `if` block in the body
of this function returns a reference to `x` and the `else` block returns a
reference to `y`!
-->
<p>助言テキストが、戻り値の型はジェネリックなライフタイム引数である必要があると明かしています。
というのも、返している参照が<code>x</code>か<code>y</code>のどちらを参照しているか、コンパイラにはわからないからです。
実際のところ、この関数の本体の<code>if</code>ブロックは<code>x</code>への参照を返し、<code>else</code>ブロックは<code>y</code>への参照を返すので、
どちらなのか私たちにもわかりません！</p>
<!--
When we’re defining this function, we don’t know the concrete values that will
be passed into this function, so we don’t know whether the `if` case or the
`else` case will execute. We also don’t know the concrete lifetimes of the
references that will be passed in, so we can’t look at the scopes as we did in
Listings 10-18 and 10-19 to determine whether the reference we return will
always be valid. The borrow checker can’t determine this either, because it
doesn’t know how the lifetimes of `x` and `y` relate to the lifetime of the
return value. To fix this error, we’ll add generic lifetime parameters that
define the relationship between the references so the borrow checker can
perform its analysis.
-->
<p>この関数を定義する際、この関数に渡される具体的な値がわからないので、<code>if</code>ケースと<code>else</code>ケースのどちらが実行されるかわからないのです。
また、リスト10-18と10-19で、返す参照が常に有効であるかを決定したときのようにスコープを見ることも、渡される参照の具体的なライフタイムがわからないのでできないのです。
借用チェッカーもこれを決定することはできません。<code>x</code>と<code>y</code>のライフタイムがどう戻り値のライフタイムと関係するかわからないからです。
このエラーを修正するために、借用チェッカーが解析を実行できるように、参照間の関係を定義するジェネリックなライフタイム引数を追加しましょう。</p>
<!--
### Lifetime Annotation Syntax
-->
<h3 id="ライフタイム注釈記法"><a class="header" href="#ライフタイム注釈記法">ライフタイム注釈記法</a></h3>
<!--
Lifetime annotations don’t change how long any of the references live. Just
as functions can accept any type when the signature specifies a generic type
parameter, functions can accept references with any lifetime by specifying a
generic lifetime parameter. Lifetime annotations describe the relationships of
the lifetimes of multiple references to each other without affecting the
lifetimes.
-->
<p>ライフタイム注釈は、いかなる参照の生存期間も変えることはありません。シグニチャにジェネリックな型引数を指定された
関数が、あらゆる型を受け取ることができるのと同様に、ジェネリックなライフタイム引数を指定された関数は、
あらゆるライフタイムの参照を受け取ることができます。ライフタイム注釈は、ライフタイムに影響することなく、
複数の参照のライフタイムのお互いの関係を記述します。</p>
<!--
Lifetime annotations have a slightly unusual syntax: the names of lifetime
parameters must start with an apostrophe (`'`) and are usually all lowercase and
very short, like generic types. Most people use the name `'a`. We place
lifetime parameter annotations after the `&` of a reference, using a space to
separate the annotation from the reference’s type.
-->
<p>ライフタイム注釈は、少し不自然な記法です: ライフタイム引数の名前はアポストロフィー(<code>'</code>)で始まらなければならず、
通常全部小文字で、ジェネリック型のようにとても短いです。多くの人は、<code>'a</code>という名前を使います。
ライフタイム引数注釈は、参照の<code>&amp;</code>の後に配置し、注釈と参照の型を区別するために空白を1つ使用します。</p>
<!--
Here are some examples: a reference to an `i32` without a lifetime parameter, a
reference to an `i32` that has a lifetime parameter named `'a`, and a mutable
reference to an `i32` that also has the lifetime `'a`.
-->
<p>例を挙げましょう: ライフタイム引数なしの<code>i32</code>への参照、<code>'a</code>というライフタイム引数付きの<code>i32</code>への参照、
そして同じくライフタイム<code>'a</code>を持つ<code>i32</code>への可変参照です。</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
            // (ただの)参照
&amp;'a i32     // a reference with an explicit lifetime
            // 明示的なライフタイム付きの参照
&amp;'a mut i32 // a mutable reference with an explicit lifetime
            // 明示的なライフタイム付きの可変参照
</code></pre>
<!--
One lifetime annotation by itself doesn’t have much meaning, because the
annotations are meant to tell Rust how generic lifetime parameters of multiple
references relate to each other. For example, let’s say we have a function with
the parameter `first` that is a reference to an `i32` with lifetime `'a`. The
function also has another parameter named `second` that is another reference to
an `i32` that also has the lifetime `'a`. The lifetime annotations indicate
that the references `first` and `second` must both live as long as that generic
lifetime.
-->
<p>1つのライフタイム注釈それだけでは、大して意味はありません。注釈は、複数の参照のジェネリックなライフタイム引数が、
お互いにどう関係するかをコンパイラに指示することを意図しているからです。例えば、
ライフタイム<code>'a</code>付きの<code>i32</code>への参照となる引数<code>first</code>のある関数があるとしましょう。
この関数にはさらに、<code>'a</code>のライフタイム付きの<code>i32</code>への別の参照となる<code>second</code>という別の引数もあります。
ライフタイム注釈は、<code>first</code>と<code>second</code>の参照がどちらもこのジェネリックなライフタイムと同じだけ生きることを示唆します。</p>
<!--
### Lifetime Annotations in Function Signatures
-->
<h3 id="関数シグニチャにおけるライフタイム注釈"><a class="header" href="#関数シグニチャにおけるライフタイム注釈">関数シグニチャにおけるライフタイム注釈</a></h3>
<!--
Now let’s examine lifetime annotations in the context of the `longest`
function. As with generic type parameters, we need to declare generic lifetime
parameters inside angle brackets between the function name and the parameter
list. The constraint we want to express in this signature is that all the
references in the parameters and the return value must have the same lifetime.
We’ll name the lifetime `'a` and then add it to each reference, as shown in
Listing 10-22.
-->
<p>さて、<code>longest</code>関数を例にライフタイム注釈を詳しく見ていきましょう。ジェネリックな型引数同様、
関数名と引数リストの間の山カッコの中にジェネリックなライフタイム引数を宣言します。
このシグニチャで表現したい制約は、引数の全ての参照と戻り値が同じライフタイムを持つことです。
リスト10-22に示すように、ライフタイムを<code>'a</code>と名付け、それを各参照に付与します。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-22: The `longest` function definition
specifying that all the references in the signature must have the same lifetime
`'a`</span>
-->
<p><span class="caption">リスト10-22: シグニチャの全参照が同じライフタイム<code>'a</code>を持つと指定した<code>longest</code>関数の定義</span></p>
<!--
This code should compile and produce the result we want when we use it with the
`main` function in Listing 10-20.
-->
<p>このコードはコンパイルでき、リスト10-20の<code>main</code>関数とともに使用したら、欲しい結果になるはずです。</p>
<!--
The function signature now tells Rust that for some lifetime `'a`, the function
takes two parameters, both of which are string slices that live at least as
long as lifetime `'a`. The function signature also tells Rust that the string
slice returned from the function will live at least as long as lifetime `'a`.
In practice, it means that the lifetime of the reference returned by the
`longest` function is the same as the smaller of the lifetimes of the
references passed in. These constraints are what we want Rust to enforce.
Remember, when we specify the lifetime parameters in this function signature,
we’re not changing the lifetimes of any values passed in or returned. Rather,
we’re specifying that the borrow checker should reject any values that don’t
adhere to these constraints. Note that the `longest` function doesn’t need to
know exactly how long `x` and `y` will live, only that some scope can be
substituted for `'a` that will satisfy this signature.
-->
<p>これで関数シグニチャは、何らかのライフタイム<code>'a</code>に対して、関数は2つの引数を取り、
どちらも少なくともライフタイム<code>'a</code>と同じだけ生きる文字列スライスであるとコンパイラに教えるようになりました。
また、この関数シグニチャは、関数から返る文字列スライスも少なくともライフタイム<code>'a</code>と同じだけ生きると、
コンパイラに教えています。
実際には、<code>longest</code>関数が返す参照のライフタイムは、渡された参照のうち、小さい方のライフタイムと同じであるという事です。
これらの制約は、まさに私たちがコンパイラに保証してほしかったものです。</p>
<p>この関数シグニチャでライフタイム引数を指定する時、渡されたり、返したりした、いかなる値のライフタイムも変更していないことを思い出してください。
むしろ、借用チェッカーは、これらの制約を守らない値全てを拒否するべきと指定しています。
<code>longest</code>関数は、<code>x</code>と<code>y</code>の正確な生存期間を知っている必要はなく、
このシグニチャを満たすようなスコープを<code>'a</code>に代入できることを知っているだけであることに注意してください。</p>
<!--
When annotating lifetimes in functions, the annotations go in the function
signature, not in the function body. Rust can analyze the code within the
function without any help. However, when a function has references to or from
code outside that function, it becomes almost impossible for Rust to figure out
the lifetimes of the parameters or return values on its own. The lifetimes
might be different each time the function is called. This is why we need to
annotate the lifetimes manually.
-->
<p>関数にライフタイムを注釈するときは、注釈は関数の本体ではなくシグニチャに付与します。
コンパイラは注釈がなくとも関数内のコードを解析できます。しかしながら、
関数に関数外からの参照や関数外への参照がある場合、コンパイラが引数や戻り値のライフタイムを自力で解決することはほとんど不可能になります。
そのライフタイムは、関数が呼び出される度に異なる可能性があります。このために、手動でライフタイムを注釈する必要があるのです。</p>
<!--
When we pass concrete references to `longest`, the concrete lifetime that is
substituted for `'a` is the part of the scope of `x` that overlaps with the
scope of `y`. In other words, the generic lifetime `'a` will get the concrete
lifetime that is equal to the smaller of the lifetimes of `x` and `y`. Because
we’ve annotated the returned reference with the same lifetime parameter `'a`,
the returned reference will also be valid for the length of the smaller of the
lifetimes of `x` and `y`.
-->
<p>具体的な参照を<code>longest</code>に渡すと、<code>'a</code>に代入される具体的なライフタイムは、<code>x</code>のスコープの一部であって<code>y</code>のスコープと重なる部分となります。
言い換えると、ジェネリックなライフタイム<code>'a</code>は、<code>x</code>と<code>y</code>のライフタイムのうち、小さい方に等しい具体的なライフタイムになるのです。
返却される参照を同じライフタイム引数<code>'a</code>で注釈したので、返却される参照も<code>x</code>か<code>y</code>のライフタイムの小さい方と同じだけ有効になるでしょう。</p>
<!--
Let’s look at how the lifetime annotations restrict the `longest` function by
passing in references that have different concrete lifetimes. Listing 10-23 is
a straightforward example.
-->
<p>ライフタイム注釈が異なる具体的なライフタイムを持つ参照を渡すことで<code>longest</code>関数を制限する方法を見ましょう。
リスト10-23はそのシンプルな例です。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 長い文字列は長い
    let string1 = String::from(&quot;long string is long&quot;);
    // （訳注：この言葉自体に深い意味はない。下の&quot;xyz&quot;より長いということだけが重要）

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        // 一番長い文字列は{}
        println!(&quot;The longest string is {}&quot;, result);
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-23: Using the `longest` function with
references to `String` values that have different concrete lifetimes</span>
-->
<p><span class="caption">リスト10-23: 異なる具体的なライフタイムを持つ<code>String</code>値への参照で<code>longest</code>関数を使用する</span></p>
<!--
In this example, `string1` is valid until the end of the outer scope, `string2`
is valid until the end of the inner scope, and `result` references something
that is valid until the end of the inner scope. Run this code, and you’ll see
that the borrow checker approves of this code; it will compile and print `The
longest string is long string is long`.
-->
<p>この例において、<code>string1</code>は外側のスコープの終わりまで有効で、<code>string2</code>は内側のスコープの終わりまで有効、
そして<code>result</code>は内側のスコープの終わりまで有効な何かを参照しています。このコードを実行すると、
借用チェッカーがこのコードを良しとするのがわかるでしょう。要するに、コンパイルでき、
<code>The longest string is long string is long</code>と出力するのです。</p>
<!--
Next, let’s try an example that shows that the lifetime of the reference in
`result` must be the smaller lifetime of the two arguments. We’ll move the
declaration of the `result` variable outside the inner scope but leave the
assignment of the value to the `result` variable inside the scope with
`string2`. Then we’ll move the `println!` that uses `result` outside the inner
scope, after the inner scope has ended. The code in Listing 10-24 will not
compile.
-->
<p>次に、<code>result</code>の参照のライフタイムが2つの引数の小さい方のライフタイムになることを示す例を試しましょう。
<code>result</code>変数の宣言を内側のスコープの外に移すものの、<code>result</code>変数への代入は<code>string2</code>のスコープ内に残したままにします。
それから<code>result</code>を使用する<code>println!</code>を内側のスコープの外、内側のスコープが終わった後に移動します。
リスト10-24のコードはコンパイルできません。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
<span class="caption">Listing 10-24: Attempting to use `result` after `string2`
has gone out of scope</span>
-->
<p><span class="caption">リスト10-24: <code>string2</code>がスコープを抜けてから<code>result</code>を使用しようとする</span></p>
<!--
When we try to compile this code, we’ll get this error:
-->
<p>このコードのコンパイルを試みると、こんなエラーになります:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;The longest string is {}&quot;, result);
  |                                          ------ borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The error shows that for `result` to be valid for the `println!` statement,
`string2` would need to be valid until the end of the outer scope. Rust knows
this because we annotated the lifetimes of the function parameters and return
values using the same lifetime parameter `'a`.
-->
<p>このエラーは、<code>result</code>が<code>println!</code>文に対して有効であるためには、<code>string2</code>が外側のスコープの終わりまで有効である必要があることを示しています。
関数引数と戻り値のライフタイムを同じライフタイム引数<code>'a</code>で注釈したので、コンパイラはこのことを知っています。</p>
<!--
As humans, we can look at this code and see that `string1` is longer than
`string2` and therefore `result` will contain a reference to `string1`.
Because `string1` has not gone out of scope yet, a reference to `string1` will
still be valid for the `println!` statement. However, the compiler can’t see
that the reference is valid in this case. We’ve told Rust that the lifetime of
the reference returned by the `longest` function is the same as the smaller of
the lifetimes of the references passed in. Therefore, the borrow checker
disallows the code in Listing 10-24 as possibly having an invalid reference.
-->
<p>人間からしたら、<code>string1</code>は<code>string2</code>よりも長く、それ故に<code>result</code>が<code>string1</code>への参照を含んでいることは
コードから明らかです。まだ<code>string1</code>はスコープを抜けていないので、
<code>string1</code>への参照は<code>println!</code>にとって有効でしょう。ですが、コンパイラはこの場合、
参照が有効であると見なせません。<code>longest</code>関数から返ってくる参照のライフタイムは、
渡した参照のうちの小さい方と同じだとコンパイラに指示しました。したがって、
借用チェッカーは、リスト10-24のコードを無効な参照がある可能性があるとして許可しないのです。</p>
<!--
Try designing more experiments that vary the values and lifetimes of the
references passed in to the `longest` function and how the returned reference
is used. Make hypotheses about whether or not your experiments will pass the
borrow checker before you compile; then check to see if you’re right!
-->
<p>試しに、値や、<code>longest</code>関数に渡される参照のライフタイムや、返される参照の使われかたが異なる実験をもっとしてみてください。
コンパイル前に、その実験が借用チェッカーを通るかどうか仮説を立ててください; そして、正しいか確かめてください！</p>
<!--
### Thinking in Terms of Lifetimes
-->
<h3 id="ライフタイムの観点で思考する"><a class="header" href="#ライフタイムの観点で思考する">ライフタイムの観点で思考する</a></h3>
<!--
The way in which you need to specify lifetime parameters depends on what your
function is doing. For example, if we changed the implementation of the
`longest` function to always return the first parameter rather than the longest
string slice, we wouldn’t need to specify a lifetime on the `y` parameter. The
following code will compile:
-->
<p>何にライフタイム引数を指定する必要があるかは、関数が行っていることに依存します。例えば、
<code>longest</code>関数の実装を最長の文字列スライスではなく、常に最初の引数を返すように変更したら、
<code>y</code>引数に対してライフタイムを指定する必要はなくなるでしょう。以下のコードはコンパイルできます:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre></pre>
<!--
In this example, we’ve specified a lifetime parameter `'a` for the parameter
`x` and the return type, but not for the parameter `y`, because the lifetime of
`y` does not have any relationship with the lifetime of `x` or the return value.
-->
<p>この例では、引数<code>x</code>と戻り値に対してライフタイム引数<code>'a</code>を指定しましたが、引数<code>y</code>には指定していません。
<code>y</code>のライフタイムは<code>x</code>や戻り値のライフタイムとは何の関係もないからです。</p>
<!--
When returning a reference from a function, the lifetime parameter for the
return type needs to match the lifetime parameter for one of the parameters. If
the reference returned does *not* refer to one of the parameters, it must refer
to a value created within this function, which would be a dangling reference
because the value will go out of scope at the end of the function. Consider
this attempted implementation of the `longest` function that won’t compile:
-->
<p>関数から参照を返す際、戻り値型のライフタイム引数は、引数のうちどれかのライフタイム引数と一致する必要があります。
返される参照が引数のどれかを参照<em>していない</em>ならば、この関数内で生成された値を参照しているはずです。
すると、その値は関数の末端でスコープを抜けるので、これはダングリング参照になるでしょう。
以下に示す、コンパイルできない<code>longest</code>関数の未完成の実装を考えてください:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    // 本当に長い文字列
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre>
<!--
Here, even though we’ve specified a lifetime parameter `'a` for the return
type, this implementation will fail to compile because the return value
lifetime is not related to the lifetime of the parameters at all. Here is the
error message we get:
-->
<p>ここでは、たとえ、戻り値型にライフタイム引数<code>'a</code>を指定していても、戻り値のライフタイムは、
引数のライフタイムと全く関係がないので、この実装はコンパイルできないでしょう。
こちらが、得られるエラーメッセージです:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
(エラー[E0515]: ローカル変数`result`を参照している値は返せません)
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here
   |    (現在の関数に所有されているデータを参照する値を返しています
   |     `result`はここで借用されています)

error: aborting due to previous error

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<!--
The problem is that `result` goes out of scope and gets cleaned up at the end
of the `longest` function. We’re also trying to return a reference to `result`
from the function. There is no way we can specify lifetime parameters that
would change the dangling reference, and Rust won’t let us create a dangling
reference. In this case, the best fix would be to return an owned data type
rather than a reference so the calling function is then responsible for
cleaning up the value.
-->
<p>問題は、<code>result</code>が<code>longest</code>関数の末端でスコープを抜け、片付けられてしまうことです。
かつ、関数から<code>result</code>への参照を返そうともしています。ダングリング参照を変えてくれるようなライフタイム引数を指定する手段はなく、
コンパイラは、ダングリング参照を生成させてくれません。今回の場合、最善の修正案は、
（呼び出し先ではなく）呼び出し元の関数に値の片付けをさせるために、参照ではなく所有されたデータ型を返すことでしょう。</p>
<!--
Ultimately, lifetime syntax is about connecting the lifetimes of various
parameters and return values of functions. Once they’re connected, Rust has
enough information to allow memory-safe operations and disallow operations that
would create dangling pointers or otherwise violate memory safety.
-->
<p>究極的にライフタイム記法は、関数のいろんな引数と戻り値のライフタイムを接続することに関するものです。
一旦それらが繋がれば、メモリ安全な処理を許可し、ダングリングポインタを生成したりメモリ安全性を侵害したりする処理を禁止するのに十分な情報をコンパイラは得たことになります。</p>
<!--
### Lifetime Annotations in Struct Definitions
-->
<h3 id="構造体定義のライフタイム注釈"><a class="header" href="#構造体定義のライフタイム注釈">構造体定義のライフタイム注釈</a></h3>
<!--
So far, we’ve only defined structs to hold owned types. It’s possible for
structs to hold references, but in that case we would need to add a lifetime
annotation on every reference in the struct’s definition. Listing 10-25 has a
struct named `ImportantExcerpt` that holds a string slice.
-->
<p>ここまで、所有された型を保持する構造体だけを定義してきました。構造体に参照を保持させることもできますが、
その場合、構造体定義の全参照にライフタイム注釈を付け加える必要があるでしょう。
リスト10-25には、文字列スライスを保持する<code>ImportantExcerpt</code>(重要な一節)という構造体があります。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    // 僕をイシュマエルとお呼び。何年か前・・・
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    //                                                  &quot;'.'が見つかりませんでした&quot;
    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre></pre>
<!--
<span class="caption">Listing 10-25: A struct that holds a reference, so its
definition needs a lifetime annotation</span>
-->
<p><span class="caption">リスト10-25: 参照を含む構造体なので、定義にライフタイム注釈が必要</span></p>
<!--
This struct has one field, `part`, that holds a string slice, which is a
reference. As with generic data types, we declare the name of the generic
lifetime parameter inside angle brackets after the name of the struct so we can
use the lifetime parameter in the body of the struct definition. This
annotation means an instance of `ImportantExcerpt` can’t outlive the reference
it holds in its `part` field.
-->
<p>この構造体には文字列スライスを保持する1つのフィールド、<code>part</code>があり、これは参照です。
ジェネリックなデータ型同様、構造体名の後、山カッコの中にジェネリックなライフタイム引数の名前を宣言するので、
構造体定義の本体でライフタイム引数を使用できます。この注釈は、<code>ImportantExcerpt</code>のインスタンスが、
<code>part</code>フィールドに保持している参照よりも長生きしないことを意味します。</p>
<!--
The `main` function here creates an instance of the `ImportantExcerpt` struct
that holds a reference to the first sentence of the `String` owned by the
variable `novel`. The data in `novel` exists before the `ImportantExcerpt`
instance is created. In addition, `novel` doesn’t go out of scope until after
the `ImportantExcerpt` goes out of scope, so the reference in the
`ImportantExcerpt` instance is valid.
-->
<p>ここの<code>main</code>関数は、変数<code>novel</code>に所有される<code>String</code>の、最初の文への参照を保持する<code>ImportantExcerpt</code>インスタンスを生成しています。
<code>novel</code>のデータは、<code>ImportantExcerpt</code>インスタンスが作られる前に存在しています。
加えて、<code>ImportantExcerpt</code>がスコープを抜けるまで<code>novel</code>はスコープを抜けないので、
<code>ImportantExcerpt</code>インスタンスの参照は有効なのです。</p>
<!--
### Lifetime Elision
-->
<h3 id="ライフタイム省略"><a class="header" href="#ライフタイム省略">ライフタイム省略</a></h3>
<!--
You’ve learned that every reference has a lifetime and that you need to specify
lifetime parameters for functions or structs that use references. However, in
Chapter 4 we had a function in Listing 4-9, which is shown again in Listing
10-26, that compiled without lifetime annotations.
-->
<p>全参照にはライフタイムがあり、参照を使用する関数や構造体にはライフタイム引数を指定する必要があることを学びました。
しかし、リスト4-9にあった関数（リスト10-26に再度示しました）はライフタイム注釈なしでコンパイルできました。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;hello world&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of `String`s
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;hello world&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word works on slices of string literals
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Because string literals *are* string slices already,
</span><span class="boring">    // this works too, without the slice syntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 10-26: A function we defined in Listing 4-9 that
compiled without lifetime annotations, even though the parameter and return
type are references</span>
-->
<p><span class="caption">リスト10-26: リスト4-9で定義した、引数と戻り値型が参照であるにも関わらず、ライフタイム注釈なしでコンパイルできた関数</span></p>
<!--
The reason this function compiles without lifetime annotations is historical:
in early versions (pre-1.0) of Rust, this code wouldn’t have compiled because
every reference needed an explicit lifetime. At that time, the function
signature would have been written like this:
-->
<p>この関数がライフタイム注釈なしでコンパイルできる理由には、Rustの歴史が関わっています: 昔のバージョンのRust(1.0以前)では、
全参照に明示的なライフタイムが必要だったので、このコードはコンパイルできませんでした。
その頃、関数シグニチャはこのように記述されていたのです:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<!--
After writing a lot of Rust code, the Rust team found that Rust programmers
were entering the same lifetime annotations over and over in particular
situations. These situations were predictable and followed a few deterministic
patterns. The developers programmed these patterns into the compiler’s code so
the borrow checker could infer the lifetimes in these situations and wouldn’t
need explicit annotations.
-->
<p>多くのRustコードを書いた後、Rustチームは、Rustプログラマが、
特定の場面で何度も同じライフタイム注釈を入力していることを発見しました。これらの場面は予測可能で、
いくつかの決まりきったパターンに従っていました。開発者はこのパターンをコンパイラのコードに落とし込んだので、
このような場面には借用チェッカーがライフタイムを推論できるようになり、明示的な注釈を必要としなくなったのです。</p>
<!--
This piece of Rust history is relevant because it’s possible that more
deterministic patterns will emerge and be added to the compiler. In the future,
even fewer lifetime annotations might be required.
-->
<p>ここで、このRustの歴史話が関係しているのは、他にも決まりきったパターンが出現し、コンパイラに追加されることもあり得るからです。
将来的に、さらに少数のライフタイム注釈しか必要にならない可能性もあります。</p>
<!--
The patterns programmed into Rust’s analysis of references are called the
*lifetime elision rules*. These aren’t rules for programmers to follow; they’re
a set of particular cases that the compiler will consider, and if your code
fits these cases, you don’t need to write the lifetimes explicitly.
-->
<p>コンパイラの参照解析に落とし込まれたパターンは、<em>ライフタイム省略規則</em>と呼ばれます。
これらはプログラマが従う規則ではありません; コンパイラが考慮する一連の特定のケースであり、
自分のコードがこのケースに当てはまれば、ライフタイムを明示的に書く必要はなくなります。</p>
<!--
The elision rules don’t provide full inference. If Rust deterministically
applies the rules but there is still ambiguity as to what lifetimes the
references have, the compiler won’t guess what the lifetime of the remaining
references should be. In this case, instead of guessing, the compiler will give
you an error that you can resolve by adding the lifetime annotations that
specify how the references relate to each other.
-->
<p>省略規則は、完全な推論を提供しません。コンパイラが決定的に規則を適用できるけれども、
参照が保持するライフタイムに関してそれでも曖昧性があるなら、コンパイラは、残りの参照がなるべきライフタイムを推測しません。
この場合コンパイラは、それらを推測するのではなくエラーを与えます。
これらは、参照がお互いにどう関係するかを指定するライフタイム注釈を追記することで解決できます。</p>
<!--
Lifetimes on function or method parameters are called *input lifetimes*, and
lifetimes on return values are called *output lifetimes*.
-->
<p>関数やメソッドの引数のライフタイムは、<em>入力ライフタイム</em>と呼ばれ、
戻り値のライフタイムは<em>出力ライフタイム</em>と称されます。</p>
<!--
The compiler uses three rules to figure out what lifetimes references have when
there aren’t explicit annotations. The first rule applies to input lifetimes,
and the second and third rules apply to output lifetimes. If the compiler gets
to the end of the three rules and there are still references for which it can’t
figure out lifetimes, the compiler will stop with an error. These rules apply
to `fn` definitions as well as `impl` blocks.
-->
<p>コンパイラは3つの規則を活用し、明示的な注釈がない時に、参照がどんなライフタイムになるかを計算します。
最初の規則は入力ライフタイムに適用され、2番目と3番目の規則は出力ライフタイムに適用されます。
コンパイラが3つの規則の最後まで到達し、それでもライフタイムを割り出せない参照があったら、
コンパイラはエラーで停止します。
これらのルールは<code>fn</code>の定義にも<code>impl</code>ブロックにも適用されます。</p>
<!--
The first rule is that each parameter that is a reference gets its own lifetime
parameter. In other words, a function with one parameter gets one lifetime
parameter: `fn foo<'a>(x: &'a i32)`; a function with two parameters gets two
separate lifetime parameters: `fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`; and so
on.
-->
<p>最初の規則は、参照である各引数は、独自のライフタイム引数を得るというものです。換言すれば、
1引数の関数は、1つのライフタイム引数を得るということです: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>;
2つ引数のある関数は、2つの個別のライフタイム引数を得ます: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>;
以下同様。</p>
<!--
The second rule is if there is exactly one input lifetime parameter, that
lifetime is assigned to all output lifetime parameters: `fn foo<'a>(x: &'a i32)
-> &'a i32`.
-->
<p>2番目の規則は、1つだけ入力ライフタイム引数があるなら、そのライフタイムが全ての出力ライフタイム引数に代入されるというものです:
<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>。</p>
<!--
The third rule is if there are multiple input lifetime parameters, but one of
them is `&self` or `&mut self` because this is a method, the lifetime of `self`
is assigned to all output lifetime parameters. This third rule makes methods
much nicer to read and write because fewer symbols are necessary.
-->
<p>3番目の規則は、複数の入力ライフタイム引数があるけれども、メソッドなのでそのうちの一つが<code>&amp;self</code>や<code>&amp;mut self</code>だったら、
<code>self</code>のライフタイムが全出力ライフタイム引数に代入されるというものです。
この3番目の規則により、必要なシンボルの数が減るので、メソッドが遥かに読み書きしやすくなります。</p>
<!--
Let’s pretend we’re the compiler. We’ll apply these rules to figure out what
the lifetimes of the references in the signature of the `first_word` function
in Listing 10-26 are. The signature starts without any lifetimes associated
with the references:
-->
<p>コンパイラの立場になってみましょう。これらの規則を適用して、リスト10-26の<code>first_word</code>関数のシグニチャの参照のライフタイムが何か計算します。
シグニチャは、参照に紐づけられるライフタイムがない状態から始まります:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<!--
Then the compiler applies the first rule, which specifies that each parameter
gets its own lifetime. We’ll call it `'a` as usual, so now the signature is
this:
-->
<p>そうして、コンパイラは最初の規則を適用し、各引数が独自のライフタイムを得ると指定します。
それを通常通り<code>'a</code>と呼ぶので、シグニチャはこうなります:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<!--
The second rule applies because there is exactly one input lifetime. The second
rule specifies that the lifetime of the one input parameter gets assigned to
the output lifetime, so the signature is now this:
-->
<p>1つだけ入力ライフタイムがあるので、2番目の規則を適用します。2番目の規則は、1つの入力引数のライフタイムが、
出力引数に代入されると指定するので、シグニチャはこうなります:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<!--
Now all the references in this function signature have lifetimes, and the
compiler can continue its analysis without needing the programmer to annotate
the lifetimes in this function signature.
-->
<p>もうこの関数シグニチャの全ての参照にライフタイムが付いたので、コンパイラは、
プログラマにこの関数シグニチャのライフタイムを注釈してもらう必要なく、解析を続行できます。</p>
<!--
Let’s look at another example, this time using the `longest` function that had
no lifetime parameters when we started working with it in Listing 10-21:
-->
<p>別の例に目を向けましょう。今回は、リスト10-21で取り掛かったときにはライフタイム引数がなかった<code>longest</code>関数です:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<!--
Let’s apply the first rule: each parameter gets its own lifetime. This time we
have two parameters instead of one, so we have two lifetimes:
-->
<p>最初の規則を適用しましょう: 各引数が独自のライフタイムを得るのです。今回は、
1つではなく2つ引数があるので、ライフタイムも2つです:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<!--
You can see that the second rule doesn’t apply because there is more than one
input lifetime. The third rule doesn’t apply either, because `longest` is a
function rather than a method, so none of the parameters are `self`. After
working through all three rules, we still haven’t figured out what the return
type’s lifetime is. This is why we got an error trying to compile the code in
Listing 10-21: the compiler worked through the lifetime elision rules but still
couldn’t figure out all the lifetimes of the references in the signature.
-->
<p>2つ以上入力ライフタイムがあるので、2番目の規則は適用されないとわかります。また3番目の規則も適用されません。
<code>longest</code>はメソッドではなく関数なので、どの引数も<code>self</code>ではないのです。3つの規則全部を適用した後でも、
まだ戻り値型のライフタイムが判明していません。このために、リスト10-21でこのコードをコンパイルしようとしてエラーになったのです:
コンパイラは、ライフタイム省略規則全てを適用したけれども、シグニチャの参照全部のライフタイムを計算できなかったのです。</p>
<!--
Because the third rule really only applies in method signatures, we’ll look at
lifetimes in that context next to see why the third rule means we don’t have to
annotate lifetimes in method signatures very often.
-->
<p>実際のところ、3番目の規則はメソッドのシグニチャにしか適用されません。ですので、次はその文脈においてライフタイムを観察し、
3番目の規則のおかげで、メソッドシグニチャであまり頻繁にライフタイムを注釈しなくても済む理由を確認します。</p>
<!--
### Lifetime Annotations in Method Definitions
-->
<h3 id="メソッド定義におけるライフタイム注釈"><a class="header" href="#メソッド定義におけるライフタイム注釈">メソッド定義におけるライフタイム注釈</a></h3>
<!--
When we implement methods on a struct with lifetimes, we use the same syntax as
that of generic type parameters shown in Listing 10-11. Where we declare and
use the lifetime parameters depends on whether they’re related to the struct
fields or the method parameters and return values.
-->
<p>構造体にライフタイムのあるメソッドを実装する際、リスト10-11で示したジェネリックな型引数と同じ記法を使用します。
ライフタイム引数を宣言し使用する場所は、構造体フィールドかメソッド引数と戻り値に関係するかによります。</p>
<!--
Lifetime names for struct fields always need to be declared after the `impl`
keyword and then used after the struct’s name, because those lifetimes are part
of the struct’s type.
-->
<p>構造体のフィールド用のライフタイム名は、<code>impl</code>キーワードの後に宣言する必要があり、
それから構造体名の後に使用されます。そのようなライフタイムは構造体の型の一部になるからです。</p>
<!--
In method signatures inside the `impl` block, references might be tied to the
lifetime of references in the struct’s fields, or they might be independent. In
addition, the lifetime elision rules often make it so that lifetime annotations
aren’t necessary in method signatures. Let’s look at some examples using the
struct named `ImportantExcerpt` that we defined in Listing 10-25.
-->
<p><code>impl</code>ブロック内のメソッドシグニチャでは、参照は構造体のフィールドの参照のライフタイムに紐づいている可能性と、
独立している可能性があります。加えて、ライフタイム省略規則により、メソッドシグニチャでライフタイム注釈が必要なくなることがよくあります。
リスト10-25で定義した<code>ImportantExcerpt</code>という構造体を使用した例をいくつか見てみましょう。</p>
<!--
First, we’ll use a method named `level` whose only parameter is a reference to
`self` and whose return value is an `i32`, which is not a reference to anything:
-->
<p>まず、唯一の引数が<code>self</code>への参照で戻り値が<code>i32</code>という何かへの参照ではない<code>level</code>というメソッドを使用します:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        //       &quot;お知らせします: {}&quot;
</span><span class="boring">        println!(&quot;Attention please: {}&quot;, announcement);
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<!--
The lifetime parameter declaration after `impl` and its use after the type name
are required, but we’re not required to annotate the lifetime of the reference
to `self` because of the first elision rule.
-->
<p><code>impl</code>後のライフタイム引数宣言と型名の後にそれを使用するのは必須ですが、最初の省略規則のため、
<code>self</code>への参照のライフタイムを注釈する必要はありません。</p>
<!--
Here is an example where the third lifetime elision rule applies:
-->
<p>3番目のライフタイム省略規則が適用される例はこちらです:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        //       &quot;お知らせします: {}&quot;
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Could not find a '.'&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<!--
There are two input lifetimes, so Rust applies the first lifetime elision rule
and gives both `&self` and `announcement` their own lifetimes. Then, because
one of the parameters is `&self`, the return type gets the lifetime of `&self`,
and all lifetimes have been accounted for.
-->
<p>2つ入力ライフタイムがあるので、コンパイラは最初のライフタイム省略規則を適用し、
<code>&amp;self</code>と<code>announcement</code>に独自のライフタイムを与えます。それから、
引数の1つが<code>&amp;self</code>なので、戻り値型は<code>&amp;self</code>のライフタイムを得て、
全てのライフタイムが説明されました。</p>
<!--
### The Static Lifetime
-->
<h3 id="静的ライフタイム"><a class="header" href="#静的ライフタイム">静的ライフタイム</a></h3>
<!--
One special lifetime we need to discuss is `'static`, which means that this
reference *can* live for the entire duration of the program. All string
literals have the `'static` lifetime, which we can annotate as follows:
-->
<p>議論する必要のある1種の特殊なライフタイムが、<code>'static</code>であり、これは、この参照がプログラムの全期間生存<em>できる</em>事を意味します。
文字列リテラルは全て<code>'static</code>ライフタイムになり、次のように注釈できます:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 僕は静的ライフタイムを持ってるよ
let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}
</span></code></pre></pre>
<!--
The text of this string is stored directly in the program’s binary, which
is always available. Therefore, the lifetime of all string literals is
`'static`.
-->
<p>この文字列のテキストは、プログラムのバイナリに直接格納され、常に利用可能です。故に、全文字列リテラルのライフタイムは、
<code>'static</code>なのです。</p>
<!--
You might see suggestions to use the `'static` lifetime in error messages. But
before specifying `'static` as the lifetime for a reference, think about
whether the reference you have actually lives the entire lifetime of your
program or not. You might consider whether you want it to live that long, even
if it could. Most of the time, the problem results from attempting to create a
dangling reference or a mismatch of the available lifetimes. In such cases, the
solution is fixing those problems, not specifying the `'static` lifetime.
-->
<p>エラーメッセージで、<code>'static</code>ライフタイムを使用するよう勧める提言を見かける可能性があります。
ですが、参照に対してライフタイムとして<code>'static</code>を指定する前に、今ある参照が本当にプログラムの全期間生きるかどうか考えてください。
それが可能であったとしても、参照がそれだけの期間生きてほしいのかどうか考慮するのも良いでしょう。
ほとんどの場合、問題は、ダングリング参照を生成しようとしているか、利用可能なライフタイムの不一致が原因です。
そのような場合、解決策はその問題を修正することであり、<code>'static</code>ライフタイムを指定することではありません。</p>
<!--
## Generic Type Parameters, Trait Bounds, and Lifetimes Together
-->
<h2 id="ジェネリックな型引数トレイト境界ライフタイムを一度に"><a class="header" href="#ジェネリックな型引数トレイト境界ライフタイムを一度に">ジェネリックな型引数、トレイト境界、ライフタイムを一度に</a></h2>
<!--
Let’s briefly look at the syntax of specifying generic type parameters, trait
bounds, and lifetimes all in one function!
-->
<p>ジェネリックな型引数、トレイト境界、ライフタイム指定の構文のすべてを1つの関数で簡単に見てみましょう！</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Today is someone's birthday!&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;The longest string is {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    //       &quot;アナウンス！ {}&quot;
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<!--
This is the `longest` function from Listing 10-22 that returns the longer of
two string slices. But now it has an extra parameter named `ann` of the generic
type `T`, which can be filled in by any type that implements the `Display`
trait as specified by the `where` clause. This extra parameter will be printed
before the function compares the lengths of the string slices, which is why the
`Display` trait bound is necessary. Because lifetimes are a type of generic,
the declarations of the lifetime parameter `'a` and the generic type parameter
`T` go in the same list inside the angle brackets after the function name.
-->
<p>これがリスト10-22からの2つの文字列のうち長い方を返す<code>longest</code>関数ですが、
ジェネリックな型<code>T</code>の<code>ann</code>という追加の引数があり、これは<code>where</code>節で指定されているように、
<code>Display</code>トレイトを実装するあらゆる型で埋めることができます。
この追加の引数は、関数が文字列スライスの長さを比較する前に出力されるので、
<code>Display</code>トレイト境界が必要なのです。ライフタイムは一種のジェネリックなので、
ライフタイム引数<code>'a</code>とジェネリックな型引数<code>T</code>が関数名の後、山カッコ内の同じリストに収まっています。</p>
<!--
## Summary
-->
<h2 id="まとめ-9"><a class="header" href="#まとめ-9">まとめ</a></h2>
<!--
We covered a lot in this chapter! Now that you know about generic type
parameters, traits and trait bounds, and generic lifetime parameters, you’re
ready to write code without repetition that works in many different situations.
Generic type parameters let you apply the code to different types. Traits and
trait bounds ensure that even though the types are generic, they’ll have the
behavior the code needs. You learned how to use lifetime annotations to ensure
that this flexible code won’t have any dangling references. And all of this
analysis happens at compile time, which doesn’t affect runtime performance!
-->
<p>たくさんのことをこの章では講義しましたね！今やジェネリックな型引数、トレイトとトレイト境界、そしてジェネリックなライフタイム引数を知ったので、
多くの異なる場面で動くコードを繰り返すことなく書く準備ができました。ジェネリックな型引数により、
コードを異なる型に適用させてくれます。トレイトとトレイト境界は、型がジェネリックであっても、
コードが必要とする振る舞いを持つことを保証します。ライフタイム注釈を活用して、
この柔軟なコードにダングリング参照が存在しないことを保証する方法を学びました。
さらにこの解析は全てコンパイル時に起こり、実行時のパフォーマンスには影響しません！</p>
<!--
Believe it or not, there is much more to learn on the topics we discussed in
this chapter: Chapter 17 discusses trait objects, which are another way to use
traits. There are also more complex scenarios involving lifetime annotations
that you will only need in very advanced scenarios; for those, you should read
the [Rust Reference][reference]. But next, you’ll learn how to write tests in
Rust so you can make sure your code is working the way it should.
-->
<p>信じられないかもしれませんが、この章で議論した話題にはもっともっと学ぶべきことがあります:
第17章ではトレイトオブジェクトを議論します。これはトレイトを使用する別の手段です。
非常に高度な筋書きの場合でのみ必要になる、ライフタイム注釈が関わる、もっと複雑な筋書きもあります。
それらについては、<a href="https://doc.rust-lang.org/reference/">Rust Reference</a>をお読みください。 
ですが次は、コードがあるべき通りに動いていることを確かめられるように、Rustでテストを書く方法を学びます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Writing Automated Tests
-->
<h1 id="自動テストを書く"><a class="header" href="#自動テストを書く">自動テストを書く</a></h1>
<!--
In his 1972 essay “The Humble Programmer,” Edsger W. Dijkstra said that
“Program testing can be a very effective way to show the presence of bugs, but
it is hopelessly inadequate for showing their absence.” That doesn’t mean we
shouldn’t try to test as much as we can!
-->
<p>1972年のエッセイ「謙虚なプログラマ」でエドガー・W・ダイクストラは以下のように述べています。
「プログラムのテストは、バグの存在を示すには非常に効率的な手法であるが、
バグの不在を示すには望み薄く不適切である」と。これは、できるだけテストを試みるべきではないということではありません。</p>
<!--
Correctness in our programs is the extent to which our code does what we intend
it to do. Rust is designed with a high degree of concern about the correctness
of programs, but correctness is complex and not easy to prove. Rust’s type
system shoulders a huge part of this burden, but the type system cannot catch
every kind of incorrectness. As such, Rust includes support for writing
automated software tests within the language.
-->
<p>プログラムの正当性は、どこまで自分のコードが意図していることをしているかなのです。
Rustは、プログラムの正当性に重きを置いて設計されていますが、
正当性は複雑で、単純に証明することはありません。Rustの型システムは、
この重荷の多くの部分を肩代わりしてくれますが、型システムはあらゆる種類の不当性を捕捉してはくれません。
ゆえに、Rustでは、言語内で自動化されたソフトウェアテストを書くことをサポートしているのです。</p>
<!--
As an example, say we write a function called `add_two` that adds 2 to whatever
number is passed to it. This function’s signature accepts an integer as a
parameter and returns an integer as a result. When we implement and compile
that function, Rust does all the type checking and borrow checking that you've
learned so far to ensure that, for instance, we aren’t passing a `String` value
or an invalid reference to this function. But Rust *can’t* check that this
function will do precisely what we intend, which is return the parameter plus 2
rather than, say, the parameter plus 10 or the parameter minus 50! That's where
tests come in.
-->
<p>例として、渡された何かの数値に2を足す<code>add_two</code>という関数を書くとしましょう。
この関数のシグニチャは、引数に整数を取り、結果として整数を返します。
この関数を実装してコンパイルすると、コンパイラはこれまでに学んできた型チェックと借用チェックを全て行い、
例えば、<code>String</code>の値や無効な参照をこの関数に渡していないかなどを確かめるのです。
ところが、コンパイラはプログラマがまさしく意図したことを関数が実行しているかどうかは確かめ<em>られません</em>。
つまり、そうですね、引数に10を足したり、50を引いたりするのではなく、引数に2を足していることです。
そんな時に、テストは必要になるのです。</p>
<!--
We can write tests that assert, for example, that when we pass `3` to the
`add_two` function, the returned value is `5`. We can run these tests whenever
we make changes to our code to make sure any existing correct behavior has not
changed.
-->
<p>例えば、<code>add_two</code>関数に<code>3</code>を渡した時に、戻り値は5であることをアサーションするようなテストを書くことができます。
コードに変更を加えた際にこれらのテストを走らせ、既存の正当な振る舞いが変わっていないことを確認できます。</p>
<!--
Testing is a complex skill: although we can’t cover every detail about how to
write good tests in one chapter, we’ll discuss the mechanics of Rust’s testing
facilities. We’ll talk about the annotations and macros available to you when
writing your tests, the default behavior and options provided for running your
tests, and how to organize tests into unit tests and integration tests.
-->
<p>テストは、複雑なスキルです: いいテストの書き方をあらゆる方面から講義することは1章だけではできないのですが、
Rustのテスト機構のメカニズムについて議論します。テストを書く際に利用可能になるアノテーションとマクロについて、
テストを実行するのに提供されているオプションと標準の動作、さらにテストをユニットテストや統合テストに体系化する方法について語ります。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## How to Write Tests
-->
<h2 id="テストの記述法"><a class="header" href="#テストの記述法">テストの記述法</a></h2>
<!--
Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform these three
actions:
-->
<p>テストは、テスト以外のコードが想定された方法で機能していることを実証するRustの関数です。
テスト関数の本体は、典型的には以下の3つの動作を行います:</p>
<!--
1. Set up any needed data or state.
2. Run the code you want to test.
3. Assert the results are what you expect.
-->
<ol>
<li>必要なデータや状態をセットアップする。</li>
<li>テスト対象のコードを走らせる。</li>
<li>結果が想定通りであることを断定（以下、アサーションという）する。</li>
</ol>
<!--
Let’s look at the features Rust provides specifically for writing tests that
take these actions, which include the `test` attribute, a few macros, and the
`should_panic` attribute.
-->
<p>Rustが、特にこれらの動作を行うテストを書くために用意している機能を見ていきましょう。
これには、<code>test</code>属性、いくつかのマクロ、<code>should_panic</code>属性が含まれます。</p>
<!--
### The Anatomy of a Test Function
-->
<h2 id="テスト関数の構成"><a class="header" href="#テスト関数の構成">テスト関数の構成</a></h2>
<!--
At its simplest, a test in Rust is a function that’s annotated with the `test`
attribute. Attributes are metadata about pieces of Rust code; one example is
the `derive` attribute we used with structs in Chapter 5. To change a function
into a test function, add `#[test]` on the line before `fn`. When you run your
tests with the `cargo test` command, Rust builds a test runner binary that runs
the functions annotated with the `test` attribute and reports on whether each
test function passes or fails.
-->
<p>最も単純には、Rustにおけるテストは<code>test</code>属性で注釈された関数のことです。属性とは、
Rustコードの部品に関するメタデータです; 一例を挙げれば、構造体とともに第5章で使用した<code>derive</code>属性です。
関数をテスト関数に変えるには、<code>fn</code>の前に<code>#[test]</code>を付け加えてください。
<code>cargo test</code>コマンドでテストを実行したら、コンパイラは<code>test</code>属性で注釈された関数を走らせるテスト用バイナリをビルドし、
各テスト関数が通過したか失敗したかを報告します。</p>
<!--
When we make a new library project with Cargo, a test module with a test
function in it is automatically generated for us. This module helps you start
writing your tests so you don’t have to look up the exact structure and syntax
of test functions every time you start a new project. You can add as many
additional test functions and as many test modules as you want!
-->
<p>新しいライブラリプロジェクトをCargoで作ると、テスト関数付きのテストモジュールが自動的に生成されます。
このモジュールのおかげで、新しいプロジェクトを始めるたびにテスト関数の正しい構造とか文法をいちいち検索しなくてすみます。
ここに好きな数だけテスト関数やテストモジュールを追加すればいいというわけです！</p>
<!--
We’ll explore some aspects of how tests work by experimenting with the template
test generated for us without actually testing any code. Then we’ll write some
real-world tests that call some code that we’ve written and assert that its
behavior is correct.
-->
<p>まず、実際にはコードをテストしない、自動生成されたテンプレートのテストで実験して、テストの動作の性質をいくらか学びましょう。
その後で、以前書いたコードを呼び出し、振る舞いが正しいことをアサーションする、ホンモノのテストを書きましょう。</p>
<!--
Let’s create a new library project called `adder`:
-->
<p><code>adder</code>という新しいライブラリプロジェクトを生成しましょう:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<!--
The contents of the *src/lib.rs* file in your `adder` library should look like
Listing 11-1.
-->
<p><code>adder</code>ライブラリの<em>src/lib.rs</em>ファイルの中身は、リスト11-1のような見た目のはずです。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-1: The test module and function generated
automatically by `cargo new`</span>
-->
<p><span class="caption">リスト11-1: <code>cargo new</code>で自動生成されたテストモジュールと関数</span></p>
<!--
For now, let’s ignore the top two lines and focus on the function to see how it
works. Note the `#[test]` annotation before the `fn` line: this attribute
indicates this is a test function, so the test runner knows to treat this
function as a test. We could also have non-test functions in the `tests` module
to help set up common scenarios or perform common operations, so we need to
indicate which functions are tests by using the `#[test]` attribute.
-->
<p>とりあえず、最初の2行は無視し、関数に集中してその動作法を見ましょう。
<code>fn</code>行の<code>#[test]</code>注釈に注目してください: この属性は、これがテスト関数であることを示すので、
テスト実行機はこの関数をテストとして扱うとわかるのです。さらに、<code>tests</code>モジュール内にはテスト関数以外の関数を入れ、
一般的なシナリオをセットアップしたり、共通の処理を行う手助けをしたりもできるので、
<code>#[test]</code>属性でどの関数がテストかを示す必要があるのです。</p>
<!--
The function body uses the `assert_eq!` macro to assert that 2 + 2 equals 4.
This assertion serves as an example of the format for a typical test. Let’s run
it to see that this test passes.
-->
<p>関数本体は、<code>assert_eq!</code>マクロを使用して、2 + 2が4に等しいことをアサーションしています。
このアサーションは、典型的なテストのフォーマット例をなしているわけです。走らせてこのテストが通る（訳注：テストが成功する、の意味。英語でpassということから、このように表現される）ことを確かめましょう。</p>
<!--
The `cargo test` command runs all tests in our project, as shown in Listing
11-2.
-->
<p><code>cargo test</code>コマンドでプロジェクトにあるテストが全て実行されます。リスト11-2に示したようにですね。</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
<span class="caption">Listing 11-2: The output from running the automatically
generated test</span>
-->
<p><span class="caption">リスト11-2: 自動生成されたテストを走らせた出力</span></p>
<!--
Cargo compiled and ran the test. After the `Compiling`, `Finished`, and
`Running` lines is the line `running 1 test`. The next line shows the name
of the generated test function, called `it_works`, and the result of running
that test, `ok`. The overall summary of running the tests appears next. The
text `test result: ok.` means that all the tests passed, and the portion that
reads `1 passed; 0 failed` totals the number of tests that passed or failed.
-->
<p>Cargoがテストをコンパイルし、走らせました。<code>Compiling</code>, <code>Finished</code>, <code>Running</code>の行の後に<code>running 1 test</code>の行があります。
次行が、生成されたテスト関数の<code>it_works</code>という名前とこのテストの実行結果、<code>ok</code>を示しています。
テスト実行の総合的なまとめが次に出現します。<code>test result:ok.</code>というテキストは、
全テストが通ったことを意味し、<code>1 passed; 0 failed</code>と読める部分は、通過または失敗したテストの数を合計しているのです。</p>
<!--
Because we don’t have any tests we’ve marked as ignored, the summary shows `0
ignored`. We also haven’t filtered the tests being run, so the end of the
summary shows `0 filtered out`. We’ll talk about ignoring and filtering out
tests in the next section, [“Controlling How Tests Are
Run.”][controlling-how-tests-are-run]
-->
<p>無視すると指定したテストは何もなかったため、まとめは<code>0 ignored</code>と示しています。
また、実行するテストにフィルタをかけもしなかったので、まとめの最後に<code>0 filtered out</code>と表示されています。
テストを無視することとフィルタすることに関しては次の節、<a href="ch11-02-running-tests.html#%E3%83%86%E3%82%B9%E3%83%88%E3%81%AE%E5%AE%9F%E8%A1%8C%E3%81%AE%E3%81%95%E3%82%8C%E6%96%B9%E3%82%92%E5%88%B6%E5%BE%A1%E3%81%99%E3%82%8B">テストの実行され方を制御する</a>で語ります。</p>
<!--
The `0 measured` statistic is for benchmark tests that measure performance.
Benchmark tests are, as of this writing, only available in nightly Rust. See
[the documentation about benchmark tests][bench] to learn more.
-->
<p><code>0 measured</code>という統計は、パフォーマンスを測定するベンチマークテスト用です。
ベンチマークテストは、本書記述の時点では、nightly版のRustでのみ利用可能です。
詳しくは、<a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">ベンチマークテストのドキュメンテーション</a>を参照されたし。</p>
<!--
The next part of the test output, which starts with `Doc-tests adder`, is for
the results of any documentation tests. We don’t have any documentation tests
yet, but Rust can compile any code examples that appear in our API
documentation. This feature helps us keep our docs and our code in sync! We’ll
discuss how to write documentation tests in the [“Documentation Comments as
Tests”][doc-comments] section of Chapter 14. For now, we’ll
ignore the `Doc-tests` output.
-->
<p>テスト出力の次の部分、つまり<code>Doc-tests adder</code>で始まる部分は、ドキュメンテーションテストの結果用のものです。
まだドキュメンテーションテストは何もないものの、コンパイラは、APIドキュメントに現れるどんなコード例もコンパイルできます。
この機能により、ドキュメントとコードを同期することができるわけです。ドキュメンテーションテストの書き方については、
第14章の<a href="ch14-02-publishing-to-crates-io.html#%E3%83%86%E3%82%B9%E3%83%88%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%86%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%B3%E3%83%A1%E3%83%B3%E3%83%88">テストとしてのドキュメンテーションコメント</a>節で議論しましょう。今は、<code>Doc-tests</code>出力は無視します。</p>
<!--
Let’s change the name of our test to see how that changes the test output.
Change the `it_works` function to a different name, such as `exploration`, like
so:
-->
<p>テストの名前を変更してどうテスト出力が変わるか確かめましょう。<code>it_works</code>関数を違う名前、<code>exploration</code>などに変えてください。
そう、以下のように:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
Then run `cargo test` again. The output now shows `exploration` instead of
`it_works`:
-->
<p>そして、<code>cargo test</code>を再度走らせます。これで出力が<code>it_works</code>の代わりに<code>exploration</code>と表示しています:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
Let’s add another test, but this time we’ll make a test that fails! Tests fail
when something in the test function panics. Each test is run in a new thread,
and when the main thread sees that a test thread has died, the test is marked
as failed. We talked about the simplest way to cause a panic in Chapter 9,
which is to call the `panic!` macro. Enter the new test, `another`, so your
*src/lib.rs* file looks like Listing 11-3.
-->
<p>別のテストを追加しますが、今回は失敗するテストにしましょう！テスト関数内の何かがパニックすると、
テストは失敗します。各テストは、新規スレッドで実行され、メインスレッドが、テストスレッドが死んだと確認した時、
テストは失敗と印づけられます。第9章でパニックを引き起こす最も単純な方法について語りました。
そう、<code>panic!</code>マクロを呼び出すことですね。<em>src/lib.rs</em>ファイルがリスト11-3のような見た目になるよう、
新しいテスト<code>another</code>を入力してください。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust panics">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        //このテストを失敗させる
        panic!(&quot;Make this test fail&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-3: Adding a second test that will fail because
we call the `panic!` macro</span>
-->
<p><span class="caption">リスト11-3: <code>panic!</code>マクロを呼び出したために失敗する2番目のテストを追加する</span></p>
<!--
Run the tests again using `cargo test`. The output should look like Listing
11-4, which shows that our `exploration` test passed and `another` failed.
-->
<p><code>cargo test</code>で再度テストを走らせてください。出力はリスト11-4のようになるはずであり、
<code>exploration</code>テストは通り、<code>another</code>は失敗したと表示されます。</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'main' panicked at 'Make this test fail', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
<span class="caption">Listing 11-4: Test results when one test passes and one
test fails</span>
-->
<p><span class="caption">リスト11-4: 一つのテストが通り、一つが失敗するときのテスト結果</span></p>
<!--
Instead of `ok`, the line `test tests::another` shows `FAILED`. Two new
sections appear between the individual results and the summary: the first
section displays the detailed reason for each test failure. In this case,
`another` failed because it `panicked at 'Make this test fail'`, which happened
on line 10 in the *src/lib.rs* file. The next section lists just the names of
all the failing tests, which is useful when there are lots of tests and lots of
detailed failing test output. We can use the name of a failing test to run just
that test to more easily debug it; we’ll talk more about ways to run tests in
the [“Controlling How Tests Are Run”][controlling-how-tests-are-run]
section.
-->
<p><code>ok</code>の代わりに<code>test test::another</code>の行は、<code>FAILED</code>を表示しています。個々の結果とまとめの間に、
2つ新たな区域ができました: 最初の区域は、失敗したテスト各々の具体的な理由を表示しています。
今回の場合、<code>another</code>は<code>'Make this test fail'でパニックした</code>ために失敗し、
これは、<em>src/lib.rs</em>ファイルの10行で起きました。次の区域は失敗したテストの名前だけを列挙しています。
これは、テストがたくさんあり、失敗したテストの詳細がたくさん表示されるときに有用になります。
失敗したテストの名前を使用してそのテストだけを実行し、より簡単にデバッグすることができます。
テストの実行方法については、<a href="ch11-02-running-tests.html#%E3%83%86%E3%82%B9%E3%83%88%E3%81%AE%E5%AE%9F%E8%A1%8C%E3%81%AE%E3%81%95%E3%82%8C%E6%96%B9%E3%82%92%E5%88%B6%E5%BE%A1%E3%81%99%E3%82%8B">テストの実行され方を制御する</a>節でもっと語りましょう。</p>
<!--
The summary line displays at the end: overall, our test result is `FAILED`.
We had one test pass and one test fail.
-->
<p>サマリー行が最後に出力されています: 総合的に言うと、テスト結果は<code>FAILED</code>でした。
一つのテストが通り、一つが失敗したわけです。</p>
<!--
Now that you’ve seen what the test results look like in different scenarios,
let’s look at some macros other than `panic!` that are useful in tests.
-->
<p>様々な状況でのテスト結果がどんな風になるか見てきたので、テストを行う際に有用になる<code>panic!</code>以外のマクロに目を向けましょう。</p>
<!--
### Checking Results with the `assert!` Macro
-->
<h3 id="assertマクロで結果を確認する"><a class="header" href="#assertマクロで結果を確認する"><code>assert!</code>マクロで結果を確認する</a></h3>
<!--
The `assert!` macro, provided by the standard library, is useful when you want
to ensure that some condition in a test evaluates to `true`. We give the
`assert!` macro an argument that evaluates to a Boolean. If the value is
`true`, `assert!` does nothing and the test passes. If the value is `false`,
the `assert!` macro calls the `panic!` macro, which causes the test to fail.
Using the `assert!` macro helps us check that our code is functioning in the
way we intend.
-->
<p><code>assert!</code>マクロは、標準ライブラリで提供されていますが、テスト内の何らかの条件が<code>true</code>と評価されることを確かめたいときに有効です。
<code>assert!</code>マクロには、論理値に評価される引数を与えます。その値が<code>true</code>なら、
<code>assert!</code>は何もせず、テストは通ります。その値が<code>false</code>なら、<code>assert!</code>マクロは<code>panic!</code>マクロを呼び出し、
テストは失敗します。<code>assert!</code>マクロを使用することで、コードが意図した通りに機能していることを確認する助けになるわけです。</p>
<!--
In Chapter 5, Listing 5-15, we used a `Rectangle` struct and a `can_hold`
method, which are repeated here in Listing 11-5. Let’s put this code in the
*src/lib.rs* file and write some tests for it using the `assert!` macro.
-->
<p>第5章のリスト5-15で、<code>Rectangle</code>構造体と<code>can_hold</code>メソッドを使用しました。リスト11-5でもそれを繰り返しています。
このコードを<em>src/lib.rs</em>ファイルに放り込み、<code>assert!</code>マクロでそれ用のテストを何か書いてみましょう。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-5: Using the `Rectangle` struct and its
`can_hold` method from Chapter 5</span>
-->
<p><span class="caption">リスト11-5: 第5章から<code>Rectangle</code>構造体とその<code>can_hold</code>メソッドを使用する</span></p>
<!--
The `can_hold` method returns a Boolean, which means it’s a perfect use case
for the `assert!` macro. In Listing 11-6, we write a test that exercises the
`can_hold` method by creating a `Rectangle` instance that has a width of 8 and
a height of 7 and asserting that it can hold another `Rectangle` instance that
has a width of 5 and a height of 1.
-->
<p><code>can_hold</code>メソッドは論理値を返すので、<code>assert!</code>マクロの完璧なユースケースになるわけです。
リスト11-6で、幅が8、高さが7の<code>Rectangle</code>インスタンスを生成し、これが幅5、
高さ1の別の<code>Rectangle</code>インスタンスを保持できるとアサーションすることで<code>can_hold</code>を用いるテストを書きます。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-6: A test for `can_hold` that checks whether a
larger rectangle can indeed hold a smaller rectangle</span>
-->
<p><span class="caption">リスト11-6: より大きな長方形がより小さな長方形を確かに保持できるかを確認する<code>can_hold</code>用のテスト</span></p>
<!--
Note that we’ve added a new line inside the `tests` module: `use super::*;`.
The `tests` module is a regular module that follows the usual visibility rules
we covered in Chapter 7 in the [“Paths for Referring to an Item in the Module
Tree”][paths-for-referring-to-an-item-in-the-module-tree]
section. Because the `tests` module is an inner module, we need to bring the
code under test in the outer module into the scope of the inner module. We use
a glob here so anything we define in the outer module is available to this
`tests` module.
-->
<p><code>tests</code>モジュール内に新しい行を加えたことに注目してください: <code>use super::*</code>です。
<code>tests</code>モジュールは、第7章の<a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">モジュールツリーの要素を示すためのパス</a>節で講義した通常の公開ルールに従う普通のモジュールです。
<code>tests</code>モジュールは、内部モジュールなので、外部モジュール内のテスト配下にあるコードを内部モジュールのスコープに持っていく必要があります。
ここではglobを使用して、外部モジュールで定義したもの全てがこの<code>tests</code>モジュールでも使用可能になるようにしています。</p>
<!--
We’ve named our test `larger_can_hold_smaller`, and we’ve created the two
`Rectangle` instances that we need. Then we called the `assert!` macro and
passed it the result of calling `larger.can_hold(&smaller)`. This expression
is supposed to return `true`, so our test should pass. Let’s find out!
-->
<p>テストは<code>larger_can_hold_smaller</code>と名付け、必要な<code>Rectangle</code>インスタンスを2つ生成しています。
そして、<code>assert!</code>マクロを呼び出し、<code>larger.can_hold(&amp;smaller)</code>の呼び出し結果を渡しました。
この式は、<code>true</code>を返すと考えられるので、テストは通るはずです。確かめましょう！</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
It does pass! Let’s add another test, this time asserting that a smaller
rectangle cannot hold a larger rectangle:
-->
<p>通ります！別のテストを追加しましょう。今回は、小さい長方形は、より大きな長方形を保持できないことをアサーションします。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
Because the correct result of the `can_hold` function in this case is `false`,
we need to negate that result before we pass it to the `assert!` macro. As a
result, our test will pass if `can_hold` returns `false`:
-->
<p>今回の場合、<code>can_hold</code>関数の正しい結果は<code>false</code>なので、その結果を<code>assert!</code>マクロに渡す前に反転させる必要があります。
結果として、<code>can_hold</code>が<code>false</code>を返せば、テストは通ります。</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
Two tests that pass! Now let’s see what happens to our test results when we
introduce a bug in our code. Let’s change the implementation of the `can_hold`
method by replacing the greater than sign with a less than sign when it
compares the widths:
-->
<p>通るテストが2つ！さて、コードにバグを導入したらテスト結果がどうなるか確認してみましょう。
幅を比較する大なり記号を小なり記号で置き換えて<code>can_hold</code>メソッドの実装を変更しましょう:</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
Running the tests now produces the following:
-->
<p>テストを実行すると、以下のような出力をします:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'main' panicked at 'assertion failed: larger.can_hold(&amp;smaller)', src/lib.rs:28:9
(スレッド'main'はsrc/lib.rs:28:9の'assertion failed: larger.can_hold(&amp;smaller)'でパニックしました)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Our tests caught the bug! Because `larger.width` is 8 and `smaller.width` is
5, the comparison of the widths in `can_hold` now returns `false`: 8 is not
less than 5.
-->
<p>テストによりバグが捕捉されました！<code>larger.width</code>が8、<code>smaller.width</code>が5なので、
<code>can_hold</code>内の幅の比較が今は<code>false</code>を返すようになったのです: 8は5より小さくないですからね。</p>
<!--
### Testing Equality with the `assert_eq!` and `assert_ne!` Macros
-->
<h3 id="assert_eqとassert_neマクロで等値性をテストする"><a class="header" href="#assert_eqとassert_neマクロで等値性をテストする"><code>assert_eq!</code>と<code>assert_ne!</code>マクロで等値性をテストする</a></h3>
<!--
A common way to test functionality is to compare the result of the code under
test to the value you expect the code to return to make sure they’re equal. You
could do this using the `assert!` macro and passing it an expression using the
`==` operator. However, this is such a common test that the standard library
provides a pair of macros—`assert_eq!` and `assert_ne!`—to perform this test
more conveniently. These macros compare two arguments for equality or
inequality, respectively. They’ll also print the two values if the assertion
fails, which makes it easier to see *why* the test failed; conversely, the
`assert!` macro only indicates that it got a `false` value for the `==`
expression, not the values that lead to the `false` value.
-->
<p>機能をテストする一般的な方法は、テスト下にあるコードの結果をコードが返すと期待される値と比較して、
等しいと確かめることです。これを<code>assert</code>マクロを使用して<code>==</code>演算子を使用した式を渡すことで行うこともできます。
しかしながら、これはありふれたテストなので、標準ライブラリには1組のマクロ(<code>assert_eq!</code>と<code>assert_ne!</code>)が提供され、
このテストをより便利に行うことができます。これらのマクロはそれぞれ、二つの引数を比べ、等しいかと等しくないかを確かめます。
また、アサーションが失敗したら二つの値の出力もし、テストが失敗した<em>原因</em>を確認しやすくなります。
一方で<code>assert!</code>マクロは、<code>==</code>式の値が<code>false</code>になったことしか示さず、<code>false</code>になった原因の値は出力しません。</p>
<!--
In Listing 11-7, we write a function named `add_two` that adds `2` to its
parameter and returns the result. Then we test this function using the
`assert_eq!` macro.
-->
<p>リスト11-7において、引数に<code>2</code>を加えて結果を返す<code>add_two</code>という名前の関数を書いています。
そして、<code>assert_eq!</code>マクロでこの関数をテストしています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-7: Testing the function `add_two` using the
`assert_eq!` macro</span>
-->
<p><span class="caption">リスト11-7: <code>assert_eq!</code>マクロで<code>add_two</code>関数をテストする</span></p>
<!--
Let’s check that it passes!
-->
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
The first argument we gave to the `assert_eq!` macro, `4`, is equal to the
result of calling `add_two(2)`. The line for this test is `test
tests::it_adds_two ... ok`, and the `ok` text indicates that our test passed!
-->
<p><code>assert_eq!</code>マクロに与えた第1引数の<code>4</code>は、<code>add_two(2)</code>の呼び出し結果と等しいです。
このテストの行は<code>test tests::it_adds_two ... ok</code>であり、<code>ok</code>というテキストはテストが通ったことを示しています！</p>
<!--
Let’s introduce a bug into our code to see what it looks like when a test that
uses `assert_eq!` fails. Change the implementation of the `add_two` function to
instead add `3`:
-->
<p>コードにバグを仕込んで、<code>assert_eq!</code>を使ったテストが失敗した時にどんな見た目になるのか確認してみましょう。
<code>add_two</code>関数の実装を代わりに<code>3</code>を足すように変えてください:</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior">pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        assert_eq!(4, add_two(2));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
Run the tests again:
-->
<p>テストを再度実行します:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Our test caught the bug! The `it_adds_two` test failed, displaying the message
`` assertion failed: `(left == right)` `` and showing that `left` was `4` and
`right` was `5`. This message is useful and helps us start debugging: it means
the `left` argument to `assert_eq!` was `4` but the `right` argument, where we
had `add_two(2)`, was `5`.
-->
<p>テストがバグを捕捉しました！<code>it_adds_two</code>のテストは失敗し、<code>assertion failed: `(left == right)`</code>というメッセージを表示し、
<code>left</code>は<code>4</code>で、<code>right</code>は<code>5</code>だったと示しています。このメッセージは有用で、デバッグを開始する助けになります:
<code>assert_eq!</code>の<code>left</code>引数は<code>4</code>だったが、<code>add_two(2)</code>がある<code>right</code>引数は<code>5</code>だったことを意味しています。</p>
<!--
Note that in some languages and test frameworks, the parameters to the
functions that assert two values are equal are called `expected` and `actual`,
and the order in which we specify the arguments matters. However, in Rust,
they’re called `left` and `right`, and the order in which we specify the value
we expect and the value that the code under test produces doesn’t matter. We
could write the assertion in this test as `assert_eq!(add_two(2), 4)`, which
would result in a failure message that displays `` assertion failed: `(left ==
right)` `` and that `left` was `5` and `right` was `4`.
-->
<p>二つの値が等しいとアサーションを行う関数の引数を
<code>expected</code>と<code>actual</code>と呼び、引数を指定する順序が問題になる言語やテストフレームワークもあることに注意してください。
ですがRustでは、<code>left</code>と<code>right</code>と呼ばれ、期待する値とテスト下のコードが生成する値を指定する順序は
問題になりません。今回のテストのアサーションを<code>assert_eq!(add_two(2), 4)</code>と書くこともでき、
そうすると失敗メッセージは、<code>assertion failed: `(left == right)`</code>となり、
<code>left</code>が<code>5</code>で<code>right</code>が<code>4</code>と表示されるでしょう。</p>
<!--
The `assert_ne!` macro will pass if the two values we give it are not equal and
fail if they’re equal. This macro is most useful for cases when we’re not sure
what a value *will* be, but we know what the value definitely *won’t* be if our
code is functioning as we intend. For example, if we’re testing a function that
is guaranteed to change its input in some way, but the way in which the input
is changed depends on the day of the week that we run our tests, the best thing
to assert might be that the output of the function is not equal to the input.
-->
<p><code>assert_ne!</code>マクロは、与えた2つの値が等しくなければ通り、等しければ失敗します。
このマクロは、値が何になる<em>だろう</em>か確信が持てないけれども、コードが意図した通りに動いていれば、
確実にこの値にはなら<em>ないだろう</em>とわかっているような場合に最も有用になります。例えば、
入力を何らかの手段で変え（て出力す）ることが保証されているけれども、入力の変え方がテストを実行する曜日に依存する関数をテストしているなら、
アサーションすべき最善の事柄は、関数の出力が入力と等しくないことかもしれません。</p>
<!--
Under the surface, the `assert_eq!` and `assert_ne!` macros use the operators
`==` and `!=`, respectively. When the assertions fail, these macros print their
arguments using debug formatting, which means the values being compared must
implement the `PartialEq` and `Debug` traits. All the primitive types and most
of the standard library types implement these traits. For structs and enums
that you define, you’ll need to implement `PartialEq` to assert that values of
those types are equal or not equal. You’ll need to implement `Debug` to print
the values when the assertion fails. Because both traits are derivable traits,
as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward
as adding the `#[derive(PartialEq, Debug)]` annotation to your struct or enum
definition. See Appendix C, [“Derivable Traits,”][derivable-traits]
for more details about these and other derivable traits.
-->
<p>内部的には、<code>assert_eq!</code>と<code>assert_ne!</code>マクロは、それぞれ<code>==</code>と<code>!=</code>演算子を使用しています。
アサーションが失敗すると、これらのマクロは引数をデバッグフォーマットを使用してプリントするので、
比較対象の値は<code>PartialEq</code>と<code>Debug</code>トレイトを実装していなければなりません。
すべての組み込み型と、ほぼすべての標準ライブラリの型はこれらのトレイトを実装しています。
自分で定義した構造体やenumについては、
その型の値が等しいか等しくないかをアサーションするために、<code>PartialEq</code>を実装する必要があるでしょう。
それが失敗した時にその値をプリントできるように、<code>Debug</code>を実装する必要もあるでしょう。
第5章のリスト5-12で触れたように、どちらのトレイトも導出可能なトレイトなので、
これは通常、単純に構造体やenum定義に<code>#[derive(PartialEq, Debug)]</code>という注釈を追加するだけですみます。
これらやその他の導出可能なトレイトに関する詳細については、付録C、<a href="appendix-03-derivable-traits.html">導出可能なトレイト</a>をご覧ください。</p>
<!--
### Adding Custom Failure Messages
-->
<h3 id="カスタムの失敗メッセージを追加する"><a class="header" href="#カスタムの失敗メッセージを追加する">カスタムの失敗メッセージを追加する</a></h3>
<!--
You can also add a custom message to be printed with the failure message as
optional arguments to the `assert!`, `assert_eq!`, and `assert_ne!` macros. Any
arguments specified after the one required argument to `assert!` or the two
required arguments to `assert_eq!` and `assert_ne!` are passed along to the
`format!` macro (discussed in Chapter 8 in the [“Concatenation with the `+`
Operator or the `format!`
Macro”][concatenation-with-the--operator-or-the-format-macro]
section), so you can pass a format string that contains `{}` placeholders and
values to go in those placeholders. Custom messages are useful to document
what an assertion means; when a test fails, you’ll have a better idea of what
the problem is with the code.
-->
<p>さらに、<code>assert!</code>、<code>assert_eq!</code>、<code>assert_ne!</code>の追加引数として、失敗メッセージと共にカスタムのメッセージが表示されるよう、
追加することもできます。<code>assert!</code>の1つの必須引数の後に、
あるいは<code>assert_eq!</code>と<code>assert_ne!</code>の2つの必須引数の後に指定された引数はすべて<code>format!</code>マクロに渡されるので、
（format!マクロについては第8章の<a href="ch08-02-strings.html#%E6%BC%94%E7%AE%97%E5%AD%90%E3%81%BE%E3%81%9F%E3%81%AFformat%E3%83%9E%E3%82%AF%E3%83%AD%E3%81%A7%E9%80%A3%E7%B5%90"><code>+</code>演算子、または<code>format!</code>マクロで連結</a>節で議論しました）、
<code>{}</code>プレースホルダーを含むフォーマット文字列とこのプレースホルダーに置き換えられる値を渡すことができます。
カスタムメッセージは、アサーションがどんな意味を持つかドキュメント化するのに役に立ちます;
もしテストが失敗した時、コードにどんな問題があるのかをよりしっかり把握できるはずです。</p>
<!--
For example, let’s say we have a function that greets people by name and we
want to test that the name we pass into the function appears in the output:
-->
<p>例として、人々に名前で挨拶をする関数があり、関数に渡した名前が出力に出現することをテストしたいとしましょう:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
The requirements for this program haven’t been agreed upon yet, and we’re
pretty sure the `Hello` text at the beginning of the greeting will change. We
decided we don’t want to have to update the test when the requirements change,
so instead of checking for exact equality to the value returned from the
`greeting` function, we’ll just assert that the output contains the text of the
input parameter.
-->
<p>このプログラムの要件はまだ取り決められておらず、挨拶の先頭の<code>Hello</code>というテキストはおそらく変わります。
要件が変わった時にテストを更新しなくてもよいようにしたいと考え、
<code>greeting</code>関数から返る値と正確な等値性を確認するのではなく、出力が入力引数のテキストを含むことをアサーションするだけにします。</p>
<!--
Let’s introduce a bug into this code by changing `greeting` to not include
`name` to see what this test failure looks like:
-->
<p><code>greeting</code>が<code>name</code>を含まないように変更してこのコードにバグを仕込み、このテストの失敗がどんな風になるのか確かめましょう:</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior">pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting(&quot;Carol&quot;);
</span><span class="boring">        assert!(result.contains(&quot;Carol&quot;));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
Running this test produces the following:
-->
<p>このテストを実行すると、以下のように出力されます:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'assertion failed: result.contains(&quot;Carol&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
This result just indicates that the assertion failed and which line the
assertion is on. A more useful failure message in this case would print the
value we got from the `greeting` function. Let’s change the test function,
giving it a custom failure message made from a format string with a placeholder
filled in with the actual value we got from the `greeting` function:
-->
<p>この結果は、アサーションが失敗し、どの行にアサーションがあるかを示しているだけです。
今回の場合、失敗メッセージが<code>greeting</code>関数から得た値を出力していればより有用でしょう。
テスト関数を変更し、
<code>greeting</code>関数から得た実際の値で埋められるプレースホルダーを含むフォーマット文字列からなるカスタムの失敗メッセージを与えてみましょう。</p>
<pre><code class="language-rust ignore"><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;Hello!&quot;)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(
            result.contains(&quot;Carol&quot;),
            //挨拶(greeting)は名前を含んでいません。その値は`{}`でした
            &quot;Greeting did not contain name, value was `{}`&quot;,
            result
        );
    }
<span class="boring">}
</span></code></pre>
<!--
Now when we run the test, we’ll get a more informative error message:
-->
<p>これでテストを実行したら、より有益なエラーメッセージが得られるでしょう:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'Greeting did not contain name, value was `Hello!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.
-->
<p>実際に得られた値がテスト出力に表示されているので、起こると想定していたものではなく、
起こったものをデバッグするのに役に立ちます。</p>
<!--
### Checking for Panics with `should_panic`
-->
<h3 id="should_panicでパニックを確認する"><a class="header" href="#should_panicでパニックを確認する"><code>should_panic</code>でパニックを確認する</a></h3>
<!--
In addition to checking that our code returns the correct values we expect,
it’s also important to check that our code handles error conditions as we
expect. For example, consider the `Guess` type that we created in Chapter 9,
Listing 9-10. Other code that uses `Guess` depends on the guarantee that `Guess`
instances will contain only values between 1 and 100. We can write a test that
ensures that attempting to create a `Guess` instance with a value outside that
range panics.
-->
<p>期待する正しい値をコードが返すことを確認することに加えて、想定通りにコードがエラー状態を扱っていることを確認するのも重要です。
例えば、第9章のリスト9-10で生成した<code>Guess</code>型を考えてください。<code>Guess</code>を使用する他のコードは、
<code>Guess</code>のインスタンスは1から100の範囲の値しか含まないという保証に依存しています。
その範囲外の値で<code>Guess</code>インスタンスを生成しようとするとパニックすることを確認するテストを書くことができます。</p>
<!--
We do this by adding another attribute, `should_panic`, to our test function.
This attribute makes a test pass if the code inside the function panics; the
test will fail if the code inside the function doesn’t panic.
-->
<p>これは、テスト関数に<code>should_panic</code>という別の属性を追加することで達成できます。
この属性は、関数内のコードがパニックしたら、テストを通過させます。つまり、
関数内のコードがパニックしなかったら、テストは失敗するわけです。</p>
<!--
Listing 11-8 shows a test that checks that the error conditions of `Guess::new`
happen when we expect them to.
-->
<p>リスト11-8は、予想どおりに<code>Guess::new</code>のエラー条件が発生していることを確認するテストを示しています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            //予想値は1から100の間でなければなりませんが、{}でした。
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-8: Testing that a condition will cause a
`panic!`</span>
-->
<p><span class="caption">リスト11-8: 状況が<code>panic!</code>を引き起こすとテストする</span></p>
<!--
We place the `#[should_panic]` attribute after the `#[test]` attribute and
before the test function it applies to. Let’s look at the result when this test
passes:
-->
<p><code>#[test]</code>属性の後、適用するテスト関数の前に<code>#[should_panic]</code>属性を配置しています。
このテストが通るときの結果を見ましょう:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

</code></pre>
<!--
Looks good! Now let’s introduce a bug in our code by removing the condition
that the `new` function will panic if the value is greater than 100:
-->
<p>よさそうですね！では、値が100より大きいときに<code>new</code>関数がパニックするという条件を除去することでコードにバグを導入しましょう:</p>
<pre><pre class="playground"><code class="language-rust not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            //予想値は1から100の間でなければなりませんが、{}でした。
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
When we run the test in Listing 11-8, it will fail:
-->
<p>リスト11-8のテストを実行すると、失敗するでしょう:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
We don’t get a very helpful message in this case, but when we look at the test
function, we see that it’s annotated with `#[should_panic]`. The failure we got
means that the code in the test function did not cause a panic.
-->
<p>この場合、それほど役に立つメッセージは得られませんが、テスト関数に目を向ければ、
<code>#[should_panic]</code>で注釈されていることがわかります。得られた失敗は、
テスト関数のコードがパニックを引き起こさなかったことを意味するのです。</p>
<!--
Tests that use `should_panic` can be imprecise because they only indicate that
the code has caused some panic. A `should_panic` test would pass even if the
test panics for a different reason from the one we were expecting to happen. To
make `should_panic` tests more precise, we can add an optional `expected`
parameter to the `should_panic` attribute. The test harness will make sure that
the failure message contains the provided text. For example, consider the
modified code for `Guess` in Listing 11-9 where the `new` function panics with
different messages depending on whether the value is too small or too large.
-->
<p><code>should_panic</code>を使用するテストは不正確なこともあります。なぜなら、コードが何らかのパニックを起こしたことしか示さないからです。
<code>should_panic</code>のテストは、起きると想定していたもの以外の理由でテストがパニックしても通ってしまうのです。
<code>should_panic</code>のテストの正確を期すために、<code>should_panic</code>属性に<code>expected</code>引数を追加することもできます。
このテストハーネスは、失敗メッセージに与えられたテキストが含まれていることを確かめてくれます。
例えば、リスト11-9の修正された<code>Guess</code>のコードを考えてください。ここでは、
<code>new</code>関数は、値が大きすぎるか小さすぎるかによって異なるメッセージでパニックします。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(
                //予想値は1以上でなければなりませんが、{}でした。
                &quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                //予想値は100以下でなければなりませんが、{}でした。
                &quot;Guess value must be less than or equal to 100, got {}.&quot;,
                value
            );
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    //予想値は100以下でなければなりません
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-9: Testing that a condition will cause a
`panic!` with a particular panic message</span>
-->
<p><span class="caption">リスト11-9: 状況が特定のパニックメッセージで<code>panic!</code>を引き起こすことをテストする</span></p>
<!--
This test will pass because the value we put in the `should_panic` attribute’s
`expected` parameter is a substring of the message that the `Guess::new`
function panics with. We could have specified the entire panic message that we
expect, which in this case would be `Guess value must be less than or equal to
100, got 200.` What you choose to specify in the expected parameter for
`should_panic` depends on how much of the panic message is unique or dynamic
and how precise you want your test to be. In this case, a substring of the
panic message is enough to ensure that the code in the test function executes
the `else if value > 100` case.
-->
<p><code>should_panic</code>属性の<code>expected</code>引数に置いた値が<code>Guess::new</code>関数がパニックしたメッセージの一部になっているので、
このテストは通ります。予想されるパニックメッセージ全体を指定することもでき、今回の場合、
<code>Guess value must be less than or equal to 100, got 200.</code>となります。
<code>should_panic</code>の予想される引数に何を指定するかは、パニックメッセージのどこが固有でどこが動的か、
またテストをどの程度正確に行いたいかによります。今回の場合、パニックメッセージの一部でも、テスト関数内のコードが、
<code>else if value &gt; 100</code>の場合を実行していると確認するのに事足りるのです。</p>
<!--
To see what happens when a `should_panic` test with an `expected` message
fails, let’s again introduce a bug into our code by swapping the bodies of the
`if value < 1` and the `else if value > 100` blocks:
-->
<p><code>expected</code>メッセージありの<code>should_panic</code>テストが失敗すると何が起きるのが確かめるために、
<code>if value &lt; 1</code>と<code>else if value &gt; 100</code>ブロックの本体を入れ替えることで再度コードにバグを仕込みましょう:</p>
<pre><code class="language-rust ignore not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(
                //予想値は100以下でなければなりませんが、{}でした。
                &quot;Guess value must be less than or equal to 100, got {}.&quot;,
                value
            );
        } else if value &gt; 100 {
            panic!(
                //予想値は1以上でなければなりませんが、{}でした。
                &quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                value
            );
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<!--
This time when we run the `should_panic` test, it will fail:
-->
<p><code>should_panic</code>テストを実行すると、今回は失敗するでしょう:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'main' panicked at 'Guess value must be greater than or equal to 1, got 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
note: panic did not contain expected string
      panic message: `&quot;Guess value must be greater than or equal to 1, got 200.&quot;`,
 expected substring: `&quot;Guess value must be less than or equal to 100&quot;`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
The failure message indicates that this test did indeed panic as we expected,
but the panic message did not include the expected string `'Guess value must be
less than or equal to 100'`. The panic message that we did get in this case was
`Guess value must be greater than or equal to 1, got 200.` Now we can start
figuring out where our bug is!
-->
<p>この失敗メッセージは、このテストが確かに予想通りパニックしたことを示していますが、
パニックメッセージは、予想される文字列の<code>'Guess value must be less than or equal to 100'</code>を含んでいませんでした。
実際に得られたパニックメッセージは今回の場合、<code>Guess value must be greater than or equal to 1, got 200</code>でした。
そうしてバグの所在地を割り出し始めることができるわけです！</p>
<!--
### Using `Result<T, E>` in Tests
-->
<h3 id="resultt-eをテストで使う"><a class="header" href="#resultt-eをテストで使う"><code>Result&lt;T, E&gt;</code>をテストで使う</a></h3>
<!--
So far, we’ve written tests that panic when they fail. We can also write tests
that use `Result<T, E>`! Here’s the test from Listing 11-1, rewritten to use
`Result<T, E>` and return an `Err` instead of panicking:
-->
<p>これまでは、失敗するとパニックするようなテストを書いてきましたが、
<code>Result&lt;T, E&gt;</code>を使うようなテストを書くこともできます！
以下は、Listing 11-1のテストを、<code>Result&lt;T, E&gt;</code>を使い、パニックする代わりに<code>Err</code>を返すように書き直したものです：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;two plus two does not equal four&quot;))
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `it_works` function now has a return type, `Result<(), String>`. In the
body of the function, rather than calling the `assert_eq!` macro, we return
`Ok(())` when the test passes and an `Err` with a `String` inside when the test
fails.
-->
<p><code>it_works</code>関数の戻り値の型は<code>Result&lt;(), String&gt;</code>になりました。
関数内で<code>assert_eq!</code>マクロを呼び出す代わりに、テストが成功すれば<code>Ok(())</code>を、失敗すれば<code>Err</code>に<code>String</code>を入れて返すようにします。</p>
<!--
Writing tests so they return a `Result<T, E>` enables you to use the question
mark operator in the body of tests, which can be a convenient way to write
tests that should fail if any operation within them returns an `Err` variant.
-->
<p><code>Result&lt;T, E&gt;</code> を返すようなテストを書くと、<code>?</code>演算子をテストの中で使えるようになります。
これは、テスト内で何らかの工程が<code>Err</code>ヴァリアントを返したときに失敗するべきテストを書くのに便利です。</p>
<!--
You can’t use the `#[should_panic]` annotation on tests that use `Result<T,
E>`. Instead, you should return an `Err` value directly when the test should
fail.
-->
<p><code>Result&lt;T, E&gt;</code>を使うテストに<code>#[should_panic]</code>注釈を使うことはできません。
テストが失敗しなければならないときは、直接<code>Err</code>値を返してください。</p>
<!--
Now that you know several ways to write tests, let’s look at what is happening
when we run our tests and explore the different options we can use with `cargo
test`.
-->
<p>今やテスト記法を複数知ったので、テストを走らせる際に起きていることに目を向け、
<code>cargo test</code>で使用できるいろんなオプションを探究しましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Controlling How Tests Are Run
-->
<h2 id="テストの実行のされ方を制御する"><a class="header" href="#テストの実行のされ方を制御する">テストの実行のされ方を制御する</a></h2>
<!--
Just as `cargo run` compiles your code and then runs the resulting binary,
`cargo test` compiles your code in test mode and runs the resulting test
binary. You can specify command line options to change the default behavior of
`cargo test`. For example, the default behavior of the binary produced by
`cargo test` is to run all the tests in parallel and capture output generated
during test runs, preventing the output from being displayed and making it
easier to read the output related to the test results.
-->
<p><code>cargo run</code>がコードをコンパイルし、出来上がったバイナリを走らせるのと全く同様に、
<code>cargo test</code>はコードをテストモードでコンパイルし、出来上がったテストバイナリを実行します。
コマンドラインオプションを指定して<code>cargo test</code>の既定動作を変更することができます。
例えば、<code>cargo test</code>で生成されるバイナリの既定動作は、テストを全て並行に実行し、
テスト実行中に生成された出力をキャプチャして出力が表示されるのを防ぎ、
テスト結果に関係する出力を読みやすくすることです。</p>
<!--
Some command line options go to `cargo test` and some go to the resulting test
binary. To separate these two types of arguments, you list the arguments that
go to `cargo test` followed by the separator `--` and then the ones that go to
the test binary. Running `cargo test --help` displays the options you can use
with `cargo test`, and running `cargo test -- --help` displays the options you
can use after the separator `--`.
-->
<p>コマンドラインオプションの中には<code>cargo test</code>にかかるものや、出来上がったテストバイナリにかかるものがあります。
この2種の引数を区別するために、<code>cargo test</code>にかかる引数を<code>--</code>という区分記号の後に列挙し、
それからテストバイナリにかかる引数を列挙します。<code>cargo test --help</code>を走らせると、<code>cargo test</code>で使用できるオプションが表示され、
<code>cargo test -- --help</code>を走らせると、<code>--</code>という区分記号の後に使えるオプションが表示されます。</p>
<!--
### Running Tests in Parallel or Consecutively
-->
<h3 id="テストを並行または連続して実行する"><a class="header" href="#テストを並行または連続して実行する">テストを並行または連続して実行する</a></h3>
<!--
When you run multiple tests, by default they run in parallel using threads.
This means the tests will finish running faster so you can get feedback quicker
on whether or not your code is working. Because the tests are running at the
same time, make sure your tests don’t depend on each other or on any shared
state, including a shared environment, such as the current working directory or
environment variables.
-->
<p>複数のテストを実行するとき、標準では、スレッドを使用して並行に走ります。これはつまり、
テストが早く実行し終わり、コードが機能しているいかんにかかわらず、反応をより早く得られることを意味します。
テストは同時に実行されているので、テストが相互や共有された環境を含む他の共通の状態に依存してないことを確かめてください。
現在の作業対象ディレクトリや環境変数などですね。</p>
<!--
For example, say each of your tests runs some code that creates a file on disk
named *test-output.txt* and writes some data to that file. Then each test reads
the data in that file and asserts that the file contains a particular value,
which is different in each test. Because the tests run at the same time, one
test might overwrite the file between when another test writes and reads the
file. The second test will then fail, not because the code is incorrect but
because the tests have interfered with each other while running in parallel.
One solution is to make sure each test writes to a different file; another
solution is to run the tests one at a time.
-->
<p>例えば、各テストがディスクに<em>test_output.txt</em>というファイルを作成し、何らかのデータを書き込むコードを走らせるとしてください。
そして、各テストはそのファイルのデータを読み取り、ファイルが特定の値を含んでいるとアサーションし、
その値は各テストで異なります。テストが同時に走るので、あるテストが、
他のテストが書き込んだり読み込んだりする間隙にファイルを上書きするかもしれません。
それから2番目のテストが失敗します。コードが不正だからではなく、
並行に実行されている間にテストがお互いに邪魔をしてしまったせいです。
各テストが異なるファイルに書き込むことを確かめるのが一つの解決策です; 別の解決策では、
一度に一つのテストを実行します。</p>
<!--
If you don’t want to run the tests in parallel or if you want more fine-grained
control over the number of threads used, you can send the `--test-threads` flag
and the number of threads you want to use to the test binary. Take a look at
the following example:
-->
<p>並行にテストを実行したくなかったり、使用されるスレッド数をよりきめ細かく制御したい場合、
<code>--test-threads</code>フラグと使用したいスレッド数をテストバイナリに送ることができます。
以下の例に目を向けてください:</p>
<pre><code class="language-text">$ cargo test -- --test-threads=1
</code></pre>
<!--
We set the number of test threads to `1`, telling the program not to use any
parallelism. Running the tests using one thread will take longer than running
them in parallel, but the tests won’t interfere with each other if they share
state.
-->
<p>テストスレッドの数を<code>1</code>にセットし、並行性を使用しないようにプログラムに指示しています。
1スレッドのみを使用してテストを実行すると、並行に実行するより時間がかかりますが、
状態を共有していても、お互いに邪魔をすることはありません。</p>
<!--
### Showing Function Output
-->
<h3 id="関数の出力を表示する"><a class="header" href="#関数の出力を表示する">関数の出力を表示する</a></h3>
<!--
By default, if a test passes, Rust’s test library captures anything printed to
standard output. For example, if we call `println!` in a test and the test
passes, we won’t see the `println!` output in the terminal; we’ll only see the
line that indicates the test passed. If a test fails, we’ll see whatever was
printed to standard output with the rest of the failure message.
-->
<p>標準では、テストが通ると、Rustのテストライブラリは標準出力に出力されたものを全てキャプチャします。例えば、
テストで<code>println!</code>を呼び出してテストが通ると、<code>println!</code>の出力は、端末に表示されません;
テストが通ったことを示す行しか見られないでしょう。テストが失敗すれば、
残りの失敗メッセージと共に、標準出力に出力されたものが全て見えるでしょう。</p>
<!--
As an example, Listing 11-10 has a silly function that prints the value of its
parameter and returns 10, as well as a test that passes and a test that fails.
-->
<p>例として、リスト11-10は引数の値を出力し、10を返す馬鹿げた関数と通過するテスト1つ、失敗するテスト1つです。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn prints_and_returns_10(a: i32) -&gt; i32 {
    //{}という値を得た
    println!(&quot;I got the value {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-10: Tests for a function that calls
`println!`</span>
-->
<p><span class="caption">リスト11-10: <code>println!</code>を呼び出す関数用のテスト</span></p>
<!--
When we run these tests with `cargo test`, we’ll see the following output:
-->
<p>これらのテストを<code>cargo test</code>で実行すると、以下のような出力を目の当たりにするでしょう:</p>
<pre><code class="language-text">running 2 tests
test tests::this_test_will_pass ... ok
test tests::this_test_will_fail ... FAILED

failures:

---- tests::this_test_will_fail stdout ----
        I got the value 8
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
Note that nowhere in this output do we see `I got the value 4`, which is what
is printed when the test that passes runs. That output has been captured. The
output from the test that failed, `I got the value 8`, appears in the section
of the test summary output, which also shows the cause of the test failure.
-->
<p>この出力のどこにも <code>I got the value 4</code> と表示されていないことに注意してください。
これは、テストに合格した場合に出力されるものです。
その出力はキャプチャされてしまいました。
失敗したテストのからの出力 <code>I got the value 8</code> がテストサマリー出力のセクションに表示され、テストが失敗した原因も示されます。</p>
<!--
If we want to see printed values for passing tests as well, we can disable the
output capture behavior by using the `--nocapture` flag:
-->
<p>通過するテストについても出力される値が見たかったら、出力キャプチャ機能を<code>--nocapture</code>フラグで無効化することができます:</p>
<pre><code class="language-text">$ cargo test -- --nocapture
</code></pre>
<!--
When we run the tests in Listing 11-10 again with the `--nocapture` flag, we
see the following output:
-->
<p>リスト11-10のテストを<code>--nocapture</code>フラグと共に再度実行したら、以下のような出力を目の当たりにします:</p>
<pre><code class="language-text">running 2 tests
I got the value 4
I got the value 8
test tests::this_test_will_pass ... ok
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.
test tests::this_test_will_fail ... FAILED

failures:

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
Note that the output for the tests and the test results are interleaved; the
reason is that the tests are running in parallel, as we talked about in the
previous section. Try using the `--test-threads=1` option and the `--nocapture`
flag, and see what the output looks like then!
-->
<p>テスト用の出力とテスト結果の出力がまぜこぜになっていることに注意してください;
その理由は、前節で語ったようにテストが並行に実行されているからです。
<code>-test-threads=1</code>オプションと<code>--nocapture</code>フラグを使ってみて、
その時、出力がどうなるか確かめてください！</p>
<!--
### Running a Subset of Tests by Name
-->
<h3 id="名前でテストの一部を実行する"><a class="header" href="#名前でテストの一部を実行する">名前でテストの一部を実行する</a></h3>
<!--
Sometimes, running a full test suite can take a long time. If you’re working on
code in a particular area, you might want to run only the tests pertaining to
that code. You can choose which tests to run by passing `cargo test` the name
or names of the test(s) you want to run as an argument.
-->
<p>時々、全テストを実行すると時間がかかってしまうことがあります。特定の部分のコードしか対象にしていない場合、
そのコードに関わるテストのみを走らせたいかもしれません。<code>cargo test</code>に走らせたいテストの名前を引数として渡すことで、
実行するテストを選ぶことができます。</p>
<!--
To demonstrate how to run a subset of tests, we’ll create three tests for our
`add_two` function, as shown in Listing 11-11, and choose which ones to run.
-->
<p>テストの一部を走らせる方法を模擬するために、リスト11-11に示したように、
<code>add_two</code>関数用に3つテストを作成し、走らせるテストを選択します。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-11: Three tests with three different
names</span>
-->
<p><span class="caption">リスト11-11: 異なる名前の3つのテスト</span></p>
<!--
If we run the tests without passing any arguments, as we saw earlier, all the
tests will run in parallel:
-->
<p>以前見かけたように、引数なしでテストを走らせたら、全テストが並行に走ります:</p>
<pre><code class="language-text">running 3 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
#### Running Single Tests
-->
<h4 id="単独のテストを走らせる"><a class="header" href="#単独のテストを走らせる">単独のテストを走らせる</a></h4>
<!--
We can pass the name of any test function to `cargo test` to run only that test:
-->
<p>あらゆるテスト関数の名前を<code>cargo test</code>に渡して、そのテストのみを実行することができます:</p>
<pre><code class="language-text">$ cargo test one_hundred
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<!--
Only the test with the name `one_hundred` ran; the other two tests didn't match
that name. The test output lets us know we had more tests than what this
command ran by displaying `2 filtered out` at the end of the summary line.
-->
<p><code>one_hundred</code>という名前のテストだけが走りました; 他の2つのテストはその名前に合致しなかったのです。
まとめ行の最後に<code>2 filtered out</code>と表示することでテスト出力は、このコマンドが走らせた以上のテストがあることを知らせてくれています。</p>
<!--
We can’t specify the names of multiple tests in this way; only the first value
given to `cargo test` will be used. But there is a way to run multiple tests.
-->
<p>この方法では、複数のテストの名前を指定することはできません; <code>cargo test</code>に与えられた最初の値のみが使われるのです。
ですが、複数のテストを走らせる方法もあります。</p>
<!--
#### Filtering to Run Multiple Tests
-->
<h4 id="複数のテストを実行するようフィルターをかける"><a class="header" href="#複数のテストを実行するようフィルターをかける">複数のテストを実行するようフィルターをかける</a></h4>
<!--
We can specify part of a test name, and any test whose name matches that value
will be run. For example, because two of our tests’ names contain `add`, we can
run those two by running `cargo test add`:
-->
<p>テスト名の一部を指定でき、その値に合致するあらゆるテストが走ります。例えば、
我々のテストの2つが<code>add</code>という名前を含むので、<code>cargo test add</code>を実行することで、その二つを走らせることができます:</p>
<pre><code class="language-text">$ cargo test add
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 2 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<!--
This command ran all tests with `add` in the name and filtered out the test
named `one_hundred`. Also note that the module in which tests appear becomes
part of the test’s name, so we can run all the tests in a module by filtering
on the module’s name.
-->
<p>このコマンドは名前に<code>add</code>を含むテストを全て実行し、<code>one_hundred</code>という名前のテストを除外しました。
また、テストが出現するモジュールがテスト名の一部になっていて、
モジュール名でフィルターをかけることで、あるモジュール内のテスト全てを実行できることに注目してください。</p>
<!--
### Ignoring Some Tests Unless Specifically Requested
-->
<h3 id="特に要望のない限りテストを無視する"><a class="header" href="#特に要望のない限りテストを無視する">特に要望のない限りテストを無視する</a></h3>
<!--
Sometimes a few specific tests can be very time-consuming to execute, so you
might want to exclude them during most runs of `cargo test`. Rather than
listing as arguments all tests you do want to run, you can instead annotate the
time-consuming tests using the `ignore` attribute to exclude them, as shown
here:
-->
<p>時として、いくつかの特定のテストが実行するのに非常に時間がかかることがあり、
<code>cargo test</code>の実行のほとんどで除外したくなるかもしれません。引数として確かに実行したいテストを全て列挙するのではなく、
ここに示したように代わりに時間のかかるテストを<code>ignore</code>属性で除外すると注釈することができます。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // 実行に1時間かかるコード
    // code that takes an hour to run
}
<span class="boring">}
</span></code></pre></pre>
<!--
After `#[test]` we add the `#[ignore]` line to the test we want to exclude. Now
when we run our tests, `it_works` runs, but `expensive_test` doesn’t:
-->
<p><code>#[test]</code>の後の除外したいテストに<code>#[ignore]</code>行を追加しています。これで、
テストを実行したら、<code>it_works</code>は実行されるものの、<code>expensive_test</code>は実行されません:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
The `expensive_test` function is listed as `ignored`. If we want to run only
the ignored tests, we can use `cargo test -- --ignored`:
-->
<p><code>expensive_test</code>関数は、<code>ignored</code>と列挙されています。無視されるテストのみを実行したかったら、
<code>cargo test -- --ignored</code>を使うことができます:</p>
<pre><code class="language-text">$ cargo test -- --ignored
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<!--
1行目後半、"make sure ..."のところを「結果が早く出る」と訳しているが、この書き方では「結果が早い」としか読めない。どうしたものか
-->
<!--
By controlling which tests run, you can make sure your `cargo test` results
will be fast. When you’re at a point where it makes sense to check the results
of the `ignored` tests and you have time to wait for the results, you can run
`cargo test -- --ignored` instead.
-->
<p>どのテストを走らせるか制御することで、結果が早く出ることを確かめることができるのです。
<code>ignored</code>テストの結果を確認することが道理に合い、結果を待つだけの時間ができたときに、
代わりに<code>cargo test -- --ignored</code>を走らせることができます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Test Organization
-->
<h2 id="テストの体系化"><a class="header" href="#テストの体系化">テストの体系化</a></h2>
<!--
As mentioned at the start of the chapter, testing is a complex discipline, and
different people use different terminology and organization. The Rust community
thinks about tests in terms of two main categories: *unit tests* and
*integration tests*. Unit tests are small and more focused, testing one module
in isolation at a time, and can test private interfaces. Integration tests are
entirely external to your library and use your code in the same way any other
external code would, using only the public interface and potentially exercising
multiple modules per test.
-->
<p>章の初めで触れたように、テストは複雑な鍛錬であり、人によって専門用語や体系化が異なります。
Rustのコミュニティでは、テストを2つの大きなカテゴリで捉えています: <em>単体テスト</em>と<em>結合テスト</em>です。
単体テストは小規模でより集中していて、個別に1回に1モジュールをテストし、非公開のインターフェイスもテストすることがあります。
結合テストは、完全にライブラリ外になり、他の外部コード同様に自分のコードを使用し、公開インターフェイスのみ使用し、
1テストにつき複数のモジュールを用いることもあります。</p>
<!--
Writing both kinds of tests is important to ensure that the pieces of your
library are doing what you expect them to, separately and together.
-->
<p>どちらのテストを書くのも、ライブラリの一部が個別かつ共同でしてほしいことをしていることを確認するのに重要なのです。</p>
<!--
### Unit Tests
-->
<h3 id="単体テスト"><a class="header" href="#単体テスト">単体テスト</a></h3>
<!--
The purpose of unit tests is to test each unit of code in isolation from the
rest of the code to quickly pinpoint where code is and isn’t working as
expected. We put unit tests in the *src* directory in each file with the
code that they’re testing. The convention is to create a module named `tests`
in each file to contain the test functions and to annotate the module with
`cfg(test)`.
-->
<p>単体テストの目的は、残りのコードから切り離して各単位のコードをテストし、
コードが想定通り、動いたり動いていなかったりする箇所を迅速に特定することです。
単体テストは、テスト対象となるコードと共に、<em>src</em>ディレクトリの各ファイルに置きます。
慣習は、各ファイルに<code>tests</code>という名前のモジュールを作り、テスト関数を含ませ、
そのモジュールを<code>cfg(test)</code>で注釈することです。</p>
<!--
#### The Tests Module and `#[cfg(test)]`
-->
<h4 id="テストモジュールとcfgtest"><a class="header" href="#テストモジュールとcfgtest">テストモジュールと<code>#[cfg(test)]</code></a></h4>
<!--
The `#[cfg(test)]` annotation on the tests module tells Rust to compile and run
the test code only when we run `cargo test`, but not when we run `cargo build`.
This saves compile time when we only want to build the library and saves space
in the resulting compiled artifact because the tests are not included. You’ll
see that because integration tests go in a different directory, they don’t need
the `#[cfg(test)]` annotation. However, because unit tests go in the same files
as the code, we use `#[cfg(test)]` to specify that they shouldn’t be
included in the compiled result.
-->
<p>testsモジュールの<code>#[cfg(test)]</code>という注釈は、コンパイラに<code>cargo build</code>を走らせた時ではなく、<code>cargo test</code>を走らせた時にだけ、
テストコードをコンパイルし走らせるよう指示します。これにより、ライブラリをビルドしたいだけの時にはコンパイルタイムを節約し、
テストが含まれないので、コンパイル後の成果物のサイズも節約します。結合テストは別のディレクトリに存在することになるので、
<code>#[cfg(test)]</code>注釈は必要ないとわかるでしょう。しかしながら、単体テストはコードと同じファイルに存在するので、
<code>#[cfg(test)]</code>を使用してコンパイル結果に含まれないよう指定するのです。</p>
<!--
Recall that when we generated the new `adder` project in the first section of
this chapter, Cargo generated this code for us:
-->
<p>この章の最初の節で新しい<code>adder</code>プロジェクトを生成した時に、Cargoがこのコードも生成してくれたことを思い出してください:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code is the automatically generated test module. The attribute `cfg`
stands for *configuration* and tells Rust that the following item should only
be included given a certain configuration option. In this case, the
configuration option is `test`, which is provided by Rust for compiling and
running tests. By using the `cfg` attribute, Cargo compiles our test code only
if we actively run the tests with `cargo test`. This includes any helper
functions that might be within this module, in addition to the functions
annotated with `#[test]`.
-->
<p>このコードが自動生成されたテストモジュールです。<code>cfg</code>という属性は、<em>configuration</em>を表していて、
コンパイラに続く要素が、ある特定の設定オプションを与えられたら、含まれるように指示します。
今回の場合、設定オプションは、<code>test</code>であり、言語によって提供されているテストをコンパイルし、
走らせるためのものです。<code>cfg</code>属性を使用することで、<code>cargo test</code>で積極的にテストを実行した場合のみ、
Cargoがテストコードをコンパイルします。これには、このモジュールに含まれるかもしれないヘルパー関数全ても含まれ、
<code>#[test]</code>で注釈された関数だけにはなりません。</p>
<!--
#### Testing Private Functions
-->
<h4 id="非公開関数をテストする"><a class="header" href="#非公開関数をテストする">非公開関数をテストする</a></h4>
<!--
There’s debate within the testing community about whether or not private
functions should be tested directly, and other languages make it difficult or
impossible to test private functions. Regardless of which testing ideology you
adhere to, Rust’s privacy rules do allow you to test private functions.
Consider the code in Listing 11-12 with the private function `internal_adder`.
-->
<p>テストコミュニティ内で非公開関数を直接テストするべきかについては議論があり、
他の言語では非公開関数をテストするのは困難だったり、不可能だったりします。
あなたがどちらのテストイデオロギーを支持しているかに関わらず、Rustの公開性規則により、
非公開関数をテストすることが確かに可能です。リスト11-12の非公開関数<code>internal_adder</code>を含むコードを考えてください。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 11-12: Testing a private function</span>
-->
<p><span class="caption">リスト11-12: 非公開関数をテストする</span></p>
<!--
Note that the `internal_adder` function is not marked as `pub`, but because
tests are just Rust code and the `tests` module is just another module, you can
import and call `internal_adder` in a test just fine. If you don’t think
private functions should be tested, there’s nothing in Rust that will compel
you to do so.
-->
<p><code>internal_adder</code>関数は<code>pub</code>とマークされていないものの、テストも単なるRustのコードであり、
<code>tests</code>モジュールもただのモジュールでしかないので、テスト内で<code>internal_adder</code>を普通にインポートし呼び出すことができます。
非公開関数はテストするべきではないとお考えなら、Rustにはそれを強制するものは何もありません。</p>
<!--
### Integration Tests
-->
<h3 id="結合テスト"><a class="header" href="#結合テスト">結合テスト</a></h3>
<!--
In Rust, integration tests are entirely external to your library. They use your
library in the same way any other code would, which means they can only call
functions that are part of your library’s public API. Their purpose is to test
whether many parts of your library work together correctly. Units of code that
work correctly on their own could have problems when integrated, so test
coverage of the integrated code is important as well. To create integration
tests, you first need a *tests* directory.
-->
<p>Rustにおいて、結合テストは完全にライブラリ外のものです。他のコードと全く同様にあなたのライブラリを使用するので、
ライブラリの公開APIの一部である関数しか呼び出すことはできません。その目的は、
ライブラリのいろんな部分が共同で正常に動作しているかをテストすることです。
単体では正常に動くコードも、結合した状態だと問題を孕む可能性もあるので、
結合したコードのテストの範囲も同様に重要になるのです。結合テストを作成するには、
まず<em>tests</em>ディレクトリが必要になります。</p>
<!--
#### The *tests* Directory
-->
<h4 id="testsディレクトリ"><a class="header" href="#testsディレクトリ"><em>tests</em>ディレクトリ</a></h4>
<!--
We create a *tests* directory at the top level of our project directory, next
to *src*. Cargo knows to look for integration test files in this directory. We
can then make as many test files as we want to in this directory, and Cargo
will compile each of the files as an individual crate.
-->
<p>プロジェクトディレクトリのトップ階層、<em>src</em>の隣に<em>tests</em>ディレクトリを作成します。
Cargoは、このディレクトリに結合テストのファイルを探すことを把握しています。
そして、このディレクトリ内にいくらでもテストファイルを作成することができ、
Cargoはそれぞれのファイルを個別のクレートとしてコンパイルします。</p>
<!--
Let’s create an integration test. With the code in Listing 11-12 still in the
*src/lib.rs* file, make a *tests* directory, create a new file named
*tests/integration_test.rs*, and enter the code in Listing 11-13.
-->
<p>結合テストを作成しましょう。リスト11-12のコードが<em>src/lib.rs</em>ファイルにあるまま、
<em>tests</em>ディレクトリを作成し、<em>tests/integration_test.rs</em>という名前の新しいファイルを生成し、
リスト11-13のコードを入力してください。</p>
<!--
<span class="filename">Filename: tests/integration_test.rs</span>
-->
<p><span class="filename">ファイル名: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<!--
<span class="caption">Listing 11-13: An integration test of a function in the
`adder` crate</span>
-->
<p><span class="caption">リスト11-13: <code>adder</code>クレートの関数の結合テスト</span></p>
<!--
We’ve added `extern crate adder` at the top of the code, which we didn’t need
in the unit tests. The reason is that each test in the `tests` directory is a
separate crate, so we need to import our library into each of them.
-->
<p>コードの頂点に<code>extern crate adder</code>を追記しましたが、これは単体テストでは必要なかったものです。
理由は、<code>tests</code>ディレクトリのテストはそれぞれ個別のクレートであるため、
各々ライブラリをインポートする必要があるためです。</p>
<!--
We don’t need to annotate any code in *tests/integration_test.rs* with
`#[cfg(test)]`. Cargo treats the `tests` directory specially and compiles files
in this directory only when we run `cargo test`. Run `cargo test` now:
-->
<p><em>tests/integration_test.rs</em>のどんなコードも<code>#[cfg(test)]</code>で注釈する必要はありません。
Cargoは<code>tests</code>ディレクトリを特別に扱い、<code>cargo test</code>を走らせた時にのみこのディレクトリのファイルをコンパイルするのです。
さあ、<code>cargo test</code>を実行してください:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running target/debug/deps/adder-abcabcabc

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-ce99bcc2479f4607

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
The three sections of output include the unit tests, the integration test, and
the doc tests. The first section for the unit tests is the same as we’ve been
seeing: one line for each unit test (one named `internal` that we added in
Listing 11-12) and then a summary line for the unit tests.
-->
<p>3つの区域の出力が単体テスト、結合テスト、ドックテストを含んでいます。単体テスト用の最初の区域は、
今まで見てきたものと同じです: 各単体テストに1行(リスト11-12で追加した<code>internal</code>という名前のもの)と、
単体テストのサマリー行です。</p>
<!--
The integration tests section starts with the line `Running
target/debug/deps/integration-test-ce99bcc2479f4607` (the hash at the end of
your output will be different). Next, there is a line for each test function in
that integration test and a summary line for the results of the integration
test just before the `Doc-tests adder` section starts.
-->
<p>結合テストの区域は、
<code>Running target/debug/deps/integration-test-ce99bcc2479f4607</code>という行で始まっています(最後のハッシュはあなたの出力とは違うでしょう)。
次に、この結合テストの各テスト関数用の行があり、<code>Doc-tests adder</code>区域が始まる直前に、
結合テストの結果用のサマリー行があります。</p>
<!--
Similarly to how adding more unit test functions adds more result lines to the
unit tests section, adding more test functions to the integration test file
adds more result lines to this integration test file’s section. Each
integration test file has its own section, so if we add more files in the
*tests* directory, there will be more integration test sections.
-->
<p>単体テスト関数を追加することで単体テスト区域のテスト結果の行が増えたように、
作成した結合テストファイルにテスト関数を追加することでそのファイルの区域に結果の行が増えることになります。
結合テストファイルはそれぞれ独自の区域があるため、<em>tests</em>ディレクトリにさらにファイルを追加すれば、
結合テストの区域が増えることになるでしょう。</p>
<!--
We can still run a particular integration test function by specifying the test
function’s name as an argument to `cargo test`. To run all the tests in a
particular integration test file, use the `--test` argument of `cargo test`
followed by the name of the file:
-->
<p>それでも、テスト関数の名前を引数として<code>cargo test</code>に指定することで、特定の結合テスト関数を走らせることができます。
特定の結合テストファイルにあるテストを全て走らせるには、<code>cargo test</code>に<code>--test</code>引数、
その後にファイル名を続けて使用してください:</p>
<pre><code class="language-text">$ cargo test --test integration_test
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/integration_test-952a27e0126bb565

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
This command runs only the tests in the *tests/integration_test.rs* file.
-->
<p>このコマンドは、<em>tests/integration_test.rs</em>ファイルにあるテストのみを実行します。</p>
<!--
#### Submodules in Integration Tests
-->
<h4 id="結合テスト内のサブモジュール"><a class="header" href="#結合テスト内のサブモジュール">結合テスト内のサブモジュール</a></h4>
<!--
As you add more integration tests, you might want to make more than one file in
the *tests* directory to help organize them; for example, you can group the
test functions by the functionality they’re testing. As mentioned earlier, each
file in the *tests* directory is compiled as its own separate crate.
-->
<p>結合テストを追加するにつれて、<em>tests</em>ディレクトリに2つ以上のファイルを作成して体系化したくなるかもしれません;
例えば、テスト対象となる機能でテスト関数をグループ化することができます。前述したように、
<em>tests</em>ディレクトリの各ファイルは、個別のクレートとしてコンパイルされます。</p>
<!--
Treating each integration test file as its own crate is useful to create
separate scopes that are more like the way end users will be using your crate.
However, this means files in the *tests* directory don’t share the same
behavior as files in *src* do, as you learned in Chapter 7 regarding how to
separate code into modules and files.
-->
<p>各結合テストファイルをそれ自身のクレートとして扱うと、
エンドユーザがあなたのクレートを使用するかのように個別のスコープを生成するのに役立ちます。
ですが、これは<em>tests</em>ディレクトリのファイルが、コードをモジュールとファイルに分ける方法に関して第7章で学んだように、
<em>src</em>のファイルとは同じ振る舞いを共有しないことを意味します。</p>
<!--
The different behavior of files in the *tests* directory is most noticeable
when you have a set of helper functions that would be useful in multiple
integration test files and you try to follow the steps in the “Moving Modules
to Other Files” section of Chapter 7 to extract them into a common module. For
example, if we create *tests/common.rs* and place a function named `setup` in
it, we can add some code to `setup` that we want to call from multiple test
functions in multiple test files:
-->
<p><em>tests</em>ディレクトリのファイルの異なる振る舞いは、複数の結合テストファイルで役に立ちそうなヘルパー関数ができ、
第7章の「モジュールを別のファイルに移動する」節の手順に従って共通モジュールに抽出しようとした時に最も気付きやすくなります。
例えば、<em>tests/common.rs</em>を作成し、そこに<code>setup</code>という名前の関数を配置したら、
複数のテストファイルの複数のテスト関数から呼び出したい<code>setup</code>に何らかのコードを追加することができます:</p>
<!--
<span class="filename">Filename: tests/common.rs</span>
-->
<p><span class="filename">ファイル名: tests/common.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn setup() {
    // ここにライブラリテスト固有のコードが来る
    // setup code specific to your library's tests would go here
}
<span class="boring">}
</span></code></pre></pre>
<!--
When we run the tests again, we’ll see a new section in the test output for the
*common.rs* file, even though this file doesn’t contain any test functions nor
did we call the `setup` function from anywhere:
-->
<p>再度テストを実行すると、<em>common.rs</em>ファイルは何もテスト関数を含んだり、<code>setup</code>関数をどこかから呼んだりしてないのに、
テスト出力に<em>common.rs</em>用の区域が見えるでしょう。</p>
<pre><code class="language-text">running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-b8b07b6f1be2db70

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-d993c68b431d39df

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
Having `common` appear in the test results with `running 0 tests` displayed for
it is not what we wanted. We just wanted to share some code with the other
integration test files.
-->
<p><code>common</code>が<code>running 0 tests</code>とテスト結果に表示されるのは、望んだ結果ではありません。
ただ単に他の結合テストファイルと何らかのコードを共有したかっただけです。</p>
<!--
To avoid having `common` appear in the test output, instead of creating
*tests/common.rs*, we’ll create *tests/common/mod.rs*. In the “Rules of Module
Filesystems” section of Chapter 7, we used the naming convention
*module_name/mod.rs* for files of modules that have submodules. We don’t have
submodules for `common` here, but naming the file this way tells Rust not to
treat the `common` module as an integration test file. When we move the `setup`
function code into *tests/common/mod.rs* and delete the *tests/common.rs* file,
the section in the test output will no longer appear. Files in subdirectories
of the *tests* directory don’t get compiled as separate crates or have sections
in the test output.
-->
<p><code>common</code>がテスト出力に出現するのを防ぐには、<em>tests/common.rs</em>を作成する代わりに、
<em>tests/common/mod.rs</em>を作成します。第7章の「モジュールファイルシステムの規則」節において、
<em>module_name/mod.rs</em>という命名規則をサブモジュールのあるモジュールのファイルに使用しました。
ここでは<code>common</code>にサブモジュールはありませんが、
このように命名することでコンパイラに<code>common</code>モジュールを結合テストファイルとして扱わないように指示します。
<code>setup</code>関数のコードを<em>tests/common/mod.rs</em>に移動し、<em>tests/common.rs</em>ファイルを削除すると、
テスト出力に区域はもう表示されなくなります。<em>tests</em>ディレクトリのサブディレクトリ内のファイルは個別クレートとしてコンパイルされたり、
テスト出力に区域が表示されることがないのです。</p>
<!--
After we’ve created *tests/common/mod.rs*, we can use it from any of the
integration test files as a module. Here’s an example of calling the `setup`
function from the `it_adds_two` test in *tests/integration_test.rs*:
-->
<p><em>tests/common/mod.rs</em>を作成した後、それをどの結合テストファイルからもモジュールとして使用することができます。
こちらは、<em>tests/integration_test.rs</em>内の<code>it_adds_two</code>テストから<code>setup</code>関数を呼び出す例です:</p>
<!--
<span class="filename">Filename: tests/integration_test.rs</span>
-->
<p><span class="filename">ファイル名: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">extern crate adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<!--
Note that the mod common; declaration is the same as the module declaration we demonstrated in Listing 7-21. Then in the test function, we can call the common::setup() function.
-->
<p><code>mod common;</code>という宣言は、リスト7-21で模擬したモジュール宣言と同じであることに注意してください。それから、テスト関数内で<code>common::setup()</code>関数を呼び出すことができます。</p>
<!--
#### Integration Tests for Binary Crates
-->
<h4 id="バイナリクレート用の結合テスト"><a class="header" href="#バイナリクレート用の結合テスト">バイナリクレート用の結合テスト</a></h4>
<!--
If our project is a binary crate that only contains a *src/main.rs* file and
doesn’t have a *src/lib.rs* file, we can’t create integration tests in the
*tests* directory and use `extern crate` to import functions defined in the
*src/main.rs* file. Only library crates expose functions that other crates can
call and use; binary crates are meant to be run on their own.
-->
<p>もしもプロジェクトが<em>src/main.rs</em>ファイルのみを含み、<em>src/lib.rs</em>ファイルを持たないバイナリクレートだったら、
<em>tests</em>ディレクトリに結合テストを作成し、
<code>extern crate</code>を使用して<em>src/main.rs</em>ファイルに定義された関数をインポートすることはできません。
ライブラリクレートのみが、他のクレートが呼び出して使用できる関数を晒せるのです; 
バイナリクレートはそれ単体で実行することを意味しています。</p>
<!--
This is one of the reasons Rust projects that provide a binary have a
straightforward *src/main.rs* file that calls logic that lives in the
*src/lib.rs* file. Using that structure, integration tests *can* test the
library crate by using `extern crate` to exercise the important functionality.
If the important functionality works, the small amount of code in the
*src/main.rs* file will work as well, and that small amount of code doesn’t
need to be tested.
-->
<p>これは、バイナリを提供するRustのプロジェクトに、
<em>src/lib.rs</em>ファイルに存在するロジックを呼び出す単純な<em>src/main.rs</em>ファイルがある一因になっています。
この構造を使用して結合テストは、<code>extern crate</code>を使用して重要な機能を用いることでライブラリクレートをテストすることが<em>できます</em>。
この重要な機能が動作すれば、<em>src/main.rs</em>ファイルの少量のコードも動作し、その少量のコードはテストする必要がないわけです。</p>
<!--
## Summary
-->
<h2 id="まとめ-10"><a class="header" href="#まとめ-10">まとめ</a></h2>
<!--
Rust’s testing features provide a way to specify how code should function to
ensure it continues to work as we expect, even as we make changes. Unit tests
exercise different parts of a library separately and can test private
implementation details. Integration tests check that many parts of the library
work together correctly, and they use the library’s public API to test the code
in the same way external code will use it. Even though Rust’s type system and
ownership rules help prevent some kinds of bugs, tests are still important to
help reduce logic bugs having to do with how your code is expected to behave.
-->
<p>Rustのテスト機能は、変更を加えた後でさえ想定通りにコードが機能し続けることを保証して、
コードが機能すべき方法を指定する手段を提供します。単体テストはライブラリの異なる部分を個別に用い、
非公開の実装詳細をテストすることができます。結合テストは、ライブラリのいろんな部分が共同で正常に動作することを確認し、
ライブラリの公開APIを使用して外部コードが使用するのと同じ方法でコードをテストします。
Rustの型システムと所有権ルールにより防がれるバグの種類もあるものの、それでもテストは、
コードが振る舞うと予想される方法に関するロジックのバグを減らすのに重要なのです。</p>
<!--
Let’s combine the knowledge you learned in this chapter and in previous
chapters and work on a project!
-->
<p>この章と以前の章で学んだ知識を結集して、とあるプロジェクトに取り掛かりましょう！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# An I/O Project: Building a Command Line Program
-->
<h1 id="入出力プロジェクト-コマンドラインプログラムを構築する"><a class="header" href="#入出力プロジェクト-コマンドラインプログラムを構築する">入出力プロジェクト: コマンドラインプログラムを構築する</a></h1>
<!--
This chapter is a recap of the many skills you’ve learned so far and an
exploration of a few more standard library features. We’ll build a command line
tool that interacts with file and command line input/output to practice some of
the Rust concepts you now have under your belt.
-->
<p>この章は、ここまでに学んできた多くのスキルを思い出すきっかけであり、もういくつか標準ライブラリの機能も探究します。
ファイルやコマンドラインの入出力と相互作用するコマンドラインツールを構築し、
今やあなたの支配下にあるRustの概念の一部を練習していきます。</p>
<!--
Rust’s speed, safety, single binary output, and cross-platform support make it
an ideal language for creating command line tools, so for our project, we’ll
make our own version of the classic command line tool `grep` (**g**lobally
search a **r**egular **e**xpression and **p**rint). In the simplest use case,
`grep` searches a specified file for a specified string. To do so, `grep` takes
as its arguments a filename and a string. Then it reads the file, finds lines
in that file that contain the string argument, and prints those lines.
-->
<p>Rustの速度、安全性、単バイナリ出力、クロスプラットフォームサポートにより、コマンドラインツールを作るのにふさわしい言語なので、
このプロジェクトでは、独自の伝統的なコマンドラインツールの<code>grep</code>(<strong>g</strong>lobally search a <strong>r</strong>egular <strong>e</strong>xpression
and <strong>p</strong>rint: 正規表現をグローバルで検索し表示する)を作成していきます。最も単純な使用法では、
<code>grep</code>は指定したファイルから指定した文字列を検索します。そうするには、
<code>grep</code>は引数としてファイル名と文字列を受け取ります。それからファイルを読み込んでそのファイル内で文字列引数を含む行を探し、
検索した行を出力するのです。</p>
<!--
Along the way, we’ll show how to make our command line tool use features of the
terminal that many command line tools use. We’ll read the value of an
environment variable to allow the user to configure the behavior of our tool.
We’ll also print to the standard error console stream (`stderr`) instead of
standard output (`stdout`), so, for example, the user can redirect successful
output to a file while still seeing error messages onscreen.
-->
<p>その過程で、多くのコマンドラインツールが使用している端末の機能を使用させる方法を示します。
環境変数の値を読み取ってユーザがこのツールの振る舞いを設定できるようにします。また、
標準出力(<code>stdout</code>)の代わりに、標準エラーに出力(<code>stderr</code>)するので、例えば、
ユーザはエラーメッセージは画面上で確認しつつ、成功した出力はファイルにリダイレクトできます。</p>
<!--
One Rust community member, Andrew Gallant, has already created a fully
featured, very fast version of `grep`, called `ripgrep`. By comparison, our
version of `grep` will be fairly simple, but this chapter will give you some of
the background knowledge you need to understand a real-world project like
`ripgrep`.
-->
<p>Rustコミュニティのあるメンバであるアンドリュー・ガラント(Andrew Gallant)が既に全機能装備の非常に高速な<code>grep</code>、
<code>ripgrep</code>と呼ばれるものを作成しました。比較対象として、我々の<code>grep</code>はとても単純ですが、
この章により、<code>ripgrep</code>のような現実世界のプロジェクトを理解するのに必要な背景知識の一部を身に付けられるでしょう。</p>
<!--
Our `grep` project will combine a number of concepts you’ve learned so far:
-->
<p>この<code>grep</code>プロジェクトは、ここまでに学んできた多くの概念を集結させます:</p>
<!--
* Organizing code (using what you learned in modules, Chapter 7)
* Using vectors and strings (collections, Chapter 8)
* Handling errors (Chapter 9)
* Using traits and lifetimes where appropriate (Chapter 10)
* Writing tests (Chapter 11)
-->
<ul>
<li>コードを体系化する(モジュール、第7章で学んだことを使用)</li>
<li>ベクタと文字列を使用する(コレクション、第8章)</li>
<li>エラーを処理する(第9章)</li>
<li>適切な箇所でトレイトとライフタイムを使用する(第10章)</li>
<li>テストを記述する(第11章)</li>
</ul>
<!--
We’ll also briefly introduce closures, iterators, and trait objects, which
Chapters 13 and 17 will cover in detail.
-->
<p>さらに、クロージャ、イテレータ、トレイトオブジェクトなど、第13章、17章で詳しく講義するものもちょっとだけ紹介します。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Accepting Command Line Arguments
-->
<h2 id="コマンドライン引数を受け付ける"><a class="header" href="#コマンドライン引数を受け付ける">コマンドライン引数を受け付ける</a></h2>
<!--
Let’s create a new project with, as always, `cargo new`. We’ll call our project
`minigrep` to distinguish it from the `grep` tool that you might already have
on your system.
-->
<p>いつものように、<code>cargo new</code>で新しいプロジェクトを作りましょう。プロジェクトを<code>minigrep</code>と名付けて、
既に自分のシステムに存在するかもしれない<code>grep</code>ツールと区別しましょう。</p>
<!--
The first task is to make `minigrep` accept its two command line arguments: the
filename and a string to search for. That is, we want to be able to run our
program with `cargo run`, a string to search for, and a path to a file to
search in, like so:
-->
<p>最初の仕事は、<code>minigrep</code>を二つの引数を受け付けるようにすることです: ファイル名と検索する文字列ですね。
つまり、<code>cargo run</code>で検索文字列と検索を行うファイルへのパスと共にプログラムを実行できるようになりたいということです。
こんな感じにね:</p>
<pre><code class="language-text">$ cargo run searchstring example-filename.txt
</code></pre>
<!--
Right now, the program generated by `cargo new` cannot process arguments we
give it. Some existing libraries on [Crates.io](https://crates.io/) can help
with writing a program that accepts command line arguments, but because you're
just learning this concept, let’s implement this capability ourselves.
-->
<p>今現在は、<code>cargo new</code>で生成されたプログラムは、与えた引数を処理できません。
<a href="https://crates.io/">Crates.io</a>に存在する既存のライブラリには、
コマンドライン引数を受け付けるプログラムを書く手助けをしてくれるものもありますが、ちょうどこの概念を学んでいる最中なので、
この能力を自分で実装しましょう。</p>
<!--
### Reading the Argument Values
-->
<h3 id="引数の値を読み取る"><a class="header" href="#引数の値を読み取る">引数の値を読み取る</a></h3>
<!--
To enable `minigrep` to read the values of command line arguments we pass to
it, we’ll need a function provided in Rust’s standard library, which is
`std::env::args`. This function returns an *iterator* of the command line
arguments that were given to `minigrep`. We haven’t discussed iterators yet
(we’ll cover them fully in Chapter 13), but for now, you only need to know two
details about iterators: iterators produce a series of values, and we can call
the `collect` function on an iterator to turn it into a collection, such as a
vector, containing all the elements the iterator produces.
-->
<p><code>minigrep</code>が渡したコマンドライン引数の値を読み取れるようにするために、Rustの標準ライブラリで提供されている関数が必要になり、
それは、<code>std::env::args</code>です。この関数は、<code>minigrep</code>に与えられたコマンドライン引数の<em>イテレータ</em>を返します。
イテレータについてはまだ議論していません(完全には第13章で講義します)が、とりあえずイテレータに関しては、
2つの詳細のみ知っていればいいです: イテレータは一連の値を生成することと、イテレータに対して<code>collect</code>関数を呼び出し、
イテレータが生成する要素全部を含むベクタなどのコレクションに変えられることです。</p>
<!--
Use the code in Listing 12-1 to allow your `minigrep` program to read any
command line arguments passed to it and then collect the values into a vector.
-->
<p>リスト12-1のコードを使用して<code>minigrep</code>プログラムに渡されたあらゆるコマンドライン引数を読み取れるようにし、
それからその値をベクタとして集結させてください。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<!--
<span class="caption">Listing 12-1: Collecting the command line arguments into
a vector and printing them</span>
-->
<p><span class="caption">リスト12-1: コマンドライン引数をベクタに集結させ、出力する</span></p>
<!--
First, we bring the `std::env` module into scope with a `use` statement so we
can use its `args` function. Notice that the `std::env::args` function is
nested in two levels of modules. As we discussed in Chapter 7, in cases where
the desired function is nested in more than one module, it’s conventional to
bring the parent module into scope rather than the function. By doing so, we
can easily use other functions from `std::env`. It’s also less ambiguous than
adding `use std::env::args` and then calling the function with just `args`
because `args` might easily be mistaken for a function that’s defined in the
current module.
-->
<p>まず、<code>std::env</code>モジュールを<code>use</code>文でスコープに導入したので、<code>args</code>関数が使用できます。
<code>std::env::args</code>関数は、2レベルモジュールがネストされていることに注目してください。
第7章で議論したように、希望の関数が2モジュール以上ネストされている場合、
関数ではなく親モジュールをスコープに導入するのが因習的です。そうすることで、
<code>std::env</code>から別の関数も容易に使用することができます。また、
<code>use std::env::args</code>を追記し、関数を<code>args</code>とするだけで呼び出すのに比べて曖昧でもありません。
というのも、<code>args</code>は現在のモジュールに定義されている関数と容易に見間違えられるかもしれないからです。</p>
<!--
> ### The `args` Function and Invalid Unicode
>
> Note that `std::env::args` will panic if any argument contains invalid
> Unicode. If your program needs to accept arguments containing invalid
> Unicode, use `std::env::args_os` instead. That function returns an iterator
> that produces `OsString` values instead of `String` values. We’ve chosen to
> use `std::env::args` here for simplicity because `OsString` values differ
> per platform and are more complex to work with than `String` values.
-->
<blockquote>
<h3 id="args関数と不正なユニコード"><a class="header" href="#args関数と不正なユニコード"><code>args</code>関数と不正なユニコード</a></h3>
<p>引数のどれかが不正なユニコードを含んでいたら、<code>std::env::args</code>はパニックすることに注意してください。
プログラムが不正なユニコードを含む引数を受け付ける必要があるなら、代わりに<code>std::env::args_os</code>を使用してください。
この関数は、<code>String</code>値ではなく、<code>OsString</code>値を生成するイテレータを返します。ここでは、
簡潔性のために<code>std::env::args</code>を使うことを選択しました。
なぜなら、<code>OsString</code>値はプラットフォームごとに異なり、<code>String</code>値に比べて取り扱いが煩雑だからです。</p>
</blockquote>
<!--
On the first line of `main`, we call `env::args`, and we immediately use
`collect` to turn the iterator into a vector containing all the values produced
by the iterator. We can use the `collect` function to create many kinds of
collections, so we explicitly annotate the type of `args` to specify that we
want a vector of strings. Although we very rarely need to annotate types in
Rust, `collect` is one function you do often need to annotate because Rust
isn’t able to infer the kind of collection you want.
-->
<p><code>main</code>の最初の行で<code>env::args</code>を呼び出し、そして即座に<code>collect</code>を使用して、
イテレータをイテレータが生成する値全てを含むベクタに変換しています。
<code>collect</code>関数を使用して多くの種類のコレクションを生成することができるので、
<code>args</code>の型を明示的に注釈して文字列のベクタが欲しいのだと指定しています。Rustにおいて、
型を注釈しなければならない頻度は非常に少ないのですが、<code>collect</code>はよく確かに注釈が必要になる一つの関数なのです。
コンパイラには、あなたが欲しているコレクションの種類が推論できないからです。</p>
<!--
Finally, we print the vector using the debug formatter, `:?`. Let’s try running
the code with no arguments and then with two arguments:
-->
<p>最後に、デバッグ整形機の<code>:?</code>を使用してベクタを出力しています。引数なしでコードを走らせてみて、
それから引数二つで試してみましょう:</p>
<pre><code class="language-text">$ cargo run
--snip--
[&quot;target/debug/minigrep&quot;]

$ cargo run needle haystack
--snip--
[&quot;target/debug/minigrep&quot;, &quot;needle&quot;, &quot;haystack&quot;]
</code></pre>
<!--
Notice that the first value in the vector is `"target/debug/minigrep"`, which
is the name of our binary. This matches the behavior of the arguments list in
C, letting programs use the name by which they were invoked in their execution.
It’s often convenient to have access to the program name in case you want to
print it in messages or change behavior of the program based on what command
line alias was used to invoke the program. But for the purposes of this
chapter, we’ll ignore it and save only the two arguments we need.
-->
<p>ベクタの最初の値は<code>&quot;target/debug/minigrep&quot;</code>であることに注目してください。これはバイナリの名前です。
これはCの引数リストの振る舞いと合致し、実行時に呼び出された名前をプログラムに使わせてくれるわけです。
メッセージで出力したり、プログラムを起動するのに使用されたコマンドラインエイリアスによってプログラムの振る舞いを変えたい場合に、
プログラム名にアクセスするのにしばしば便利です。ですが、この章の目的には、これを無視し、必要な二つの引数のみを保存します。</p>
<!--
### Saving the Argument Values in Variables
-->
<h3 id="引数の値を変数に保存する"><a class="header" href="#引数の値を変数に保存する">引数の値を変数に保存する</a></h3>
<!--
Printing the value of the vector of arguments illustrated that the program is
able to access the values specified as command line arguments. Now we need to
save the values of the two arguments in variables so we can use the values
throughout the rest of the program. We do that in Listing 12-2.
-->
<p>引数のベクタの値を出力すると、プログラムはコマンドライン引数として指定された値にアクセスできることが説明されました。
さて、プログラムの残りを通して使用できるように、二つの引数の値を変数に保存する必要があります。
それをしているのがリスト12-2です。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    // {}を探しています
    println!(&quot;Searching for {}&quot;, query);
    // {}というファイルの中
    println!(&quot;In file {}&quot;, filename);
}
</code></pre></pre>
<!--
<span class="caption">Listing 12-2: Creating variables to hold the query
argument and filename argument</span>
-->
<p><span class="caption">リスト12-2: クエリ引数とファイル名引数を保持する変数を生成</span></p>
<!--
As we saw when we printed the vector, the program’s name takes up the first
value in the vector at `args[0]`, so we’re starting at index `1`. The first
argument `minigrep` takes is the string we’re searching for, so we put a
reference to the first argument in the variable `query`. The second argument
will be the filename, so we put a reference to the second argument in the
variable `filename`.
-->
<p>ベクタを出力した時に確認したように、プログラム名がベクタの最初の値、<code>args[0]</code>を占めているので、
添え字<code>1</code>から始めます。<code>minigrep</code>が取る最初の引数は、検索する文字列なので、
最初の引数への参照を変数<code>query</code>に置きました。2番目の引数はファイル名でしょうから、
2番目の引数への参照は変数<code>filename</code>に置きました。</p>
<!--
We temporarily print the values of these variables to prove that the code is
working as we intend. Let’s run this program again with the arguments `test`
and `sample.txt`:
-->
<p>一時的にこれらの変数の値を出力して、コードが意図通りに動いていることを証明しています。
再度このプログラムを<code>test</code>と<code>sample.txt</code>という引数で実行しましょう:</p>
<pre><code class="language-text">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<!--
Great, the program is working! The values of the arguments we need are being
saved into the right variables. Later we’ll add some error handling to deal
with certain potential erroneous situations, such as when the user provides no
arguments; for now, we’ll ignore that situation and work on adding file-reading
capabilities instead.
-->
<p>素晴らしい、プログラムは動作しています！必要な引数の値が、正しい変数に保存されています。後ほど、
何らかのエラー処理を加えて、ユーザが引数を提供しなかった場合など、可能性のある特定のエラー状況に対処します;
今は、そのような状況はないものとし、代わりにファイル読み取り能力を追加することに取り組みます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Reading a File
-->
<h2 id="ファイルを読み込む"><a class="header" href="#ファイルを読み込む">ファイルを読み込む</a></h2>
<!--
Now we’ll add functionality to read the file that is specified in the
`filename` command line argument. First, we need a sample file to test it with:
the best kind of file to use to make sure `minigrep` is working is one with a
small amount of text over multiple lines with some repeated words. Listing 12-3
has an Emily Dickinson poem that will work well! Create a file called
*poem.txt* at the root level of your project, and enter the poem “I’m Nobody!
Who are you?”
-->
<p>では、<code>filename</code>コマンドライン引数で指定されたファイルを読み込む機能を追加しましょう。
まず、テスト実行するためのサンプルファイルが必要ですね: <code>minigrep</code>が動作していることを確かめるために使用するのに最適なファイルは、
複数行にわたって同じ単語の繰り返しのある少量のテキストです。リスト12-3は、
うまくいくであろうエミリー・ディキンソン(Emily Dickinson)の詩です！
プロジェクトのルート階層に<em>poem.txt</em>というファイルを作成し、この詩「私は誰でもない！あなたは誰？」を入力してください。</p>
<!--
<span class="filename">Filename: poem.txt</span>
-->
<p><span class="filename">ファイル名: poem.txt</span></p>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!

私は誰でもない！あなたは誰？
あなたも誰でもないの？
なら、私たちは組だね、何も言わないで！
あの人たちは、私たちを追放するでしょう。わかりますよね？

誰かでいるなんて侘しいじゃない！
カエルみたいで公すぎるじゃない。
自分の名を長い1日に告げるのなんて。
感服するような沼地にね！
</code></pre>
<!--
<span class="caption">Listing 12-3: A poem by Emily Dickinson makes a good test
case</span>
-->
<p><span class="caption">リスト12-3: エミリー・ディキンソンの詩は、いいテストケースになる</span></p>
<!--
With the text in place, edit *src/main.rs* and add code to open the file, as
shown in Listing 12-4.
-->
<p>テキストを適当な場所に置いて、<em>src/main.rs</em>を編集し、ファイルを開くコードを追加してください。
リスト12-4に示したようにですね。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic">use std::env;
use std::fs::File;
use std::io::prelude::*;

fn main() {
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let filename = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, query);
</span>    // --snip--
    println!(&quot;In file {}&quot;, filename);

    // ファイルが見つかりませんでした
    let mut f = File::open(filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        // ファイルの読み込み中に問題がありました
        .expect(&quot;something went wrong reading the file&quot;);

    // テキストは\n{}です
    println!(&quot;With text:\n{}&quot;, contents);
}
</code></pre></pre>
<!--
<span class="caption">Listing 12-4: Reading the contents of the file specified
by the second argument</span>
-->
<p><span class="caption">リスト12-4: 第2引数で指定されたファイルの中身を読み込む</span></p>
<!--
First, we add some more `use` statements to bring in relevant parts of the
standard library: we need `std::fs::File` to handle files, and
`std::io::prelude::*` contains various useful traits for doing I/O, including
file I/O. In the same way that Rust has a general prelude that brings certain
types and functions into scope automatically, the `std::io` module has its own
prelude of common types and functions you’ll need when working with I/O. Unlike
the default prelude, we must explicitly add a `use` statement for the
prelude from `std::io`.
-->
<p>最初に、もう何個か<code>use</code>文を追記して、標準ライブラリの関係のある箇所を持ってきています:
ファイルを扱うのに<code>std::fs::File</code>が必要ですし、
<code>std::io::prelude::*</code>はファイル入出力を含む入出力処理をするのに有用なトレイトを色々含んでいます。
言語が一般的な初期化処理で特定の型や関数を自動的にスコープに導入するように、
<code>std::io</code>モジュールにはそれ独自の共通の型や関数の初期化処理があり、入出力を行う際に必要になるわけです。
標準の初期化処理とは異なり、<code>std::io</code>の初期化処理には明示的に<code>use</code>文を加えなければなりません。</p>
<!--
In `main`, we’ve added three statements: first, we get a mutable handle to the
file by calling the `File::open` function and passing it the value of the
`filename` variable. Second, we create a variable called `contents` and set it
to a mutable, empty `String`. This will hold the content of the file after we
read it in. Third, we call `read_to_string` on our file handle and pass a
mutable reference to `contents` as an argument.
-->
<p><code>main</code>に3文を追記しました: 一つ目が、<code>File::open</code>関数を呼んで<code>filename</code>変数の値に渡して、
ファイルへの可変なハンドルを得る処理です。二つ目が、<code>contents</code>という名の変数を生成して、
可変で空の<code>String</code>を割り当てる処理です。この変数が、ファイル読み込み後に中身を保持します。
三つ目が、ファイルハンドルに対して<code>read_to_string</code>を呼び出し、引数として<code>contents</code>への可変参照を渡す処理です。</p>
<!--
After those lines, we’ve again added a temporary `println!` statement that
prints the value of `contents` after the file is read, so we can check that the
program is working so far.
-->
<p>それらの行の後に、今回もファイル読み込み後に<code>contents</code>の値を出力する一時的な<code>println!</code>文を追記したので、
ここまでプログラムがきちんと動作していることを確認できます。</p>
<!--
Let’s run this code with any string as the first command line argument (because
we haven’t implemented the searching part yet) and the *poem.txt* file as the
second argument:
-->
<p>第1コマンドライン引数には適当な文字列(まだ検索する箇所は実装してませんからね)を、第2引数に<em>poem.txt</em>ファイルを入れて、
このコードを実行しましょう:</p>
<pre><code class="language-text">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<!--
4行目の冒頭は、末端のone ideaをあえて訳していない。こちらの方が日本語としては自然と思われる
-->
<!--
Great! The code read and then printed the content of the file. But the code
has a few flaws. The `main` function has multiple responsibilities: generally,
functions are clearer and easier to maintain if each function is responsible
for only one idea. The other problem is that we’re not handling errors as well
as we could. The program is still small, so these flaws aren’t a big problem,
but as the program grows, it will be harder to fix them cleanly. It’s good
practice to begin refactoring early on when developing a program, because it’s
much easier to refactor smaller amounts of code. We’ll do that next.
-->
<p>素晴らしい！コードがファイルの中身を読み込み、出力するようになりました。しかし、このコードにはいくつか欠陥があります。
<code>main</code>関数が複数の責任を受け持っています: 一般に、各関数がただ一つの責任だけを持つようになれば、
関数は明確かつ、管理しやすくなります。もう一つの問題点は、できうる限りのエラー処理を怠っていることです。
まだプログラムが小規模なので、これらの欠陥は大きな問題にはなりませんが、プログラムが大規模になるにつれ、
それを綺麗に解消するのは困難になっていきます。プログラムを開発する際に早い段階でリファクタリングを行うのは、
良い戦術です。リファクタリングするコードの量が少なければ、はるかに簡単になりますからね。次は、それを行いましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Refactoring to Improve Modularity and Error Handling
-->
<h2 id="リファクタリングしてモジュール性とエラー処理を向上させる"><a class="header" href="#リファクタリングしてモジュール性とエラー処理を向上させる">リファクタリングしてモジュール性とエラー処理を向上させる</a></h2>
<!--
To improve our program, we’ll fix four problems that have to do with the
program’s structure and how it’s handling potential errors.
-->
<p>プログラムを改善するために、プログラムの構造と起こりうるエラーに対処する方法に関連する4つの問題を修正していきましょう。</p>
<!--
First, our `main` function now performs two tasks: it parses arguments and
opens files. For such a small function, this isn’t a major problem. However, if
we continue to grow our program inside `main`, the number of separate tasks the
`main` function handles will increase. As a function gains responsibilities, it
becomes more difficult to reason about, harder to test, and harder to change
without breaking one of its parts. It’s best to separate functionality so each
function is responsible for one task.
-->
<p>1番目は、<code>main</code>関数が2つの仕事を受け持っていることです: 引数を解析し、ファイルを開いています。
このような小さな関数なら、これは、大した問題ではありませんが、<code>main</code>内でプログラムを巨大化させ続けたら、
<code>main</code>関数が扱う個別の仕事の数も増えていきます。関数が責任を受け持つごとに、
正しいことを確認しにくくなり、テストも行いづらくなり、機能を壊さずに変更するのも困難になっていきます。
機能を小分けして、各関数が1つの仕事のみに責任を持つようにするのが最善です。</p>
<!--
This issue also ties into the second problem: although `query` and `filename`
are configuration variables to our program, variables like `f` and `contents`
are used to perform the program’s logic. The longer `main` becomes, the more
variables we’ll need to bring into scope; the more variables we have in scope,
the harder it will be to keep track of the purpose of each. It’s best to group
the configuration variables into one structure to make their purpose clear.
-->
<p>この問題は、2番目の問題にも結びついています: <code>query</code>と<code>filename</code>はプログラムの設定用変数ですが、
<code>f</code>や<code>contents</code>といった変数は、プログラムのロジックを担っています。<code>main</code>が長くなるほど、
スコープに入れるべき変数も増えます。そして、スコープにある変数が増えれば、各々の目的を追うのも大変になるわけです。
設定用変数を一つの構造に押し込め、目的を明瞭化するのが最善です。</p>
<!--
The third problem is that we’ve used `expect` to print an error message when
opening the file fails, but the error message just prints `file not found`.
Opening a file can fail in a number of ways besides the file being missing: for
example, the file might exist, but we might not have permission to open it.
Right now, if we’re in that situation, we’d print the `file not found` error
message, which would give the user the wrong information!
-->
<p>3番目の問題は、ファイルを開き損ねた時に<code>expect</code>を使ってエラーメッセージを出力しているのに、
エラーメッセージが<code>ファイルが見つかりませんでした</code>としか表示しないことです。
ファイルを開く行為は、ファイルが存在しない以外にもいろんな方法で失敗することがあります:
例えば、ファイルは存在するかもしれないけれど、開く権限がないかもしれないなどです。
現時点では、そのような状況になった時、「ファイルが見つかりませんでした」というエラーメッセージを出力し、
これはユーザに間違った情報を与えるのです。</p>
<!--
1行目最後の方のandを順接の理由で訳している
-->
<!--
Fourth, we use `expect` repeatedly to handle different errors, and if the user
runs our program without specifying enough arguments, they’ll get an `index out
of bounds` error from Rust that doesn’t clearly explain the problem. It would
be best if all the error-handling code was in one place so future maintainers
have only one place to consult in the code if the error-handling logic needs to
change. Having all the error-handling code in one place will also ensure that
we’re printing messages that will be meaningful to our end users.
-->
<p>4番目は、異なるエラーを処理するのに<code>expect</code>を繰り返し使用しているので、ユーザが十分な数の引数を渡さずにプログラムを起動した時に、
問題を明確に説明しない「範囲外アクセス(index out of bounds)」というエラーがRustから得られることです。
エラー処理のコードが全て1箇所に存在し、将来エラー処理ロジックが変更になった時に、
メンテナンス者が1箇所のコードのみを考慮すればいいようにするのが最善でしょう。
エラー処理コードが1箇所にあれば、エンドユーザにとって意味のあるメッセージを出力していることを確認することにもつながります。</p>
<!--
Let’s address these four problems by refactoring our project.
-->
<p>プロジェクトをリファクタリングして、これら4つの問題を扱いましょう。</p>
<!--
### Separation of Concerns for Binary Projects
-->
<h3 id="バイナリプロジェクトの責任の分離"><a class="header" href="#バイナリプロジェクトの責任の分離">バイナリプロジェクトの責任の分離</a></h3>
<!--
The organizational problem of allocating responsibility for multiple tasks to
the `main` function is common to many binary projects. As a result, the Rust
community has developed a process to use as a guideline for splitting the
separate concerns of a binary program when `main` starts getting large. The
process has the following steps:
-->
<p><code>main</code>関数に複数の仕事の責任を割り当てるという構造上の問題は、多くのバイナリプロジェクトでありふれています。
結果として、<code>main</code>が肥大化し始めた際にバイナリプログラムの個別の責任を分割するためにガイドラインとして活用できる工程をRustコミュニティは、
開発しました。この工程は、以下のような手順になっています:</p>
<!--
* Split your program into a *main.rs* and a *lib.rs* and move your program’s
logic to *lib.rs*.
* As long as your command line parsing logic is small, it can remain in
*main.rs*.
* When the command line parsing logic starts getting complicated, extract it
from *main.rs* and move it to *lib.rs*.
-->
<ul>
<li>プログラムを<em>main.rs</em>と<em>lib.rs</em>に分け、ロジックを<em>lib.rs</em>に移動する。</li>
<li>コマンドライン引数の解析ロジックが小規模な限り、<em>main.rs</em>に置いても良い。</li>
<li>コマンドライン引数の解析ロジックが複雑化の様相を呈し始めたら、<em>main.rs</em>から抽出して<em>lib.rs</em>に移動する。</li>
</ul>
<!--
The responsibilities that remain in the `main` function after this process
should be limited to the following:
-->
<p>この工程の後に<code>main</code>関数に残る責任は以下に限定される:</p>
<!--
* Calling the command line parsing logic with the argument values
* Setting up any other configuration
* Calling a `run` function in *lib.rs*
* Handling the error if `run` returns an error
-->
<ul>
<li>引数の値でコマンドライン引数の解析ロジックを呼び出す</li>
<li>他のあらゆる設定を行う</li>
<li><em>lib.rs</em>の<code>run</code>関数を呼び出す</li>
<li><code>run</code>がエラーを返した時に処理する</li>
</ul>
<!--
This pattern is about separating concerns: *main.rs* handles running the
program, and *lib.rs* handles all the logic of the task at hand. Because we
can’t test the `main` function directly, this structure lets us test all of
your program’s logic by moving it into functions in *lib.rs*. The only code
that remains in *main.rs* will be small enough to verify its correctness by
reading it. Let’s rework our program by following this process.
-->
<p>このパターンは、責任の分離についてです: <em>main.rs</em>はプログラムの実行を行い、
そして、<em>lib.rs</em>が手にある仕事のロジック全てを扱います。<code>main</code>関数を直接テストすることはできないので、
この構造により、プログラムのロジック全てを<em>lib.rs</em>の関数に移すことでテストできるようになります。
<em>main.rs</em>に残る唯一のコードは、読めばその正当性が評価できるだけ小規模になるでしょう。
この工程に従って、プログラムのやり直しをしましょう。</p>
<!--
#### Extracting the Argument Parser
-->
<h4 id="引数解析器を抽出する"><a class="header" href="#引数解析器を抽出する">引数解析器を抽出する</a></h4>
<!--
We’ll extract the functionality for parsing arguments into a function that
`main` will call to prepare for moving the command line parsing logic to
*src/lib.rs*. Listing 12-5 shows the new start of `main` that calls a new
function `parse_config`, which we’ll define in *src/main.rs* for the moment.
-->
<p>引数解析の機能を<code>main</code>が呼び出す関数に抽出して、コマンドライン引数解析ロジックを<em>src/lib.rs</em>に移動する準備をします。
リスト12-5に新しい関数<code>parse_config</code>を呼び出す<code>main</code>の冒頭部を示し、
この新しい関数は今だけ<em>src/main.rs</em>に定義します。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // --snip--
}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<!--
<span class="caption">Listing 12-5: Extracting a `parse_config` function from
`main`</span>
-->
<p><span class="caption">リスト12-5: <code>main</code>から<code>parse_config</code>関数を抽出する</span></p>
<!--
We’re still collecting the command line arguments into a vector, but instead of
assigning the argument value at index 1 to the variable `query` and the
argument value at index 2 to the variable `filename` within the `main`
function, we pass the whole vector to the `parse_config` function. The
`parse_config` function then holds the logic that determines which argument
goes in which variable and passes the values back to `main`. We still create
the `query` and `filename` variables in `main`, but `main` no longer has the
responsibility of determining how the command line arguments and variables
correspond.
-->
<p>それでもまだ、コマンドライン引数をベクタに集結させていますが、<code>main</code>関数内で引数の値の添え字1を変数<code>query</code>に、
添え字2を変数<code>filename</code>に代入する代わりに、ベクタ全体を<code>parse_config</code>関数に渡しています。
そして、<code>parse_config</code>関数にはどの引数がどの変数に入り、それらの値を<code>main</code>に返すというロジックが存在します。
まだ<code>main</code>内に<code>query</code>と<code>filename</code>という変数を生成していますが、もう<code>main</code>は、
コマンドライン引数と変数がどう対応するかを決定する責任は持ちません。</p>
<!--
This rework may seem like overkill for our small program, but we’re refactoring
in small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. It’s good to check your progress
often, to help you identify the cause of problems when they occur.
-->
<p>このやり直しは、私たちの小規模なプログラムにはやりすぎに思えるかもしれませんが、
少しずつ段階的にリファクタリングしているのです。この変更後、プログラムを再度実行して、
引数解析がまだ動作していることを実証してください。問題が発生した時に原因を特定する助けにするために頻繁に進捗を確認するのはいいことです。</p>
<!--
#### Grouping Configuration Values
-->
<h4 id="設定値をまとめる"><a class="header" href="#設定値をまとめる">設定値をまとめる</a></h4>
<!--
We can take another small step to improve the `parse_config` function further.
At the moment, we’re returning a tuple, but then we immediately break that
tuple into individual parts again. This is a sign that perhaps we don’t have
the right abstraction yet.
-->
<p>もう少し<code>parse_config</code>関数を改善することができます。現時点では、タプルを返していますが、
即座にタプルを分解して再度個別の値にしています。これは、正しい抽象化をまだできていないかもしれない兆候です。</p>
<!--
Another indicator that shows there’s room for improvement is the `config` part
of `parse_config`, which implies that the two values we return are related and
are both part of one configuration value. We’re not currently conveying this
meaning in the structure of the data other than grouping the two values into
a tuple; we could put the two values into one struct and give each of the
struct fields a meaningful name. Doing so will make it easier for future
maintainers of this code to understand how the different values relate to each
other and what their purpose is.
-->
<p>まだ改善の余地があると示してくれる他の徴候は、<code>parse_config</code>の<code>config</code>の部分であり、
返却している二つの値は関係があり、一つの設定値の一部にどちらもなることを暗示しています。
現状では、一つのタプルにまとめていること以外、この意味をデータの構造に載せていません;
この二つの値を1構造体に置き換え、構造体のフィールドそれぞれに意味のある名前をつけることもできるでしょう。
そうすることで将来このコードのメンテナンス者が、異なる値が相互に関係する仕方や、目的を理解しやすくできるでしょう。</p>
<!--
> Note: Some people call this anti-pattern of using primitive values when a
> complex type would be more appropriate *primitive obsession*.
-->
<blockquote>
<p>注釈: この複雑型(complex type)がより適切な時に組み込みの値を使うアンチパターンを、
<em>primitive obsession</em>(<code>訳注</code>: 初めて聞いた表現。<em>組み込み型強迫観念</em>といったところだろうか)と呼ぶ人もいます。</p>
</blockquote>
<!--
Listing 12-6 shows the improvements to the `parse_config` function.
-->
<p>リスト12-6は、<code>parse_config</code>関数の改善を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs::File;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    // --snip--
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<!--
<span class="caption">Listing 12-6: Refactoring `parse_config` to return an
instance of a `Config` struct</span>
-->
<p><span class="caption">リスト12-6: <code>parse_config</code>をリファクタリングして<code>Config</code>構造体のインスタンスを返す</span></p>
<!--
We’ve added a struct named `Config` defined to have fields named `query` and
`filename`. The signature of `parse_config` now indicates that it returns a
`Config` value. In the body of `parse_config`, where we used to return string
slices that reference `String` values in `args`, we now define `Config` to
contain owned `String` values. The `args` variable in `main` is the owner of
the argument values and is only letting the `parse_config` function borrow
them, which means we’d violate Rust’s borrowing rules if `Config` tried to take
ownership of the values in `args`.
-->
<p><code>query</code>と<code>filename</code>というフィールドを持つよう定義された<code>Config</code>という構造体を追加しました。
<code>parse_config</code>のシグニチャは、これで<code>Config</code>値を返すと示すようになりました。<code>parse_config</code>の本体では、
以前は<code>args</code>の<code>String</code>値を参照する文字列スライスを返していましたが、
今では所有する<code>String</code>値を含むように<code>Config</code>を定義しています。<code>main</code>の<code>args</code>変数は引数値の所有者であり、
<code>parse_config</code>関数だけに借用させていますが、これは<code>Config</code>が<code>args</code>の値の所有権を奪おうとしたら、
Rustの借用規則に違反してしまうことを意味します。</p>
<!--
We could manage the `String` data in a number of different ways, but the
easiest, though somewhat inefficient, route is to call the `clone` method on
the values. This will make a full copy of the data for the `Config` instance to
own, which takes more time and memory than storing a reference to the string
data. However, cloning the data also makes our code very straightforward
because we don’t have to manage the lifetimes of the references; in this
circumstance, giving up a little performance to gain simplicity is a worthwhile
trade-off.
-->
<p><code>String</code>のデータは、多くの異なる手法で管理できますが、最も単純だけれどもどこか非効率的な手段は、
値に対して<code>clone</code>メソッドを呼び出すことです。これにより、<code>Config</code>インスタンスが所有するデータの総コピーが生成されるので、
文字列データへの参照を保持するよりも時間とメモリを消費します。ですが、データをクローンすることで、
コードがとても素直にもなります。というのも、参照のライフタイムを管理する必要がないからです。
つまり、この場面において、少々のパフォーマンスを犠牲にして単純性を得るのは、価値のある代償です。</p>
<!--
> ### The Trade-Offs of Using `clone`
>
> There’s a tendency among many Rustaceans to avoid using `clone` to fix
> ownership problems because of its runtime cost. In Chapter 13, you’ll learn
> how to use more efficient methods in this type of situation. But for now,
> it’s okay to copy a few strings to continue making progress because we’ll
> make these copies only once and your filename and query string are very
> small. It’s better to have a working program that’s a bit inefficient than to
> try to hyperoptimize code on your first pass. As you become more experienced
> with Rust, it’ll be easier to start with the most efficient solution, but for
> now, it’s perfectly acceptable to call `clone`.
-->
<blockquote>
<h3 id="cloneを使用する代償"><a class="header" href="#cloneを使用する代償"><code>clone</code>を使用する代償</a></h3>
<p>実行時コストのために<code>clone</code>を使用して所有権問題を解消するのを避ける傾向が多くのRustaceanにあります。
第13章で、この種の状況においてより効率的なメソッドの使用法を学ぶでしょう。ですがとりあえずは、
これらのコピーをするのは1回だけですし、ファイル名とクエリ文字列は非常に小さなものなので、
いくつかの文字列をコピーして進捗するのは良しとしましょう。最初の通り道でコードを究極的に効率化しようとするよりも、
ちょっと非効率的でも動くプログラムを用意する方がいいでしょう。もっとRustの経験を積めば、
最も効率的な解決法から開始することも簡単になるでしょうが、今は、<code>clone</code>を呼び出すことは完璧に受け入れられることです。</p>
</blockquote>
<!--
We’ve updated `main` so it places the instance of `Config` returned by
`parse_config` into a variable named `config`, and we updated the code that
previously used the separate `query` and `filename` variables so it now uses
the fields on the `Config` struct instead.
-->
<p><code>main</code>を更新したので、<code>parse_config</code>から返された<code>Config</code>のインスタンスを<code>config</code>という変数に置くようになり、
以前は個別の<code>query</code>と<code>filename</code>変数を使用していたコードを更新したので、代わりに<code>Config</code>構造体のフィールドを使用するようになりました。</p>
<!--
Now our code more clearly conveys that `query` and `filename` are related and
that their purpose is to configure how the program will work. Any code that
uses these values knows to find them in the `config` instance in the fields
named for their purpose.
-->
<p>これでコードは<code>query</code>と<code>filename</code>が関連していることと、その目的がプログラムの振る舞い方を設定するということをより明確に伝えます。
これらの値を使用するあらゆるコードは、<code>config</code>インスタンスの目的の名前を冠したフィールドにそれらを発見することを把握しています。</p>
<!--
#### Creating a Constructor for `Config`
-->
<h4 id="configのコンストラクタを作成する"><a class="header" href="#configのコンストラクタを作成する"><code>Config</code>のコンストラクタを作成する</a></h4>
<!--
So far, we’ve extracted the logic responsible for parsing the command line
arguments from `main` and placed it in the `parse_config` function. Doing so
helped us to see that the `query` and `filename` values were related and that
relationship should be conveyed in our code. We then added a `Config` struct to
name the related purpose of `query` and `filename` and to be able to return the
values’ names as struct field names from the `parse_config` function.
-->
<p>ここまでで、コマンドライン引数を解析する責任を負ったロジックを<code>main</code>から抽出し、<code>parse_config</code>関数に配置しました。
そうすることで<code>query</code>と<code>filename</code>の値が関連し、その関係性がコードに載っていることを確認する助けになりました。
それから<code>Config</code>構造体を追加して<code>query</code>と<code>filename</code>の関係する目的を名前付けし、
構造体のフィールド名として<code>parse_config</code>関数からその値の名前を返すことができています。</p>
<!--
So now that the purpose of the `parse_config` function is to create a `Config`
instance, we can change `parse_config` from a plain function to a function
named `new` that is associated with the `Config` struct. Making this change
will make the code more idiomatic. We can create instances of types in the
standard library, such as `String`, by calling `String::new`. Similarly, by
changing `parse_config` into a `new` function associated with `Config`, we’ll
be able to create instances of `Config` by calling `Config::new`. Listing 12-7
shows the changes we need to make.
-->
<p>したがって、今や<code>parse_config</code>関数の目的は<code>Config</code>インスタンスを生成することになったので、
<code>parse_config</code>をただの関数から<code>Config</code>構造体に紐づく<code>new</code>という関数に変えることができます。
この変更を行うことで、コードがより慣用的になります。<code>String</code>などの標準ライブラリの型のインスタンスを、
<code>String::new</code>を呼び出すことで生成できます。同様に、<code>parse_config</code>を<code>Config</code>に紐づく<code>new</code>関数に変えれば、
<code>Config::new</code>を呼び出すことで<code>Config</code>のインスタンスを生成できるようになります。リスト12-7が、
行う必要のある変更を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

    // --snip--
}

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 12-7: Changing `parse_config` into
`Config::new`</span>
-->
<p><span class="caption">リスト12-7: <code>parse_config</code>を<code>Config::new</code>に変える</span></p>
<!--
We’ve updated `main` where we were calling `parse_config` to instead call
`Config::new`. We’ve changed the name of `parse_config` to `new` and moved it
within an `impl` block, which associates the `new` function with `Config`. Try
compiling this code again to make sure it works.
-->
<p><code>parse_config</code>を呼び出していた<code>main</code>を代わりに<code>Config::new</code>を呼び出すように更新しました。
<code>parse_config</code>の名前を<code>new</code>に変え、<code>impl</code>ブロックに入れ込んだので、<code>new</code>関数と<code>Config</code>が紐づくようになりました。
再度このコードをコンパイルしてみて、動作することを確かめてください。</p>
<!--
### Fixing the Error Handling
-->
<h3 id="エラー処理を修正する"><a class="header" href="#エラー処理を修正する">エラー処理を修正する</a></h3>
<!--
Now we’ll work on fixing our error handling. Recall that attempting to access
the values in the `args` vector at index 1 or index 2 will cause the program to
panic if the vector contains fewer than three items. Try running the program
without any arguments; it will look like this:
-->
<p>さて、エラー処理の修正に取り掛かりましょう。ベクタが2個以下の要素しか含んでいないときに<code>args</code>ベクタの添え字1か2にアクセスしようとすると、
プログラムがパニックすることを思い出してください。試しに引数なしでプログラムを実行してください。すると、こんな感じになります:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1
but the index is 1', src/main.rs:29:21
(スレッド'main'は、「境界外アクセス: 長さは1なのに添え字も1です」でパニックしました)
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!--
The line `index out of bounds: the len is 1 but the index is 1` is an error
message intended for programmers. It won’t help our end users understand what
happened and what they should do instead. Let’s fix that now.
-->
<p><code>境界外アクセス: 長さは1なのに添え字も1です</code>という行は、プログラマ向けのエラーメッセージです。
エンドユーザが起きたことと代わりにすべきことを理解する手助けにはならないでしょう。これを今修正しましょう。</p>
<!--
#### Improving the Error Message
-->
<h4 id="エラーメッセージを改善する"><a class="header" href="#エラーメッセージを改善する">エラーメッセージを改善する</a></h4>
<!--
In Listing 12-8, we add a check in the `new` function that will verify that the
slice is long enough before accessing index 1 and 2. If the slice isn’t long
enough, the program panics and displays a better error message than the `index
out of bounds` message.
-->
<p>リスト12-8で、<code>new</code>関数に、添え字1と2にアクセスする前にスライスが十分長いことを実証するチェックを追加しています。
スライスの長さが十分でなければ、プログラムはパニックし、<code>境界外インデックス</code>よりもいいエラーメッセージを表示します。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        // 引数の数が足りません
        panic!(&quot;not enough arguments&quot;);
    }
    // --snip--
</code></pre>
<!--
<span class="caption">Listing 12-8: Adding a check for the number of
arguments</span>
-->
<p><span class="caption">リスト12-8: 引数の数のチェックを追加する</span></p>
<!--
This code is similar to the `Guess::new` function we wrote in Listing 9-9,
where we called `panic!` when the `value` argument was out of the range of
valid values. Instead of checking for a range of values here, we’re checking
that the length of `args` is at least 3 and the rest of the function can
operate under the assumption that this condition has been met. If `args` has
fewer than three items, this condition will be true, and we call the `panic!`
macro to end the program immediately.
-->
<p>このコードは、リスト9-9で記述した<code>value</code>引数が正常な値の範囲外だった時に<code>panic!</code>を呼び出した<code>Guess::new</code>関数と似ています。
ここでは、値の範囲を確かめる代わりに、<code>args</code>の長さが少なくとも3であることを確かめていて、
関数の残りの部分は、この条件が満たされているという前提のもとで処理を行うことができます。
<code>args</code>に2要素以下しかなければ、この条件は真になり、<code>panic!</code>マクロを呼び出して、即座にプログラムを終了させます。</p>
<!--
With these extra few lines of code in `new`, let’s run the program without any
arguments again to see what the error looks like now:
-->
<p>では、<code>new</code>のこの追加の数行がある状態で、再度引数なしでプログラムを走らせ、エラーがどんな見た目か確かめましょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:30:12
(スレッド'main'は「引数が足りません」でパニックしました)
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!--
This output is better: we now have a reasonable error message. However, we also
have extraneous information we don’t want to give to our users. Perhaps using
the technique we used in Listing 9-9 isn’t the best to use here: a call to
`panic!` is more appropriate for a programming problem than a usage problem, as
discussed in Chapter 9. Instead, we can use the other technique you learned
about in Chapter 9—returning a `Result` that indicates either success or an
error.
-->
<p>この出力の方がマシです: これでエラーメッセージが合理的になりました。ですが、
ユーザに与えたくない追加の情報も含まれてしまっています。おそらく、
ここではリスト9-9で使用したテクニックを使用するのは最善ではありません: 
<code>panic!</code>の呼び出しは、第9章で議論したように、使用の問題よりもプログラミング上の問題により適しています。
代わりに、第9章で学んだもう一つのテクニックを使用することができます。成功か失敗かを示唆する<code>Result</code>を返すことです。</p>
<!--
#### Returning a `Result` from `new` Instead of Calling `panic!`
-->
<h4 id="panicを呼び出す代わりにnewからresultを返す"><a class="header" href="#panicを呼び出す代わりにnewからresultを返す"><code>panic!</code>を呼び出す代わりに<code>new</code>から<code>Result</code>を返す</a></h4>
<!--
We can instead return a `Result` value that will contain a `Config` instance in
the successful case and will describe the problem in the error case. When
`Config::new` is communicating to `main`, we can use the `Result` type to
signal there was a problem. Then we can change `main` to convert an `Err`
variant into a more practical error for our users without the surrounding text
about `thread 'main'` and `RUST_BACKTRACE` that a call to `panic!` causes.
-->
<p>代わりに、成功時には<code>Config</code>インスタンスを含み、エラー時には問題に言及する<code>Result</code>値を返すことができます。
<code>Config::new</code>が<code>main</code>と対話する時、<code>Result</code>型を使用して問題があったと信号を送ることができます。
それから<code>main</code>を変更して、<code>panic!</code>呼び出しが引き起こしていた<code>thread 'main'</code>と<code>RUST_BACKTRACE</code>に関する周囲のテキストがない、
ユーザ向けのより実用的なエラーに<code>Err</code>列挙子を変換することができます。</p>
<!--
Listing 12-9 shows the changes we need to make to the return value of
`Config::new` and the body of the function needed to return a `Result`. Note
that this won’t compile until we update `main` as well, which we’ll do in the
next listing.
-->
<p>リスト12-9は、<code>Config::new</code>の戻り値に必要な変更と<code>Result</code>を返すのに必要な関数の本体を示しています。
<code>main</code>も更新するまで、これはコンパイルできないことに注意してください。その更新は次のリストで行います。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-9: Returning a `Result` from
`Config::new`</span>
-->
<p><span class="caption">リスト12-9: <code>Config::new</code>から<code>Result</code>を返却する</span></p>
<!--
Our `new` function now returns a `Result` with a `Config` instance in the
success case and a `&'static str` in the error case. Recall from “The Static
Lifetime” section in Chapter 10 that `&'static str` is the type of string
literals, which is our error message type for now.
-->
<p><code>new</code>関数は、これで、成功時には<code>Config</code>インスタンスを、エラー時には<code>&amp;'static str</code>を伴う<code>Result</code>を返すようになりました。
第10章の「静的ライフタイム」節から<code>&amp;'static str</code>は文字列リテラルの型であることを思い出してください。
これは、今はエラーメッセージの型になっています。</p>
<!--
We’ve made two changes in the body of the `new` function: instead of calling
`panic!` when the user doesn’t pass enough arguments, we now return an `Err`
value, and we’ve wrapped the `Config` return value in an `Ok`. These changes
make the function conform to its new type signature.
-->
<p><code>new</code>関数の本体で2つ変更を行いました: 十分な数の引数をユーザが渡さなかった場合に<code>panic!</code>を呼び出す代わりに、
今は<code>Err</code>値を返し、<code>Config</code>戻り値を<code>Ok</code>に包んでいます。これらの変更により、関数が新しい型シグニチャに適合するわけです。</p>
<!--
Returning an `Err` value from `Config::new` allows the `main` function to
handle the `Result` value returned from the `new` function and exit the process
more cleanly in the error case.
-->
<p><code>Config::new</code>から<code>Err</code>値を返すことにより、<code>main</code>関数は、<code>new</code>関数から返ってくる<code>Result</code>値を処理し、
エラー時により綺麗にプロセスから抜け出すことができます。</p>
<!--
#### Calling `Config::new` and Handling Errors
-->
<h4 id="confignewを呼び出しエラーを処理する"><a class="header" href="#confignewを呼び出しエラーを処理する"><code>Config::new</code>を呼び出し、エラーを処理する</a></h4>
<!--
To handle the error case and print a user-friendly message, we need to update
`main` to handle the `Result` being returned by `Config::new`, as shown in
Listing 12-10. We’ll also take the responsibility of exiting the command line
tool with a nonzero error code from `panic!` and implement it by hand. A
nonzero exit status is a convention to signal to the process that called our
program that the program exited with an error state.
-->
<p>エラーケースを処理し、ユーザフレンドリーなメッセージを出力するために、<code>main</code>を更新して、
リスト12-10に示したように<code>Config::new</code>から返されている<code>Result</code>を処理する必要があります。
また、<code>panic!</code>からコマンドラインツールを0以外のエラーコードで抜け出す責任も奪い取り、
手作業でそれも実装します。0以外の終了コードは、
我々のプログラムを呼び出したプロセスにプログラムがエラー状態で終了したことを通知する慣習です。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        // 引数解析時に問題
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
</code></pre>
<!--
<span class="caption">Listing 12-10: Exiting with an error code if creating a
new `Config` fails</span>
-->
<p><span class="caption">リスト12-10: 新しい<code>Config</code>作成に失敗したら、エラーコードで終了する</span></p>
<!--
In this listing, we’ve used a method we haven’t covered before:
`unwrap_or_else`, which is defined on `Result<T, E>` by the standard library.
Using `unwrap_or_else` allows us to define some custom, non-`panic!` error
handling. If the `Result` is an `Ok` value, this method’s behavior is similar
to `unwrap`: it returns the inner value `Ok` is wrapping. However, if the value
is an `Err` value, this method calls the code in the *closure*, which is an
anonymous function we define and pass as an argument to `unwrap_or_else`. We’ll
cover closures in more detail in Chapter 13. For now, you just need to know
that `unwrap_or_else` will pass the inner value of the `Err`, which in this
case is the static string `not enough arguments` that we added in Listing 12-9,
to our closure in the argument `err` that appears between the vertical pipes.
The code in the closure can then use the `err` value when it runs.
-->
<p>このリストにおいて、以前には講義していないメソッドを使用しました: <code>unwrap_or_else</code>です。
これは標準ライブラリで<code>Result&lt;T, E&gt;</code>に定義されています。<code>unwrap_or_else</code>を使うことで、
<code>panic!</code>ではない何らか独自のエラー処理を定義できるのです。この<code>Result</code>が<code>Ok</code>値だったら、
このメソッドの振る舞いは<code>unwrap</code>に似ています: <code>Ok</code>が包んでいる中身の値を返すのです。
しかし、値が<code>Err</code>値なら、このメソッドは、<em>クロージャ</em>内でコードを呼び出し、
クロージャは私たちが定義し、引数として<code>unwrap_or_else</code>に渡す匿名関数です。クロージャについては第13章で詳しく講義します。
とりあえず、<code>unwrap_or_else</code>は、今回リスト12-9で追加した<code>not enough arguments</code>という静的文字列の<code>Err</code>の中身を、
縦棒の間に出現する<code>err</code>引数のクロージャに渡していることだけ知っておく必要があります。
クロージャのコードはそれから、実行された時に<code>err</code>値を使用できます。</p>
<!--
We’ve added a new `use` line to import `process` from the standard library. The
code in the closure that will be run in the error case is only two lines: we
print the `err` value and then call `process::exit`. The `process::exit`
function will stop the program immediately and return the number that was
passed as the exit status code. This is similar to the `panic!`-based handling
we used in Listing 12-8, but we no longer get all the extra output. Let’s try
it:
-->
<p>新規<code>use</code>行を追加して標準ライブラリから<code>process</code>をインポートしました。クロージャ内のエラー時に走るコードは、
たった2行です: <code>err</code>の値を出力し、それから<code>process::exit</code>を呼び出します。<code>process::exit</code>関数は、
即座にプログラムを停止させ、渡された数字を終了コードとして返します。これは、リスト12-8で使用した<code>panic!</code>ベースの処理と似ていますが、
もう余計な出力はされません。試しましょう:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<!--
Great! This output is much friendlier for our users.
-->
<p>素晴らしい！この出力の方が遥かにユーザに優しいです。</p>
<!--
### Extracting Logic from `main`
-->
<h3 id="mainからロジックを抽出する"><a class="header" href="#mainからロジックを抽出する"><code>main</code>からロジックを抽出する</a></h3>
<!--
Now that we’ve finished refactoring the configuration parsing, let’s turn to
the program’s logic. As we stated in “Separation of Concerns for Binary
Projects”, we’ll extract a function named `run` that will hold all the logic
currently in the `main` function that isn’t involved with setting up
configuration or handling errors. When we’re done, `main` will be concise and
easy to verify by inspection, and we’ll be able to write tests for all the
other logic.
-->
<p>これで設定解析のリファクタリングが終了したので、プログラムのロジックに目を向けましょう。
「バイナリプロジェクトの責任の分離」で述べたように、
現在<code>main</code>関数に存在する設定のセットアップやエラー処理に関わらない全てのロジックを保持することになる<code>run</code>という関数を抽出します。
やり終わったら、<code>main</code>は簡潔かつ視察で確かめやすくなり、他のロジック全部に対してテストを書くことができるでしょう。</p>
<!--
Listing 12-11 shows the extracted `run` function. For now, we’re just making
the small, incremental improvement of extracting the function. We’re still
defining the function in *src/main.rs*.
-->
<p>リスト12-11は、抜き出した<code>run</code>関数を示しています。今は少しずつ段階的に関数を抽出する改善を行っています。
それでも、<em>src/main.rs</em>に関数を定義していきます。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let mut f = File::open(config.filename).expect(&quot;file not found&quot;);

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)
        .expect(&quot;something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// --snip--
</code></pre>
<!--
<span class="caption">Listing 12-11: Extracting a `run` function containing the
rest of the program logic</span>
-->
<p><span class="caption">リスト12-11: 残りのプログラムロジックを含む<code>run</code>関数を抽出する</span></p>
<!--
The `run` function now contains all the remaining logic from `main`, starting
from reading the file. The `run` function takes the `Config` instance as an
argument.
-->
<p>これで<code>run</code>関数は、ファイル読み込みから始まる<code>main</code>関数の残りのロジック全てを含むようになりました。
この<code>run</code>関数は、引数に<code>Config</code>インスタンスを取ります。</p>
<!--
#### Returning Errors from the `run` Function
-->
<h4 id="run関数からエラーを返す"><a class="header" href="#run関数からエラーを返す"><code>run</code>関数からエラーを返す</a></h4>
<!--
1行目。ここではwith ...を順接の理由で訳している。with ...は普通、状態を表す表現
ちょっと意味が強すぎるかもしれない。
With you next to me, I'll drive to wherever you like. (君が隣にいる状態で、何処へでも君の好きな場所にドライブするよ)
-->
<!--
With the remaining program logic separated into the `run` function, we can
improve the error handling, as we did with `Config::new` in Listing 12-9.
Instead of allowing the program to panic by calling `expect`, the `run`
function will return a `Result<T, E>` when something goes wrong. This will let
us further consolidate into `main` the logic around handling errors in a
user-friendly way. Listing 12-12 shows the changes we need to make to the
signature and body of `run`.
-->
<p>残りのプログラムロジックが<code>run</code>関数に隔離されたので、リスト12-9の<code>Config::new</code>のように、
エラー処理を改善することができます。<code>expect</code>を呼び出してプログラムにパニックさせる代わりに、
<code>run</code>関数は、何か問題が起きた時に<code>Result&lt;T, E&gt;</code>を返します。これにより、
さらにエラー処理周りのロジックをユーザに優しい形で<code>main</code>に統合することができます。
リスト12-12にシグニチャと<code>run</code>本体に必要な変更を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;

// --snip--

fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<!--
<span class="caption">Listing 12-12: Changing the `run` function to return
`Result`</span>
-->
<p><span class="caption">リスト12-12: <code>run</code>関数を変更して<code>Result</code>を返す</span></p>
<!--
We’ve made three significant changes here. First, we changed the return type of
the `run` function to `Result<(), Box<dyn Error>>`. This function previously
returned the unit type, `()`, and we keep that as the value returned in the
`Ok` case.
-->
<p>ここでは、3つの大きな変更を行いました。まず、<code>run</code>関数の戻り値を<code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>に変えました。
この関数は、以前はユニット型、<code>()</code>を返していて、それを<code>Ok</code>の場合に返される値として残しました。</p>
<!--
For the error type, we used the *trait object* `Box<dyn Error>` (and we’ve
brought `std::error::Error` into scope with a `use` statement at the top).
We’ll cover trait objects in Chapter 17. For now, just know that `Box<dyn
Error>` means the function will return a type that implements the `Error`
trait, but we don’t have to specify what particular type the return value will
be. This gives us flexibility to return error values that may be of different
types in different error cases. The `dyn` keyword is short for “dynamic.”
-->
<p>エラー型については、<em>トレイトオブジェクト</em>の<code>Box&lt;dyn Error&gt;</code>を使用しました(同時に冒頭で<code>use</code>文により、
<code>std::error::Error</code>をスコープに導入しています)。トレイトオブジェクトについては、第17章で講義します。
とりあえず、<code>Box&lt;dyn Error&gt;</code>は、関数が<code>Error</code>トレイトを実装する型を返すことを意味しますが、
戻り値の型を具体的に指定しなくても良いことを知っておいてください。これにより、
エラーケースによって異なる型のエラー値を返す柔軟性を得ます。<code>dyn</code> キーワードは、&quot;dynamic&quot;の略です。</p>
<!--
Second, we’ve removed the calls to `expect` in favor of the `?` operator, as we
talked about in Chapter 9. Rather than `panic!` on an error, the `?` operator
will return the error value from the current function for the caller to handle.
-->
<p>2番目に、<code>expect</code>の呼び出しよりも<code>?</code>演算子を選択して取り除きました。第9章で語りましたね。
エラーでパニックするのではなく、<code>?</code>演算子は呼び出し元が処理できるように、現在の関数からエラー値を返します。</p>
<!--
Third, the `run` function now returns an `Ok` value in the success case. We’ve
declared the `run` function’s success type as `()` in the signature, which
means we need to wrap the unit type value in the `Ok` value. This `Ok(())`
syntax might look a bit strange at first, but using `()` like this is the
idiomatic way to indicate that we’re calling `run` for its side effects only;
it doesn’t return a value we need.
-->
<p>3番目に、<code>run</code>関数は今、成功時に<code>Ok</code>値を返すようになりました。<code>run</code>関数の成功型は、
シグニチャで<code>()</code>と定義したので、ユニット型の値を<code>Ok</code>値に包む必要があります。
最初は、この<code>Ok(())</code>という記法は奇妙に見えるかもしれませんが、このように<code>()</code>を使うことは、
<code>run</code>を副作用のためだけに呼び出していると示唆する慣習的な方法です; 必要な値は返しません。</p>
<!--
When you run this code, it will compile but will display a warning:
-->
<p>このコードを実行すると、コンパイルは通るものの、警告が表示されるでしょう:</p>
<pre><code class="language-text">warning: unused `std::result::Result` which must be used
(警告: 使用されなければならない`std::result::Result`が未使用です)
  --&gt; src/main.rs:18:5
   |
18 |     run(config);
   |     ^^^^^^^^^^^^
= note: #[warn(unused_must_use)] on by default
</code></pre>
<!--
3行目中盤、andだが、逆接のように訳している。andはフローが流れていることを表すだけなので、こうなっている模様
-->
<!--
Rust tells us that our code ignored the `Result` value and the `Result` value
might indicate that an error occurred. But we’re not checking to see whether or
not there was an error, and the compiler reminds us that we probably meant to
have some error-handling code here! Let’s rectify that problem now.
-->
<p>コンパイラは、コードが<code>Result</code>値を無視していると教えてくれて、この<code>Result</code>値は、
エラーが発生したと示唆しているかもしれません。しかし、エラーがあったか確認するつもりはありませんが、
コンパイラは、ここにエラー処理コードを書くつもりだったんじゃないかと思い出させてくれています！
今、その問題を改修しましょう。</p>
<!--
#### Handling Errors Returned from `run` in `main`
-->
<h4 id="mainでrunから返ってきたエラーを処理する"><a class="header" href="#mainでrunから返ってきたエラーを処理する"><code>main</code>で<code>run</code>から返ってきたエラーを処理する</a></h4>
<!--
We’ll check for errors and handle them using a technique similar to one we used
with `Config::new` in Listing 12-10, but with a slight difference:
-->
<p>リスト12-10の<code>Config::new</code>に対して行った方法に似たテクニックを使用してエラーを確認し、扱いますが、
少し違いがあります:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<!--
We use `if let` rather than `unwrap_or_else` to check whether `run` returns an
`Err` value and call `process::exit(1)` if it does. The `run` function doesn’t
return a value that we want to `unwrap` in the same way that `Config::new`
returns the `Config` instance. Because `run` returns `()` in the success case
we only care about detecting an error, so we don’t need `unwrap_or_else` to
return the unwrapped value because it would only be `()`.
-->
<p><code>unwrap_or_else</code>ではなく、<code>if let</code>で<code>run</code>が<code>Err</code>値を返したかどうかを確認し、そうなら<code>process::exit(1)</code>を呼び出しています。
<code>run</code>関数は、<code>Config::new</code>が<code>Config</code>インスタンスを返すのと同じように<code>unwrap</code>したい値を返すことはありません。
<code>run</code>は成功時に<code>()</code>を返すので、エラーを検知することにのみ興味があり、<code>()</code>でしかないので、
<code>unwrap_or_else</code>に包まれた値を返してもらう必要はないのです。</p>
<!--
The bodies of the `if let` and the `unwrap_or_else` functions are the same in
both cases: we print the error and exit.
-->
<p><code>if let</code>と<code>unwrap_or_else</code>関数の中身はどちらも同じです: エラーを出力して終了します。</p>
<!--
### Splitting Code into a Library Crate
-->
<h3 id="コードをライブラリクレートに分割する"><a class="header" href="#コードをライブラリクレートに分割する">コードをライブラリクレートに分割する</a></h3>
<!--
Our `minigrep` project is looking good so far! Now we’ll split the
*src/main.rs* file and put some code into the *src/lib.rs* file so we can test
it and have a *src/main.rs* file with fewer responsibilities.
-->
<p>ここまで<code>minigrep</code>は良さそうですね！では、テストを行え、<em>src/main.rs</em>ファイルの責任が減らせるように、
<em>src/main.rs</em>ファイルを分割し、一部のコードを<em>src/lib.rs</em>ファイルに置きましょう。</p>
<!--
Let’s move all the code that isn’t the `main` function from *src/main.rs* to
*src/lib.rs*:
-->
<p><code>main</code>関数以外のコード全部を<em>src/main.rs</em>から<em>src/lib.rs</em>に移動しましょう:</p>
<!--
* The `run` function definition
* The relevant `use` statements
* The definition of `Config`
* The `Config::new` function definition
-->
<ul>
<li><code>run</code>関数定義</li>
<li>関係する<code>use</code>文</li>
<li><code>Config</code>の定義</li>
<li><code>Config::new</code>関数定義</li>
</ul>
<!--
The contents of *src/lib.rs* should have the signatures shown in Listing 12-13
(we’ve omitted the bodies of the functions for brevity). Note that this won't
compile until we modify *src/main.rs* in Listing 12-14.
-->
<p><em>src/lib.rs</em>の中身にはリスト12-13に示したようなシグニチャがあるはずです(関数の本体は簡潔性のために省略しました)。
リスト12-14で<em>src/main.rs</em>に変更を加えるまで、このコードはコンパイルできないことに注意してください。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --snip--
}
</code></pre>
<!--
<span class="caption">Listing 12-13: Moving `Config` and `run` into
*src/lib.rs*</span>
-->
<p><span class="caption">リスト12-13: <code>Config</code>と<code>run</code>を<em>src/lib.rs</em>に移動する</span></p>
<!--
We’ve made liberal use of `pub` here: on `Config`, on its fields and its
`new` method, and on the `run` function. We now have a library crate that has a
public API that we can test!
-->
<p>ここでは、寛大に<code>pub</code>を使用しています: <code>Config</code>のフィールドと<code>new</code>メソッドと<code>run</code>関数です。
これでテスト可能な公開APIのあるライブラリクレートができました！</p>
<!--
Now we need to bring the code we moved to *src/lib.rs* into the scope of the
binary crate in *src/main.rs*, as shown in Listing 12-14.
-->
<p>さて、<em>src/lib.rs</em>に移動したコードを<em>src/main.rs</em>のバイナリクレートのスコープに持っていく必要があります。
リスト12-14に示したようにですね。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate minigrep;

use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
    if let Err(e) = minigrep::run(config) {
        // --snip--
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-14: Bringing the `minigrep` crate into the
scope of *src/main.rs*</span>
-->
<p><span class="caption">リスト12-14: <code>minigrep</code>クレートを<em>src/main.rs</em>のスコープに持っていく</span></p>
<!--
To bring the library crate into the binary crate, we use `extern crate
minigrep`. Then we add a `use minigrep::Config` line to bring the `Config` type
into scope, and we prefix the `run` function with our crate name. Now all the
functionality should be connected and should work. Run the program with `cargo
run` and make sure everything works correctly.
-->
<p>ライブラリクレートをバイナリクレートに持っていくのに、<code>extern crate minigrep</code>を使用しています。
それから<code>use minigrep::Config</code>行を追加して<code>Config</code>型をスコープに持ってきて、
<code>run</code>関数にクレート名を接頭辞として付けます。これで全機能が連結され、動くはずです。
<code>cargo run</code>でプログラムを走らせて、すべてがうまくいっていることを確かめてください。</p>
<!--
Whew! That was a lot of work, but we’ve set ourselves up for success in the
future. Now it’s much easier to handle errors, and we’ve made the code more
modular. Almost all of our work will be done in *src/lib.rs* from here on out.
-->
<p>ふう！作業量が多かったですね。ですが、将来成功する準備はできています。
もう、エラー処理は遥かに楽になり、コードのモジュール化もできました。
ここから先の作業は、ほぼ<em>src/lib.rs</em>で完結するでしょう。</p>
<!--
Let’s take advantage of this newfound modularity by doing something that would
have been difficult with the old code but is easy with the new code: we’ll
write some tests!
-->
<p>古いコードでは大変だけれども、新しいコードでは楽なことをして新発見のモジュール性を活用しましょう:
テストを書くのです！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Developing the Library’s Functionality with Test Driven Development
-->
<h2 id="テスト駆動開発でライブラリの機能を開発する"><a class="header" href="#テスト駆動開発でライブラリの機能を開発する">テスト駆動開発でライブラリの機能を開発する</a></h2>
<!--
Now that we’ve extracted the logic into *src/lib.rs* and left the argument
collecting and error handling in *src/main.rs*, it’s much easier to write tests
for the core functionality of our code. We can call functions directly with
various arguments and check return values without having to call our binary
from the command line. Feel free to write some tests for the functionality in
the `Config::new` and `run` functions on your own.
-->
<p>今や、ロジックを<em>src/lib.rs</em>に抜き出し、引数集めとエラー処理を<em>src/main.rs</em>に残したので、
コードの核となる機能のテストを書くのが非常に容易になりました。いろんな引数で関数を直接呼び出し、
コマンドラインからバイナリを呼び出す必要なく戻り値を確認できます。ご自由に<code>Config::new</code>や<code>run</code>関数の機能のテストは、
ご自身でお書きください。</p>
<!--
In this section, we’ll add the searching logic to the `minigrep` program by
using the Test Driven Development (TDD) process. This software development
technique follows these steps:
-->
<p>この節では、テスト駆動開発(TDD)過程を活用して<code>minigrep</code>プログラムに検索ロジックを追加します。
このソフトウェア開発テクニックは、以下の手順に従います:</p>
<!--
1. Write a test that fails, and run it to make sure it fails for the reason you
expected.
2. Write or modify just enough code to make the new test pass.
3. Refactor the code you just added or changed and make sure the tests
continue to pass.
4. Repeat from step 1!
-->
<ol>
<li>失敗するテストを書き、走らせて想定通りの理由で失敗することを確かめる。</li>
<li>十分な量のコードを書くか変更して新しいテストを通過するようにする。</li>
<li>追加または変更したばかりのコードをリファクタリングし、テストが通り続けることを確認する。</li>
<li>手順1から繰り返す！</li>
</ol>
<!--
This process is just one of many ways to write software, but TDD can help drive
code design as well. Writing the test before you write the code that makes the
test pass helps to maintain high test coverage throughout the process.
-->
<p>この過程は、ソフトウェアを書く多くの方法のうちの一つに過ぎませんが、TDDによりコードデザインも駆動することができます。
テストを通過させるコードを書く前にテストを書くことで、過程を通して高いテストカバー率を保つ助けになります。</p>
<!--
We’ll test drive the implementation of the functionality that will actually do
the searching for the query string in the file contents and produce a list of
lines that match the query. We’ll add this functionality in a function called
`search`.
-->
<p>実際にクエリ文字列の検索を行う機能の実装をテスト駆動し、クエリに合致する行のリストを生成します。
この機能を<code>search</code>という関数に追加しましょう。</p>
<!--
### Writing a Failing Test
-->
<h3 id="失敗するテストを記述する"><a class="header" href="#失敗するテストを記述する">失敗するテストを記述する</a></h3>
<!--
Because we don’t need them anymore, let’s remove the `println!` statements from
*src/lib.rs* and *src/main.rs* that we used to check the program’s behavior.
Then, in *src/lib.rs*, we’ll add a `test` module with a test function, as we
did in Chapter 11. The test function specifies the behavior we want the
`search` function to have: it will take a query and the text to search for the
query in, and will return only the lines from the text that contain the
query. Listing 12-15 shows this test, which won't compile yet.
-->
<p>もう必要ないので、プログラムの振る舞いを確認していた<code>println!</code>文を<em>src/lib.rs</em>と<em>src/main.rs</em>から削除しましょう。
それから<em>src/lib.rs</em>で、テスト関数のある<code>test</code>モジュールを追加します。第11章のようにですね。
このテスト関数が<code>search</code>関数に欲しい振る舞いを指定します: クエリとそれを検索するテキストを受け取り、
クエリを含む行だけをテキストから返します。リスト12-15にこのテストを示していますが、まだコンパイルは通りません。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">     vec![]
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        // Rustは
        // 安全で速く生産性も高い。
        // 3つ選んで。
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 12-15: Creating a failing test for the `search`
function we wish we had</span>
-->
<p><span class="caption">リスト12-15: こうだったらいいなという<code>search</code>関数の失敗するテストを作成する</span></p>
<!--
This test searches for the string `“duct”`. The text we’re searching is three
lines, only one of which contains `“duct”`. We assert that the value returned
from the `search` function contains only the line we expect.
-->
<p>このテストは、<code>&quot;duct&quot;</code>という文字列を検索します。検索対象の文字列は3行で、うち1行だけが<code>&quot;duct&quot;</code>を含みます。
<code>search</code>関数から返る値が想定している行だけを含むことをアサーションします。</p>
<!--
We aren’t able to run this test and watch it fail because the test doesn’t even
compile: the `search` function doesn’t exist yet! So now we’ll add just enough
code to get the test to compile and run by adding a definition of the `search`
function that always returns an empty vector, as shown in Listing 12-16. Then
the test should compile and fail because an empty vector doesn’t match a vector
containing the line `"safe, fast, productive."`.
-->
<p>このテストを走らせ、失敗するところを観察することはできません。このテストはコンパイルもできないからです:
まだ<code>search</code>関数が存在していません！ゆえに今度は、空のベクタを常に返す<code>search</code>関数の定義を追加することで、
テストをコンパイルし走らせるだけのコードを追記します。リスト12-16に示したようにですね。そうすれば、
テストはコンパイルでき、失敗するはずです。なぜなら、空のベクタは、
<code>&quot;safe, fast, productive.&quot;</code>という行を含むベクタとは合致しないからです。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 12-16: Defining just enough of the `search`
function so our test will compile</span>
-->
<p><span class="caption">リスト12-16: テストがコンパイルできるのに十分なだけ<code>search</code>関数を定義する</span></p>
<!--
3行目後半、which argument lifetimeをwhich argument's lifetimeの形で訳している。記述ミス？
-->
<!--
Notice that we need an explicit lifetime `'a` defined in the signature of
`search` and used with the `contents` argument and the return value. Recall in
Chapter 10 that the lifetime parameters specify which argument lifetime is
connected to the lifetime of the return value. In this case, we indicate that
the returned vector should contain string slices that reference slices of the
argument `contents` (rather than the argument `query`).
-->
<p>明示的なライフタイムの<code>'a</code>が<code>search</code>のシグニチャで定義され、<code>contents</code>引数と戻り値で使用されていることに注目してください。
第10章からライフタイム仮引数は、どの実引数のライフタイムが戻り値のライフタイムに関連づけられているかを指定することを思い出してください。
この場合、返却されるベクタは、
(<code>query</code>引数ではなく)<code>contents</code>引数のスライスを参照する文字列スライスを含むべきと示唆しています。</p>
<!--
In other words, we tell Rust that the data returned by the `search` function
will live as long as the data passed into the `search` function in the
`contents` argument. This is important! The data referenced *by* a slice needs
to be valid for the reference to be valid; if the compiler assumes we’re making
string slices of `query` rather than `contents`, it will do its safety checking
incorrectly.
-->
<p>言い換えると、コンパイラに<code>search</code>関数に返されるデータは、
<code>search</code>関数に<code>contents</code>引数で渡されているデータと同期間生きることを教えています。
これは重要なことです！スライス<em>に</em>参照されるデータは、参照が有効になるために有効である必要があるのです;
コンパイラが<code>contents</code>ではなく<code>query</code>の文字列スライスを生成すると想定してしまったら、
安全性チェックを間違って行うことになってしまいます。</p>
<!--
If we forget the lifetime annotations and try to compile this function, we’ll
get this error:
-->
<p>ライフタイム注釈を忘れてこの関数をコンパイルしようとすると、こんなエラーが出ます:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
(エラー: ライフタイム指定子が欠けています)
 --&gt; src/lib.rs:5:51
  |
5 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                                                   ^ expected lifetime
parameter
  |
  = help: this function's return type contains a borrowed value, but the
  signature does not say whether it is borrowed from `query` or `contents`
  (助言: この関数の戻り値は、借用された値を含んでいますが、シグニチャにはそれが、
  `query`か`contents`から借用されたものであるかが示されていません)
</code></pre>
<!--
Rust can’t possibly know which of the two arguments we need, so we need to tell
it. Because `contents` is the argument that contains all of our text and we
want to return the parts of that text that match, we know `contents` is the
argument that should be connected to the return value using the lifetime syntax.
-->
<p>コンパイラには、二つの引数のどちらが必要なのか知る由がないので、教えてあげる必要があるのです。
<code>contents</code>がテキストを全て含む引数で、合致するそのテキストの一部を返したいので、
<code>contents</code>がライフタイム記法で戻り値に関連づくはずの引数であることをプログラマは知っています。</p>
<!--
Other programming languages don’t require you to connect arguments to return
values in the signature. Although this might seem strange, it will get easier
over time. You might want to compare this example with “Validating
References with Lifetimes” section in Chapter 10.
-->
<p>他のプログラミング言語では、シグニチャで引数と戻り値を関連づける必要はありません。これは奇妙に思えるかもしれませんが、
時間とともに楽になっていきます。この例を第10章、「ライフタイムで参照を有効化する」節と比較したくなるかもしれません。</p>
<!--
Now let’s run the test:
-->
<p>さあ、テストを実行しましょう:</p>
<pre><code class="language-text">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
--warnings--
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running target/debug/deps/minigrep-abcabcabc

running 1 test
test test::one_result ... FAILED

failures:

---- test::one_result stdout ----
        thread 'test::one_result' panicked at 'assertion failed: `(left ==
right)`
left: `[&quot;safe, fast, productive.&quot;]`,
right: `[]`)', src/lib.rs:48:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    test::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<!--
Great, the test fails, exactly as we expected. Let’s get the test to pass!
-->
<p>素晴らしい。テストは全く想定通りに失敗しています。テストが通るようにしましょう！</p>
<!--
### Writing Code to Pass the Test
-->
<h3 id="テストを通過させるコードを書く"><a class="header" href="#テストを通過させるコードを書く">テストを通過させるコードを書く</a></h3>
<!--
Currently, our test is failing because we always return an empty vector. To fix
that and implement `search`, our program needs to follow these steps:
-->
<p>空のベクタを常に返しているために、現状テストは失敗しています。それを修正し、<code>search</code>を実装するには、
プログラムは以下の手順に従う必要があります:</p>
<!--
* Iterate through each line of the contents.
* Check whether the line contains our query string.
* If it does, add it to the list of values we’re returning.
* If it doesn’t, do nothing.
* Return the list of results that match.
-->
<ul>
<li>中身を各行ごとに繰り返す。</li>
<li>行にクエリ文字列が含まれるか確認する。</li>
<li>するなら、それを返却する値のリストに追加する。</li>
<li>しないなら、何もしない。</li>
<li>一致する結果のリストを返す。</li>
</ul>
<!--
Let’s work through each step, starting with iterating through lines.
-->
<p>各行を繰り返す作業から、この手順に順に取り掛かりましょう。</p>
<!--
#### Iterating Through Lines with the `lines` Method
-->
<h4 id="linesメソッドで各行を繰り返す"><a class="header" href="#linesメソッドで各行を繰り返す"><code>lines</code>メソッドで各行を繰り返す</a></h4>
<!--
Rust has a helpful method to handle line-by-line iteration of strings,
conveniently named `lines`, that works as shown in Listing 12-17. Note this
won’t compile yet.
-->
<p>Rustには、文字列を行ごとに繰り返す役立つメソッドがあり、利便性のために<code>lines</code>と名付けられ、
リスト12-17のように動作します。まだ、これはコンパイルできないことに注意してください。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // 行に対して何かする
        // do something with line
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-17: Iterating through each line in `contents`
</span>
-->
<p><span class="caption">リスト12-17: <code>contents</code>の各行を繰り返す</span></p>
<!--
The `lines` method returns an iterator. We’ll talk about iterators in depth in
Chapter 13, but recall that you saw this way of using an iterator in Listing
3-5, where we used a `for` loop with an iterator to run some code on each item
in a collection.
-->
<p><code>lines</code>メソッドはイテレータを返します。イテレータについて詳しくは、第13章で話しますが、
リスト3-5でこのようなイテレータの使用法は見かけたことを思い出してください。
そこでは、イテレータに<code>for</code>ループを使用してコレクションの各要素に対して何らかのコードを走らせていました。</p>
<!--
#### Searching Each Line for the Query
-->
<h4 id="クエリを求めて各行を検索する"><a class="header" href="#クエリを求めて各行を検索する">クエリを求めて各行を検索する</a></h4>
<!--
Next, we’ll check whether the current line contains our query string.
Fortunately, strings have a helpful method named `contains` that does this for
us! Add a call to the `contains` method in the `search` function, as shown in
Listing 12-18. Note this still won’t compile yet.
-->
<p>次に現在の行がクエリ文字列を含むか確認します。幸運なことに、
文字列にはこれを行ってくれる<code>contains</code>という役に立つメソッドがあります！<code>search</code>関数に、
<code>contains</code>メソッドの呼び出しを追加してください。リスト12-18のようにですね。
それでもまだコンパイルできないことに注意してください。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-18: Adding functionality to see whether the
line contains the string in `query`</span>
-->
<p><span class="caption">リスト12-18: 行が<code>query</code>の文字列を含むか確認する機能を追加する</span></p>
<!--
#### Storing Matching Lines
-->
<h4 id="合致した行を保存する"><a class="header" href="#合致した行を保存する">合致した行を保存する</a></h4>
<!--
We also need a way to store the lines that contain our query string. For that,
we can make a mutable vector before the `for` loop and call the `push` method
to store a `line` in the vector. After the `for` loop, we return the vector, as
shown in Listing 12-19.
-->
<p>また、クエリ文字列を含む行を保存する方法が必要です。そのために、<code>for</code>ループの前に可変なベクタを生成し、
<code>push</code>メソッドを呼び出して<code>line</code>をベクタに保存することができます。<code>for</code>ループの後でベクタを返却します。
リスト12-19のようにですね。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<!--
<span class="caption">Listing 12-19: Storing the lines that match so we can
return them</span>
-->
<p><span class="caption">リスト12-19: 合致する行を保存したので、返すことができる</span></p>
<!--
Now the `search` function should return only the lines that contain `query`,
and our test should pass. Let’s run the test:
-->
<p>これで<code>search</code>関数は、<code>query</code>を含む行だけを返すはずであり、テストも通るはずです。
テストを実行しましょう:</p>
<pre><code class="language-text">$ cargo test
--snip--
running 1 test
test test::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
Our test passed, so we know it works!
-->
<p>テストが通り、動いていることがわかりました！</p>
<!--
At this point, we could consider opportunities for refactoring the
implementation of the search function while keeping the tests passing to
maintain the same functionality. The code in the search function isn’t too bad,
but it doesn’t take advantage of some useful features of iterators. We’ll
return to this example in Chapter 13, where we’ll explore iterators in detail,
and look at how to improve it.
-->
<p>ここで、テストが通過するよう保ったまま、同じ機能を保持しながら、検索関数の実装をリファクタリングする機会を考えることもできます。
検索関数のコードは悪すぎるわけではありませんが、イテレータの有用な機能の一部を活用していません。
この例には第13章で再度触れ、そこでは、イテレータをより深く探究し、さらに改善する方法に目を向けます。</p>
<!--
#### Using the `search` Function in the `run` Function
-->
<h4 id="run関数内でsearch関数を使用する"><a class="header" href="#run関数内でsearch関数を使用する"><code>run</code>関数内で<code>search</code>関数を使用する</a></h4>
<!--
Now that the `search` function is working and tested, we need to call `search`
from our `run` function. We need to pass the `config.query` value and the
`contents` that `run` reads from the file to the `search` function. Then `run`
will print each line returned from `search`:
-->
<p><code>search</code>関数が動きテストできたので、<code>run</code>関数から<code>search</code>を呼び出す必要があります。<code>config.query</code>の値と、
ファイルから<code>run</code>が読み込む<code>contents</code>の値を<code>search</code>関数に渡す必要があります。
それから<code>run</code>は、<code>search</code>から返ってきた各行を出力するでしょう:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
</code></pre>
<!--
We’re still using a `for` loop to return each line from `search` and print it.
-->
<p>それでも<code>for</code>ループで<code>search</code>から各行を返し、出力しています。</p>
<!--
Now the entire program should work! Let’s try it out, first with a word that
should return exactly one line from the Emily Dickinson poem, “frog”:
-->
<p>さて、プログラム全体が動くはずです！試してみましょう。まずはエミリー・ディキンソンの詩から、
ちょうど1行だけを返すはずの言葉から。&quot;frog&quot;です:</p>
<pre><code class="language-text">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38 secs
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<!--
Cool! Now let’s try a word that will match multiple lines, like “body”:
-->
<p>かっこいい！今度は、複数行にマッチするであろう言葉を試しましょう。&quot;body&quot;とかね:</p>
<pre><code class="language-text">$ cargo run body poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep body poem.txt`
I’m nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!--
And finally, let’s make sure that we don’t get any lines when we search for a
word that isn’t anywhere in the poem, such as “monomorphization”:
-->
<p>そして最後に、詩のどこにも現れない単語を探したときに、何も出力がないことを確かめましょう。
&quot;monomorphization&quot;などね:</p>
<pre><code class="language-text">$ cargo run monomorphization poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<!--
Excellent! We’ve built our own mini version of a classic tool and learned a lot
about how to structure applications. We’ve also learned a bit about file input
and output, lifetimes, testing, and command line parsing.
-->
<p>最高です！古典的なツールの独自のミニバージョンを構築し、アプリケーションを構造化する方法を多く学びました。
また、ファイル入出力、ライフタイム、テスト、コマンドライン引数の解析についても、少し学びました。</p>
<!--
To round out this project, we’ll briefly demonstrate how to work with
environment variables and how to print to standard error, both of which are
useful when you’re writing command line programs.
-->
<p>このプロジェクトをまとめ上げるために、環境変数を扱う方法と標準エラー出力に出力する方法を少しだけデモします。
これらはどちらも、コマンドラインプログラムを書く際に有用です。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Working with Environment Variables
-->
<h2 id="環境変数を取り扱う"><a class="header" href="#環境変数を取り扱う">環境変数を取り扱う</a></h2>
<!--
We’ll improve `minigrep` by adding an extra feature: an option for
case-insensitive searching that the user can turn on via an environment
variable. We could make this feature a command line option and require that
users enter it each time they want it to apply, but instead we’ll use an
environment variable. Doing so allows our users to set the environment variable
once and have all their searches be case insensitive in that terminal session.
-->
<p>おまけの機能を追加して<code>minigrep</code>を改善します: 環境変数でユーザがオンにできる大文字小文字無視の検索用のオプションです。
この機能をコマンドラインオプションにして、適用したい度にユーザが入力しなければならないようにすることもできますが、
代わりに環境変数を使用します。そうすることでユーザは1回環境変数をセットすれば、そのターミナルセッションの間は、
大文字小文字無視の検索を行うことができるようになるわけです。</p>
<!--
### Writing a Failing Test for the Case-Insensitive `search` Function
-->
<h3 id="大文字小文字を区別しないsearch関数用に失敗するテストを書く"><a class="header" href="#大文字小文字を区別しないsearch関数用に失敗するテストを書く">大文字小文字を区別しない<code>search</code>関数用に失敗するテストを書く</a></h3>
<!--
We want to add a new `search_case_insensitive` function that we’ll call when
the environment variable is on. We’ll continue to follow the TDD process, so
the first step is again to write a failing test. We’ll add a new test for the
new `search_case_insensitive` function and rename our old test from
`one_result` to `case_sensitive` to clarify the differences between the two
tests, as shown in Listing 12-20.
-->
<p>環境変数がオンの場合に呼び出す<code>search_case_insensitive</code>関数を新しく追加したいです。テスト駆動開発の過程に従い続けるので、
最初の手順は、今回も失敗するテストを書くことです。新しい<code>search_case_insensitive</code>関数用の新規テストを追加し、
古いテストを<code>one_result</code>から<code>case_sensitive</code>に名前変更して、二つのテストの差異を明確化します。
リスト12-20に示したようにですね。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
// Rust
// 安全かつ高速で生産的
// 三つを選んで
// ガムテープ
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
// (最後の行のみ)
// 私を信じて
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 12-20: Adding a new failing test for the
case-insensitive function we’re about to add</span>
-->
<p><span class="caption">リスト12-20: 追加しようとしている大文字小文字を区別しない関数用の失敗するテストを新しく追加する</span></p>
<!--
Note that we’ve edited the old test’s `contents` too. We’ve added a new line
with the text `“Duct tape”` using a capital D that shouldn’t match the query
`“duct”` when we’re searching in a case-sensitive manner. Changing the old test
in this way helps ensure that we don’t accidentally break the case-sensitive
search functionality that we’ve already implemented. This test should pass now
and should continue to pass as we work on the case-insensitive search.
-->
<p>古いテストの<code>contents</code>も変更していることに注意してください。大文字小文字を区別する検索を行う際に、
<code>&quot;duct&quot;</code>というクエリに合致しないはずの大文字Dを使用した<code>&quot;Duct tape&quot;</code>(ガムテープ)という新しい行を追加しました。
このように古いテストを変更することで、既に実装済みの大文字小文字を区別する検索機能を誤って壊してしまわないことを保証する助けになります。
このテストはもう通り、大文字小文字を区別しない検索に取り掛かっても通り続けるはずです。</p>
<!--
The new test for the case-*insensitive* search uses “rUsT” as its query. In the
`search_case_insensitive` function we’re about to add, the query “rUsT”
should match the line containing “Rust:” with a capital R and match the line
`“Trust me.”` even though both have different casing than the query. This is
our failing test, and it will fail to compile because we haven’t yet defined
the `search_case_insensitive` function. Feel free to add a skeleton
implementation that always returns an empty vector, similar to the way we did
for the `search` function in Listing 12-16 to see the test compile and fail.
-->
<p>大文字小文字を区別<em>しない</em>検索の新しいテストは、クエリに&quot;rUsT&quot;を使用しています。
追加直前の<code>search_case_insensitive</code>関数では、&quot;rUsT&quot;というクエリは、
両方ともクエリとは大文字小文字が異なるのに、大文字Rの&quot;Rust:&quot;を含む行と、
<code>“Trust me.”</code>という行にもマッチするはずです。これが失敗するテストであり、まだ<code>search_case_insensitive</code>関数を定義していないので、
コンパイルは失敗するでしょう。リスト12-16の<code>search</code>関数で行ったのと同様に空のベクタを常に返すような仮実装を追加し、テストがコンパイルされるものの、失敗する様をご自由に確認してください。</p>
<!--
### Implementing the `search_case_insensitive` Function
-->
<h3 id="search_case_insensitive関数を実装する"><a class="header" href="#search_case_insensitive関数を実装する"><code>search_case_insensitive</code>関数を実装する</a></h3>
<!--
The `search_case_insensitive` function, shown in Listing 12-21, will be almost
the same as the `search` function. The only difference is that we’ll lowercase
the `query` and each `line` so whatever the case of the input arguments,
they’ll be the same case when we check whether the line contains the query.
-->
<p><code>search_case_insensitive</code>関数は、リスト12-21に示しましたが、<code>search</code>関数とほぼ同じです。
唯一の違いは、<code>query</code>と各<code>line</code>を小文字化していることなので、入力引数の大文字小文字によらず、
行がクエリを含んでいるか確認する際には、同じになるわけです。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 12-21: Defining the `search_case_insensitive`
function to lowercase the query and the line before comparing them</span>
-->
<p><span class="caption">リスト12-21: 比較する前にクエリと行を小文字化するよう、<code>search_case_insensitive</code>関数を定義する</span></p>
<!--
First, we lowercase the `query` string and store it in a shadowed variable with
the same name. Calling `to_lowercase` on the query is necessary so no matter
whether the user’s query is `“rust”`, `“RUST”`, `“Rust”`, or `“rUsT”`, we’ll treat the
query as if it was `“rust”` and be insensitive to the case.
-->
<p>まず、<code>query</code>文字列を小文字化し、同じ名前の覆い隠された変数に保存します。ユーザのクエリが<code>&quot;rust&quot;</code>や<code>&quot;RUST&quot;</code>、
<code>&quot;Rust&quot;</code>、<code>&quot;rUsT&quot;</code>などだったりしても、<code>&quot;rust&quot;</code>であり、大文字小文字を区別しないかのようにクエリを扱えるように、
<code>to_lowercase</code>をクエリに対して呼び出すことは必須です。</p>
<!--
Note that `query` is now a `String` rather than a string slice, because calling
`to_lowercase` creates new data rather than referencing existing data. Say the
query is `“rUsT”`, as an example: that string slice doesn’t contain a lowercase
`u` or `t` for us to use, so we have to allocate a new `String` containing
`“rust”`. When we pass `query` as an argument to the `contains` method now, we
need to add an ampersand because the signature of `contains` is defined to take
a string slice.
-->
<p><code>query</code>は最早、文字列スライスではなく<code>String</code>であることに注意してください。というのも、
<code>to_lowercase</code>を呼び出すと、既存のデータを参照するというよりも、新しいデータを作成するからです。
例として、クエリは<code>&quot;rUsT&quot;</code>だとしましょう: その文字列スライスは、小文字の<code>u</code>や<code>t</code>を使えるように含んでいないので、
<code>&quot;rust&quot;</code>を含む新しい<code>String</code>のメモリを確保しなければならないのです。今、<code>contains</code>メソッドに引数として<code>query</code>を渡すと、
アンド記号を追加する必要があります。<code>contains</code>のシグニチャは、文字列スライスを取るよう定義されているからです。</p>
<!--
2行目真ん中、to lowercase ...がかかる先が微妙。今の訳の通りなら、beforeの前にtoを記述する気もする
-->
<!--
Next, we add a call to `to_lowercase` on each `line` before we check whether it
contains `query` to lowercase all characters. Now that we’ve converted `line`
and `query` to lowercase, we’ll find matches no matter what the case of the
query is.
-->
<p>次に、各<code>line</code>が<code>query</code>を含むか確かめる前に<code>to_lowercase</code>の呼び出しを追加し、全文字を小文字化しています。
今や<code>line</code>と<code>query</code>を小文字に変換したので、クエリが大文字であろうと小文字であろうとマッチを検索するでしょう。</p>
<!--
Let’s see if this implementation passes the tests:
-->
<p>この実装がテストを通過するか確認しましょう:</p>
<pre><code class="language-text">running 2 tests
test test::case_insensitive ... ok
test test::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
Great! They passed. Now, let’s call the new `search_case_insensitive` function
from the `run` function. First, we’ll add a configuration option to the
`Config` struct to switch between case-sensitive and case-insensitive search.
Adding this field will cause compiler errors because we aren’t initializing
this field anywhere yet:
-->
<p>素晴らしい！どちらも通りました。では、<code>run</code>関数から新しい<code>search_case_insensitive</code>関数を呼び出しましょう。
1番目に大文字小文字の区別を切り替えられるよう、<code>Config</code>構造体に設定オプションを追加します。
まだどこでも、このフィールドの初期化をしていないので、追加するとコンパイルエラーが起きます:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
<span class="boring">}
</span></code></pre></pre>
<!--
Note that we added the `case_sensitive` field that holds a Boolean. Next, we
need the `run` function to check the `case_sensitive` field’s value and use
that to decide whether to call the `search` function or the
`search_case_insensitive` function, as shown in Listing 12-22. Note this still
won’t compile yet.
-->
<p>論理値を持つ<code>case_sensitive</code>フィールドを追加したことに注意してください。次に、<code>run</code>関数に、
<code>case_sensitive</code>フィールドの値を確認し、<code>search</code>関数か<code>search_case_insensitive</code>関数を呼ぶかを決定するのに使ってもらう必要があります。
リスト12-22のようにですね。それでも、これはまだコンパイルできないことに注意してください。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs::File;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">
</span><span class="boring">fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">     vec![]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">     vec![]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">    case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let mut f = File::open(config.filename)?;

    let mut contents = String::new();
    f.read_to_string(&amp;mut contents)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 12-22: Calling either `search` or
`search_case_insensitive` based on the value in `config.case_sensitive`</span>
-->
<p><span class="caption">リスト12-22: <code>config.case_sensitive</code>の値に基づいて<code>search</code>か<code>search_case_insensitive</code>を呼び出す</span></p>
<!--
Finally, we need to check for the environment variable. The functions for
working with environment variables are in the `env` module in the standard
library, so we want to bring that module into scope with a `use std::env;` line
at the top of *src/lib.rs*. Then we’ll use the `var` function from the `env`
module to check for an environment variable named `CASE_INSENSITIVE`, as shown
in Listing 12-23.
-->
<p>最後に、環境変数を確認する必要があります。環境変数を扱う関数は、標準ライブラリの<code>env</code>モジュールにあるので、
<code>use std::env;</code>行で<em>src/lib.rs</em>の冒頭でそのモジュールをスコープに持ってくる必要があります。そして、
<code>env</code>モジュールから<code>var</code>関数を使用して<code>CASE_INSENSITIVE</code>という環境変数のチェックを行います。
リスト12-23のようにですね。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::env;
<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">    case_sensitive: bool,
</span><span class="boring">}
</span>
// --snip--

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 12-23: Checking for an environment variable named
`CASE_INSENSITIVE`</span>
-->
<p><span class="caption">リスト12-23: <code>CASE_INSENSITIVE</code>という環境変数のチェックを行う</span></p>
<!--
Here, we create a new variable `case_sensitive`. To set its value, we call the
`env::var` function and pass it the name of the `CASE_INSENSITIVE` environment
variable. The `env::var` function returns a `Result` that will be the successful
`Ok` variant that contains the value of the environment variable if the
environment variable is set. It will return the `Err` variant if the
environment variable is not set.
-->
<p>ここで、<code>case_sensitive</code>という新しい変数を生成しています。その値をセットするために、
<code>env::var</code>関数を呼び出し、<code>CASE_INSENSITIVE</code>環境変数の名前を渡しています。<code>env::var</code>関数は、
環境変数がセットされていたら、環境変数の値を含む<code>Ok</code>列挙子の成功値になる<code>Result</code>を返します。
環境変数がセットされていなければ、<code>Err</code>列挙子を返すでしょう。</p>
<!--
We’re using the `is_err` method on the `Result` to check whether it’s an error
and therefore unset, which means it *should* do a case-sensitive search. If the
`CASE_INSENSITIVE` environment variable is set to anything, `is_err` will
return false and the program will perform a case-insensitive search. We don’t
care about the *value* of the environment variable, just whether it’s set or
unset, so we’re checking `is_err` rather than `unwrap`, `expect`, or any
of the other methods we’ve seen on `Result`.
-->
<p><code>Result</code>の<code>is_err</code>メソッドを使用して、エラーでありゆえに、セットされていないことを確認しています。
これは大文字小文字を区別する検索をす<em>べき</em>ことを意味します。<code>CASE_INSENSITIVE</code>環境変数が何かにセットされていれば、
<code>is_err</code>はfalseを返し、プログラムは大文字小文字を区別しない検索を実行するでしょう。環境変数の<em>値</em>はどうでもよく、
セットされているかどうかだけ気にするので、<code>unwrap</code>や<code>expect</code>あるいは、他のここまで見かけた<code>Result</code>のメソッドではなく、
<code>is_err</code>をチェックしています。</p>
<!--
We pass the value in the `case_sensitive` variable to the `Config` instance so
the `run` function can read that value and decide whether to call `search` or
`search_case_insensitive`, as we implemented in Listing 12-22.
-->
<p><code>case_sensitive</code>変数の値を<code>Config</code>インスタンスに渡しているので、リスト12-22で実装したように、
<code>run</code>関数はその値を読み取り、<code>search</code>か<code>search_case_insensitive</code>を呼び出すか決定できるのです。</p>
<!--
Let’s give it a try! First, we’ll run our program without the environment
variable set and with the query `to`, which should match any line that contains
the word “to” in all lowercase:
-->
<p>試行してみましょう！まず、環境変数をセットせずにクエリは<code>to</code>でプログラムを実行し、
この時は全て小文字で&quot;to&quot;という言葉を含むあらゆる行が合致するはずです。</p>
<pre><code class="language-text">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!--
Looks like that still works! Now, let’s run the program with `CASE_INSENSITIVE`
set to `1` but with the same query `to`.
-->
<p>まだ機能しているようです！では、<code>CASE_INSENSITIVE</code>を1にしつつ、同じクエリの<code>to</code>でプログラムを実行しましょう。</p>
<!--
If you’re using PowerShell, you will need to set the environment variable and
run the program in two commands rather than one:
-->
<p>PowerShellを使用しているなら、1コマンドではなく、2コマンドで環境変数をセットし、プログラムを実行する必要があるでしょう:</p>
<pre><code class="language-text">$ $env:CASE_INSENSITIVE=1
$ cargo run to poem.txt
</code></pre>
<!--
We should get lines that contain “to” that might have uppercase letters:
-->
<p>大文字も含む可能性のある&quot;to&quot;を含有する行が得られるはずです:</p>
<pre><code class="language-text">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<!--
Excellent, we also got lines containing “To”! Our `minigrep` program can now do
case-insensitive searching controlled by an environment variable. Now you know
how to manage options set using either command line arguments or environment
variables.
-->
<p>素晴らしい、&quot;To&quot;を含む行も出てきましたね！<code>minigrep</code>プログラムはこれで、
環境変数によって制御できる大文字小文字を区別しない検索も行えるようになりました。もうコマンドライン引数か、
環境変数を使ってオプションを管理する方法も知りましたね。</p>
<!--
Some programs allow arguments *and* environment variables for the same
configuration. In those cases, the programs decide that one or the other takes
precedence. For another exercise on your own, try controlling case
insensitivity through either a command line argument or an environment
variable. Decide whether the command line argument or the environment variable
should take precedence if the program is run with one set to case sensitive and
one set to case insensitive.
-->
<p>引数<em>と</em>環境変数で同じ設定を行うことができるプログラムもあります。そのような場合、
プログラムはどちらが優先されるか決定します。自身の別の鍛錬として、コマンドライン引数か、
環境変数で大文字小文字の区別を制御できるようにしてみてください。
片方は大文字小文字を区別するようにセットされ、もう片方は区別しないようにセットしてプログラムが実行された時に、
コマンドライン引数と環境変数のどちらの優先度が高くなるかを決めてください。</p>
<!--
The `std::env` module contains many more useful features for dealing with
environment variables: check out its documentation to see what is available.
-->
<p><code>std::env</code>モジュールは、環境変数を扱うもっと多くの有用な機能を有しています:
ドキュメンテーションを確認して、何が利用可能か確かめてください。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Writing Error Messages to Standard Error Instead of Standard Output
-->
<h2 id="標準出力ではなく標準エラーにエラーメッセージを書き込む"><a class="header" href="#標準出力ではなく標準エラーにエラーメッセージを書き込む">標準出力ではなく標準エラーにエラーメッセージを書き込む</a></h2>
<!--
At the moment we’re writing all of our output to the terminal using the
`println!` function. Most terminals provide two kinds of output: *standard
output* (`stdout`) for general information and *standard error* (`stderr`)
for error messages. This distinction enables users to choose to direct the
successful output of a program to a file but still print error messages to the
screen.
-->
<p>現時点では、すべての出力を<code>println!</code>関数を使用して端末に書き込んでいます。多くの端末は、
2種類の出力を提供します: 普通の情報用の<em>標準出力</em>(<code>stdout</code>)とエラーメッセージ用の<em>標準エラー出力</em>(<code>stderr</code>)です。
この差異のおかげで、ユーザは、エラーメッセージを画面に表示しつつ、
プログラムの成功した出力をファイルにリダイレクトすることを選択できます。</p>
<!--
The `println!` function is only capable of printing to standard output, so we
have to use something else to print to standard error.
-->
<p><code>println!</code>関数は、標準出力に出力する能力しかないので、標準エラーに出力するには他のものを使用しなければなりません。</p>
<!--
### Checking Where Errors Are Written to
-->
<h3 id="エラーが書き込まれる場所を確認する"><a class="header" href="#エラーが書き込まれる場所を確認する">エラーが書き込まれる場所を確認する</a></h3>
<!--
First, let’s observe how the content printed by `minigrep` is currently being
written to standard output, including any error messages we want to write to
standard error instead. We’ll do that by redirecting the standard output stream
to a file while also intentionally causing an error. We won’t redirect the
standard error stream, so any content sent to standard error will continue to
display on the screen.
-->
<p>まず、<code>minigrep</code>に出力される中身が、代わりに標準エラーに書き込みたいいかなるエラーメッセージも含め、
どのように標準出力に書き込まれているかを観察しましょう。意図的にエラーを起こしつつ、
ファイルに標準出力ストリームをリダイレクトすることでそうします。標準エラーストリームはリダイレクトしないので、
標準エラーに送られる内容は、すべて画面に表示され続けます。</p>
<!--
Command line programs are expected to send error messages to the standard error
stream so we can still see error messages on the screen even if we redirect the
standard output stream to a file. Our program is not currently well-behaved:
we’re about to see that it saves the error message output to a file instead!
-->
<p>コマンドラインプログラムは、エラーメッセージを標準エラー出力に送信していると期待されているので、
標準出力ストリームをファイルにリダイレクトしても、画面にエラーメッセージが見られます。
我々のプログラムは、現状、いい振る舞いをしていません: 代わりにファイルにエラーメッセージ出力を保存するところを、
目撃するところです！</p>
<!--
The way to demonstrate this behavior is by running the program with `>` and the
filename, *output.txt*, that we want to redirect the standard output stream to.
We won’t pass any arguments, which should cause an error:
-->
<p>この動作をデモする方法は、<code>&gt;</code>と標準出力ストリームをリダイレクトする先のファイル名、<em>output.txt</em>でプログラムを走らせることによります。
引数は何も渡さず、そうするとエラーが起きるはずです:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
</code></pre>
<!--
The `>` syntax tells the shell to write the contents of standard output to
*output.txt* instead of the screen. We didn’t see the error message we were
expecting printed to the screen, so that means it must have ended up in the
file. This is what *output.txt* contains:
-->
<p><code>&gt;</code>記法により、標準出力の中身を画面の代わりに<em>output.txt</em>に書き込むようシェルは指示されます。
画面に出力されると期待していたエラーメッセージは見られないので、ファイルに入っているということでしょう。
以下が<em>output.txt</em>が含んでいる内容です:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<!--
Yup, our error message is being printed to standard output. It’s much more
useful for error messages like this to be printed to standard error so only
data from a successful run ends up in the file. We'll change that.
-->
<p>そうです。エラーメッセージは標準出力に出力されているのです。このようなエラーメッセージは標準エラーに出力され、
成功した状態のデータのみがファイルに残ると遥かに有用です。それを変更します。</p>
<!--
### Printing Errors to Standard Error
-->
<h3 id="エラーを標準エラーに出力する"><a class="header" href="#エラーを標準エラーに出力する">エラーを標準エラーに出力する</a></h3>
<!--
We’ll use the code in Listing 12-24 to change how error messages are printed.
Because of the refactoring we did earlier in this chapter, all the code that
prints error messages is in one function, `main`. The standard library provides
the `eprintln!` macro that prints to the standard error stream, so let’s change
the two places we were calling `println!` to print errors to use `eprintln!`
instead.
-->
<p>リスト12-24のコードを使用して、エラーメッセージの出力の仕方を変更します。この章の前で行ったリファクタリングのため、
エラーメッセージを出力するコードはすべて1関数、<code>main</code>にあります。標準ライブラリは、
標準エラーストリームに出力する<code>eprintln!</code>マクロを提供しているので、
<code>println!</code>を呼び出してエラーを出力していた2箇所を代わりに<code>eprintln!</code>を使うように変更しましょう。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<!--
<span class="caption">Listing 12-24: Writing error messages to standard error
instead of standard output using `eprintln!`</span>
-->
<p><span class="caption">リスト12-24: <code>eprintln!</code>を使って標準出力ではなく、標準エラーにエラーメッセージを書き込む</span></p>
<!--
After changing `println!` to `eprintln!`, let’s run the program again in the
same way, without any arguments and redirecting standard output with `>`:
-->
<p><code>println!</code>を<code>eprintln!</code>に変えてから、再度同じようにプログラムを実行しましょう。
引数なしかつ、標準出力を<code>&gt;</code>でリダイレクトしてね:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<!--
Now we see the error onscreen and *output.txt* contains nothing, which is the
behavior we expect of command line programs.
-->
<p>これで、エラーは画面に見えつつ、<em>output.txt</em>は何も含まなくなり、これはコマンドラインプログラムに期待する動作です。</p>
<!--
Let’s run the program again with arguments that don’t cause an error but still
redirect standard output to a file, like so:
-->
<p>再度、標準出力をファイルにリダイレクトしてエラーは起こさない引数でプログラムを走らせましょう。以下のようにですね:</p>
<pre><code class="language-text">$ cargo run to poem.txt &gt; output.txt
</code></pre>
<!--
We won’t see any output to the terminal, and *output.txt* will contain our
results:
-->
<p>ターミナルには出力は見られず、<em>output.txt</em>に結果が含まれます:</p>
<!--
<span class="filename">Filename: output.txt</span>
-->
<p><span class="filename">ファイル名: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<!--
This demonstrates that we’re now using standard output for successful output
and standard error for error output as appropriate.
-->
<p>これは、もう成功した出力には標準出力を、エラー出力には標準エラーを適切に使用していることをデモしています。</p>
<!--
## Summary
-->
<h2 id="まとめ-11"><a class="header" href="#まとめ-11">まとめ</a></h2>
<!--
This chapter recapped some of the major concepts you’ve learned so far and
covered how to perform common I/O operations in Rust. By using command line
arguments, files, environment variables, and the `eprintln!` macro for printing
errors, you’re now prepared to write command line applications. By using the
concepts in previous chapters, your code will be well organized, store data
effectively in the appropriate data structures, handle errors nicely, and be
well tested.
-->
<p>この章では、ここまでに学んできた主要な概念の一部を念押しし、Rustで入出力処理を行う方法を講義しました。
コマンドライン引数、ファイル、環境変数、そしてエラー出力に<code>eprintln!</code>マクロを使用することで、
もう、コマンドラインアプリケーションを書く準備ができています。以前の章の概念を使用することで、
コードはうまく体系化され、適切なデータ構造に効率的にデータを保存し、エラーをうまく扱い、
よくテストされるでしょう。</p>
<!--
Next, we’ll explore some Rust features that were influenced by functional
languages: closures and iterators.
-->
<p>次は、関数型言語に影響されたRust機能を一部探究します: クロージャとイテレータです。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Functional Language Features: Iterators and Closures
-->
<h1 id="関数型言語の機能-イテレータとクロージャ"><a class="header" href="#関数型言語の機能-イテレータとクロージャ">関数型言語の機能: イテレータとクロージャ</a></h1>
<!--
Rust’s design has taken inspiration from many existing languages and
techniques, and one significant influence is *functional programming*.
Programming in a functional style often includes using functions as values by
passing them in arguments, returning them from other functions, assigning them
to variables for later execution, and so forth.
-->
<p>Rustの設計は、多くの既存の言語やテクニックにインスピレーションを得ていて、
その一つの大きな影響が<em>関数型プログラミング</em>です。関数型でのプログラミングには、しばしば、
引数で渡したり、関数から関数を返したり、関数を後ほど使用するために変数に代入することで関数を値として使用することが含まれます。</p>
<!--
In this chapter, we won’t debate the issue of what functional programming is or
isn’t but will instead discuss some features of Rust that are similar to
features in many languages often referred to as functional.
-->
<p>この章では、関数型プログラミングがどんなものであったり、なかったりするかという問題については議論しませんが、
代わりに関数型とよく言及される多くの言語の機能に似たRustの機能の一部について議論しましょう。</p>
<!--
More specifically, we’ll cover:
-->
<p>具体的には、以下を講義します:</p>
<!--
* *Closures*, a function-like construct you can store in a variable
* *Iterators*, a way of processing a series of elements
* How to use these two features to improve the I/O project in Chapter 12
* The performance of these two features (Spoiler alert: they’re faster than you
might think!)
-->
<ul>
<li><em>クロージャ</em>、変数に保存できる関数に似た文法要素</li>
<li><em>イテレータ</em>、一連の要素を処理する方法</li>
<li>これら2つの機能を使用して第12章の入出力プロジェクトを改善する方法</li>
<li>これら2つの機能のパフォーマンス(ネタバレ: 思ったよりも速いです)</li>
</ul>
<!--
Other Rust features, such as pattern matching and enums, which we've covered in
other chapters, are influenced by the functional style as well. Mastering
closures and iterators is an important part of writing idiomatic, fast Rust
code, so we’ll devote this entire chapter to them.
-->
<p>パターンマッチングやenumなど、他のRustの機能も関数型に影響されていますが、他の章で講義してきました。
クロージャとイテレータをマスターすることは、慣用的で速いRustコードを書くことの重要な部分なので、
この章を丸ごと捧げます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Closures: Anonymous Functions that Can Capture Their Environment
-->
<h2 id="クロージャ-環境をキャプチャできる匿名関数"><a class="header" href="#クロージャ-環境をキャプチャできる匿名関数">クロージャ: 環境をキャプチャできる匿名関数</a></h2>
<!--
Rust’s closures are anonymous functions you can save in a variable or pass as
arguments to other functions. You can create the closure in one place and then
call the closure to evaluate it in a different context. Unlike functions,
closures can capture values from the scope in which they’re called. We’ll
demonstrate how these closure features allow for code reuse and behavior
customization.
-->
<p>Rustのクロージャは、変数に保存したり、引数として他の関数に渡すことのできる匿名関数です。
ある場所でクロージャを生成し、それから別の文脈でクロージャを呼び出して評価することができます。
関数と異なり、呼び出されたスコープの値をクロージャは、キャプチャすることができます。
これらのクロージャの機能がコードの再利用や、動作のカスタマイズを行わせてくれる方法を模擬しましょう。</p>
<!--
### Creating an Abstraction of Behavior with Closures
-->
<h3 id="クロージャで動作の抽象化を行う"><a class="header" href="#クロージャで動作の抽象化を行う">クロージャで動作の抽象化を行う</a></h3>
<!--
Let’s work on an example of a situation in which it’s useful to store a closure
to be executed later. Along the way, we’ll talk about the syntax of closures,
type inference, and traits.
-->
<p>クロージャを保存して後々使用できるようにするのが有用な場面の例に取り掛かりましょう。その過程で、
クロージャの記法、型推論、トレイトについて語ります。</p>
<!--
Consider this hypothetical situation: we work at a startup that’s making an app
to generate custom exercise workout plans. The backend is written in Rust, and
the algorithm that generates the workout plan takes into account many factors,
such as the app user’s age, body mass index, exercise preferences, recent
workouts, and an intensity number they specify. The actual algorithm used isn’t
important in this example; what’s important is that this calculation takes a
few seconds. We want to call this algorithm only when we need to and only call
it once so we don’t make the user wait more than necessary.
-->
<p>以下のような架空の場面を考えてください: カスタマイズされたエクササイズのトレーニングプランを生成するアプリを作るスタートアップで働くことになりました。
バックエンドはRustで記述され、トレーニングプランを生成するアルゴリズムは、アプリユーザの年齢や、
BMI、運動の好み、最近のトレーニング、指定された強弱値などの多くの要因を考慮します。
実際に使用されるアルゴリズムは、この例では重要ではありません; 重要なのは、この計算が数秒要することです。
必要なときだけこのアルゴリズムを呼び出し、1回だけ呼び出したいので、必要以上にユーザを待たせないことになります。</p>
<!--
We’ll simulate calling this hypothetical algorithm with the
`simulated_expensive_calculation` shown in Listing 13-1, which will print
`calculating slowly...`, wait for two seconds, and then return whatever number
we passed in.
-->
<p>リスト13-1に示した<code>simulated_expensive_calculation</code>関数でこの仮定のアルゴリズムを呼び出すことをシミュレートし、
この関数は<code>calculating slowly</code>と出力し、2秒待ってから、渡した数値をなんでも返します。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    // ゆっくり計算します
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-1: A function to stand in for a hypothetical
calculation that takes about 2 seconds to run</span>
-->
<p><span class="caption">リスト13-1: 実行に約2秒かかる架空の計算の代役を務める関数</span></p>
<!--
Next is the `main` function that contains the parts of the workout app
important for this example. This function represents the code that the app will
call when a user asks for a workout plan. Because the interaction with the
app’s frontend isn’t relevant to the use of closures, we’ll hardcode values
representing inputs to our program and print the outputs.
-->
<p>次は、この例で重要なトレーニングアプリの部分を含む<code>main</code>関数です。この関数は、
ユーザがトレーニングプランを要求した時にアプリが呼び出すコードを表します。
アプリのフロントエンドと相互作用する部分は、クロージャの使用と関係ないので、プログラムへの入力を表す値をハードコードし、
その出力を表示します。</p>
<!--
The required inputs are these:
-->
<p>必要な入力は以下の通りです:</p>
<!--
* An intensity number from the user, which is specified when they request
a workout to indicate whether they want a low-intensity workout or a
high-intensity workout.
* A random number that will generate some variety in the workout plans.
-->
<ul>
<li>ユーザの強弱値、これはユーザがトレーニングを要求して、低強度のトレーニングか、
高強度のトレーニングがしたいかを示したときに指定されます。</li>
<li>乱数、これはトレーニングプランにバリエーションを起こします。</li>
</ul>
<!--
The output will be the recommended workout plan. Listing 13-2 shows the `main`
function we’ll use.
-->
<p>出力は、推奨されるトレーニングプランになります。リスト13-2は使用する<code>main</code>関数を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(
        simulated_user_specified_value,
        simulated_random_number
    );
}
<span class="boring">fn generate_workout(intensity: u32, random_number: u32) {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-2: A `main` function with hardcoded values to
simulate user input and random number generation</span>
-->
<p><span class="caption">リスト13-2: ユーザ入力や乱数生成をシミュレートするハードコードされた値がある<code>main</code>関数</span></p>
<!--
We’ve hardcoded the variable `simulated_user_specified_value` as 10 and the
variable `simulated_random_number` as 7 for simplicity’s sake; in an actual
program, we’d get the intensity number from the app frontend, and we’d use the
`rand` crate to generate a random number, as we did in the Guessing Game
example in Chapter 2. The `main` function calls a `generate_workout` function
with the simulated input values.
-->
<p>簡潔性のために、変数<code>simulated_user_specified_value</code>は10、変数<code>simulated_random_number</code>は7とハードコードしました;
実際のプログラムにおいては、強弱値はアプリのフロントエンドから取得し、乱数の生成には、第2章の数当てゲームの例のように、<code>rand</code>クレートを使用するでしょう。
<code>main</code>関数は、シミュレートされた入力値とともに<code>generate_workout</code>関数を呼び出します。</p>
<!--
Now that we have the context, let’s get to the algorithm. The
`generate_workout` function in Listing 13-3 contains the business logic of the
app that we’re most concerned with in this example. The rest of the code
changes in this example will be made to this function.
-->
<p>今や文脈ができたので、アルゴリズムに取り掛かりましょう。リスト13-3の<code>generate_workout</code>関数は、
この例で最も気にかかるアプリのビジネスロジックを含んでいます。この例での残りの変更は、
この関数に対して行われるでしょう:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(num: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calculating slowly...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    num
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &lt; 25 {

        println!(
            // 今日は{}回腕立て伏せをしてください！
            &quot;Today, do {} pushups!&quot;,
            simulated_expensive_calculation(intensity)
        );

        println!(
            // 次に、{}回腹筋をしてください！
            &quot;Next, do {} situps!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            // 今日は休憩してください！水分補給を忘れずに！
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                // 今日は、{}分間走ってください！
                &quot;Today, run for {} minutes!&quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-3: The business logic that prints the workout
plans based on the inputs and calls to the `simulated_expensive_calculation`
function</span>
-->
<p><span class="caption">リスト13-3: 入力に基づいてトレーニングプランを出力するビジネスロジックと、
<code>simulated_expensive_calculation</code>関数の呼び出し</span></p>
<!--
The code in Listing 13-3 has multiple calls to the slow calculation function.
The first `if` block calls `simulated_expensive_calculation` twice, the `if`
inside the outer `else` doesn’t call it at all, and the code inside the
second `else` case calls it once.
-->
<p>リスト13-3のコードには、遅い計算を行う関数への呼び出しが複数あります。最初の<code>if</code>ブロックが、
<code>simulated_expensive_calculation</code>を2回呼び出し、外側の<code>else</code>内の<code>if</code>は全く呼び出さず、
2番目の<code>else</code>ケースの内側にあるコードは1回呼び出しています。</p>
<!--
NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199
-->
<!--
The desired behavior of the `generate_workout` function is to first check
whether the user wants a low-intensity workout (indicated by a number less
than 25) or a high-intensity workout (a number of 25 or greater).
-->
<p><code>generate_workout</code>関数の期待される振る舞いは、まずユーザが低強度のトレーニング(25より小さい数値で表される)か、
高強度のトレーニング(25以上の数値)を欲しているか確認することです。</p>
<!--
Low-intensity workout plans will recommend a number of push-ups and sit-ups
based on the complex algorithm we’re simulating.
-->
<p>低強度のトレーニングプランは、シミュレーションしている複雑なアルゴリズムに基づいて、
多くの腕立て伏せや腹筋運動を推奨してきます。</p>
<!--
If the user wants a high-intensity workout, there’s some additional logic: if
the value of the random number generated by the app happens to be 3, the app
will recommend a break and hydration. If not, the user will get a number of
minutes of running based on the complex algorithm.
-->
<p>ユーザが高強度のトレーニングを欲していれば、追加のロジックがあります: アプリが生成した乱数がたまたま3なら、
アプリは休憩と水分補給を勧めます。そうでなければ、ユーザは複雑なアルゴリズムに基づいて数分間のランニングをします。</p>
<!--
This code works the way the business wants it to now, but let's say the data
science team decides that we need to make some changes to the way we call the
`simulated_expensive_calculation` function in the future. To simplify the
update when those changes happen, we want to refactor this code so it calls the
`simulated_expensive_calculation` function only once. We also want to cut the
place where we’re currently unnecessarily calling the function twice without
adding any other calls to that function in the process. That is, we don’t want
to call it if the result isn’t needed, and we still want to call it only once.
-->
<p>このコードは現在、ビジネスのほしいままに動くでしょうが、データサイエンスチームが、
<code>simulated_expensive_calculation</code>関数を呼び出す方法に何らかの変更を加える必要があると決定したとしましょう。
そのような変更が起きた時に更新を簡略化するため、<code>simulated_expensive_calculation</code>関数を1回だけ呼び出すように、
このコードをリファクタリングしたいです。また、その過程でその関数への呼び出しを増やすことなく無駄に2回、
この関数を現時点で呼んでいるところを切り捨てたくもあります。要するに、結果が必要なければ関数を呼び出したくなく、
それでも1回だけ呼び出したいのです。</p>
<!--
#### Refactoring Using Functions
-->
<h4 id="関数でリファクタリング"><a class="header" href="#関数でリファクタリング">関数でリファクタリング</a></h4>
<!--
We could restructure the workout program in many ways. First, we’ll try
extracting the duplicated call to the `simulated_expensive_calculation`
function into a variable, as shown in Listing 13-4.
-->
<p>多くの方法でトレーニングプログラムを再構築することもできます。
1番目に<code>simulated_expensive_calculation</code>関数への重複した呼び出しを変数に抽出しようとしましょう。リスト13-4に示したように。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(num: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calculating slowly...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    num
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result =
        simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-4: Extracting the calls to
`simulated_expensive_calculation` to one place and storing the result in the
`expensive_result` variable</span>
-->
<p><span class="caption">リスト13-4: 複数の<code>simulated_expensive_calculation</code>の呼び出しを1箇所に抽出し、
結果を<code>expensive_result</code>変数に保存する</span></p>
<!--
This change unifies all the calls to `simulated_expensive_calculation` and
solves the problem of the first `if` block unnecessarily calling the function
twice. Unfortunately, we’re now calling this function and waiting for the
result in all cases, which includes the inner `if` block that doesn’t use the
result value at all.
-->
<p>この変更により<code>simulated_expensive_calculation</code>の呼び出しが単一化され、
最初の<code>if</code>ブロックが無駄に関数を2回呼んでいた問題を解決します。不幸なことに、これでは、
あらゆる場合にこの関数を呼び出し、その結果を待つことになり、結果値を全く使用しない内側の<code>if</code>ブロックでもそうしてしまいます。</p>
<!--
We want to define code in one place in our program, but only *execute* that
code where we actually need the result. This is a use case for closures!
-->
<p>プログラムの1箇所でコードを定義したいですが、結果が本当に必要なところでだけコードを<em>実行</em>します。
これは、クロージャのユースケースです！</p>
<!--
#### Refactoring with Closures to Store Code
-->
<h4 id="クロージャでリファクタリングしてコードを保存する"><a class="header" href="#クロージャでリファクタリングしてコードを保存する">クロージャでリファクタリングして、コードを保存する</a></h4>
<!--
Instead of always calling the `simulated_expensive_calculation` function before
the `if` blocks, we can define a closure and store the *closure* in a variable
rather than storing the result of the function call, as shown in Listing 13-5.
We can actually move the whole body of `simulated_expensive_calculation` within
the closure we’re introducing here.
-->
<p><code>if</code>ブロックの前にいつも<code>simulated_expensive_calculation</code>関数を呼び出す代わりに、
クロージャを定義し、関数呼び出しの結果を保存するのではなく、その<em>クロージャ</em>を変数に保存できます。リスト13-5のようにですね。
<code>simulated_expensive_calculation</code>の本体全体を実際に、ここで導入しているクロージャ内に移すことができます。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>let expensive_closure = |num| {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
<span class="boring">expensive_closure(5);
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-5: Defining a closure and storing it in the
`expensive_closure` variable</span>
-->
<p><span class="caption">リスト13-5: クロージャを定義し、<code>expensive_closure</code>変数に保存する</span></p>
<!--
The closure definition comes after the `=` to assign it to the variable
`expensive_closure`. To define a closure, we start with a pair of vertical
pipes (`|`), inside which we specify the parameters to the closure; this syntax
was chosen because of its similarity to closure definitions in Smalltalk and
Ruby. This closure has one parameter named `num`: if we had more than one
parameter, we would separate them with commas, like `|param1, param2|`.
-->
<p>クロージャ定義が<code>=</code>に続き、変数<code>expensive_closure</code>に代入されています。クロージャを定義するには、
1組の縦棒から始め、その内部にクロージャの仮引数を指定します; この記法は、SmalltalkやRubyのクロージャ定義と類似していることから、
選択されました。このクロージャには、<code>num</code>という引数が1つあります: 2つ以上引数があるなら、
<code>|param1, param2|</code>のように、カンマで区切ります。</p>
<!--
After the parameters, we place curly brackets that hold the body of the
closure—these are optional if the closure body is a single expression. The end
of the closure, after the curly brackets, needs a semicolon to complete the
`let` statement. The value returned from the last line in the closure body
(`num`) will be the value returned from the closure when it’s called, because
that line doesn’t end in a semicolon; just as in function bodies.
-->
<p>引数の後に、クロージャの本体を保持する波括弧を配置します(これはクロージャ本体が式一つなら省略可能です)。
波括弧の後、クロージャのお尻には、セミコロンが必要で、<code>let</code>文を完成させます。クロージャ本体の最後の行から返る値(<code>num</code>)が、
呼び出された時にクロージャから返る値になります。その行がセミコロンで終わっていないからです;
ちょうど関数の本体みたいですね。</p>
<!--
Note that this `let` statement means `expensive_closure` contains the
*definition* of an anonymous function, not the *resulting value* of calling the
anonymous function. Recall that we’re using a closure because we want to define
the code to call at one point, store that code, and call it at a later point;
the code we want to call is now stored in `expensive_closure`.
-->
<p>この<code>let</code>文は、<code>expensive_closure</code>が、匿名関数を呼び出した<em>結果の値</em>ではなく、
匿名関数の<em>定義</em>を含むことを意味することに注意してください。コードを定義して、
1箇所で呼び出し、そのコードを保存し、後々、それを呼び出したいがためにクロージャを使用していることを思い出してください;
呼び出したいコードは、現在、<code>expensive_closure</code>に保存されています。</p>
<!--
この冒頭のwithも順接の理由にしている。やはり強すぎるか？
-->
<!--
With the closure defined, we can change the code in the `if` blocks to call the
closure to execute the code and get the resulting value. We call a closure like
we do a function: we specify the variable name that holds the closure
definition and follow it with parentheses containing the argument values we
want to use, as shown in Listing 13-6.
-->
<p>クロージャが定義されたので、<code>if</code>ブロックのコードを変更して、そのコードを実行するクロージャを呼び出し、結果値を得ることができます。
クロージャは、関数のように呼び出せます: クロージャ定義を含む変数名を指定し、使用したい引数値を含むかっこを続けます。
リスト13-6に示したようにですね。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_closure(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_closure(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-6: Calling the `expensive_closure` we’ve
defined</span>
-->
<p><span class="caption">リスト13-6: 定義した<code>expensive_closure</code>を呼び出す</span></p>
<!--
2行目最後は、今の通りにも(at) whereのようにも取れるか？
-->
<!--
Now the expensive calculation is called in only one place, and we’re only
executing that code where we need the results.
-->
<p>今では、重い計算はたった1箇所でのみ呼び出され、その結果が必要なコードを実行するだけになりました。</p>
<!--
However, we’ve reintroduced one of the problems from Listing 13-3: we’re still
calling the closure twice in the first `if` block, which will call the
expensive code twice and make the user wait twice as long as they need to. We
could fix this problem by creating a variable local to that `if` block to hold
the result of calling the closure, but closures provide us with another
solution. We’ll talk about that solution in a bit. But first let’s talk about
why there aren’t type annotations in the closure definition and the traits
involved with closures.
-->
<p>ところが、リスト13-3の問題の一つを再浮上させてしまいました: それでも、最初の<code>if</code>ブロックでクロージャを2回呼んでいて、
そうすると、重いコードを2回呼び出し、必要な分の2倍ユーザを待たせてしまいます。その<code>if</code>ブロックのみに属する変数を生成して、
クロージャの呼び出し結果を保持するその<code>if</code>ブロックに固有の変数を生成することでこの問題を解消することもできますが、
クロージャは他の解決法も用意してくれます。その解決策については、もう少し先で語りましょう。でもまずは、
クロージャ定義に型注釈がない理由とクロージャに関わるトレイトについて話しましょう。</p>
<!--
### Closure Type Inference and Annotation
-->
<h3 id="クロージャの型推論と注釈"><a class="header" href="#クロージャの型推論と注釈">クロージャの型推論と注釈</a></h3>
<!--
Closures don’t require you to annotate the types of the parameters or the
return value like `fn` functions do. Type annotations are required on functions
because they’re part of an explicit interface exposed to your users. Defining
this interface rigidly is important for ensuring that everyone agrees on what
types of values a function uses and returns. But closures aren’t used in an
exposed interface like this: they’re stored in variables and used without
naming them and exposing them to users of our library.
-->
<p>クロージャでは、<code>fn</code>関数のように引数の型や戻り値の型を注釈する必要はありません。関数では、
型注釈は必要です。ユーザに露出する明示的なインターフェイスの一部だからです。このインターフェイスを堅実に定義することは、
関数が使用したり、返したりする値の型についてみんなが合意していることを保証するために重要なのです。
しかし、クロージャはこのような露出するインターフェイスには使用されません: 変数に保存され、
名前付けしたり、ライブラリの使用者に晒されることなく、使用されます。</p>
<!--
Closures are usually short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler is
reliably able to infer the types of the parameters and the return type, similar
to how it’s able to infer the types of most variables.
-->
<p>クロージャは通常短く、あらゆる任意の筋書きではなく、狭い文脈でのみ関係します。
このような限定された文脈内では、コンパイラは、多くの変数の型を推論できるのと似たように、
引数や戻り値の型を頼もしく推論することができます。</p>
<!--
Making programmers annotate the types in these small, anonymous functions would
be annoying and largely redundant with the information the compiler already has
available.
-->
<p>このような小さく匿名の関数で型をプログラマに注釈させることは煩わしいし、コンパイラがすでに利用可能な情報と大きく被っています。</p>
<!--
As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for the closure we defined in Listing 13-5
would look like the definition shown in Listing 13-7.
-->
<p>本当に必要な以上に冗長になることと引き換えに、明示性と明瞭性を向上させたいなら、変数に型注釈を加えることもできます;
リスト13-5で定義したクロージャに型を注釈するなら、リスト13-7に示した定義のようになるでしょう。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>let expensive_closure = |num: u32| -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-7: Adding optional type annotations of the
parameter and return value types in the closure</span>
-->
<p><span class="caption">リスト13-7: クロージャの引数と戻り値の省略可能な型注釈を追加する</span></p>
<!--
With type annotations added, the syntax of closures looks more similar to the
syntax of functions. The following is a vertical comparison of the syntax for
the definition of a function that adds 1 to its parameter and a closure that
has the same behavior. We’ve added some spaces to line up the relevant parts.
This illustrates how closure syntax is similar to function syntax except for
the use of pipes and the amount of syntax that is optional:
-->
<p>型注釈を付け加えると、クロージャの記法は、関数の記法により酷似して見えます。以下が、引数に1を加える関数の定義と、
同じ振る舞いをするクロージャの定義の記法を縦に比べたものです。
空白を追加して、関連のある部分を並べています。これにより、縦棒の使用と省略可能な記法の量を除いて、
クロージャ記法が関数記法に似ているところを説明しています。</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<!--
The first line shows a function definition, and the second line shows a fully
annotated closure definition. The third line removes the type annotations from
the closure definition, and the fourth line removes the brackets, which are
optional because the closure body has only one expression. These are all valid
definitions that will produce the same behavior when they’re called.
-->
<p>1行目が関数定義を示し、2行目がフルに注釈したクロージャ定義を示しています。
3行目は、クロージャ定義から型注釈を取り除き、4行目は、かっこを取り除いていて、
かっこはクロージャの本体がただ1つの式からなるので、省略可能です。これらは全て、
呼び出された時に同じ振る舞いになる合法な定義です。</p>
<!--
Closure definitions will have one concrete type inferred for each of their
parameters and for their return value. For instance, Listing 13-8 shows the
definition of a short closure that just returns the value it receives as a
parameter. This closure isn’t very useful except for the purposes of this
example. Note that we haven’t added any type annotations to the definition: if
we then try to call the closure twice, using a `String` as an argument the
first time and a `u32` the second time, we’ll get an error.
-->
<p>クロージャ定義には、引数それぞれと戻り値に対して推論される具体的な型が一つあります。例えば、
リスト13-8に引数として受け取った値を返すだけの短いクロージャの定義を示しました。
このクロージャは、この例での目的以外には有用ではありません。この定義には、
何も型注釈を加えていないことに注意してください: それから1回目に<code>String</code>を引数に、
2回目に<code>u32</code>を引数に使用してこのクロージャを2回呼び出そうとしたら、エラーになります。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
</code></pre>
<!--
<span class="caption">Listing 13-8: Attempting to call a closure whose types
are inferred with two different types</span>
-->
<p><span class="caption">リスト13-8: 2つの異なる型で型が推論されるクロージャの呼び出しを試みる</span></p>
<!--
The compiler gives us this error:
-->
<p>コンパイラは、次のエラーを返します:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs
  |
  | let n = example_closure(5);
  |                         ^ expected struct `std::string::String`, found
  integral variable
  |
  = note: expected type `std::string::String`
             found type `{integer}`
</code></pre>
<!--
The first time we call `example_closure` with the `String` value, the compiler
infers the type of `x` and the return type of the closure to be `String`. Those
types are then locked in to the closure in `example_closure`, and we get a type
error if we try to use a different type with the same closure.
-->
<p><code>String</code>値で<code>example_closure</code>を呼び出した最初の時点で、コンパイラは<code>x</code>とクロージャの戻り値の型を<code>String</code>と推論します。
そして、その型が<code>example_closure</code>のクロージャに閉じ込められ、同じクロージャを異なる型で使用しようとすると、
型エラーが出るのです。</p>
<!--
### Storing Closures Using Generic Parameters and the `Fn` Traits
-->
<h3 id="ジェネリック引数とfnトレイトを使用してクロージャを保存する"><a class="header" href="#ジェネリック引数とfnトレイトを使用してクロージャを保存する">ジェネリック引数と<code>Fn</code>トレイトを使用してクロージャを保存する</a></h3>
<!--
Let’s return to our workout generation app. In Listing 13-6, our code was still
calling the expensive calculation closure more times than it needed to. One
option to solve this issue is to save the result of the expensive closure in a
variable for reuse and use the variable in each place we need the result,
instead of calling the closure again. However, this method could result in a
lot of repeated code.
-->
<p>トレーニング生成アプリに戻りましょう。リスト13-6において、まだコードは必要以上の回数、重い計算のクロージャを呼んでいました。
この問題を解決する一つの選択肢は、重いクロージャの結果を再利用できるように変数に保存し、クロージャを再度呼ぶ代わりに、
結果が必要になる箇所それぞれでその変数を使用することです。しかしながら、この方法は同じコードを大量に繰り返す可能性があります。</p>
<!--
Fortunately, another solution is available to us. We can create a struct that
will hold the closure and the resulting value of calling the closure. The
struct will execute the closure only if we need the resulting value, and it
will cache the resulting value so the rest of our code doesn’t have to be
responsible for saving and reusing the result. You may know this pattern as
*memoization* or *lazy evaluation*.
-->
<p>運のいいことに、別の解決策もあります。クロージャやクロージャの呼び出し結果の値を保持する構造体を作れるのです。
結果の値が必要な場合のみにその構造体はクロージャを実行し、その結果の値をキャッシュするので、残りのコードは、
結果を保存し、再利用する責任を負わなくて済むのです。このパターンは、<em>メモ化</em>(memoization)または、
<em>遅延評価</em>(lazy evaluation)として知っているかもしれません。</p>
<!--
5行目、structs, enumsにthatがかかるか曖昧だが、この訳の方が自然と思われる
-->
<!--
To make a struct that holds a closure, we need to specify the type of the
closure, because a struct definition needs to know the types of each of its
fields. Each closure instance has its own unique anonymous type: that is, even
if two closures have the same signature, their types are still considered
different. To define structs, enums, or function parameters that use closures,
we use generics and trait bounds, as we discussed in Chapter 10.
-->
<p>クロージャを保持する構造体を作成するために、クロージャの型を指定する必要があります。
構造体定義は、各フィールドの型を把握しておく必要がありますからね。各クロージャインスタンスには、
独自の匿名の型があります: つまり、たとえ2つのクロージャが全く同じシグニチャでも、その型はそれでも違うものと考えられるということです。
クロージャを使用する構造体、enum、関数引数を定義するには、第10章で議論したように、
ジェネリクスとトレイト境界を使用します。</p>
<!--
The `Fn` traits are provided by the standard library. All closures implement
one of the traits: `Fn`, `FnMut`, or `FnOnce`. We’ll discuss the
difference between these traits in the "Capturing the Environment with
Closures" section; in this example, we can use the `Fn` trait.
-->
<p><code>Fn</code>トレイトは、標準ライブラリで用意されています。全てのクロージャは、以下のいずれかのトレイトを実装しています:
<code>Fn</code>、<code>FnMut</code>または、<code>FnOnce</code>です。「クロージャで環境をキャプチャする」節で、これらのトレイト間の差異を議論します;
この例では、<code>Fn</code>トレイトを使えます。</p>
<!--
We add types to the `Fn` trait bound to represent the types of the parameters
and return values the closures must have to match this trait bound. In this
case, our closure has a parameter of type `u32` and returns a `u32`, so the
trait bound we specify is `Fn(u32) -> u32`.
-->
<p><code>Fn</code>トレイト境界にいくつかの型を追加することで、このトレイト境界に合致するクロージャが持つべき引数と戻り値の型を示します。
今回のクロージャは<code>u32</code>型の引数を一つ取り、<code>u32</code>を返すので、指定するトレイト境界は<code>Fn(u32) -&gt; u32</code>になります。</p>
<!--
Listing 13-9 shows the definition of the `Cacher` struct that holds a closure
and an optional result value.
-->
<p>リスト13-9は、クロージャとオプションの結果値を保持する<code>Cacher</code>構造体の定義を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-9: Defining a `Cacher` struct that holds a
closure in `calculation` and an optional result in `value`</span>
-->
<p><span class="caption">リスト13-9: クロージャを<code>calculation</code>に、オプションの結果値を<code>value</code>に保持する<code>Cacher</code>構造体を定義する</span></p>
<!--
The `Cacher` struct has a `calculation` field of the generic type `T`. The
trait bounds on `T` specify that it’s a closure by using the `Fn` trait. Any
closure we want to store in the `calculation` field must have one `u32`
parameter (specified within the parentheses after `Fn`) and must return a
`u32` (specified after the `->`).
-->
<p><code>Cacher</code>構造体は、ジェネリックな型<code>T</code>の<code>calculation</code>フィールドを持ちます。<code>T</code>のトレイト境界は、
<code>Fn</code>トレイトを使うことでクロージャであると指定しています。<code>calculation</code>フィールドに保存したいクロージャは全て、
1つの<code>u32</code>引数(<code>Fn</code>の後の括弧内で指定されている)を取り、<code>u32</code>(<code>-&gt;</code>の後に指定されている)を返さなければなりません。</p>
<!--
> Note: Functions implement all three of the `Fn` traits too. If what we want
> to do doesn’t require capturing a value from the environment, we can use a
> function rather than a closure where we need something that implements an `Fn`
> trait.
-->
<blockquote>
<p>注釈: 関数も3つの<code>Fn</code>トレイト全部を実装します。もし環境から値をキャプチャする必要がなければ、
<code>Fn</code>トレイトを実装する何かが必要になるクロージャではなく、関数を使用できます。</p>
</blockquote>
<!--
The `value` field is of type `Option<u32>`. Before we execute the closure,
`value` will be `None`. When code using a `Cacher` asks for the *result* of the
closure, the `Cacher` will execute the closure at that time and store the
result within a `Some` variant in the `value` field. Then if the code asks for
the result of the closure again, instead of executing the closure again, the
`Cacher` will return the result held in the `Some` variant.
-->
<p><code>value</code>フィールドの型は、<code>Option&lt;u32&gt;</code>です。クロージャを実行する前に、<code>value</code>は<code>None</code>になるでしょう。
<code>Cacher</code>を使用するコードがクロージャの<em>結果</em>を求めてきたら、その時点で<code>Cacher</code>はクロージャを実行し、
その結果を<code>value</code>フィールドの<code>Some</code>列挙子に保存します。それから、コードが再度クロージャの結果を求めたら、
クロージャを再実行するのではなく、<code>Cacher</code>は<code>Some</code>列挙子に保持された結果を返すでしょう。</p>
<!--
The logic around the `value` field we’ve just described is defined in Listing
13-10.
-->
<p>たった今解説した<code>value</code>フィールド周りのロジックは、リスト13-10で定義されています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">    where T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    calculation: T,
</span><span class="boring">    value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;T&gt; Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-10: The caching logic of `Cacher`</span>
-->
<p><span class="caption">リスト13-10: <code>Cacher</code>のキャッシュ機構</span></p>
<!--
We want `Cacher` to manage the struct fields’ values rather than letting the
calling code potentially change the values in these fields directly, so these
fields are private.
-->
<p>呼び出し元のコードにこれらのフィールドの値を直接変えてもらうのではなく、<code>Cacher</code>に構造体のフィールドの値を管理してほしいので、
これらのフィールドは非公開になっています。</p>
<!--
The `Cacher::new` function takes a generic parameter `T`, which we’ve defined
as having the same trait bound as the `Cacher` struct. Then `Cacher::new`
returns a `Cacher` instance that holds the closure specified in the
`calculation` field and a `None` value in the `value` field, because we haven’t
executed the closure yet.
-->
<p><code>Cacher::new</code>関数はジェネリックな引数の<code>T</code>を取り、<code>Cacher</code>構造体と同じトレイト境界を持つよう定義しました。
それから<code>calculation</code>フィールドに指定されたクロージャと、
<code>value</code>フィールドに<code>None</code>値を保持する<code>Cacher</code>インスタンスを<code>Cacher::new</code>は返します。
まだクロージャを実行していないからですね。</p>
<!--
When the calling code needs the result of evaluating the closure, instead of
calling the closure directly, it will call the `value` method. This method
checks whether we already have a resulting value in `self.value` in a `Some`;
if we do, it returns the value within the `Some` without executing the closure
again.
-->
<p>呼び出し元のコードがクロージャの評価結果を必要としたら、クロージャを直接呼ぶ代わりに、<code>value</code>メソッドを呼びます。
このメソッドは、結果の値が<code>self.value</code>の<code>Some</code>に既にあるかどうか確認します; そうなら、
クロージャを再度実行することなく<code>Some</code>内の値を返します。</p>
<!--
If `self.value` is `None`, the code calls the closure stored in
`self.calculation`, saves the result in `self.value` for future use, and
returns the value as well.
-->
<p><code>self.value</code>が<code>None</code>なら、コードは<code>self.calculation</code>に保存されたクロージャを呼び出し、
結果を将来使えるように<code>self.value</code>に保存し、その値を返しもします。</p>
<!--
Listing 13-11 shows how we can use this `Cacher` struct in the function
`generate_workout` from Listing 13-6.
-->
<p>リスト13-11は、リスト13-6の関数<code>generate_workout</code>でこの<code>Cacher</code>構造体を使用する方法を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">    where T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    calculation: T,
</span><span class="boring">    value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cacher&lt;T&gt;
</span><span class="boring">    where T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
</span><span class="boring">        Cacher {
</span><span class="boring">            calculation,
</span><span class="boring">            value: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn value(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">        match self.value {
</span><span class="boring">            Some(v) =&gt; v,
</span><span class="boring">            None =&gt; {
</span><span class="boring">                let v = (self.calculation)(arg);
</span><span class="boring">                self.value = Some(v);
</span><span class="boring">                v
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result.value(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result.value(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-11: Using `Cacher` in the `generate_workout`
function to abstract away the caching logic</span>
-->
<p><span class="caption">リスト13-11: <code>generate_workout</code>関数内で<code>Cacher</code>を使用し、キャッシュ機構を抽象化する</span></p>
<!--
Instead of saving the closure in a variable directly, we save a new instance of
`Cacher` that holds the closure. Then, in each place we want the result, we
call the `value` method on the `Cacher` instance. We can call the `value`
method as many times as we want, or not call it at all, and the expensive
calculation will be run a maximum of once.
-->
<p>クロージャを変数に直接保存する代わりに、クロージャを保持する<code>Cacher</code>の新規インスタンスを保存しています。
そして、結果が必要な場所それぞれで、その<code>Cacher</code>インスタンスに対して<code>value</code>メソッドを呼び出しています。
必要なだけ<code>value</code>メソッドを呼び出したり、全く呼び出さないこともでき、重い計算は最大でも1回しか走りません。</p>
<!--
Try running this program with the `main` function from Listing 13-2. Change the
values in the `simulated_user_specified_value` and `simulated_random_number`
variables to verify that in all the cases in the various `if` and `else`
blocks, `calculating slowly...` appears only once and only when needed. The
`Cacher` takes care of the logic necessary to ensure we aren’t calling the
expensive calculation more than we need to so `generate_workout` can focus on
the business logic.
-->
<p>リスト13-2の<code>main</code>関数とともにこのプログラムを走らせてみてください。
<code>simulated_user_specified_value</code>と<code>simulated_random_number</code>変数の値を変えて、
いろんな<code>if</code>や<code>else</code>ブロックの場合全てで、<code>calculating slowly</code>は1回だけ、必要な時にのみ出現することを実証してください。
必要以上に重い計算を呼び出さないことを保証するのに必要なロジックの面倒を<code>Cacher</code>は見るので、
<code>generate_workout</code>はビジネスロジックに集中できるのです。</p>
<!--
### Limitations of the `Cacher` Implementation
-->
<h3 id="cacher実装の限界"><a class="header" href="#cacher実装の限界"><code>Cacher</code>実装の限界</a></h3>
<!--
Caching values is a generally useful behavior that we might want to use in
other parts of our code with different closures. However, there are two
problems with the current implementation of `Cacher` that would make reusing it
in different contexts difficult.
-->
<p>値をキャッシュすることは、コードの他の部分でも異なるクロージャで行いたくなる可能性のある一般的に有用な振る舞いです。
しかし、現在の<code>Cacher</code>の実装には、他の文脈で再利用することを困難にしてしまう問題が2つあります。</p>
<!--
The first problem is that a `Cacher` instance assumes it will always get the
same value for the parameter `arg` to the `value` method. That is, this test of
`Cacher` will fail:
-->
<p>1番目の問題は、<code>Cacher</code>インスタンスが、常に<code>value</code>メソッドの引数<code>arg</code>に対して同じ値になると想定していることです。
言い換えると、<code>Cacher</code>のこのテストは、失敗するでしょう:</p>
<pre><code class="language-rust ignore">#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}
</code></pre>
<!--
This test creates a new `Cacher` instance with a closure that returns the value
passed into it. We call the `value` method on this `Cacher` instance with an
`arg` value of 1 and then an `arg` value of 2, and we expect the call to
`value` with the `arg` value of 2 to return 2.
-->
<p>このテストは、渡された値を返すクロージャを伴う<code>Cacher</code>インスタンスを新しく生成しています。
この<code>Cacher</code>インスタンスに対して1という<code>arg</code>値で呼び出し、それから2という<code>arg</code>値で呼び出し、
2という<code>arg</code>値の<code>value</code>呼び出しは2を返すべきと期待しています。</p>
<!--
Run this test with the `Cacher` implementation in Listing 13-9 and Listing
13-10, and the test will fail on the `assert_eq!` with this message:
-->
<p>このテストをリスト13-9とリスト13-10の<code>Cacher</code>実装で動かすと、<code>assert_eq</code>からこんなメッセージが出て、
テストは失敗します:</p>
<pre><code class="language-text">thread 'call_with_different_values' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/main.rs
</code></pre>
<!--
The problem is that the first time we called `c.value` with 1, the `Cacher`
instance saved `Some(1)` in `self.value`. Thereafter, no matter what we pass in
to the `value` method, it will always return 1.
-->
<p>問題は、初めて<code>c.value</code>を1で呼び出した時に、<code>Cacher</code>インスタンスは<code>self.value</code>に<code>Some(1)</code>を保存したことです。
その後<code>value</code>メソッドに何を渡しても、常に1を返すわけです。</p>
<!--
Try modifying `Cacher` to hold a hash map rather than a single value. The keys
of the hash map will be the `arg` values that are passed in, and the values of
the hash map will be the result of calling the closure on that key. Instead of
looking at whether `self.value` directly has a `Some` or a `None` value, the
`value` function will look up the `arg` in the hash map and return the value if
it’s present. If it’s not present, the `Cacher` will call the closure and save
the resulting value in the hash map associated with its `arg` value.
-->
<p>単独の値ではなく、ハッシュマップを保持するように<code>Cacher</code>を改変してみてください。ハッシュマップのキーは、
渡される<code>arg</code>値になり、ハッシュマップの値は、そのキーでクロージャを呼び出した結果になるでしょう。
<code>self.value</code>が直接<code>Some</code>か<code>None</code>値であることを調べる代わりに、<code>value</code>関数はハッシュマップの<code>arg</code>を調べ、
存在するならその値を返します。存在しないなら、<code>Cacher</code>はクロージャを呼び出し、
<code>arg</code>値に紐づけてハッシュマップに結果の値を保存します。</p>
<!--
The second problem with the current `Cacher` implementation is that it only
accepts closures that take one parameter of type `u32` and return a `u32`. We
might want to cache the results of closures that take a string slice and return
`usize` values, for example. To fix this issue, try introducing more generic
parameters to increase the flexibility of the `Cacher` functionality.
-->
<p>現在の<code>Cacher</code>実装の2番目の問題は、引数の型に<code>u32</code>を一つ取り、<code>u32</code>を返すクロージャしか受け付けないことです。
例えば、文字列スライスを取り、<code>usize</code>を返すクロージャの結果をキャッシュしたくなるかもしれません。
この問題を修正するには、<code>Cacher</code>機能の柔軟性を向上させるためによりジェネリックな引数を導入してみてください。</p>
<!--
### Capturing the Environment with Closures
-->
<h3 id="クロージャで環境をキャプチャする"><a class="header" href="#クロージャで環境をキャプチャする">クロージャで環境をキャプチャする</a></h3>
<!--
In the workout generator example, we only used closures as inline anonymous
functions. However, closures have an additional capability that functions don’t
have: they can capture their environment and access variables from the scope in
which they’re defined.
-->
<p>トレーニング生成の例においては、クロージャをインラインの匿名関数として使っただけでした。しかし、
クロージャには、関数にはない追加の能力があります: 環境をキャプチャし、
自分が定義されたスコープの変数にアクセスできるのです。</p>
<!--
Listing 13-12 has an example of a closure stored in the `equal_to_x` variable
that uses the `x` variable from the closure’s surrounding environment.
-->
<p>リスト13-12は、<code>equal_to_x</code>変数に保持されたクロージャを囲む環境から<code>x</code>変数を使用するクロージャの例です。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<!--
<span class="caption">Listing 13-12: Example of a closure that refers to a
variable in its enclosing scope</span>
-->
<p><span class="caption">リスト13-12: 内包するスコープの変数を参照するクロージャの例</span></p>
<!--
Here, even though `x` is not one of the parameters of `equal_to_x`, the
`equal_to_x` closure is allowed to use the `x` variable that’s defined in the
same scope that `equal_to_x` is defined in.
-->
<p>ここで、<code>x</code>は<code>equal_to_x</code>の引数でもないのに、
<code>equal_to_x</code>が定義されているのと同じスコープで定義されている<code>x</code>変数を<code>equal_to_x</code>クロージャは使用できています。</p>
<!--
We can’t do the same with functions; if we try with the following example, our
code won’t compile:
-->
<p>同じことを関数では行うことができません; 以下の例で試したら、コードはコンパイルできません:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool { z == x }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre>
<!--
We get an error:
-->
<p>エラーが出ます:</p>
<pre><code class="language-text">error[E0434]: can't capture dynamic environment in a fn item; use the || { ...
} closure form instead
(エラー: fn要素では動的な環境をキャプチャできません; 代わりに|| { ... }のクロージャ形式を
使用してください)
 --&gt; src/main.rs
  |
4 |     fn equal_to_x(z: i32) -&gt; bool { z == x }
  |                                          ^
</code></pre>
<!--
The compiler even reminds us that this only works with closures!
-->
<p>コンパイラは、この形式はクロージャでのみ動作することさえも思い出させてくれています！</p>
<!--
When a closure captures a value from its environment, it uses memory to store
the values for use in the closure body. This use of memory is overhead that we
don’t want to pay in more common cases where we want to execute code that
doesn’t capture its environment. Because functions are never allowed to capture
their environment, defining and using functions will never incur this overhead.
-->
<p>クロージャが環境から値をキャプチャすると、メモリを使用してクロージャ本体で使用できるようにその値を保存します。
このメモリ使用は、環境をキャプチャしないコードを実行するようなもっと一般的な場合には払いたくないオーバーヘッドです。
関数は、絶対に環境をキャプチャすることが許可されていないので、関数を定義して使えば、このオーバーヘッドを招くことは絶対にありません。</p>
<!--
Closures can capture values from their environment in three ways, which
directly map to the three ways a function can take a parameter: taking
ownership, borrowing mutably, and borrowing immutably. These are encoded in the
three `Fn` traits as follows:
-->
<p>クロージャは、3つの方法で環境から値をキャプチャでき、この方法は関数が引数を取れる3つの方法に直に対応します:
所有権を奪う、可変で借用する、不変で借用するです。これらは、以下のように3つの<code>Fn</code>トレイトでコード化されています:</p>
<!--
* `FnOnce` consumes the variables it captures from its enclosing scope, known
as the closure’s *environment*. To consume the captured variables, the
closure must take ownership of these variables and move them into the closure
when it is defined. The `Once` part of the name represents the fact that the
closure can’t take ownership of the same variables more than once, so it can
only be called one time.
* `FnMut` can change the environment because it mutably borrows values.
* `Fn` borrows values from the environment immutably.
-->
<ul>
<li><code>FnOnce</code>は、クロージャの<em>環境</em>として知られている内包されたスコープからキャプチャした変数を消費します。
キャプチャした変数を消費するために、定義された際にクロージャはこれらの変数の所有権を奪い、
自身にムーブするのです。名前のうち、<code>Once</code>の部分は、
このクロージャは同じ変数の所有権を2回以上奪うことができないという事実を表しているので、1回しか呼ぶことができないのです。</li>
<li><code>FnMut</code>は、可変で値を借用するので、環境を変更することができます。</li>
<li><code>Fn</code>は、環境から値を不変で借用します。</li>
</ul>
<!--
When you create a closure, Rust infers which trait to use based on how the
closure uses the values from the environment. All closures implement `FnOnce`,
because they can all be called at least once. Closures that don't move the
captured variables also implement `FnMut`, and closures that don't need mutable
access to the captured variables also implement `Fn`. In Listing 13-12, the
`equal_to_x` closure borrows `x` immutably (so `equal_to_x` has the `Fn` trait)
because the body of the closure only needs to read the value in `x`.
-->
<p>クロージャを生成する時、クロージャが環境を使用する方法に基づいて、コンパイラはどのトレイトを使用するか推論します。
少なくとも1回は呼び出されるので、全てのクロージャは<code>FnOnce</code>を実装しています。キャプチャした変数をムーブしないクロージャは、
<code>FnMut</code>も実装し、キャプチャした変数に可変でアクセスする必要のないクロージャは、<code>Fn</code>も実装しています。
リスト13-12では、<code>equal_to_x</code>クロージャは<code>x</code>を不変で借用しています(ゆえに<code>equal_to_x</code>は<code>Fn</code>トレイトです)。
クロージャの本体は、<code>x</code>を読む必要しかないからです。</p>
<!--
If you want to force the closure to take ownership of the values it uses in the
environment, we can use the `move` keyword before the parameter list. This
technique is mostly useful when passing a closure to a new thread to move the
data so it’s owned by the new thread.
-->
<p>環境でクロージャが使用している値の所有権を奪うことをクロージャに強制したいなら、引数リストの前に<code>move</code>キーワードを使用できます。
このテクニックは、新しいスレッドにデータが所有されるように、クロージャを新しいスレッドに渡して、
データをムーブする際に大概は有用です。</p>
<!--
We’ll have more examples of `move` closures in Chapter 16 when we talk about
concurrency. For now, here’s the code from Listing 13-12 with the `move`
keyword added to the closure definition and using vectors instead of integers,
because integers can be copied rather than moved; note that this code will not
yet compile.
-->
<p>並行性について語る第16章で、<code>move</code>クロージャの例はもっと多く出てきます。とりあえず、
こちらが<code>move</code>キーワードがクロージャ定義に追加され、整数の代わりにベクタを使用するリスト13-12からのコードです。
整数はムーブではなく、コピーされてしまいますからね; このコードはまだコンパイルできないことに注意してください。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    // ここでは、xを使用できません: {:?}
    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre>
<!--
We receive the following error:
-->
<p>以下のようなエラーを受けます:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `x`
(エラー: ムーブされた値の使用: `x`)
 --&gt; src/main.rs:6:40
  |
4 |     let equal_to_x = move |z| z == x;
  |                      -------- value moved (into closure) here
                                  (値はここで(クロージャに)ムーブされた)
5 |
6 |     println!(&quot;can't use x here: {:?}&quot;, x);
  |                                        ^ value used here after move
                                             (ムーブ後、値はここで使用された)
  |
  = note: move occurs because `x` has type `std::vec::Vec&lt;i32&gt;`, which does not
  implement the `Copy` trait
  (注釈: `x`が`std::vec::Vec&lt;i32&gt;`という`Copy`トレイトを実装しない型のため、ムーブが起きました)
</code></pre>
<!--
The `x` value is moved into the closure when the closure is defined, because we
added the `move` keyword. The closure then has ownership of `x`, and `main`
isn’t allowed to use `x` anymore in the `println!` statement. Removing
`println!` will fix this example.
-->
<p>クロージャが定義された際に、クロージャに<code>x</code>の値はムーブされています。<code>move</code>キーワードを追加したからです。
そして、クロージャは<code>x</code>の所有権を持ち、<code>main</code>が<code>println!</code>で<code>x</code>を使うことはもう叶わないのです。
<code>println!</code>を取り除けば、この例は修正されます。</p>
<!--
Most of the time when specifying one of the `Fn` trait bounds, you can start
with `Fn` and the compiler will tell you if you need `FnMut` or `FnOnce` based
on what happens in the closure body.
-->
<p><code>Fn</code>トレイトのどれかを指定するほとんどの場合、<code>Fn</code>から始めると、コンパイラがクロージャ本体内で起こっていることにより、
<code>FnMut</code>や<code>FnOnce</code>が必要な場合、教えてくれるでしょう。</p>
<!--
To illustrate situations where closures that can capture their environment are
useful as function parameters, let’s move on to our next topic: iterators.
-->
<p>環境をキャプチャできるクロージャが関数の引数として有用な場面を説明するために、次のトピックに移りましょう: イテレータです。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Processing a Series of Items with Iterators
-->
<h2 id="一連の要素をイテレータで処理する"><a class="header" href="#一連の要素をイテレータで処理する">一連の要素をイテレータで処理する</a></h2>
<!--
The iterator pattern allows you to perform some task on a sequence of items in
turn. An iterator is responsible for the logic of iterating over each item and
determining when the sequence has finished. When you use iterators, you don’t
have to reimplement that logic yourself.
-->
<p>イテレータパターンにより、一連の要素に順番に何らかの作業を行うことができます。イテレータは、
各要素を繰り返し、シーケンスが終わったことを決定するロジックの責任を負います。イテレータを使用すると、
自身でそのロジックを再実装する必要がなくなるのです。</p>
<!--
In Rust, iterators are *lazy*, meaning they have no effect until you call
methods that consume the iterator to use it up. For example, the code in
Listing 13-13 creates an iterator over the items in the vector `v1` by calling
the `iter` method defined on `Vec<T>`. This code by itself doesn’t do anything
useful.
-->
<p>Rustにおいて、イテレータは<em>怠惰</em>です。つまり、イテレータを使い込んで消費するメソッドを呼ぶまで何の効果もないということです。
例えば、リスト13-13のコードは、<code>Vec&lt;T&gt;</code>に定義された<code>iter</code>メソッドを呼ぶことで<code>v1</code>ベクタの要素に対するイテレータを生成しています。
このコード単独では、何も有用なことはしません。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-13: Creating an iterator</span>
-->
<p><span class="caption">リスト13-13: イテレータを生成する</span></p>
<!--
Once we’ve created an iterator, we can use it in a variety of ways. In Listing
3-5 in Chapter 3, we used iterators with `for` loops to execute some code on
each item, although we glossed over what the call to `iter` did until now.
-->
<p>一旦イテレータを生成したら、いろんな手段で使用することができます。第3章のリスト3-5では、
ここまで<code>iter</code>の呼び出しが何をするかごまかしてきましたが、<code>for</code>ループでイテレータを使い、
各要素に何かコードを実行しています。</p>
<!--
The example in Listing 13-14 separates the creation of the iterator from the
use of the iterator in the `for` loop. The iterator is stored in the `v1_iter`
variable, and no iteration takes place at that time. When the `for` loop is
called using the iterator in `v1_iter`, each element in the iterator is used in
one iteration of the loop, which prints out each value.
-->
<p>リスト13-14の例は、イテレータの生成と<code>for</code>ループでイテレータを使用することを区別しています。
イテレータは、<code>v1_iter</code>変数に保存され、その時には繰り返しは起きていません。<code>v1_iter</code>のイテレータで、
<code>for</code>ループが呼び出された時に、イテレータの各要素がループの繰り返しで使用され、各値が出力されます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    // {}でした
    println!(&quot;Got: {}&quot;, val);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-14: Using an iterator in a `for` loop
-->
<p><span class="caption">リスト13-14: <code>for</code>ループでイテレータを使用する</span></p>
<!--
In languages that don’t have iterators provided by their standard libraries,
you would likely write this same functionality by starting a variable at index
0, using that variable to index into the vector to get a value, and
incrementing the variable value in a loop until it reached the total number of
item in the vector.
-->
<p>標準ライブラリにより提供されるイテレータが存在しない言語では、変数を添え字0から始め、
その変数でベクタに添え字アクセスして値を得て、ベクタの総要素数に到達するまでループでその変数の値をインクリメントすることで、
この同じ機能を書く可能性が高いでしょう。</p>
<!--
Iterators handle all that logic for you, cutting down on repetitive code you
could potentially mess up. Iterators give you more flexibility to use the same
logic with many different kinds of sequences, not just data structures you can
index into, like vectors. Let’s examine how iterators do that.
-->
<p>イテレータはそのロジック全てを処理してくれるので、めちゃくちゃにしてしまう可能性のあるコードの繰り返しを減らしてくれます。
イテレータにより、添え字を使えるデータ構造、ベクタなどだけではなく、多くの異なるシーケンスに対して同じロジックを使う柔軟性も得られます。
イテレータがそれをする方法を調査しましょう。</p>
<!--
### The `Iterator` Trait and the `next` Method
-->
<h3 id="iteratorトレイトとnextメソッド"><a class="header" href="#iteratorトレイトとnextメソッド"><code>Iterator</code>トレイトと<code>next</code>メソッド</a></h3>
<!--
All iterators implement a trait named `Iterator` that is defined in the
standard library. The definition of the trait looks like this:
-->
<p>全てのイテレータは、標準ライブラリで定義されている<code>Iterator</code>というトレイトを実装しています。
このトレイトの定義は、以下のようになっています:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // デフォルト実装のあるメソッドは省略
    // methods with default implementations elided
}
<span class="boring">}
</span></code></pre></pre>
<!--
Notice this definition uses some new syntax: `type Item` and `Self::Item`,
which are defining an *associated type* with this trait. We’ll talk about
associated types in depth in Chapter 19. For now, all you need to know is that
this code says implementing the `Iterator` trait requires that you also define
an `Item` type, and this `Item` type is used in the return type of the `next`
method. In other words, the `Item` type will be the type returned from the
iterator.
-->
<p>この定義は新しい記法を使用していることに注目してください: <code>type Item</code>と<code>Self::Item</code>で、
これらはこのトレイトとの<em>関連型</em>(associated type)を定義しています。関連型についての詳細は、第19章で語ります。
とりあえず、知っておく必要があることは、このコードが<code>Iterator</code>トレイトを実装するには、<code>Item</code>型も定義する必要があり、
そして、この<code>Item</code>型が<code>next</code>メソッドの戻り値の型に使われていると述べていることです。換言すれば、
<code>Item</code>型がイテレータから返ってくる型になるだろうということです。</p>
<!--
The `Iterator` trait only requires implementors to define one method: the
`next` method, which returns one item of the iterator at a time wrapped in
`Some` and, when iteration is over, returns `None`.
-->
<p><code>Iterator</code>トレイトは、一つのメソッドを定義することを実装者に要求することだけします: <code>next</code>メソッドで、
これは1度に<code>Some</code>に包まれたイテレータの1要素を返し、繰り返しが終わったら、<code>None</code>を返します。</p>
<!--
We can call the `next` method on iterators directly; Listing 13-15 demonstrates
what values are returned from repeated calls to `next` on the iterator created
from the vector.
-->
<p>イテレータに対して直接<code>next</code>メソッドを呼び出すこともできます; リスト13-15は、
ベクタから生成されたイテレータの<code>next</code>を繰り返し呼び出した時にどんな値が返るかを模擬しています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;3));
    assert_eq!(v1_iter.next(), None);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-15: Calling the `next` method on an
iterator</span>
-->
<p><span class="caption">リスト13-15: イテレータに対して<code>next</code>メソッドを呼び出す</span></p>
<!--
Note that we needed to make `v1_iter` mutable: calling the `next` method on an
iterator changes internal state that the iterator uses to keep track of where
it is in the sequence. In other words, this code *consumes*, or uses up, the
iterator. Each call to `next` eats up an item from the iterator. We didn’t need
to make `v1_iter` mutable when we used a `for` loop because the loop took
ownership of `v1_iter` and made it mutable behind the scenes.
-->
<p><code>v1_iter</code>を可変にする必要があったことに注目してください: イテレータの<code>next</code>メソッドを呼び出すと、
今シーケンスのどこにいるかを追いかけるためにイテレータが使用している内部の状態が変わります。
つまり、このコードはイテレータを<em>消費</em>、または使い込むのです。
<code>next</code>の各呼び出しは、イテレータの要素を一つ、食います。<code>for</code>ループを使用した時には、
<code>v1_iter</code>を可変にする必要はありませんでした。というのも、ループが<code>v1_iter</code>の所有権を奪い、
陰で可変にしていたからです。</p>
<!--
Also note that the values we get from the calls to `next` are immutable
references to the values in the vector. The `iter` method produces an iterator
over immutable references. If we want to create an iterator that takes
ownership of `v1` and returns owned values, we can call `into_iter` instead of
`iter`. Similarly, if we want to iterate over mutable references, we can call
`iter_mut` instead of `iter`.
-->
<p>また、<code>next</code>の呼び出しで得られる値は、ベクタの値への不変な参照であることにも注目してください。
<code>iter</code>メソッドは、不変参照へのイテレータを生成します。<code>v1</code>の所有権を奪い、所有された値を返すイテレータを生成したいなら、
<code>iter</code>ではなく<code>into_iter</code>を呼び出すことができます。同様に、可変参照を繰り返したいなら、
<code>iter</code>ではなく<code>iter_mut</code>を呼び出せます。</p>
<!--
### Methods that Consume the Iterator
-->
<h3 id="イテレータを消費するメソッド"><a class="header" href="#イテレータを消費するメソッド">イテレータを消費するメソッド</a></h3>
<!--
The `Iterator` trait has a number of different methods with default
implementations provided by the standard library; you can find out about these
methods by looking in the standard library API documentation for the `Iterator`
trait. Some of these methods call the `next` method in their definition, which
is why we’re required to implement the `next` method when implementing the
`Iterator` trait.
-->
<p><code>Iterator</code>トレイトには、標準ライブラリが提供してくれているデフォルト実装のある多くの異なるメソッドがあります;
<code>Iterator</code>トレイトの標準ライブラリのAPIドキュメントを検索することで、これらのメソッドについて知ることができます。
これらのメソッドの中には、定義内で<code>next</code>メソッドを呼ぶものもあり、故に<code>Iterator</code>トレイトを実装する際には、
<code>next</code>メソッドを実装する必要があるのです。</p>
<!--
Methods that call `next` are called *consuming adaptors*, because calling them
uses up the iterator. One example is the `sum` method, which takes ownership of
the iterator and iterates through the items by repeatedly calling `next`, thus
consuming the iterator. As it iterates through, it adds each item to a running
total and returns the total when iteration is complete. Listing 13-16 has a
test illustrating a use of the `sum` method:
-->
<p><code>next</code>を呼び出すメソッドは、<em>消費アダプタ</em>(consuming adaptors)と呼ばれます。呼び出しがイテレータの使い込みになるからです。
一例は、<code>sum</code>メソッドで、これはイテレータの所有権を奪い、<code>next</code>を繰り返し呼び出すことで要素を繰り返し、
故にイテレータを消費するのです。繰り返しが進むごとに、各要素を一時的な合計に追加し、
繰り返しが完了したら、その合計を返します。リスト13-16は、<code>sum</code>の使用を説明したテストです:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-16: Calling the `sum` method to get the total
of all items in the iterator</span>
-->
<p><span class="caption">リスト13-16: <code>sum</code>メソッドを呼び出してイテレータの全要素の合計を得る</span></p>
<!--
We aren’t allowed to use `v1_iter` after the call to `sum` because `sum` takes
ownership of the iterator we call it on.
-->
<p><code>sum</code>は呼び出し対象のイテレータの所有権を奪うので、<code>sum</code>呼び出し後に<code>v1_iter</code>を使用することはできません。</p>
<!--
### Methods that Produce Other Iterators
-->
<h2 id="他のイテレータを生成するメソッド"><a class="header" href="#他のイテレータを生成するメソッド">他のイテレータを生成するメソッド</a></h2>
<!--
Other methods defined on the `Iterator` trait, known as *iterator adaptors*,
allow us to change iterators into different kind of iterators. You can chain
multiple calls to iterator adaptors to perform complex actions in a readable
way. But because all iterators are lazy, we have to call one of the consuming
adaptor methods to get results from calls to iterator adaptors.
-->
<p><code>Iterator</code>トレイトに定義された他のメソッドは、<em>イテレータアダプタ</em>(iterator adaptors)として知られていますが、
イテレータを別の種類のイテレータに変えさせてくれます。イテレータアダプタを複数回呼ぶ呼び出しを連結して、
複雑な動作を読みやすい形で行うことができます。ですが、全てのイテレータは怠惰なので、消費アダプタメソッドのどれかを呼び出し、
イテレータアダプタの呼び出しから結果を得なければなりません。</p>
<!--
Listing 13-17 shows an example of calling the iterator adaptor method `map`,
which takes a closure to call on each item to produce a new iterator. The
closure here creates a new iterator in which each item from the vector has been
incremented by 1. However, this code produces a warning:
-->
<p>リスト13-17は、イテレータアダプタメソッドの<code>map</code>の呼び出し例を示し、各要素に対して呼び出すクロージャを取り、
新しいイテレータを生成します。ここのクロージャは、ベクタの各要素が1インクリメントされる新しいイテレータを作成します。
ところが、このコードは警告を発します:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-17: Calling the iterator adaptor `map` to
create a new iterator</span>
-->
<p><span class="caption">リスト13-17: イテレータアダプタの<code>map</code>を呼び出して新規イテレータを作成する</span></p>
<!--
The warning we get is this:
-->
<p>出る警告は以下の通りです:</p>
<pre><code class="language-text">warning: unused `std::iter::Map` which must be used: iterator adaptors are lazy
and do nothing unless consumed
(警告: 使用されねばならない`std::iter::Map`が未使用です: イテレータアダプタは怠惰で、
消費されるまで何もしません)
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_must_use)] on by default
</code></pre>
<!--
The code in Listing 13-17 doesn’t do anything; the closure we’ve specified
never gets called. The warning reminds us why: iterator adaptors are lazy, and
we need to consume the iterator here.
-->
<p>リスト13-17のコードは何もしません; 指定したクロージャは、決して呼ばれないのです。警告が理由を思い出させてくれています:
イテレータアダプタは怠惰で、ここでイテレータを消費する必要があるのです。</p>
<!--
To fix this and consume the iterator, we’ll use the `collect` method, which we
used in Chapter 12 with `env::args` in Listing 12-1. This method consumes the
iterator and collects the resulting values into a collection data type.
-->
<p>これを修正し、イテレータを消費するには、<code>collect</code>メソッドを使用しますが、これは第12章のリスト12-1で<code>env::args</code>とともに使用しました。
このメソッドはイテレータを消費し、結果の値をコレクションデータ型に集結させます。</p>
<!--
In Listing 13-18, we collect the results of iterating over the iterator that’s
returned from the call to `map` into a vector. This vector will end up
containing each item from the original vector incremented by 1.
-->
<p>リスト13-18において、<code>map</code>呼び出しから返ってきたイテレータを繰り返した結果をベクタに集結させています。
このベクタは、最終的に元のベクタの各要素に1を足したものが含まれます。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-18: Calling the `map` method to create a new
iterator and then calling the `collect` method to consume the new iterator and
create a vector</span>
-->
<p><span class="caption">リスト13-18: <code>map</code>メソッドを呼び出して新規イテレータを作成し、
それから<code>collect</code>メソッドを呼び出してその新規イテレータを消費し、ベクタを生成する</span></p>
<!--
Because `map` takes a closure, we can specify any operation we want to perform
on each item. This is a great example of how closures let us customize some
behavior while reusing the iteration behavior that the `Iterator` trait
provides.
-->
<p><code>map</code>はクロージャを取るので、各要素に対して行いたいどんな処理も指定することができます。
これは、<code>Iterator</code>トレイトが提供する繰り返し動作を再利用しつつ、
クロージャにより一部の動作をカスタマイズできる好例になっています。</p>
<!--
### Using Closures that Capture Their Environment
-->
<h3 id="環境をキャプチャするクロージャを使用する"><a class="header" href="#環境をキャプチャするクロージャを使用する">環境をキャプチャするクロージャを使用する</a></h3>
<!--
Now that we’ve introduced iterators, we can demonstrate a common use of
closures that capture their environment by using the `filter` iterator adaptor.
The `filter` method on an iterator takes a closure that takes each item from
the iterator and returns a Boolean. If the closure returns `true`, the value
will be included in the iterator produced by `filter`. If the closure returns
`false`, the value won’t be included in the resulting iterator.
-->
<p>イテレータが出てきたので、<code>filter</code>イテレータアダプタを使って環境をキャプチャするクロージャの一般的な使用をデモすることができます。
イテレータの<code>filter</code>メソッドは、イテレータの各要素を取り、論理値を返すクロージャを取ります。
このクロージャが<code>true</code>を返せば、<code>filter</code>が生成するイテレータにその値が含まれます。クロージャが<code>false</code>を返したら、
結果のイテレータにその値は含まれません。</p>
<!--
In Listing 13-19 we use `filter` with a closure that captures the `shoe_size`
variable from its environment to iterate over a collection of `Shoe` struct
instances. It will return only shoes that are the specified size.
-->
<p>リスト13-19では、環境から<code>shoe_size</code>変数をキャプチャするクロージャで<code>filter</code>を使って、
<code>Shoe</code>構造体インスタンスのコレクションを繰り返しています。指定したサイズの靴だけを返すわけです。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
        Shoe { size: 13, style: String::from(&quot;sandal&quot;) },
        Shoe { size: 10, style: String::from(&quot;boot&quot;) },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
            Shoe { size: 10, style: String::from(&quot;boot&quot;) },
        ]
    );
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-19: Using the `filter` method with a closure
that captures `shoe_size`</span>
-->
<p><span class="caption">リスト13-19: <code>shoe_size</code>をキャプチャするクロージャで<code>filter</code>メソッドを使用する</span></p>
<!--
The `shoes_in_my_size` function takes ownership of a vector of shoes and a shoe
size as parameters. It returns a vector containing only shoes of the specified
size.
-->
<p><code>shoes_in_my_size</code>関数は、引数として靴のベクタとサイズの所有権を奪います。指定されたサイズの靴だけを含むベクタを返します。</p>
<!--
In the body of `shoes_in_my_size`, we call `into_iter` to create an iterator
that takes ownership of the vector. Then we call `filter` to adapt that
iterator into a new iterator that only contains elements for which the closure
returns `true`.
-->
<p><code>shoes_in_my_size</code>の本体で、<code>into_iter</code>を呼び出してベクタの所有権を奪うイテレータを作成しています。
そして、<code>filter</code>を呼び出してそのイテレータをクロージャが<code>true</code>を返した要素だけを含む新しいイテレータに適合させます。</p>
<!--
The closure captures the `shoe_size` parameter from the environment and
compares the value with each shoe’s size, keeping only shoes of the size
specified. Finally, calling `collect` gathers the values returned by the
adapted iterator into a vector that’s returned by the function.
-->
<p>クロージャは、環境から<code>shoe_size</code>引数をキャプチャし、指定されたサイズの靴だけを保持しながら、
その値を各靴のサイズと比較します。最後に、<code>collect</code>を呼び出すと、
関数により返ってきたベクタに適合させたイテレータから返ってきた値が集まるのです。</p>
<!--
The test shows that when we call `shoes_in_my_size`, we get back only shoes
that have the same size as the value we specified.
-->
<p><code>shoes_in_my_size</code>を呼び出した時に、指定した値と同じサイズの靴だけが得られることをテストは示しています。</p>
<!--
### Creating Our Own Iterators with `Iterator` Trait
-->
<h3 id="iteratorトレイトで独自のイテレータを作成する"><a class="header" href="#iteratorトレイトで独自のイテレータを作成する"><code>Iterator</code>トレイトで独自のイテレータを作成する</a></h3>
<!--
We’ve shown that you can create an iterator by calling `iter`, `into_iter`, or
`iter_mut` on a vector. You can create iterators from the other collection
types in the standard library, such as hash map. You can also create iterators
that do anything you want by implementing the `Iterator` trait on your own
types. As previously mentioned, the only method you’re required to provide a
definition for is the `next` method. Once you’ve done that, you can use all
other methods that have default implementations provided by the `Iterator`
trait!
-->
<p>ベクタに対し、<code>iter</code>、<code>into_iter</code>、<code>iter_mut</code>を呼び出すことでイテレータを作成できることを示してきました。
ハッシュマップなどの標準ライブラリの他のコレクション型からもイテレータを作成できます。
<code>Iterator</code>トレイトを自分で実装することで、したいことを何でもするイテレータを作成することもできます。
前述の通り、定義を提供する必要のある唯一のメソッドは、<code>next</code>メソッドなのです。一旦、そうしてしまえば、
<code>Iterator</code>トレイトが用意しているデフォルト実装のある他の全てのメソッドを使うことができるのです！</p>
<!--
To demonstrate, let’s create an iterator that will only ever count from 1 to 5.
First, we’ll create a struct to hold some values. Then we’ll make this struct
into an iterator by implementing the `Iterator` trait and use the values in
that implementation.
-->
<p>デモ用に、絶対に1から5をカウントするだけのイテレータを作成しましょう。まず、値を保持する構造体を生成し、
<code>Iterator</code>トレイトを実装することでこの構造体をイテレータにし、その実装内の値を使用します。</p>
<!--
Listing 13-20 has the definition of the `Counter` struct and an associated
`new` function to create instances of `Counter`:
-->
<p>リスト13-20は、<code>Counter</code>構造体と<code>Counter</code>のインスタンスを作る<code>new</code>関連関数の定義です:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-20: Defining the `Counter` struct and a `new`
function that creates instances of `Counter` with an initial value of 0 for
`count`</span>
-->
<p><span class="caption">リスト13-20: <code>Counter</code>構造体と<code>count</code>に対して0という初期値で<code>Counter</code>のインスタンスを作る<code>new</code>関数を定義する</span></p>
<!--
The `Counter` struct has one field named `count`. This field holds a `u32`
value that will keep track of where we are in the process of iterating from 1
to 5. The `count` field is private because we want the implementation of
`Counter` to manage its value. The `new` function enforces the behavior of
always starting new instances with a value of 0 in the `count` field.
-->
<p><code>Counter</code>構造体には、<code>count</code>というフィールドがあります。このフィールドは、
1から5までの繰り返しのどこにいるかを追いかける<code>u32</code>値を保持しています。<code>Counter</code>の実装にその値を管理してほしいので、
<code>count</code>フィールドは非公開です。<code>count</code>フィールドは常に0という値から新規インスタンスを開始するという動作を<code>new</code>関数は強要します。</p>
<!--
Next, we’ll implement the `Iterator` trait for our `Counter` type by defining
the body of the `next` method to specify what we want to happen when this
iterator is used, as shown in Listing 13-21:
-->
<p>次に、<code>next</code>メソッドの本体をこのイテレータが使用された際に起きてほしいことを指定するように定義して、
<code>Counter</code>型に対して<code>Iterator</code>トレイトを実装します。リスト13-21のようにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;

        if self.count &lt; 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-21: Implementing the `Iterator` trait on our
`Counter` struct</span>
-->
<p><span class="caption">リスト13-21: <code>Counter</code>構造体に<code>Iterator</code>トレイトを実装する</span></p>
<!--
We set the associated `Item` type for our iterator to `u32`, meaning the
iterator will return `u32` values. Again, don’t worry about associated types
yet, we’ll cover them in Chapter 19.
-->
<p>イテレータの<code>Item</code>関連型を<code>u32</code>に設定しました。つまり、イテレータは、<code>u32</code>の値を返します。
ここでも、まだ関連型について心配しないでください。第19章で講義します。</p>
<!--
We want our iterator to add 1 to the current state, so we initialized `count`
to 0 so it would return 1 first. If the value of `count` is less than 6, `next`
will return the current value wrapped in `Some`, but if `count` is 6 or higher,
our iterator will return `None`.
-->
<p>イテレータに現在の状態に1を足してほしいので、まず1を返すように<code>count</code>を0に初期化しました。
<code>count</code>の値が5以下なら、<code>next</code>は<code>Some</code>に包まれた現在の値を返しますが、
<code>count</code>が6以上なら、イテレータは<code>None</code>を返します。</p>
<!--
#### Using Our `Counter` Iterator’s `next` Method
-->
<h4 id="counterイテレータのnextメソッドを使用する"><a class="header" href="#counterイテレータのnextメソッドを使用する"><code>Counter</code>イテレータの<code>next</code>メソッドを使用する</a></h4>
<!--
Once we’ve implemented the `Iterator` trait, we have an iterator! Listing 13-22
shows a test demonstrating that we can use the iterator functionality of our
`Counter` struct by calling the `next` method on it directly, just as we did
with the iterator created from a vector in Listing 13-15.
-->
<p>一旦<code>Iterator</code>トレイトを実装し終わったら、イテレータの出来上がりです！リスト13-22は、
リスト13-15のベクタから生成したイテレータと全く同様に、直接<code>next</code>メソッドを呼び出すことで、
<code>Counter</code>構造体のイテレータ機能を使用できることをデモするテストを示しています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Counter {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        self.count += 1;
</span><span class="boring">
</span><span class="boring">        if self.count &lt; 6 {
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-22: Testing the functionality of the `next`
method implementation</span>
-->
<p><span class="caption">リスト13-22: <code>next</code>メソッド実装の機能をテストする</span></p>
<!--
This test creates a new `Counter` instance in the `counter` variable and then
calls `next` repeatedly, verifying that we have implemented the behavior we
want this iterator to have: returning the values from 1 to 5.
-->
<p>このテストは、<code>counter</code>変数に新しい<code>Counter</code>インスタンスを生成し、
それからイテレータにほしい動作が実装し終わっていることを実証しながら、<code>next</code>を繰り返し呼び出しています:
1から5の値を返すことです。</p>
<!--
#### Using Other `Iterator` Trait Methods
-->
<h4 id="他のiteratorトレイトメソッドを使用する"><a class="header" href="#他のiteratorトレイトメソッドを使用する">他の<code>Iterator</code>トレイトメソッドを使用する</a></h4>
<!--
We implemented the `Iterator` trait by defining the `next` method, so we
can now use any `Iterator` trait method’s default implementations as defined in
the standard library, because they all use the `next` method’s functionality.
-->
<p><code>next</code>メソッドを定義して<code>Iterator</code>トレイトを実装したので、今では、標準ライブラリで定義されているように、
どんな<code>Iterator</code>トレイトメソッドのデフォルト実装も使えるようになりました。全て<code>next</code>メソッドの機能を使っているからです。</p>
<!--
For example, if for some reason we wanted to take the values produced by an
instance of `Counter`, pair them with values produced by another `Counter`
instance after skipping the first value, multiply each pair together, keep only
those results that are divisible by 3, and add all the resulting values
together, we could do so, as shown in the test in Listing 13-23:
-->
<p>例えば、何らかの理由で、<code>Counter</code>インスタンスが生成する値を取り、最初の値を飛ばしてから、
別の<code>Counter</code>インスタンスが生成する値と一組にし、各ペアを掛け算し、3で割り切れる結果だけを残し、
全結果の値を足し合わせたくなったら、リスト13-23のテストに示したように、そうすることができます:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<!--
check to seeは畳語だが、いい訳はあるだろうか
-->
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Counter {
</span><span class="boring">    // このイテレータはu32を生成します
</span><span class="boring">    // Our iterator will produce u32s
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        // カウントをインクリメントする。故に0から始まる
</span><span class="boring">        // increment our count. This is why we started at zero.
</span><span class="boring">        self.count += 1;
</span><span class="boring">
</span><span class="boring">        // カウントが終わったかどうか確認する
</span><span class="boring">        // check to see if we've finished counting or not.
</span><span class="boring">        if self.count &lt; 6 {
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 13-23: Using a variety of `Iterator` trait
methods on our `Counter` iterator</span>
-->
<p><span class="caption">リスト13-23: <code>Counter</code>イテレータに対していろんな<code>Iterator</code>トレイトのメソッドを使用する</span></p>
<!--
Note that `zip` produces only four pairs; the theoretical fifth pair `(5,
None)` is never produced because `zip` returns `None` when either of its input
iterators return `None`.
-->
<p><code>zip</code>は4組しか生成しないことに注意してください; 理論的な5番目の組の<code>(5, None)</code>は、
入力イテレータのどちらかが<code>None</code>を返したら、<code>zip</code>は<code>None</code>を返却するため、決して生成されることはありません。</p>
<!--
All of these method calls are possible because we specified how the `next`
method works, and the standard library provides default implementations for
other methods that call `next`.
-->
<p><code>next</code>メソッドの動作方法を指定し、標準ライブラリが<code>next</code>を呼び出す他のメソッドにデフォルト実装を提供しているので、
これらのメソッド呼び出しは全て可能です。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Improving Our I/O Project
-->
<h2 id="入出力プロジェクトを改善する"><a class="header" href="#入出力プロジェクトを改善する">入出力プロジェクトを改善する</a></h2>
<!--
ここでは、withを条件のように訳している。(今まではなかったのに、)今はある状態で -> ...があればという意訳である
やはりwithは状態を表すだけなので、強すぎる気がしなくもない
-->
<!--
With this new knowledge about iterators, we can improve the I/O project in
Chapter 12 by using iterators to make places in the code clearer and more
concise. Let’s look at how iterators can improve our implementation of the
`Config::new` function and the `search` function.
-->
<p>このイテレータに関する新しい知識があれば、イテレータを使用してコードのいろんな場所をより明確で簡潔にすることで、
第12章の入出力プロジェクトを改善することができます。イテレータが<code>Config::new</code>関数と<code>search</code>関数の実装を改善する方法に目を向けましょう。</p>
<!--
### Removing a `clone` Using an Iterator
-->
<h3 id="イテレータを使用してcloneを取り除く"><a class="header" href="#イテレータを使用してcloneを取り除く">イテレータを使用して<code>clone</code>を取り除く</a></h3>
<!--
In Listing 12-6, we added code that took a slice of `String` values and created
an instance of the `Config` struct by indexing into the slice and cloning the
values, allowing the `Config` struct to own those values. In Listing 13-24,
we’ve reproduced the implementation of the `Config::new` function as it was in
Listing 12-23:
-->
<p>リスト12-6において、スライスに添え字アクセスして値をクローンすることで、<code>Config</code>構造体に値を所有させながら、
<code>String</code>値のスライスを取り、<code>Config</code>構造体のインスタンスを作るコードを追記しました。リスト13-24では、
リスト12-23のような<code>Config::new</code>の実装を再現しました:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
</code></pre>
<!--
<span class="caption">Listing 13-24: Reproduction of the `Config::new` function
from Listing 12-23</span>
-->
<p><span class="caption">リスト13-24: リスト12-23から<code>Config::new</code>関数の再現</span></p>
<!--
At the time, we said not to worry about the inefficient `clone` calls because
we would remove them in the future. Well, that time is now!
-->
<p>その際、将来的に除去する予定なので、非効率的な<code>clone</code>呼び出しを憂慮するなと述べました。
えっと、その時は今です！</p>
<!--
We needed `clone` here because we have a slice with `String` elements in the
parameter `args`, but the `new` function doesn’t own `args`. To return
ownership of a `Config` instance, we had to clone the values from the `query`
and `filename` fields of `Config` so the `Config` instance can own its values.
-->
<p>引数<code>args</code>に<code>String</code>要素のスライスがあるためにここで<code>clone</code>が必要だったのですが、
<code>new</code>関数は<code>args</code>を所有していません。<code>Config</code>インスタンスの所有権を返すためには、
<code>Config</code>インスタンスがその値を所有できるように、<code>Config</code>の<code>query</code>と<code>filename</code>フィールドから値をクローンしなければなりませんでした。</p>
<!--
ここも節冒頭と同様。やはり強すぎるか？
-->
<!--
With our new knowledge about iterators, we can change the `new` function to
take ownership of an iterator as its argument instead of borrowing a slice.
We’ll use the iterator functionality instead of the code that checks the length
of the slice and indexes into specific locations. This will clarify what the
`Config::new` function is doing because the iterator will access the values.
-->
<p>イテレータについての新しい知識があれば、<code>new</code>関数をスライスを借用する代わりに、
引数としてイテレータの所有権を奪うように変更することができます。スライスの長さを確認し、
特定の場所に添え字アクセスするコードの代わりにイテレータの機能を使います。これにより、
イテレータは値にアクセスするので、<code>Config::new</code>関数がすることが明確化します。</p>
<!--
Once `Config::new` takes ownership of the iterator and stops using indexing
operations that borrow, we can move the `String` values from the iterator into
`Config` rather than calling `clone` and making a new allocation.
-->
<p>ひとたび、<code>Config::new</code>がイテレータの所有権を奪い、借用する添え字アクセス処理をやめたら、
<code>clone</code>を呼び出して新しくメモリ確保するのではなく、イテレータからの<code>String</code>値を<code>Config</code>にムーブできます。</p>
<!--
#### Using the Returned Iterator Directly
-->
<h4 id="返却されるイテレータを直接使う"><a class="header" href="#返却されるイテレータを直接使う">返却されるイテレータを直接使う</a></h4>
<!--
Open your I/O project’s *src/main.rs* file, which should look like this:
-->
<p>入出力プロジェクトの<em>src/main.rs</em>ファイルを開いてください。こんな見た目のはずです:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
}
</code></pre>
<!--
We’ll change the start of the `main` function that we had in Listing 12-24 to
the code in Listing 13-25. This won’t compile until we update `Config::new` as
well.
-->
<p>リスト12-24のような<code>main</code>関数の冒頭をリスト13-25のコードに変更します。
これは、<code>Config::new</code>も更新するまでコンパイルできません。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
}
</code></pre>
<!--
<span class="caption">Listing 13-25: Passing the return value of `env::args` to
`Config::new`</span>
-->
<p><span class="caption">リスト13-25: <code>env::args</code>の戻り値を<code>Config::new</code>に渡す</span></p>
<!--
The `env::args` function returns an iterator! Rather than collecting the
iterator values into a vector and then passing a slice to `Config::new`, now
we’re passing ownership of the iterator returned from `env::args` to
`Config::new` directly.
-->
<p><code>env::args</code>関数は、イテレータを返します！イテレータの値をベクタに集結させ、それからスライスを<code>Config::new</code>に渡すのではなく、
今では<code>env::args</code>から返ってくるイテレータの所有権を直接<code>Config::new</code>に渡しています。</p>
<!--
Next, we need to update the definition of `Config::new`. In your I/O project’s
*src/lib.rs* file, let’s change the signature of `Config::new` to look like
Listing 13-26. This still won’t compile because we need to update the function
body.
-->
<p>次に、<code>Config::new</code>の定義を更新する必要があります。入出力プロジェクトの<em>src/lib.rs</em>ファイルで、
<code>Config::new</code>のシグニチャをリスト13-26のように変えましょう。関数本体を更新する必要があるので、
それでもコンパイルはできません。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
</code></pre>
<!--
<span class="caption">Listing 13-26: Updating the signature of `Config::new` to
expect an iterator</span>
-->
<p><span class="caption">リスト13-26: <code>Config::new</code>のシグニチャをイテレータを期待するように更新する</span></p>
<!--
The standard library documentation for the `env::args` function shows that the
type of the iterator it returns is `std::env::Args`. We’ve updated the
signature of the `Config::new` function so the parameter `args` has the type
`std::env::Args` instead of `&[String]`. Because we’re taking ownership of
`args` and we’ll be mutating `args` by iterating over it, we can add the `mut`
keyword into the specification of the `args` parameter to make it mutable.
-->
<p><code>env::args</code>関数の標準ライブラリドキュメントは、自身が返すイテレータの型は、<code>std::env::Args</code>であると表示しています。
<code>Config::new</code>関数のシグニチャを更新したので、引数<code>args</code>の型は、<code>&amp;[String]</code>ではなく、
<code>std::env::Args</code>になりました。<code>args</code>の所有権を奪い、繰り返しを行うことで<code>args</code>を可変化する予定なので、
<code>args</code>引数の仕様に<code>mut</code>キーワードを追記でき、可変にします。</p>
<!--
#### Using `Iterator` Trait Methods Instead of Indexing
-->
<h4 id="添え字の代わりにiteratorトレイトのメソッドを使用する"><a class="header" href="#添え字の代わりにiteratorトレイトのメソッドを使用する">添え字の代わりに<code>Iterator</code>トレイトのメソッドを使用する</a></h4>
<!--
Next, we’ll fix the body of `Config::new`. The standard library documentation
also mentions that `std::env::Args` implements the `Iterator` trait, so we know
we can call the `next` method on it! Listing 13-27 updates the code from
Listing 12-23 to use the `next` method:
-->
<p>次に、<code>Config::new</code>の本体を修正しましょう。標準ライブラリのドキュメントは、
<code>std::env::Args</code>が<code>Iterator</code>トレイトを実装していることにも言及しているので、
それに対して<code>next</code>メソッドを呼び出せることがわかります！リスト13-27は、
リスト12-23のコードを<code>next</code>メソッドを使用するように更新したものです:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span><span class="boring">use std::env;
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">    case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            // クエリ文字列を取得しませんでした
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            // ファイル名を取得しませんでした
            None =&gt; return Err(&quot;Didn't get a file name&quot;),
        };

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 13-27: Changing the body of `Config::new` to use
iterator methods</span>
-->
<p><span class="caption">リスト13-27: <code>Config::new</code>の本体をイテレータメソッドを使うように変更する</span></p>
<!--
6行目真ん中のandを順接の理由で訳している。
-->
<!--
Remember that the first value in the return value of `env::args` is the name of
the program. We want to ignore that and get to the next value, so first we call
`next` and do nothing with the return value. Second, we call `next` to get the
value we want to put in the `query` field of `Config`. If `next` returns a
`Some`, we use a `match` to extract the value. If it returns `None`, it means
not enough arguments were given and we return early with an `Err` value. We do
the same thing for the `filename` value.
-->
<p><code>env::args</code>の戻り値の1番目の値は、プログラム名であることを思い出してください。それは無視し、
次の値を取得したいので、まず<code>next</code>を呼び出し、戻り値に対して何もしません。2番目に、
<code>next</code>を呼び出して<code>Config</code>の<code>query</code>フィールドに置きたい値を得ます。<code>next</code>が<code>Some</code>を返したら、
<code>match</code>を使用してその値を抜き出します。<code>None</code>を返したら、十分な引数が与えられなかったということなので、
<code>Err</code>値で早期リターンします。<code>filename</code>値に対しても同じことをします。</p>
<!--
### Making Code Clearer with Iterator Adaptors
-->
<h3 id="イテレータアダプタでコードをより明確にする"><a class="header" href="#イテレータアダプタでコードをより明確にする">イテレータアダプタでコードをより明確にする</a></h3>
<!--
We can also take advantage of iterators in the `search` function in our I/O
project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:
-->
<p>入出力プロジェクトの<code>search</code>関数でも、イテレータを活用することができます。その関数はリスト12-19に示していますが、以下のリスト13-28に再掲します。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<!--
<span class="caption">Listing 13-28: The implementation of the `search`
function from Listing 12-19</span>
-->
<p><span class="caption">リスト13-28: リスト12-19の<code>search</code>関数の実装</span></p>
<!--
We can write this code in a more concise way using iterator adaptor methods.
Doing so also lets us avoid having a mutable intermediate `results` vector. The
functional programming style prefers to minimize the amount of mutable state to
make code clearer. Removing the mutable state might enable a future enhancement
to make searching happen in parallel, because we wouldn’t have to manage
concurrent access to the `results` vector. Listing 13-29 shows this change:
-->
<p>イテレータアダプタメソッドを使用して、このコードをもっと簡潔に書くことができます。そうすれば、
可変な中間の<code>results</code>ベクタをなくすこともできます。関数型プログラミングスタイルは、可変な状態の量を最小化することを好み、
コードを明瞭化します。可変な状態を除去すると、検索を同時並行に行うという将来的な改善をするのが、
可能になる可能性があります。なぜなら、<code>results</code>ベクタへの同時アクセスを管理する必要がなくなるからです。
リスト13-29は、この変更を示しています:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents.lines()
        .filter(|line| line.contains(query))
        .collect()
}
</code></pre>
<!--
<span class="caption">Listing 13-29: Using iterator adaptor methods in the
implementation of the `search` function</span>
-->
<p><span class="caption">リスト13-29: <code>search</code>関数の実装でイテレータアダプタのメソッドを使用する</span></p>
<!--
Recall that the purpose of the `search` function is to return all lines in
`contents` that contain the `query`. Similar to the `filter` example in Listing
13-19, this code uses the `filter` adaptor to keep only the lines that
`line.contains(query)` returns true for. We then collect the matching lines
into another vector with `collect`. Much simpler! Feel free to make the same
change to use iterator methods in the `search_case_insensitive` function as
well.
-->
<p><code>search</code>関数の目的は、<code>query</code>を含む<code>contents</code>の行全てを返すことであることを思い出してください。
リスト13-19の<code>filter</code>例に酷似して、このコードは<code>filter</code>アダプタを使用して<code>line.contains(query)</code>が真を返す行だけを残すことができます。
それから、合致した行を別のベクタに<code>collect</code>で集結させます。ずっと単純です！ご自由に、
同じ変更を行い、<code>search_case_insensitive</code>関数でもイテレータメソッドを使うようにしてください。</p>
<!--
The next logical question is which style you should choose in your own code and
why: the original implementation in Listing 13-28 or the version using
iterators in Listing 13-29. Most Rust programmers prefer to use the iterator
style. It’s a bit tougher to get the hang of at first, but once you get a feel
for the various iterator adaptors and what they do, iterators can be easier to
understand. Instead of fiddling with the various bits of looping and building
new vectors, the code focuses on the high-level objective of the loop. This
abstracts away some of the commonplace code so it’s easier to see the concepts
that are unique to this code, such as the filtering condition each element in
the iterator must pass.
-->
<p>次の論理的な疑問は、自身のコードでどちらのスタイルを選ぶかと理由です: リスト13-28の元の実装とリスト13-29のイテレータを使用するバージョンです。
多くのRustプログラマは、イテレータスタイルを好みます。とっかかりが少し困難ですが、
いろんなイテレータアダプタとそれがすることの感覚を一度掴めれば、イテレータの方が理解しやすいこともあります。
いろんなループを少しずつもてあそんだり、新しいベクタを構築する代わりに、コードは、ループの高難度の目的に集中できるのです。
これは、ありふれたコードの一部を抽象化するので、イテレータの各要素が通過しなければならないふるい条件など、
このコードに独特の概念を理解しやすくなります。</p>
<!--
But are the two implementations truly equivalent? The intuitive assumption
might be that the more low-level loop will be faster. Let’s talk about
performance.
-->
<p>ですが、本当に2つの実装は等価なのでしょうか？直観的な仮説は、より低レベルのループの方がより高速ということかもしれません。
パフォーマンスに触れましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Comparing Performance: Loops vs. Iterators
-->
<h2 id="パフォーマンス比較-ループvsイテレータ"><a class="header" href="#パフォーマンス比較-ループvsイテレータ">パフォーマンス比較: ループVSイテレータ</a></h2>
<!--
To determine whether to use loops or iterators, you need to know which version
of our `search` functions is faster: the version with an explicit `for` loop or
the version with iterators.
-->
<p>ループを使うべきかイテレータを使うべきか決定するために、<code>search</code>関数のうち、どちらのバージョンが速いか知る必要があります:
明示的な<code>for</code>ループがあるバージョンと、イテレータのバージョンです。</p>
<!--
We ran a benchmark by loading the entire contents of *The Adventures of
Sherlock Holmes* by Sir Arthur Conan Doyle into a `String` and looking for the
word *the* in the contents. Here are the results of the benchmark on the
version of `search` using the `for` loop and the version using iterators:
-->
<p>サー・アーサー・コナン・ドイル(Sir Arthur Conan Doyle)の、
<em>シャーロックホームズの冒険</em>(The Adventures of Sherlock Homes)全体を<code>String</code>に読み込み、
そのコンテンツで<em>the</em>という単語を検索することでベンチマークを行いました。
こちらが、<code>for</code>を使用した<code>search</code>関数のバージョンと、イテレータを使用したバージョンに関するベンチマーク結果です。</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<!--
The iterator version was slightly faster! We won’t explain the benchmark code
here, because the point is not to prove that the two versions are equivalent
but to get a general sense of how these two implementations compare
performance-wise.
-->
<p>イテレータバージョンの方が<ruby>些<rp>(</rp><rt>いささ</rt><rp>)</rp></ruby>か高速ですね！ここでは、ベンチマークのコードは説明しません。
なぜなら、要点は、2つのバージョンが等価であることを証明することではなく、
これら2つの実装がパフォーマンス的にどう比較されるかを大まかに把握することだからです。</p>
<!--
For a more comprehensive benchmark, you should check various texts of
various sizes as the `contents`, different words and words of different lengths
as the `query`, and all kinds of other variations. The point is this:
iterators, although a high-level abstraction, get compiled down to roughly the
same code as if you’d written the lower-level code yourself. Iterators are one
of Rust’s *zero-cost abstractions*, by which we mean using the abstraction
imposes no additional runtime overhead. This is analogous to how Bjarne
Stroustrup, the original designer and implementor of C++, defines
*zero-overhead* in “Foundations of C++” (2012):
-->
<p>より包括的なベンチマークとするためには、いろんなサイズの様々なテキストを<code>contents</code>として、異なる単語、異なる長さの単語を<code>query</code>として、
他のあらゆる種類のバリエーションを確認するべきです。重要なのは: イテレータは、
高度な抽象化にも関わらず、低レベルのコードを自身で書いているかのように、ほぼ同じコードにコンパイルされることです。
イテレータは、Rustの<em>ゼロコスト抽象化</em>の一つであり、これは、抽象化を使うことが追加の実行時オーバーヘッドを生まないことを意味しています。
このことは、C++の元の設計者であり実装者のビャーネ・ストロヴストルップ(Bjarne Stroustrup)が、
<em>ゼロオーバーヘッド</em>を「C++の基礎(2012)」で定義したのと類似しています。</p>
<!--
> In general, C++ implementations obey the zero-overhead principle: What you
> don’t use, you don’t pay for. And further: What you do use, you couldn’t hand
> code any better.
-->
<blockquote>
<p>一般的に、C++の実装は、ゼロオーバーヘッド原則を遵守します: 使用しないものには、支払わなくてよい。
さらに: 実際に使っているものに対して、コードをそれ以上うまく渡すことはできない。</p>
</blockquote>
<!--
As another example, the following code is taken from an audio decoder. The
decoding algorithm uses the linear prediction mathematical operation to
estimate future values based on a linear function of the previous samples. This
code uses an iterator chain to do some math on three variables in scope: a
`buffer` slice of data, an array of 12 `coefficients`, and an amount by which
to shift data in `qlp_shift`. We’ve declared the variables within this example
but not given them any values; although this code doesn’t have much meaning
outside of its context, it’s still a concise, real-world example of how Rust
translates high-level ideas to low-level code:
-->
<p>別の例として、以下のコードは、オーディオデコーダから取ってきました。デコードアルゴリズムは、
線形予測数学演算を使用して、以前のサンプルの線形関数に基づいて未来の値を予測します。このコードは、
イテレータ連結をしてスコープにある3つの変数に計算を行っています: <code>buffer</code>というデータのスライス、
12の<code>coefficients</code>(係数)の配列、<code>qlp_shift</code>でデータをシフトする量です。この例の中で変数を宣言しましたが、
値は与えていません; このコードは、文脈の外では大して意味を持ちませんが、
それでもRustが高レベルな考えを低レベルなコードに翻訳する簡潔で現実的な例になっています:</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
</code></pre>
<!--
To calculate the value of `prediction`, this code iterates through each of the
12 values in `coefficients` and uses the `zip` method to pair the coefficient
values with the previous 12 values in `buffer`. Then, for each pair, we
multiply the values together, sum all the results, and shift the bits in the
sum `qlp_shift` bits to the right.
-->
<p><code>prediction</code>の値を算出するために、このコードは、<code>coefficients</code>の12の値を繰り返し、<code>zip</code>メソッドを使用して、
係数値を前の<code>buffer</code>の12の値と組にします。それから各組について、その値をかけ合わせ、結果を全て合計し、
合計のビットを<code>qlp_shift</code>ビット分だけ右にシフトさせます。</p>
<!--
Calculations in applications like audio decoders often prioritize performance
most highly. Here, we’re creating an iterator, using two adaptors, and then
consuming the value. What assembly code would this Rust code compile to? Well,
as of this writing, it compiles down to the same assembly you’d write by hand.
There’s no loop at all corresponding to the iteration over the values in
`coefficients`: Rust knows that there are 12 iterations, so it “unrolls” the
loop. *Unrolling* is an optimization that removes the overhead of the loop
controlling code and instead generates repetitive code for each iteration of
the loop.
-->
<p>オーディオデコーダのようなアプリケーションの計算は、しばしばパフォーマンスに最も重きを置きます。
ここでは、イテレータを作成し、2つのアダプタを使用し、それから値を消費しています。
このRustコードは、どんな機械語コードにコンパイルされるのでしょうか？えー、執筆時点では、
手作業で書いたものと同じ機械語にコンパイルされます。<code>coefficients</code>の値の繰り返しに対応するループは全く存在しません:
コンパイラは、12回繰り返しがあることを把握しているので、ループを「展開」します。
<em>ループの展開</em>は、ループ制御コードのオーバーヘッドを除去し、代わりにループの繰り返しごとに同じコードを生成する最適化です。</p>
<!--
All of the coefficients get stored in registers, which means accessing the
values is very fast. There are no bounds checks on the array access at runtime.
All these optimizations that Rust is able to apply make the resulting code
extremely efficient. Now that you know this, you can use iterators and closures
without fear! They make code seem like it’s higher level but don’t impose a
runtime performance penalty for doing so.
-->
<p>係数は全てレジスタに保存されます。つまり、値に非常に高速にアクセスします。実行時に配列の境界チェックをすることもありません。
コンパイラが適用可能なこれらの最適化全てにより、結果のコードは究極的に効率化されます。このことがわかったので、
もうイテレータとクロージャを恐れなしに使用することができますね！それらのおかげでコードは、高レベルだけれども、
そうすることに対して実行時のパフォーマンスを犠牲にしないようになります。</p>
<!--
## Summary
-->
<h2 id="まとめ-12"><a class="header" href="#まとめ-12">まとめ</a></h2>
<!--
Closures and iterators are Rust features inspired by functional programming
language ideas. They contribute to Rust’s capability to clearly express
high-level ideas at low-level performance. The implementations of closures and
iterators are such that runtime performance is not affected. This is part of
Rust’s goal to strive to provide zero-cost abstractions.
-->
<p>クロージャとイテレータは、関数型言語の考えに着想を得たRustの機能です。低レベルのパフォーマンスで、
高レベルの考えを明確に表現するというRustの能力に貢献しています。クロージャとイテレータの実装は、
実行時のパフォーマンスが影響されないようなものです。これは、ゼロ代償抽象化を提供するのに努力を惜しまないRustの目標の一部です。</p>
<!--
Now that we’ve improved the expressiveness of our I/O project, let’s look at
some more features of `cargo` that will help us share the project with the
world.
-->
<p>今や入出力プロジェクトの表現力を改善したので、プロジェクトを世界と共有するのに役に立つ<code>cargo</code>の機能にもっと目を向けましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# More About Cargo and Crates.io
-->
<h1 id="cargoとcratesioについてより詳しく"><a class="header" href="#cargoとcratesioについてより詳しく">CargoとCrates.ioについてより詳しく</a></h1>
<!--
So far we’ve used only the most basic features of Cargo to build, run, and test
our code, but it can do a lot more. In this chapter, we’ll discuss some of its
other, more advanced features to show you how to do the following:
-->
<p>今までCargoのビルド、実行、コードのテストを行うという最も基礎的な機能のみを使ってきましたが、
他にもできることはたくさんあります。この章では、そのような他のより高度な機能の一部を議論し、
以下のことをする方法をお見せしましょう:</p>
<!--
* Customize your build through release profiles
* Publish libraries on [crates.io](https://crates.io)
* Organize large projects with workspaces
* Install binaries from [crates.io](https://crates.io)
* Extend Cargo using custom commands
-->
<ul>
<li>リリースプロファイルでビルドをカスタマイズする</li>
<li><a href="https://crates.io">crates.io</a>でライブラリを公開する</li>
<li>ワークスペースで巨大なプロジェクトを体系化する</li>
<li><a href="https://crates.io">crates.io</a>からバイナリをインストールする</li>
<li>独自のコマンドを使用してCargoを拡張する</li>
</ul>
<!--
Cargo can do even more than what we cover in this chapter, so for a full
explanation of all its features, see [its
documentation](https://doc.rust-lang.org/cargo/).
-->
<p>また、Cargoはこの章で講義する以上のこともできるので、機能の全解説を見るには、
<a href="https://doc.rust-lang.org/cargo/">ドキュメンテーション</a>を参照されたし。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Customizing Builds with Release Profiles
-->
<h2 id="リリースプロファイルでビルドをカスタマイズする"><a class="header" href="#リリースプロファイルでビルドをカスタマイズする">リリースプロファイルでビルドをカスタマイズする</a></h2>
<!--
In Rust, *release profiles* are predefined and customizable profiles with
different configurations that allow a programmer to have more control over
various options for compiling code. Each profile is configured independently of
the others.
-->
<p>Rustにおいて、<em>リリースプロファイル</em>とは、プログラマがコードのコンパイルオプションについてより制御可能にしてくれる、
定義済みのカスタマイズ可能なプロファイルです。各プロファイルは、それぞれ独立して設定されます。</p>
<!--
Cargo has two main profiles: the `dev` profile Cargo uses when you run `cargo
build` and the `release` profile Cargo uses when you run `cargo build
--release`. The `dev` profile is defined with good defaults for development,
and the `release` profile has good defaults for release builds.
-->
<p>Cargoには2つの主なプロファイルが存在します: <code>dev</code>プロファイルは、<code>cargo build</code>コマンドを実行したときに使用され、
<code>release</code>プロファイルは、<code>cargo build --release</code>コマンドを実行したときに使用されます。
<code>dev</code>プロファイルは、開発中に役に立つデフォルト設定がなされており、<code>release</code>プロファイルは、
リリース用の設定がなされています。</p>
<!--
These profile names might be familiar from the output of your builds:
-->
<p>これらのプロファイル名は、ビルドの出力で馴染みのある可能性があります:</p>
<pre><code class="language-text">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
$ cargo build --release
    Finished release [optimized] target(s) in 0.0 secs
</code></pre>
<!--
The `dev` and `release` shown in this build output indicate that the compiler
is using different profiles.
-->
<p>このビルド出力で表示されている<code>dev</code>と<code>release</code>は、コンパイラが異なるプロファイルを使用していることを示しています。</p>
<!--
Cargo has default settings for each of the profiles that apply when there
aren’t any `[profile.*]` sections in the project’s *Cargo.toml* file. By adding
`[profile.*]` sections for any profile you want to customize, you can override
any subset of the default settings. For example, here are the default values
for the `opt-level` setting for the `dev` and `release` profiles:
-->
<p>プロジェクトの<em>Cargo.toml</em>ファイルに<code>[profile.*]</code>セクションが存在しない際に適用される各プロファイル用のデフォルト設定が、
Cargoには存在します。カスタマイズしたいプロファイル用の<code>[profile.*]</code>セクションを追加することで、
デフォルト設定の一部を上書きすることができます。例えば、こちらが<code>dev</code>と<code>release</code>プロファイルの<code>opt-level</code>設定のデフォルト値です:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<!--
4行目最後、唯一の理由と言っているのは、the reasonになっているから
-->
<!--
The `opt-level` setting controls the number of optimizations Rust will apply to
your code with a range of 0 to 3. Applying more optimizations extends
compiling time, so if you’re in development and compiling your code often,
you’ll want faster compiling even if the resulting code runs slower. That is
the reason the default `opt-level` for `dev` is `0`. When you’re ready to
release your code, it’s best to spend more time compiling. You’ll only compile
in release mode once, but you’ll run the compiled program many times, so
release mode trades longer compile time for code that runs faster. That is why
the default `opt-level` for the `release` profile is `3`.
-->
<p><code>opt-level</code>設定は、0から3の範囲でコンパイラがコードに適用する最適化の度合いを制御します。
最適化を多くかけると、コンパイル時間が延びるので、開発中に頻繁にコードをコンパイルするのなら、
たとえ出力結果のコードの動作速度が遅くなっても早くコンパイルが済んでほしいですよね。
これが、<code>dev</code>の<code>opt-level</code>のデフォルト設定が<code>0</code>になっている唯一の理由です。
コードのリリース準備ができたら、より長い時間をコンパイルにかけるのが最善の策です。
リリースモードでコンパイルするのはたった1回ですが、コンパイル結果のプログラムは何度も実行するので、
リリースモードでは、長いコンパイル時間と引き換えに、生成したコードが速く動作します。
そのため、<code>release</code>の<code>opt-level</code>のデフォルト設定が<code>3</code>になっているのです。</p>
<!--
You can override any default setting by adding a different value for it in
*Cargo.toml*. For example, if we want to use optimization level 1 in the
development profile, we can add these two lines to our project’s *Cargo.toml*
file:
-->
<p>デフォルト設定に対して<code>Cargo.toml</code>で異なる値を追加すれば、上書きすることができます。
例として、開発用プロファイルで最適化レベル1を使用したければ、以下の2行をプロジェクトの<em>Cargo.toml</em>ファイルに追加できます:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<!--
This code overrides the default setting of `0`. Now when we run `cargo build`,
Cargo will use the defaults for the `dev` profile plus our customization to
`opt-level`. Because we set `opt-level` to `1`, Cargo will apply more
optimizations than the default, but not as many as in a release build.
-->
<p>このコードは、デフォルト設定の<code>0</code>を上書きします。こうすると、<code>cargo build</code>を実行したときに、
<code>dev</code>プロファイル用のデフォルト設定に加えて、Cargoは<code>opt-level</code>の変更を適用します。
<code>opt-level</code>を<code>1</code>に設定したので、Cargoはデフォルトよりは最適化を行いますが、リリースビルドほどではありません。</p>
<!--
For the full list of configuration options and defaults for each profile, see
[Cargo’s documentation](https://doc.rust-lang.org/cargo/).
-->
<p>設定の選択肢と各プロファイルのデフォルト設定の一覧は、<a href="https://doc.rust-lang.org/cargo/">Cargoのドキュメンテーション</a>を参照されたし。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Publishing a Crate to Crates.io
-->
<h2 id="cratesioにクレートを公開する"><a class="header" href="#cratesioにクレートを公開する">Crates.ioにクレートを公開する</a></h2>
<!--
We’ve used packages from [crates.io](https://crates.io) as
dependencies of our project, but you can also share your code with other people
by publishing your own packages. The crate registry at
[crates.io](https://crates.io) distributes the source code of
your packages, so it primarily hosts code that is open source.
-->
<p>プロジェクトの依存として<a href="https://crates.io">crates.io</a>のパッケージを使用しましたが、
自分のパッケージを公開することで他の人とコードを共有することもできます。
<a href="https://crates.io">crates.io</a>のクレート登録所は、自分のパッケージのソースコードを配布するので、
主にオープンソースのコードをホストします。</p>
<!--
Rust and Cargo have features that help make your published package easier for
people to use and to find in the first place. We’ll talk about some of these
features next and then explain how to publish a package.
-->
<p>RustとCargoは、公開したパッケージを人が使用し、そもそも見つけやすくしてくれる機能を有しています。
これらの機能の一部を次に語り、そして、パッケージの公開方法を説明します。</p>
<!--
### Making Useful Documentation Comments
-->
<h3 id="役に立つドキュメンテーションコメントを行う"><a class="header" href="#役に立つドキュメンテーションコメントを行う">役に立つドキュメンテーションコメントを行う</a></h3>
<!--
Accurately documenting your packages will help other users know how and when to
use them, so it’s worth investing the time to write documentation. In Chapter
3, we discussed how to comment Rust code using two slashes, `//`. Rust also has
a paticular kind of comment for documentation, known conveniently as
a *documentation comment*, that will generate HTML documentation. The HTML
displays the contents of documentation comments for public API items intended
for programmers interested in knowing how to *use* your crate as opposed to how
your crate is *implemented*.
-->
<p>パッケージを正確にドキュメントすることで、他のユーザがパッケージを使用する方法や、いつ使用すべきかを理解する手助けをすることになるので、
ドキュメンテーションを書くことに時間を費やす価値があります。第3章で、2連スラッシュ、<code>//</code>でRustのコードにコメントをつける方法を議論しました。
Rustには、ドキュメンテーション用のコメントも用意されていて、便利なことに<em>ドキュメンテーションコメント</em>として知られ、
HTMLドキュメントを生成します。クレートの<em>実装</em>法とは対照的にクレートの<em>使用</em>法を知ることに興味のあるプログラマ向けの、
公開API用のドキュメンテーションコメントの中身をこのHTMLは表示します。</p>
<!--
Documentation comments use three slashes, `///`, instead of two and support
Markdown notation for formatting the text. Place documentation comments just
before the item they’re documenting. Listing 14-1 shows documentation comments
for an `add_one` function in a crate named `my_crate`:
-->
<p>ドキュメンテーションコメントは、2つではなく、3連スラッシュ、<code>///</code>を使用し、テキストを整形するMarkdown記法もサポートしています。
ドキュメント対象の要素の直前にドキュメンテーションコメントを配置してください。
リスト14-1は、<code>my_crate</code>という名のクレートの<code>add_one</code>関数用のドキュメンテーションコメントを示しています:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
/// 与えられた数値に1を足す。
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, my_crate::add_one(5));
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<!--
<span class="caption">Listing 14-1: A documentation comment for a
function</span>
-->
<p><span class="caption">リスト14-1: 関数のドキュメンテーションコメント</span></p>
<!--
Here, we give a description of what the `add_one` function does, start a
section with the heading `Examples`, and then provide code that demonstrates
how to use the `add_one` function. We can generate the HTML documentation from
this documentation comment by running `cargo doc`. This command runs the
`rustdoc` tool distributed with Rust and puts the generated HTML documentation
in the *target/doc* directory.
-->
<p>ここで、<code>add_one</code>関数がすることの説明を与え、<code>Examples</code>というタイトルでセクションを開始し、
<code>add_one</code>関数の使用法を模擬するコードを提供しています。このドキュメンテーションコメントから<code>cargo doc</code>を実行することで、
HTMLドキュメントを生成することができます。このコマンドはコンパイラとともに配布されている<code>rustdoc</code>ツールを実行し、
生成されたHTMLドキュメントを<em>target/doc</em>ディレクトリに配置します。</p>
<!--
For convenience, running `cargo doc --open` will build the HTML for your
current crate’s documentation (as well as the documentation for all of your
crate’s dependencies) and open the result in a web browser. Navigate to the
`add_one` function and you’ll see how the text in the documentation comments is
rendered, as shown in Figure 14-1:
-->
<p>利便性のために、<code>cargo doc --open</code>を走らせれば、現在のクレートのドキュメント用のHTML(と、
自分のクレートが依存している全てのドキュメント)を構築し、その結果をWebブラウザで開きます。
<code>add_one</code>関数まで下り、図14-1に示したように、ドキュメンテーションコメントのテキストがどう描画されるかを確認しましょう:</p>
<!--
<img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="img/trpl14-01.png" class="center" />
-->
<img alt="`my_crate`の`add_one`関数の描画済みのHTMLドキュメント" src="img/trpl14-01.png" class="center" />
<!--
<span class="caption">Figure 14-1: HTML documentation for the `add_one`
function</span>
-->
<p><span class="caption">図14-1: <code>add_one</code>関数のHTMLドキュメント</span></p>
<!--
#### Commonly Used Sections
-->
<h4 id="よく使われるセクション"><a class="header" href="#よく使われるセクション">よく使われるセクション</a></h4>
<!--
We used the `# Examples` Markdown heading in Listing 14-1 to create a section
in the HTML with the title “Examples.” Here are some other sections that crate
authors commonly use in their documentation:
-->
<p><code># Examples</code>マークダウンのタイトルをリスト14-1で使用し、「例」というタイトルのセクションをHTMLに生成しました。
こちらがこれ以外にドキュメントでよくクレート筆者が使用するセクションです:</p>
<!--
* **Panics**: The scenarios in which the function being documented could
`panic!`. Callers of the function who don’t want their programs to panic should
make sure they don’t call the function in these situations.
* **Errors**: If the function returns a `Result`, describing the kinds of
errors that might occur and what conditions might cause those errors to be
returned can be helpful to callers so they can write code to handle the
different kinds of errors in different ways.
* **Safety**: If the function is `unsafe` to call (we discuss unsafety in
Chapter 19), there should be a section explaining why the function is unsafe
and covering the invariants that the function expects callers to uphold.
-->
<ul>
<li><strong>Panics</strong>: ドキュメント対象の関数が<code>panic!</code>する可能性のある筋書きです。プログラムをパニックさせたくない関数の使用者は、
これらの状況で関数が呼ばれないことを確かめる必要があります。</li>
<li><strong>Errors</strong>: 関数が<code>Result</code>を返すなら、起きうるエラーの種類とどんな条件がそれらのエラーを引き起こす可能性があるのか解説すると、
呼び出し側の役に立つので、エラーの種類によって処理するコードを変えて書くことができます。</li>
<li><strong>Safety</strong>: 関数が呼び出すのに<code>unsafe</code>(unsafeについては第19章で議論します)なら、
関数がunsafeな理由を説明し、関数が呼び出し元に保持していると期待する不変条件を講義するセクションがあるべきです。</li>
</ul>
<!--
Most documentation comments don’t need all of these sections, but this is a
good checklist to remind you of the aspects of your code that people calling
your code will be interested in knowing about.
-->
<p>多くのドキュメンテーションコメントでは、これら全てのセクションが必要になることはありませんが、
これは自分のコードを呼び出している人が知りたいと思うコードの方向性を思い出させてくれるいいチェックリストになります。</p>
<!--
#### Documentation Comments as Tests
-->
<h4 id="テストとしてのドキュメンテーションコメント"><a class="header" href="#テストとしてのドキュメンテーションコメント">テストとしてのドキュメンテーションコメント</a></h4>
<!--
Adding example code blocks in your documentation comments can help demonstrate
how to use your library, and doing so has an additional bonus: running `cargo
test` will run the code examples in your documentation as tests! Nothing is
better than documentation with examples. But nothing is worse than examples
that don’t work because the code has changed since the documentation was
written. If we run `cargo test` with the documentation for the `add_one`
function from Listing 14-1, we will see a section in the test results like this:
-->
<p>ドキュメンテーションコメントに例のコードブロックを追加すると、ライブラリの使用方法のデモに役立ち、
おまけもついてきます: <code>cargo test</code>を走らせると、ドキュメントのコード例をテストとして実行するのです！
例付きのドキュメントに上回るものはありません。しかし、ドキュメントが書かれてからコードが変更されたがために、
動かない例がついているよりも悪いものもありません。リスト14-1から<code>add_one</code>関数のドキュメンテーションとともに、
<code>cargo test</code>を走らせたら、テスト結果に以下のような区域が見られます:</p>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
2行目最後、catch that S Vの用法は辞書に載っていなかった。Oxfordには載っているのかもしれません
-->
<!--
Now if we change either the function or the example so the `assert_eq!` in the
example panics and run `cargo test` again, we’ll see that the doc tests catch
that the example and the code are out of sync from one another!
-->
<p>さて、例の<code>assert_eq!</code>がパニックするように、関数か例を変更し、再度<code>cargo test</code>を実行したら、
docテストが、例とコードがお互いに同期されていないことを捕捉するところを目撃するでしょう！</p>
<!--
#### Commenting Contained Items
-->
<h4 id="含まれている要素にコメントする"><a class="header" href="#含まれている要素にコメントする">含まれている要素にコメントする</a></h4>
<!--
Another style of doc comment, `//!`, adds documentation to the item that
contains the comments rather than adding documentation to the items following
the comments. We typically use these doc comments inside the crate root file
(*src/lib.rs* by convention) or inside a module to document the crate or the
module as a whole.
-->
<p>docコメントの別スタイル、<code>//!</code>は、コメントに続く要素にドキュメンテーションを付け加えるのではなく、
コメントを含む要素にドキュメンテーションを付け加えます。典型的には、クレートのルートファイル(慣例的には、<em>src/lib.rs</em>)内部や、
モジュールの内部で使用して、クレートやモジュール全体にドキュメントをつけます。</p>
<!--
For example, if we want to add documentation that describes the purpose of the
`my_crate` crate that contains the `add_one` function, we can add documentation
comments that start with `//!` to the beginning of the *src/lib.rs* file, as
shown in Listing 14-2:
-->
<p>例えば、<code>add_one</code>関数を含む<code>my_crate</code>クレートの目的を解説するドキュメンテーションを追加したいのなら、
<code>//!</code>で始まるドキュメンテーションコメントを<em>src/lib.rs</em>ファイルの先頭につけることができます。
リスト14-2に示したようにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

//! #自分のクレート
//!
//! `my_crate`は、ユーティリティの集まりであり、特定の計算をより便利に行うことができます。

/// Adds one to the number given.
// --snip--
</code></pre>
<!--
<span class="caption">Listing 14-2: Documentation for the `my_crate` crate as a
whole</span>
-->
<p><span class="caption">リスト14-2: 全体として<code>my_crate</code>クレートにドキュメントをつける</span></p>
<!--
Notice there isn’t any code after the last line that begins with `//!`. Because
we started the comments with `//!` instead of `///`, we’re documenting the item
that contains this comment rather than an item that follows this comment. In
this case, the item that contains this comment is the *src/lib.rs* file, which
is the crate root. These comments describe the entire crate.
-->
<p><code>//!</code>で始まる最後の行のあとにコードがないことに注目してください。<code>///</code>ではなく、<code>//!</code>でコメントを開始しているので、
このコメントに続く要素ではなく、このコメントを含む要素にドキュメントをつけているわけです。
今回の場合、このコメントを含む要素は<em>src/lib.rs</em>ファイルであり、クレートのルートです。
これらのコメントは、クレート全体を解説しています。</p>
<!--
When we run `cargo doc --open`, these comments will display on the front
page of the documentation for `my_crate` above the list of public items in the
crate, as shown in Figure 14-2:
-->
<p><code>cargo doc --open</code>を実行すると、これらのコメントは、<code>my_crate</code>のドキュメントの最初のページ、
クレートの公開要素のリストの上部に表示されます。図14-2のようにですね:</p>
<!--
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="img/trpl14-02.png" class="center" />
-->
<img alt="クレート全体のコメント付きの描画済みHTMLドキュメンテーション" src="img/trpl14-02.png" class="center" />
<!--
<span class="caption">Figure 14-2: Rendered documentation for `my_crate`,
including the comment describing the crate as a whole</span>
-->
<p><span class="caption">図14-2: クレート全体を解説するコメントを含む<code>my_crate</code>の描画されたドキュメンテーション</span></p>
<!--
Documentation comments within items are useful for describing crates and
modules especially. Use them to explain the overall purpose of the container to
help your crate users understand the crate’s organization.
-->
<p>要素内のドキュメンテーションコメントは、特にクレートやモジュールを解説するのに有用です。
コンテナの全体の目的を説明し、クレートの使用者がクレートの体系を理解する手助けをするのに使用してください。</p>
<!--
### Exporting a Convenient Public API with `pub use`
-->
<h3 id="pub-useで便利な公開apiをエクスポートする"><a class="header" href="#pub-useで便利な公開apiをエクスポートする"><code>pub use</code>で便利な公開APIをエクスポートする</a></h3>
<!--
In Chapter 7, we covered how to organize our code into modules using the `mod`
keyword, how to make items public using the `pub` keyword, and how to bring
items into a scope with the `use` keyword. However, the structure that makes
sense to you while you’re developing a crate might not be very convenient for
your users. You might want to organize your structs in a hierarchy containing
multiple levels, but then people who want to use a type you’ve defined deep in
the hierarchy might have trouble finding out that type exists. They might also
be annoyed at having to enter `use`
`my_crate::some_module::another_module::UsefulType;` rather than `use`
`my_crate::UsefulType;`.
-->
<p>第7章において、<code>mod</code>キーワードを使用してモジュールにコードを体系化する方法、<code>pub</code>キーワードで要素を公開にする方法、
<code>use</code>キーワードで要素をスコープに導入する方法について講義しました。しかしながら、クレートの開発中に、
自分にとって意味のある構造は、ユーザにはあまり便利ではない可能性があります。複数階層を含む階層で、
自分の構造体を体系化したくなるかもしれませんが、それから階層の深いところで定義した型を使用したい人は、
型が存在することを見つけ出すのに困難を伴う可能性もあります。また、そのような人は、
<code>use my_crate::UsefulType</code>の代わりに<code>use my_crate::some_module::another_module::UsefulType;</code>と入力するのを煩わしく感じる可能性もあります。</p>
<!--
The structure of your public API is a major consideration when publishing a
crate. People who use your crate are less familiar with the structure than you
are and might have difficulty finding the pieces they want to use if your crate
has a large module hierarchy.
-->
<p>自分の公開APIの構造は、クレートを公開する際に考慮すべき点です。自分のクレートを使用したい人は、
自分よりもその構造に馴染みがないですし、クレートのモジュール階層が大きければ、使用したい部分を見つけるのが困難になる可能性があります。</p>
<!--
The good news is that if the structure *isn’t* convenient for others to use
from another library, you don’t have to rearrange your internal organization:
instead, you can re-export items to make a public structure that’s different
than your private structure by using `pub use`. Re-exporting takes a public
item in one location and makes it public in another location, as if it were
defined in the other location instead.
-->
<p>嬉しいお知らせは、構造が他人が他のライブラリから使用するのに便利では<em>ない</em>場合、内部的な体系を再構築する必要はないということです:
代わりに、要素を再エクスポートし、<code>pub use</code>で自分の非公開構造とは異なる公開構造にできます。
再エクスポートは、ある場所の公開要素を一つ取り、別の場所で定義されているかのように別の場所で公開します。</p>
<!--
For example, say we made a library named `art` for modeling artistic concepts.
Within this library are two modules: a `kinds` module containing two enums
named `PrimaryColor` and `SecondaryColor` and a `utils` module containing a
function named `mix`, as shown in Listing 14-3:
-->
<p>例えば、芸術的な概念をモデル化するために<code>art</code>という名のライブラリを作ったとしましょう。
このライブラリ内には、2つのモジュールがあります: <code>PrimaryColor</code>と<code>SecondaryColor</code>という名前の2つのenumを含む、
<code>kinds</code>モジュールと<code>mix</code>という関数を含む<code>utils</code>モジュールです。リスト14-3のようにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.
//! #芸術
//!
//! 芸術的な概念をモデル化するライブラリ。

pub mod kinds {
    /// The primary colors according to the RYB color model.
    /// RYBカラーモデルによる主色
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    /// RYBカラーモデルによる副色
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    ///2つの主色を同じ割合で混合し、副色にする
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
    }
}
</code></pre>
<!--
<span class="caption">Listing 14-3: An `art` library with items organized into
`kinds` and `utils` modules</span>
-->
<p><span class="caption">リスト14-3: <code>kinds</code>と<code>utils</code>モジュールに体系化される要素を含む<code>art</code>ライブラリ</span></p>
<!--
Figure 14-3 shows what the front page of the documentation for this crate
generated by `cargo doc` would look like:
-->
<p>図14-3は、<code>cargo doc</code>により生成されるこのクレートのドキュメンテーションの最初のページがどんな見た目になるか示しています:</p>
<!--
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="img/trpl14-03.png" class="center" />
-->
<img alt="`kinds`と`utils`モジュールを列挙する`art`クレートの描画されたドキュメンテーション" src="img/trpl14-03.png" class="center" />
<!--
<span class="caption">Figure 14-3: Front page of the documentation for `art`
that lists the `kinds` and `utils` modules</span>
-->
<p><span class="caption">図14-3: <code>kinds</code>と<code>utils</code>モジュールを列挙する<code>art</code>のドキュメンテーションのトップページ</span></p>
<!--
Note that the `PrimaryColor` and `SecondaryColor` types aren’t listed on the
front page, nor is the `mix` function. We have to click `kinds` and `utils` to
see them.
-->
<p><code>PrimaryColor</code>型も<code>SecondaryColor</code>型も、<code>mix</code>関数もトップページには列挙されていないことに注意してください。
<code>kinds</code>と<code>utils</code>をクリックしなければ、参照することができません。</p>
<!--
Another crate that depends on this library would need `use` statements that
import the items from `art`, specifying the module structure that’s currently
defined. Listing 14-4 shows an example of a crate that uses the `PrimaryColor`
and `mix` items from the `art` crate:
-->
<p>このライブラリに依存する別のクレートは、現在定義されているモジュール構造を指定して、
<code>art</code>の要素をインポートする<code>use</code>文が必要になるでしょう。リスト14-4は、
<code>art</code>クレートから<code>PrimaryColor</code>と<code>mix</code>要素を使用するクレートの例を示しています:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate art;

use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
</code></pre>
<!--
<span class="caption">Listing 14-4: A crate using the `art` crate’s items with
its internal structure exported</span>
-->
<p><span class="caption">リスト14-4: 内部構造がエクスポートされて<code>art</code>クレートの要素を使用するクレート</span></p>
<!--
The author of the code in Listing 14-4, which uses the `art` crate, had to
figure out that `PrimaryColor` is in the `kinds` module and `mix` is in the
`utils` module. The module structure of the `art` crate is more relevant to
developers working on the `art` crate than to developers using the `art` crate.
The internal structure that organizes parts of the crate into the `kinds`
module and the `utils` module doesn’t contain any useful information for
someone trying to understand how to use the `art` crate. Instead, the `art`
crate’s module structure causes confusion because developers have to figure out
where to look, and the structure is inconvenient because developers must
specify the module names in the `use` statements.
-->
<p>リスト14-4は<code>art</code>クレートを使用していますが、このコードの筆者は、<code>PrimaryColor</code>が<code>kinds</code>モジュールにあり、
<code>mix</code>が<code>utils</code>モジュールにあることを理解しなければなりませんでした。<code>art</code>クレートのモジュール構造は、
<code>art</code>クレートの使用者よりも、<code>art</code>クレートに取り組む開発者などに関係が深いです。
クレートの一部を<code>kinds</code>モジュールと<code>utils</code>モジュールに体系化する内部構造は、<code>art</code>クレートの使用方法を理解しようとする人には、
何も役に立つ情報を含んでいません。代わりに、開発者がどこを見るべきか計算する必要があるので、
<code>art</code>クレートのモジュール構造は混乱を招き、また、開発者はモジュール名を<code>use</code>文で指定しなければならないので、
この構造は不便です。</p>
<!--
To remove the internal organization from the public API, we can modify the
`art` crate code in Listing 14-3 to add `pub use` statements to re-export the
items at the top level, as shown in Listing 14-5:
-->
<p>公開APIから内部体系を除去するために、リスト14-3の<code>art</code>クレートコードを変更し、<code>pub use</code>文を追加して、
最上位で要素を再エクスポートすることができます。リスト14-5みたいにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use kinds::PrimaryColor;
pub use kinds::SecondaryColor;
pub use utils::mix;

pub mod kinds {
    // --snip--
}

pub mod utils {
    // --snip--
}
</code></pre>
<!--
<span class="caption">Listing 14-5: Adding `pub use` statements to re-export
items</span>
-->
<p><span class="caption">リスト14-5: <code>pub use</code>文を追加して要素を再エクスポートする</span></p>
<!--
The API documentation that `cargo doc` generates for this crate will now list
and link re-exports on the front page, as shown in Figure 14-4, making the
`PrimaryColor` and `SecondaryColor` types and the `mix` function easier to find.
-->
<p>このクレートに対して<code>cargo doc</code>が生成するAPIドキュメンテーションは、これで図14-4のようにトップページに再エクスポートを列挙しリンクするので、
<code>PrimaryColor</code>型と<code>SecondaryColor</code>型と<code>mix</code>関数を見つけやすくします。</p>
<!--
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="img/trpl14-04.png" class="center" />
-->
<img alt="トップページに再エクスポートのある`art`クレートの描画されたドキュメンテーション" src="img/trpl14-04.png" class="center" />
<!--
<span class="caption">Figure 14-4: The front page of the documentation for `art`
that lists the re-exports</span>
-->
<p><span class="caption">図14-4: 再エクスポートを列挙する<code>art</code>のドキュメンテーションのトップページ</span></p>
<!--
The `art` crate users can still see and use the internal structure from Listing
14-3 as demonstrated in Listing 14-4, or they can use the more convenient
structure in Listing 14-5, as shown in Listing 14-6:
-->
<p><code>art</code>クレートのユーザは、それでも、リスト14-4にデモされているように、リスト14-3の内部構造を見て使用することもできますし、
リスト14-5のより便利な構造を使用することもできます。リスト14-6に示したようにですね:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate art;

use art::PrimaryColor;
use art::mix;

fn main() {
    // --snip--
}
</code></pre>
<!--
<span class="caption">Listing 14-6: A program using the re-exported items from
the `art` crate</span>
-->
<p><span class="caption">リスト14-6: <code>art</code>クレートの再エクスポートされた要素を使用するプログラム</span></p>
<!--
In cases where there are many nested modules, re-exporting the types at the top
level with `pub use` can make a significant difference in the experience of
people who use the crate.
-->
<p>ネストされたモジュールがたくさんあるような場合、最上位階層で<code>pub use</code>により型を再エクスポートすることは、
クレートの使用者の経験に大きな違いを生みます。</p>
<!--
Creating a useful public API structure is more of an art than a science, and
you can iterate to find the API that works best for your users. Choosing `pub
use` gives you flexibility in how you structure your crate internally and
decouples that internal structure from what you present to your users. Look at
some of the code of crates you’ve installed to see if their internal structure
differs from their public API.
-->
<p>役に立つAPI構造を作ることは、科学というよりも芸術の領域であり、ユーザにとって何が最善のAPIなのか、
探究するために繰り返してみることができます。<code>pub use</code>は、内部的なクレート構造に柔軟性をもたらし、
その内部構造をユーザに提示する構造から切り離してくれます。インストールしてある他のクレートを見て、
内部構造が公開APIと異なっているか確認してみてください。</p>
<!--
### Setting Up a Crates.io Account
-->
<h3 id="cratesioのアカウントをセットアップする"><a class="header" href="#cratesioのアカウントをセットアップする">Crates.ioのアカウントをセットアップする</a></h3>
<!--
Before you can publish any crates, you need to create an account on
[crates.io](https://crates.io) and get an API token. To do so,
visit the home page at [crates.io](https://crates.io) and log in
via a GitHub account. (The GitHub account is currently a requirement, but the
site might support other ways of creating an account in the future.) Once
you're logged in, visit your account settings at
[https://crates.io/me/](https://crates.io/me/) and retrieve your
API key. Then run the `cargo login` command with your API key, like this:
-->
<p>クレートを公開する前に、<a href="https://crates.io">crates.io</a>のアカウントを作成し、
APIトークンを取得する必要があります。そうするには、<a href="https://crates.io">crates.io</a>のホームページを訪れ、
Githubアカウントでログインしてください。(現状は、Githubアカウントがなければなりませんが、
いずれは他の方法でもアカウントを作成できるようになる可能性があります。)ログインしたら、
<a href="https://crates.io/me/">https://crates.io/me/</a>で自分のアカウントの設定に行き、
APIキーを取り扱ってください。そして、<code>cargo login</code>コマンドをAPIキーとともに実行してください。
以下のようにですね:</p>
<pre><code class="language-text">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<!--
This command will inform Cargo of your API token and store it locally in
*~/.cargo/credentials*. Note that this token is a *secret*: do not share it
with anyone else. If you do share it with anyone for any reason, you should
revoke it and generate a new token on [crates.io](https://crates.io)
-->
<p>このコマンドは、CargoにAPIトークンを知らせ、<em>~/.cargo/credentials</em>にローカルに保存します。
このトークンは、<em>秘密</em>です: 他人とは共有しないでください。なんらかの理由で他人と実際に共有してしまったら、
古いものを破棄して<a href="https://crates.io">crates.io</a>で新しいトークンを生成するべきです。</p>
<!--
### Adding Metadata to a New Crate
-->
<h3 id="新しいクレートにメタデータを追加する"><a class="header" href="#新しいクレートにメタデータを追加する">新しいクレートにメタデータを追加する</a></h3>
<!--
Now that you have an account, let’s say you have a crate you want to publish.
Before publishing, you’ll need to add some metadata to your crate by adding it
to the `[package]` section of the crate’s *Cargo.toml* file.
-->
<p>アカウントはできたので、公開したいクレートがあるとしましょう。公開前に、
<em>Cargo.toml</em>ファイルの<code>[package]</code>セクションに追加することでクレートにメタデータを追加する必要があるでしょう。</p>
<!--
Your crate will need a unique name. While you’re working on a crate locally,
you can name a crate whatever you’d like. However, crate names on
[crates.io](https://crates.io) are allocated on a first-come,
first-served basis. Once a crate name is taken, no one else can publish a crate
with that name. Search for the name you want to use on the site to find out
whether it has been used. If it hasn’t, edit the name in the *Cargo.toml* file
under `[package]` to use the name for publishing, like so:
-->
<p>クレートには、独自の名前が必要でしょう。クレートをローカルで作成している間、
クレートの名前はなんでもいい状態でした。ところが、<a href="https://crates.io">crates.io</a>のクレート名は、
最初に来たもの勝ちの精神で付与されていますので、一旦クレート名が取られてしまったら、
その名前のクレートを他の人が公開することは絶対できません。もう使われているか、
サイトで使いたい名前を検索してください。まだなら、<em>Cargo.toml</em>ファイルの<code>[package]</code>以下の名前を編集して、
名前を公開用に使ってください。以下のように:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<!--
Even if you’ve chosen a unique name, when you run `cargo publish` to publish
the crate at this point, you’ll get a warning and then an error:
-->
<p>たとえ、独自の名前を選択していたとしても、この時点で<code>cargo publish</code>を実行すると、警告とエラーが出ます:</p>
<pre><code class="language-text">$ cargo publish
    Updating registry `https://github.com/rust-lang/crates.io-index`
warning: manifest has no description, license, license-file, documentation,
homepage or repository.
(警告: マニフェストに説明、ライセンス、ライセンスファイル、ドキュメンテーション、ホームページ、
リポジトリがありません)
--snip--
error: api errors: missing or empty metadata fields: description, license.
(エラー: APIエラー: 存在しないメタデータフィールド: description, license)
</code></pre>
<!--
The reason is that you’re missing some crucial information: a description and
license are required so people will know what your crate does and under what
terms they can use it. To rectify this error, you need to include this
information in the *Cargo.toml* file.
-->
<p>原因は、大事な情報を一部入れていないからです: 説明とライセンスは、
他の人があなたのクレートは何をし、どんな条件の元で使っていいのかを知るために必要なのです。
このエラーを解消するには、<em>Cargo.toml</em>ファイルにこの情報を入れ込む必要があります。</p>
<!--
Add a description that is just a sentence or two, because it will appear with
your crate in search results. For the `license` field, you need to give a
*license identifier value*. The [Linux Foundation’s Software Package Data
Exchange (SPDX)][spdx] lists the identifiers you can use for this value. For
example, to specify that you’ve licensed your crate using the MIT License, add
the `MIT` identifier:
-->
<p>1文か2文程度の説明をつけてください。これは、検索結果に表示されますからね。
<code>license</code>フィールドには、<em>ライセンス識別子</em>を与える必要があります。
<a href="http://spdx.org/licenses/">Linux団体のSoftware Package Data Exchange(SPDX)</a>に、この値に使用できる識別子が列挙されています。
例えば、自分のクレートをMITライセンスでライセンスするためには、
<code>MIT</code>識別子を追加してください:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<!--
If you want to use a license that doesn’t appear in the SPDX, you need to place
the text of that license in a file, include the file in your project, and then
use `license-file` to specify the name of that file instead of using the
`license` key.
-->
<p>SPDXに出現しないライセンスを使用したい場合、そのライセンスをファイルに配置し、
プロジェクトにそのファイルを含め、それから<code>license</code>キーを使う代わりに、
そのファイルの名前を指定するのに<code>license-file</code>を使う必要があります。</p>
<!--
Guidance on which license is appropriate for your project is beyond the scope
of this book. Many people in the Rust community license their projects in the
same way as Rust by using a dual license of `MIT OR Apache-2.0`. This practice
demonstrates that you can also specify multiple license identifiers separated
by `OR` to have multiple licenses for your project.
-->
<p>どのライセンスが自分のプロジェクトに<ruby>相<rp>(</rp><rt>ふ</rt><rp>)</rp>応<rp>(</rp><rt>さわ</rt><rp>)</rp></ruby>しいかというガイドは、
この本の範疇を超えています。Rustコミュニティの多くの人間は、<code>MIT OR Apache-2.0</code>のデュアルライセンスを使用することで、
Rust自体と同じようにプロジェクトをライセンスします。この実践は、<code>OR</code>で区切られる複数のライセンス識別子を指定して、
プロジェクトに複数のライセンスを持たせることもできることを模擬しています。</p>
<!--
With a unique name, the version, the author details that `cargo new` added
when you created the crate, your description, and a license added, the
*Cargo.toml* file for a project that is ready to publish might look like this:
-->
<p>独自の名前、バージョン、クレート作成時に<code>cargo new</code>が追加した筆者の詳細、説明、ライセンスが追加され、
公開準備のできたプロジェクト用の<code>Cargo.toml</code>ファイルは以下のような見た目になっていることでしょう:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
              (コンピュータが選択した数字を言い当てる面白いゲーム)
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<!--
[Cargo’s documentation](https://doc.rust-lang.org/cargo/) describes other
metadata you can specify to ensure others can discover and use your crate more
easily.
-->
<p><a href="https://doc.rust-lang.org/cargo">Cargoのドキュメンテーション</a>には、
指定して他人が発見し、より容易くクレートを使用できることを保証する他のメタデータが解説されています。</p>
<!--
### Publishing to Crates.io
-->
<h3 id="cratesioに公開する"><a class="header" href="#cratesioに公開する">Crates.ioに公開する</a></h3>
<!--
Now that you’ve created an account, saved your API token, chosen a name for
your crate, and specified the required metadata, you’re ready to publish!
Publishing a crate uploads a specific version to
[crates.io](https://crates.io) for others to use.
-->
<p>アカウントを作成し、APIトークンを保存し、クレートの名前を決め、必要なメタデータを指定したので、
公開する準備が整いました！クレートを公開すると、特定のバージョンが、
<a href="http://crates.io">crates.io</a>に他の人が使用できるようにアップロードされます。</p>
<!--
Be careful when publishing a crate because a publish is *permanent*. The
version can never be overwritten, and the code cannot be deleted. One major
goal of [crates.io](https://crates.io) is to act as a permanent
archive of code so that builds of all projects that depend on crates from
[crates.io](https://crates.io) will continue to work. Allowing
version deletions would make fulfilling that goal impossible. However, there is
no limit to the number of crate versions you can publish.
-->
<p>公開は<em>永久</em>なので、クレートの公開時には気をつけてください。バージョンは絶対に上書きできず、
コードも削除できません。<a href="https://crates.io">crates.io</a>の一つの主な目標が、
<a href="https://crates.io">crates.io</a>のクレートに依存している全てのプロジェクトのビルドが、
動き続けるようにコードの永久アーカイブとして機能することなのです。バージョン削除を可能にしてしまうと、
その目標を達成するのが不可能になってしまいます。ですが、公開できるクレートバージョンの数に制限はありません。</p>
<!--
Run the `cargo publish` command again. It should succeed now:
-->
<p>再度<code>cargo publish</code>コマンドを実行してください。今度は成功するはずです:</p>
<pre><code class="language-text">$ cargo publish
 Updating registry `https://github.com/rust-lang/crates.io-index`
Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
 Finished dev [unoptimized + debuginfo] target(s) in 0.19 secs
Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<!--
Congratulations! You’ve now shared your code with the Rust community, and
anyone can easily add your crate as a dependency of their project.
-->
<p>おめでとうございます！Rustコミュニティとコードを共有し、誰でもあなたのクレートを依存として簡単に追加できます。</p>
<!--
### Publishing a New Version of an Existing Crate
-->
<h3 id="既存のクレートの新バージョンを公開する"><a class="header" href="#既存のクレートの新バージョンを公開する">既存のクレートの新バージョンを公開する</a></h3>
<!--
When you’ve made changes to your crate and are ready to release a new version,
you change the `version` value specified in your *Cargo.toml* file and
republish. Use the [Semantic Versioning rules][semver] to decide what an
appropriate next version number is based on the kinds of changes you’ve made.
Then run `cargo publish` to upload the new version.
-->
<p>クレートに変更を行い、新バージョンをリリースする準備ができたら、
<em>Cargo.toml</em>ファイルに指定された<code>version</code>の値を変更し、再公開します。
<a href="http://semver.org/">セマンティックバージョンルール</a>を使用して加えた変更の種類に基づいて次の適切なバージョン番号を決定してください。
そして、<code>cargo publish</code>を実行し、新バージョンをアップロードします。</p>
<!--
### Removing Versions from Crates.io with `cargo yank`
-->
<h3 id="cargo-yankでcratesioからバージョンを削除する"><a class="header" href="#cargo-yankでcratesioからバージョンを削除する"><code>cargo yank</code>でCrates.ioからバージョンを削除する</a></h3>
<!--
最後の行。辞書には、yankingはグイっと引っ張ることとしかないが、ここでは取り下げと意訳しておく
-->
<!--
Although you can’t remove previous versions of a crate, you can prevent any
future projects from adding them as a new dependency. This is useful when a
crate version is broken for one reason or another. In such situations, Cargo
supports *yanking* a crate version.
-->
<p>以前のバージョンのクレートを削除することはできないものの、将来のプロジェクトがこれに新たに依存することを防ぐことはできます。
これは、なんらかの理由により、クレートバージョンが壊れている場合に有用です。そのような場面において、
Cargoはクレートバージョンの <em>取り下げ(yank)</em> をサポートしています。</p>
<!--
Yanking a version prevents new projects from starting to depend on that version
while allowing all existing projects that depend on it to continue to download
and depend on that version. Essentially, a yank means that all projects with a
*Cargo.lock* will not break, and any future *Cargo.lock* files generated will
not use the yanked version.
-->
<p>バージョンを取り下げると、既存のプロジェクトは、引き続きダウンロードしたりそのバージョンに依存したりしつづけられますが、
新規プロジェクトが新しくそのバージョンに依存しだすことは防止されます。つまるところ、取り下げは、
すでに<em>Cargo.lock</em>が存在するプロジェクトは壊さないが、将来的に生成された<em>Cargo.lock</em>ファイルは
取り下げられたバージョンを使わない、ということを意味します。</p>
<!--
To yank a version of a crate, run `cargo yank` and specify which version you
want to yank:
-->
<p>あるバージョンのクレートを取り下げるには、<code>cargo yank</code>を実行し、取り下げたいバージョンを指定します:</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1
</code></pre>
<!--
By adding `--undo` to the command, you can also undo a yank and allow projects
to start depending on a version again:
-->
<p><code>--undo</code>をコマンドに付与することで、取り下げを取り消し、再度あるバージョンにプロジェクトを依存させ始めることもできます:</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<!--
A yank *does not* delete any code. For example, the yank feature is not
intended for deleting accidentally uploaded secrets. If that happens, you must
reset those secrets immediately.
-->
<p>取り下げは、コードの削除は一切し<em>ません</em>。例として、取り下げ機能は、誤ってアップロードされた秘密鍵を削除するためのものではありません。
もしそうなってしまったら、即座に秘密鍵をリセットしなければなりません。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Cargo Workspaces
-->
<h2 id="cargoのワークスペース"><a class="header" href="#cargoのワークスペース">Cargoのワークスペース</a></h2>
<!--
In Chapter 12, we built a package that included a binary crate and a library
crate. As your project develops, you might find that the library crate
continues to get bigger and you want to split up your package further into
multiple library crates. In this situation, Cargo offers a feature called
*workspaces* that can help manage multiple related packages that are developed
in tandem.
-->
<p>第12章で、バイナリクレートとライブラリクレートを含むパッケージを構築しました。プロジェクトの開発が進むにつれて、
ライブラリクレートの肥大化が続き、その上で複数のライブラリクレートにパッケージを分割したくなることでしょう。
この場面において、Cargoは<em>ワークスペース</em>という協調して開発された関連のある複数のパッケージを管理するのに役立つ機能を提供しています。</p>
<!--
### Creating a Workspace
-->
<h3 id="ワークスペースを生成する"><a class="header" href="#ワークスペースを生成する">ワークスペースを生成する</a></h3>
<!--
A *workspace* is a set of packages that share the same *Cargo.lock* and output
directory. Let’s make a project using a workspace-we'll use trivial code so we
can concentrate on the structure of the workspace. There are multiple ways to
structure a workspace; we’re going to show a common way. We’ll have a
workspace containing a binary and two libraries. The binary, which will provide
the main functionality, will depend on the two libraries. One library will
provide an `add_one` function, and a second library an `add_two` function.
These three crates will be part of the same workspace. We'll start by creating
a new directory for the workspace:
-->
<p><em>ワークスペース</em>は、同じ<em>Cargo.lock</em>と出力ディレクトリを共有する一連のパッケージです。
ワークスペースを使用したプロジェクトを作成し、ワークスペースの構造に集中できるよう、瑣末なコードを使用しましょう。
ワークスペースを構築する方法は複数ありますが、一般的な方法を提示しましょう。バイナリ1つとライブラリ2つを含むワークスペースを作ります。
バイナリは、主要な機能を提供しますが、2つのライブラリに依存しています。
一方のライブラリは、<code>add_one</code>関数を提供し、2番目のライブラリは、<code>add_two</code>関数を提供します。
これら3つのクレートが同じワークスペースの一部になります。ワークスペース用の新しいディレクトリを作ることから始めましょう:</p>
<pre><code class="language-text">$ mkdir add
$ cd add
</code></pre>
<!--
Next, in the *add* directory, we create the *Cargo.toml* file that will
configure the entire workspace. This file won't have a `[package]` section or
the metadata we’ve seen in other *Cargo.toml* files. Instead, it will start
with a `[workspace]` section that will allow us to add members to the workspace
by specifying the path to our binary crate; in this case, that path is *adder*:
-->
<p>次に<em>add</em>ディレクトリにワークスペース全体を設定する<em>Cargo.toml</em>ファイルを作成します。
このファイルには、他の<em>Cargo.toml</em>ファイルで見かけるような<code>[package]</code>セクションやメタデータはありません。
代わりにバイナリクレートへのパスを指定することでワークスペースにメンバを追加させてくれる<code>[workspace]</code>セクションから開始します;
今回の場合、そのパスは<em>adder</em>です:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<!--
Next, we’ll create the `adder` binary crate by running `cargo new` within the
*add* directory:
-->
<p>次に、<em>add</em>ディレクトリ内で<code>cargo new</code>を実行することで<code>adder</code>バイナリクレートを作成しましょう:</p>
<pre><code class="language-text">$ cargo new --bin adder
     Created binary (application) `adder` project
</code></pre>
<!--
At this point, we can build the workspace by running `cargo build`. The files
in your *add* directory should look like this:
-->
<p>この時点で、<code>cargo build</code>を走らせるとワークスペースを構築できます。<em>add</em>ディレクトリに存在するファイルは、
以下のようになるはずです:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<!--
The workspace has one *target* directory at the top level for the compiled
artifacts to be placed into; the `adder` crate doesn’t have its own *target*
directory. Even if we were to run `cargo build` from inside the *adder*
directory, the compiled artifacts would still end up in *add/target* rather
than *add/adder/target*. Cargo structures the *target* directory in a workspace
like this because the crates in a workspace are meant to depend on each other.
If each crate had its own *target* directory, each crate would have to
recompile each of the other crates in the workspace to have the artifacts in
its own *target* directory. By sharing one *target* directory, the crates can
avoid unnecessary rebuilding.
-->
<p>ワークスペースには、コンパイルした生成物を置けるように最上位に<em>target</em>のディレクトリがあります;
<code>adder</code>クレートには<em>target</em>ディレクトリはありません。
<em>adder</em>ディレクトリ内部から<code>cargo build</code>を走らせることになっていたとしても、コンパイルされる生成物は、
<em>add/adder/target</em>ではなく、<em>add/target</em>に落ち着くでしょう。ワークスペースのクレートは、
お互いに依存しあうことを意味するので、Cargoはワークスペースの<em>target</em>ディレクトリをこのように構成します。
各クレートが<em>target</em>ディレクトリを持っていたら、各クレートがワークスペースの他のクレートを再コンパイルし、
<em>target</em>ディレクトリに生成物がある状態にしなければならないでしょう。一つの<em>target</em>ディレクトリを共有することで、
クレートは不必要な再ビルドを回避できるのです。</p>
<!--
### Creating the Second Crate in the Workspace
-->
<h3 id="ワークスペース内に2番目のクレートを作成する"><a class="header" href="#ワークスペース内に2番目のクレートを作成する">ワークスペース内に2番目のクレートを作成する</a></h3>
<!--
Next, let’s create another member crate in the workspace and call it `add-one`.
Change the top-level *Cargo.toml* to specify the *add-one* path in the
`members` list:
-->
<p>次に、ワークスペースに別のメンバクレートを作成し、<code>add-one</code>と呼びましょう。
最上位の<em>Cargo.toml</em>を変更して<code>members</code>リストで<em>add-one</em>パスを指定するようにしてください:</p>
<!--
<span class="filename">Filename: Cargo.toml</span>
-->
<p><span class="filename">ファイル名: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add-one&quot;,
]
</code></pre>
<!--
Then generate a new library crate named `add-one`:
-->
<p>それから、<code>add-one</code>という名前のライブラリクレートを生成してください:</p>
<pre><code class="language-text">$ cargo new add-one --lib
     Created library `add-one` project
</code></pre>
<!--
Your *add* directory should now have these directories and files:
-->
<p>これで<em>add</em>ディレクトリには、以下のディレクトリやファイルが存在するはずです:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<!--
In the *add-one/src/lib.rs* file, let’s add an `add_one` function:
-->
<p><em>add-one/src/lib.rs</em>ファイルに<code>add_one</code>関数を追加しましょう:</p>
<!--
<span class="filename">Filename: add-one/src/lib.rs</span>
-->
<p><span class="filename">ファイル名: add-one/src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<!--
Now that we have a library crate in the workspace, we can have the binary crate
`adder` depend on the library crate `add-one`. First, we’ll need to add a path
dependency on `add-one` to *adder/Cargo.toml*:
-->
<p>ワークスペースにライブラリクレートが存在するようになったので、バイナリクレート<code>adder</code>をライブラリクレートの<code>add-one</code>に依存させられます。
まず、<code>add-one</code>へのパス依存を<em>adder/Cargo.toml</em>に追加する必要があります:</p>
<!--
<span class="filename">Filename: adder/Cargo.toml</span>
-->
<p><span class="filename">ファイル名: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

add-one = { path = &quot;../add-one&quot; }
</code></pre>
<!--
Cargo doesn't assume that crates in a workspace will depend on each other, so
we need to be explicit about the dependency relationships between the crates.
-->
<p>Cargoはワークスペースのクレートが、お互いに依存しているとは想定していないので、
クレート間の依存関係について明示する必要があります。</p>
<!--
Next, let’s use the `add_one` function from the `add-one` crate in the `adder`
crate. Open the *adder/src/main.rs* file and add an `extern crate` line at
the top to bring the new `add-one` library crate into scope. Then change the
`main` function to call the `add_one` function, as in Listing 14-7:
-->
<p>次に、<code>adder</code>クレートの<code>add-one</code>クレートから<code>add_one</code>関数を使用しましょう。<em>adder/src/main.rs</em>ファイルを開き、
冒頭に<code>extern crate</code>行を追加して新しい<code>add-one</code>ライブラリクレートをスコープに導入してください。
それから<code>main</code>関数を変更し、<code>add_one</code>関数を呼び出します。リスト14-7のようにですね:</p>
<!--
<span class="filename">Filename: adder/src/main.rs</span>
-->
<p><span class="filename">ファイル名: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate add_one;

fn main() {
    let num = 10;
    // こんにちは世界！{}+1は{}!
    println!(&quot;Hello, world! {} plus one is {}!&quot;, num, add_one::add_one(num));
}
</code></pre>
<!--
<span class="caption">Listing 14-7: Using the `add-one` library crate from the
`adder` crate</span>
-->
<p><span class="caption">リスト14-7: <code>adder</code>クレートから<code>add-one</code>ライブラリクレートを使用する</span></p>
<!--
Let’s build the workspace by running `cargo build` in the top-level *add*
directory!
-->
<p>最上位の<em>add</em>ディレクトリで<code>cargo build</code>を実行することでワークスペースをビルドしましょう！</p>
<pre><code class="language-text">$ cargo build
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68 secs
</code></pre>
<!--
To run the binary crate from the *add* directory, we need to specify which
package in the workspace we want to use by using the `-p` argument and the
package name with `cargo run`:
-->
<p><em>add</em>ディレクトリからバイナリクレートを実行するには、<code>-p</code>引数とパッケージ名を<code>cargo run</code>と共に使用して、
使用したいワークスペースのパッケージを指定する必要があります:</p>
<pre><code class="language-text">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<!--
This runs the code in *adder/src/main.rs*, which depends on the `add-one` crate.
-->
<p>これにより、<em>adder/src/main.rs</em>のコードが実行され、これは<code>add_one</code>クレートに依存しています。</p>
<!--
#### Depending on an External Crate in a Workspace
-->
<h4 id="ワークスペースの外部クレートに依存する"><a class="header" href="#ワークスペースの外部クレートに依存する">ワークスペースの外部クレートに依存する</a></h4>
<!--
Notice that the workspace has only one *Cargo.lock* file at the top level of
the workspace rather than having a *Cargo.lock* in each crate’s directory. This
ensures that all crates are using the same version of all dependencies. If we
add the `rand` crate to the *adder/Cargo.toml* and *add-one/Cargo.toml*
files, Cargo will resolve both of those to one version of `rand` and record
that in the one *Cargo.lock*. Making all crates in the workspace use the same
dependencies means the crates in the workspace will always be compatible with
each other. Let’s add the `rand` crate to the `[dependencies]` section in the
*add-one/Cargo.toml* file to be able to use the `rand` crate in the `add-one`
crate:
-->
<p>ワークスペースには、各クレートのディレクトリそれぞれに<em>Cargo.lock</em>が存在するのではなく、
ワークスペースの最上位階層にただ一つの<em>Cargo.lock</em>が存在するだけのことに注目してください。
これにより、全クレートが全依存の同じバージョンを使用していることが確認されます。
<code>rand</code>クレートを<em>adder/Cargo.toml</em>と<em>add-one/Cargo.toml</em>ファイルに追加すると、
Cargoは両者をあるバージョンの<code>rand</code>に解決し、それを一つの<em>Cargo.lock</em>に記録します。
ワークスペースの全クレートに同じ依存を使用させるということは、
ワークスペースのクレートが相互に互換性を常に維持するということになります。
<em>add-one/Cargo.toml</em>ファイルの<code>[dependencies]</code>セクションに<code>rand</code>クレートを追加して、
<code>add-one</code>クレートで<code>rand</code>クレートを使用できます:</p>
<!--
<span class="filename">Filename: add-one/Cargo.toml</span>
-->
<p><span class="filename">ファイル名: add-one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<!--
We can now add `extern crate rand;` to the *add-one/src/lib.rs* file, and
building the whole workspace by running `cargo build` in the *add* directory
will bring in and compile the `rand` crate:
-->
<p>これで、<em>add-one/src/lib.rs</em>ファイルに<code>extern crate rand;</code>を追加でき、
<em>add</em>ディレクトリで<code>cargo build</code>を実行することでワークスペース全体をビルドすると、
<code>rand</code>クレートを持ってきてコンパイルするでしょう:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
   --snip--
   Compiling rand v0.3.14
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18 secs
</code></pre>
<!--
The top-level *Cargo.lock* now contains information about the dependency of
`add-one` on `rand`. However, even though `rand` is used somewhere in the
workspace, we can’t use it in other crates in the workspace unless we add
`rand` to their *Cargo.toml* files as well. For example, if we add `extern
crate rand;` to the *adder/src/main.rs* file for the `adder` crate, we’ll get
an error:
-->
<p>さて、最上位の<em>Cargo.lock</em>は、<code>rand</code>に対する<code>add-one</code>の依存の情報を含むようになりました。
ですが、<code>rand</code>はワークスペースのどこかで使用されているにも関わらず、それぞれの<em>Cargo.toml</em>ファイルにも、
<code>rand</code>を追加しない限り、ワークスペースの他のクレートでそれを使用することはできません。
例えば、<code>adder</code>クレートの<em>adder/src/main.rs</em>ファイルに<code>extern crate rand;</code>を追加すると、
エラーが出ます:</p>
<pre><code class="language-text">$ cargo build
   Compiling adder v0.1.0 (file:///projects/add/adder)
error: use of unstable library feature 'rand': use `rand` from crates.io (see
issue #27703)
(エラー: 不安定なライブラリの機能'rand'を使用しています: crates.ioの`rand`を使用してください)
 --&gt; adder/src/main.rs:1:1
  |
1 | extern crate rand;
</code></pre>
<!--
To fix this, edit the *Cargo.toml* file for the `adder` crate and indicate that
`rand` is a dependency for that crate as well. Building the `adder` crate will
add `rand` to the list of dependencies for `adder` in *Cargo.lock*, but no
additional copies of `rand` will be downloaded. Cargo has ensured that any
crate in the workspace using the `rand` crate will be using the same version.
Using the same version of `rand` across the workspace saves space because we
won’t have multiple copies and ensures that the crates in the workspace will be
compatible with each other.
-->
<p>これを修正するには、<code>adder</code>クレートの<em>Cargo.toml</em>ファイルを編集し、同様にそのクレートが<code>rand</code>に依存していることを示してください。
<code>adder</code>クレートをビルドすると、<code>rand</code>を<em>Cargo.lock</em>の<code>adder</code>の依存一覧に追加しますが、
<code>rand</code>のファイルが追加でダウンロードされることはありません。Cargoが、ワークスペースの<code>rand</code>を使用するどのクレートも、
同じバージョンを使っていることを確かめてくれるのです。ワークスペース全体で<code>rand</code>の同じバージョンを使用することにより、
複数のコピーが存在しないのでスペースを節約し、ワークスペースのクレートが相互に互換性を維持することを確かめます。</p>
<!--
#### Adding a Test to a Workspace
-->
<h4 id="ワークスペースにテストを追加する"><a class="header" href="#ワークスペースにテストを追加する">ワークスペースにテストを追加する</a></h4>
<!--
For another enhancement, let’s add a test of the `add_one::add_one` function
within the `add_one` crate:
-->
<p>さらなる改善として、<code>add_one</code>クレート内に<code>add_one::add_one</code>関数のテストを追加しましょう:</p>
<!--
<span class="filename">Filename: add-one/src/lib.rs</span>
-->
<p><span class="filename">ファイル名: add-one/src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
Now run `cargo test` in the top-level *add* directory:
-->
<p>では、最上位の<em>add</em>ディレクトリで<code>cargo test</code>を実行してください:</p>
<pre><code class="language-text">$ cargo test
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/adder-f88af9d2cc175a5e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
The first section of the output shows that the `it_works` test in the `add-one`
crate passed. The next section shows that zero tests were found in the `adder`
crate, and then the last section shows zero documentation tests were found in
the `add-one` crate. Running `cargo test` in a workspace structured like this
one will run the tests for all the crates in the workspace.
-->
<p>出力の最初の区域が、<code>add-one</code>クレートの<code>it_works</code>テストが通ったことを示しています。
次の区域には、<code>adder</code>クレートにはテストが見つからなかったことが示され、
さらに最後の区域には、<code>add-one</code>クレートにドキュメンテーションテストは見つからなかったと表示されています。
このような構造をしたワークスペースで<code>cargo test</code>を走らせると、ワークスペースの全クレートのテストを実行します。</p>
<!--
We can also run tests for one particular crate in a workspace from the
top-level directory by using the `-p` flag and specifying the name of the crate
we want to test:
-->
<p><code>-p</code>フラグを使用し、テストしたいクレートの名前を指定することで最上位ディレクトリから、
ワークスペースのある特定のクレート用のテストを実行することもできます:</p>
<pre><code class="language-text">$ cargo test -p add-one
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<!--
This output shows `cargo test` only ran the tests for the `add-one` crate and
didn’t run the `adder` crate tests.
-->
<p>この出力は、<code>cargo test</code>が<code>add-one</code>クレートのテストのみを実行し、<code>adder</code>クレートのテストは実行しなかったことを示しています。</p>
<!--
If you publish the crates in the workspace to *https://crates.io/*, each crate
in the workspace will need to be published separately. The `cargo publish`
command does not have an `--all` flag or a `-p` flag, so you must change to
each crate’s directory and run `cargo publish` on each crate in the workspace
to publish the crates.
-->
<p>ワークスペースのクレートを <em>https://crates.io/</em> に公開したら、ワークスペースのクレートは個別に公開される必要があります。
<code>cargo publish</code>コマンドには<code>--all</code>フラグや<code>-p</code>フラグはないので、各クレートのディレクトリに移動して、
ワークスペースの各クレートを<code>cargo publish</code>して、公開しなければなりません。</p>
<!--
For additional practice, add an `add-two` crate to this workspace in a similar
way as the `add-one` crate!
-->
<p>鍛錬を積むために、<code>add-one</code>クレートと同様の方法でワークスペースに<code>add-two</code>クレートを追加してください！</p>
<!--
As your project grows, consider using a workspace: it’s easier to understand
smaller, individual components than one big blob of code. Furthermore, keeping
the crates in a workspace can make coordination between them easier if they are
often changed at the same time.
-->
<p>プロジェクトが肥大化してきたら、ワークスペースの使用を考えてみてください: 大きな一つのコードの塊よりも、
微細で個別のコンポーネントの方が理解しやすいです。またワークスペースにクレートを保持することは、
同時に変更されることが多いのなら、協調しやすくなることにも繋がります。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Installing Binaries from Crates.io with `cargo install`
-->
<h2 id="cargo-installでcratesioからバイナリをインストールする"><a class="header" href="#cargo-installでcratesioからバイナリをインストールする"><code>cargo install</code>でCrates.ioからバイナリをインストールする</a></h2>
<!--
The `cargo install` command allows you to install and use binary crates
locally. This isn’t intended to replace system packages; it’s meant to be a
convenient way for Rust developers to install tools that others have shared on
[crates.io](https://crates.io). Note that you can only install
packages that have binary targets. A binary target is the runnable program
that is created if the crate has a *src/main.rs* file or another file specified
as a binary, as opposed to a library target that isn’t runnable on its own but
is suitable for including within other programs. Usually, crates have
information in the *README* file about whether a crate is a library, has a
binary target, or both.
-->
<p><code>cargo install</code>コマンドにより、バイナリクレートをローカルにインストールし、使用することができます。
これは、システムパッケージを置き換えることを意図したものではありません。<ruby>即<rp>(</rp><rt>すなわ</rt><rp>)</rp></ruby>ち、
Rustの開発者が、他人が<a href="https://crates.io">crates.io</a>に共有したツールをインストールするのに便利な方法を意味するのです。
バイナリターゲットを持つパッケージのみインストールできることに注意してください。バイナリターゲットとは、
クレートが<em>src/main.rs</em>ファイルやバイナリとして指定された他のファイルを持つ場合に生成される実行可能なプログラムのことであり、
単独では実行不可能なものの、他のプログラムに含むのには適しているライブラリターゲットとは一線を画します。
通常、クレートには、<em>README</em>ファイルに、クレートがライブラリかバイナリターゲットか、両方をもつかという情報があります。</p>
<!--
All binaries installed with `cargo install` are stored in the installation
root’s *bin* folder. If you installed Rust using `rustup` and don’t have any
custom configurations, this directory will be *$HOME/.cargo/bin*. Ensure that
directory is in your `$PATH` to be able to run programs you’ve installed with
`cargo install`.
-->
<p><code>cargo install</code>でインストールされるバイナリは全て、インストールのルートの<em>bin</em>フォルダに保持されます。
Rustを<code>rustup</code>を使用し、独自の設定を何も行なっていなければ、このディレクトリは、<em>$HOME/.cargo/bin</em>になります。
<code>cargo install</code>でインストールしたプログラムを実行できるようにするためには、そのディレクトリが<code>$PATH</code>に含まれていることを確かめてください。</p>
<!--
For example, in Chapter 12 we mentioned that there’s a Rust implementation of
the `grep` tool called `ripgrep` for searching files. If we want to install
`ripgrep`, we can run the following:
-->
<p>例えば、第12章で、ファイルを検索する<code>ripgrep</code>という<code>grep</code>ツールのRust版があることに触れました。
<code>ripgrep</code>をインストールしたかったら、以下を実行することができます:</p>
<pre><code class="language-text">$ cargo install ripgrep
Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading ripgrep v0.3.2
 --snip--
   Compiling ripgrep v0.3.2
    Finished release [optimized + debuginfo] target(s) in 97.91 secs
  Installing ~/.cargo/bin/rg
</code></pre>
<!--
The last line of the output shows the location and the name of the installed
binary, which in the case of `ripgrep` is `rg`. As long as the installation
directory is in your `$PATH`, as mentioned previously, you can then run `rg
--help` and start using a faster, rustier tool for searching files!
-->
<p>出力の最後の行が、インストールされたバイナリの位置と名前を示していて、<code>ripgrep</code>の場合、<code>rg</code>です。
インストールディレクトリが<code>$PATH</code>に存在する限り、前述したように、<code>rg --help</code>を走らせて、
より高速でRustらしいファイル検索ツールを使用し始めることができます！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Extending Cargo with Custom Commands
-->
<h2 id="独自のコマンドでcargoを拡張する"><a class="header" href="#独自のコマンドでcargoを拡張する">独自のコマンドでCargoを拡張する</a></h2>
<!--
Cargo is designed so you can extend it with new subcommands without having to
modify Cargo. If a binary in your `$PATH` is named `cargo-something`, you can
run it as if it was a Cargo subcommand by running `cargo something`. Custom
commands like this are also listed when you run `cargo --list`. Being able to
use `cargo install` to install extensions and then run them just like the
built-in Cargo tools is a super convenient benefit of Cargo’s design!
-->
<p>Cargoは変更する必要なく、新しいサブコマンドで拡張できるように設計されています。
<code>$PATH</code>にあるバイナリが<code>cargo-something</code>という名前なら、<code>cargo something</code>を実行することで、
Cargoのサブコマンドであるかのように実行することができます。このような独自のコマンドは、
<code>cargo --list</code>を実行すると、列挙もされます。<code>cargo install</code>を使用して拡張をインストールし、
それから組み込みのCargoツール同様に実行できることは、Cargoの設計上の非常に便利な恩恵です！</p>
<!--
## Summary
-->
<h2 id="まとめ-13"><a class="header" href="#まとめ-13">まとめ</a></h2>
<!--
Sharing code with Cargo and [crates.io](https://crates.io) is
part of what makes the Rust ecosystem useful for many different tasks. Rust’s
standard library is small and stable, but crates are easy to share, use, and
improve on a timeline different from that of the language. Don’t be shy about
sharing code that’s useful to you on [crates.io](https://crates.io);
it’s likely that it will be useful to someone else as well!
-->
<p>Cargoで<a href="https://crates.io">crates.io</a>とコードを共有することは、
Rustのエコシステムを多くの異なる作業に有用にするものの一部です。Rustの標準ライブラリは、
小さく安定的ですが、クレートは共有および使用しやすく、言語とは異なるタイムラインで進化します。
積極的に<a href="https://crates.io">crates.io</a>で自分にとって有用なコードを共有してください;
他の誰かにとっても、役に立つものであることでしょう！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Smart Pointers
-->
<h1 id="スマートポインタ"><a class="header" href="#スマートポインタ">スマートポインタ</a></h1>
<!--
A *pointer* is a general concept for a variable that contains an address in
memory. This address refers to, or “points at,” some other data. The most
common kind of pointer in Rust is a reference, which you learned about in
Chapter 4. References are indicated by the `&` symbol and borrow the value they
point to. They don’t have any special capabilities other than referring to
data. Also, they don’t have any overhead and are the kind of pointer we use
most often.
-->
<p><em>ポインタ</em>は、メモリのアドレスを含む変数の一般的な概念です。このアドレスは、何らかの他のデータを参照、または「指します」。
Rustにおいて最もありふれた種類のポインタは参照です。参照については第4章で習いましたね。参照は<code>&amp;</code>記号で示唆され、指している値を借用します。データを参照すること以外に特別な能力は何もありません。
また、オーバーヘッドもなく、ポインタの中では最も頻繁に使われます。</p>
<!--
*Smart pointers*, on the other hand, are data structures that not only act like
a pointer but also have additional metadata and capabilities. The concept of
smart pointers isn’t unique to Rust: smart pointers originated in C++ and exist
in other languages as well. In Rust, the different smart pointers defined in
the standard library provide functionality beyond that provided by references.
One example that we’ll explore in this chapter is the *reference counting*
smart pointer type. This pointer enables you to have multiple owners of data by
keeping track of the number of owners and, when no owners remain, cleaning up
the data.
-->
<p>一方、<em>スマートポインタ</em>は、ポインタのように振る舞うだけでなく、追加のメタデータと能力があるデータ構造です。
スマートポインタという概念は、Rustに特有のものではありません。スマートポインタは、C++に端を発し、
他の言語にも存在しています。Rustでは、標準ライブラリに定義された色々なスマートポインタが、
参照以上の機能を提供します。この章で探究する一つの例が、<em>参照カウント</em>方式のスマートポインタ型です。
このポインタのおかげでデータに複数の所有者を持たせることができます。
所有者の数を追いかけ、所有者がいなくなったらデータの片付けをしてくれるからです。</p>
<!--
In Rust, which uses the concept of ownership and borrowing, an additional
difference between references and smart pointers is that references are
pointers that only borrow data; in contrast, in many cases, smart pointers
*own* the data they point to.
-->
<p>所有権と借用の概念を使うRustにおいて、参照とスマートポインタにはもう1つ違いがあります。参照はデータを借用するだけのポインタなのです。
対照的に多くの場合、スマートポインタは指しているデータを<em>所有</em>します。</p>
<!--
We’ve already encountered a few smart pointers in this book, such as `String`
and `Vec<T>` in Chapter 8, although we didn’t call them smart pointers at the
time. Both these types count as smart pointers because they own some memory and
allow you to manipulate it. They also have metadata (such as their capacity)
and extra capabilities or guarantees (such as with `String` ensuring its data
will always be valid UTF-8).
-->
<p>私達はすでに、この本の中でいくつかのスマートポインタに遭遇してきました。例えば第8章の<code>String</code>や<code>Vec&lt;T&gt;</code>です。ただし、私達はそれらをスマートポインタとは呼んでいませんでした。
これらの型がどちらもスマートポインタに数えられるのは、あるメモリを所有しそれを弄ることができるからです。
また、メタデータ（キャパシティなど）や追加の能力、あるいは保証（<code>String</code>ならデータが常に有効なUTF-8であると保証することなど）もあります。</p>
<!--
Smart pointers are usually implemented using structs. The characteristic that
distinguishes a smart pointer from an ordinary struct is that smart pointers
implement the `Deref` and `Drop` traits. The `Deref` trait allows an instance
of the smart pointer struct to behave like a reference so you can write code
that works with either references or smart pointers. The `Drop` trait allows
you to customize the code that is run when an instance of the smart pointer
goes out of scope. In this chapter, we’ll discuss both traits and demonstrate
why they’re important to smart pointers.
-->
<p>スマートポインタは普通、構造体を使用して実装されています。スマートポインタを通常の構造体と区別する特徴は、
スマートポインタが<code>Deref</code>と<code>Drop</code>トレイトを実装していることです。<code>Deref</code>トレイトにより、スマートポインタ構造体のインスタンスは、
参照のように振る舞うことができるので、参照あるいはスマートポインタのどちらとも動作するコードを書くことができます。
<code>Drop</code>トレイトにより、スマートポインタのインスタンスがスコープを外れた時に走るコードをカスタマイズすることができます。
この章では、どちらのトレイトについても議論し、これらのトレイトがスマートポインタにとって重要な理由を説明します。</p>
<!--
Given that the smart pointer pattern is a general design pattern used
frequently in Rust, this chapter won’t cover every existing smart pointer. Many
libraries have their own smart pointers, and you can even write your own. We’ll
cover the most common smart pointers in the standard library:
-->
<p>スマートポインタパターンがRustにおいてよく使われる一般的なデザインパターンであることを考えれば、この章で既存のスマートポインタを全て取り扱うことなどできません。
多くのライブラリに独自のスマートポインタがあり、自分だけのスマートポインタを書くことさえできるのです。
ここでは標準ライブラリの最もありふれたスマートポインタを取り扱っていきます。</p>
<!--
* `Box<T>` for allocating values on the heap
* `Rc<T>`, a reference counting type that enables multiple ownership
* `Ref<T>` and `RefMut<T>`, accessed through `RefCell<T>`, a type that enforces
the borrowing rules at runtime instead of compile time
-->
<ul>
<li>ヒープに値を確保する<code>Box&lt;T&gt;</code></li>
<li>複数の所有権を可能にする参照カウント型の<code>Rc&lt;T&gt;</code></li>
<li><code>RefCell&lt;T&gt;</code>を通してアクセスされ、コンパイル時ではなく実行時に借用規則を強制する型の<code>Ref&lt;T&gt;</code>と<code>RefMut&lt;T&gt;</code></li>
</ul>
<!--
In addition, we’ll cover the *interior mutability* pattern where an immutable
type exposes an API for mutating an interior value. We’ll also discuss
*reference cycles*: how they can leak memory and how to prevent them.
-->
<p>さらに、<em>内部可変性</em>パターンも扱います。そこでは不変な型が、内部の値を変更するためのAPIを公開するのです。
また、<em>循環参照</em>についても議論します。つまり、循環参照によっていかにしてメモリがリークするのか、そしてどうやってそれを回避するのかを議論します。</p>
<!--
Let’s dive in!
-->
<p>さあ、飛び込みましょう！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Using `Box<T>` to Point to Data on the Heap
-->
<h2 id="ヒープのデータを指すboxtを使用する"><a class="header" href="#ヒープのデータを指すboxtを使用する">ヒープのデータを指す<code>Box&lt;T&gt;</code>を使用する</a></h2>
<!--
The most straightforward smart pointer is a *box*, whose type is written
`Box<T>`. Boxes allow you to store data on the heap rather than the stack. What
remains on the stack is the pointer to the heap data. Refer to Chapter 4 to
review the difference between the stack and the heap.
-->
<p>最も素直なスマートポインタは<em>ボックス</em>であり、その型は<code>Box&lt;T&gt;</code>と記述されます。
ボックスにより、スタックではなくヒープにデータを格納することができます。スタックに残るのは、
ヒープデータへのポインタです。スタックとヒープの違いを再確認するには、第4章を参照されたし。</p>
<!--
Boxes don’t have performance overhead, other than storing their data on the
heap instead of on the stack. But they don’t have many extra capabilities
either. You’ll use them most often in these situations:
-->
<p>ボックスは、データをスタックの代わりにヒープに格納する以外は、パフォーマンスのオーバーヘッドはありません。
しかし、特別な能力がたくさんあるわけでもありません。以下のような場面で最もよく使われるでしょう。</p>
<!--
* When you have a type whose size can’t be known at compile time and you want
to use a value of that type in a context that requires an exact size
* When you have a large amount of data and you want to transfer ownership but
ensure the data won’t be copied when you do so
* When you want to own a value and you care only that it’s a type that
implements a particular trait rather than being of a specific type
-->
<ul>
<li>コンパイル時にはサイズを知ることができない型があり、正確なサイズを要求する文脈でその型の値を使用する時</li>
<li>多くのデータがあり、その所有権を移したいが、その際にデータがコピーされないようにしたい時</li>
<li>値を所有する必要があり、特定の型であることではなく、特定のトレイトを実装する型であることのみ気にかけている時</li>
</ul>
<!--
最後の行がよくわからない。what ... (that) you'll apply ... なのか？
辞書には文の先頭に用いて強調する用法があると書かれているので、これのことと思われる
-->
<!--
We’ll demonstrate the first situation in the “Enabling Recursive Types with
Boxes” section. In the second case, transferring ownership of a large amount of
data can take a long time because the data is copied around on the stack. To
improve performance in this situation, we can store the large amount of data on
the heap in a box. Then, only the small amount of pointer data is copied around
on the stack, while the data it references stays in one place on the heap. The
third case is known as a *trait object*, and Chapter 17 devotes an entire
section, “Using Trait Objects That Allow for Values of Different Types,” just
to that topic. So what you learn here you’ll apply again in Chapter 17!
-->
<p>「ボックスで再帰的な型を可能にする」節で1つ目の場合について実際に説明します。
2番目の場合、多くのデータの所有権を転送するには、データがスタック上でコピーされるので、長い時間がかかり得ます。
この場面でパフォーマンスを向上させるために、多くのデータをヒープ上にボックスとして格納することができます。
そして、小さなポインタのデータのみがスタック上でコピーされる一方、それが参照しているデータはヒープ上の1箇所に留まります。
3番目のケースは<em>トレイトオブジェクト</em>として知られています。第17章の「トレイトオブジェクトで異なる型の値を許容する」の節は、
すべてその話題に捧げられています。
従って、ここで学ぶことは第17章でもまた使うことになります！</p>
<!--
### Using a `Box<T>` to Store Data on the Heap
-->
<h3 id="boxtを使ってヒープにデータを格納する"><a class="header" href="#boxtを使ってヒープにデータを格納する"><code>Box&lt;T&gt;</code>を使ってヒープにデータを格納する</a></h3>
<!--
Before we discuss this use case for `Box<T>`, we’ll cover the syntax and how to
interact with values stored within a `Box<T>`.
-->
<p><code>Box&lt;T&gt;</code>のこのユースケースを議論する前に、<code>Box&lt;T&gt;</code>の記法と、<code>Box&lt;T&gt;</code>内に格納された値を読み書きする方法について講義しましょう。</p>
<!--
Listing 15-1 shows how to use a box to store an `i32` value on the heap:
-->
<p>リスト15-1は、ボックスを使用してヒープに<code>i32</code>の値を格納する方法を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-1: Storing an `i32` value on the heap using a
box</span>
-->
<p><span class="caption">リスト15-1: ボックスを使用して<code>i32</code>の値をヒープに格納する</span></p>
<!--
We define the variable `b` to have the value of a `Box` that points to the
value `5`, which is allocated on the heap. This program will print `b = 5`; in
this case, we can access the data in the box similar to how we would if this
data was on the stack. Just like any owned value, when a box goes out of
scope, as `b` does at the end of `main`, it will be deallocated. The
deallocation happens for the box (stored on the stack) and the data it points
to (stored on the heap).
-->
<p>変数<code>b</code>を定義して<code>Box</code>の値を保持します。<code>Box</code>は値<code>5</code>を指し、値<code>5</code>はヒープに確保されています。このプログラムは、<code>b = 5</code>と出力するでしょう。つまりこの場合、このデータがスタックにあるのと同じような方法でボックスのデータにアクセスできます。
所有された値と全く同じでスコープを抜けるとき、実際<code>b</code>は<code>main</code>の終わりで抜けるのですが、
ボックスはメモリから解放されます。メモリの解放は（スタックに格納されている）ボックスと（ヒープに格納されている）指しているデータに対して起きます。</p>
<!--
Putting a single value on the heap isn’t very useful, so you won’t use boxes by
themselves in this way very often. Having values like a single `i32` on the
stack, where they’re stored by default, is more appropriate in the majority of
situations. Let’s look at a case where boxes allow us to define types that we
wouldn’t be allowed to if we didn’t have boxes.
-->
<p>ヒープに単独の値を置いても嬉しいことはほとんどないので、このように単独でボックスを使用することはあまりありません。
単独の<code>i32</code>のような値はデフォルトではスタックに置かれます。ほとんどの場合ではその方が適切です。
ボックスのおかげで定義できるようになる型を見てみましょう。ボックスがなければそれらの型は定義できません。</p>
<!--
### Enabling Recursive Types with Boxes
-->
<h3 id="ボックスで再帰的な型を可能にする"><a class="header" href="#ボックスで再帰的な型を可能にする">ボックスで再帰的な型を可能にする</a></h3>
<!--
At compile time, Rust needs to know how much space a type takes up. One type
whose size can’t be known at compile time is a *recursive type*, where a value
can have as part of itself another value of the same type. Because this nesting
of values could theoretically continue infinitely, Rust doesn’t know how much
space a value of a recursive type needs. However, boxes have a known size, so
by inserting a box in a recursive type definition, you can have recursive types.
-->
<p>コンパイル時にコンパイラが知っておかねばならないのは、ある型が占有する領域の大きさです。コンパイル時にサイズがわからない型の1つ
として
<em>再帰的な型</em>があります。この型の値は、値の一部として同じ型の他の値を持つ場合があります。値のこうしたネストは、理論的には無限に続く可能性があるので、コンパイラは再帰的な型の値が必要とする領域を知ることができないのです。
しかしながら、ボックスのサイズはわかっているので、再帰的な型の定義にボックスを挟むことで再帰的な型を作ることができます。</p>
<!--
Let’s explore the *cons list*, which is a data type common in functional
programming languages, as an example of a recursive type. The cons list type
we’ll define is straightforward except for the recursion; therefore, the
concepts in the example we’ll work with will be useful any time you get into
more complex situations involving recursive types.
-->
<p><em>コンスリスト</em>は関数型プログラミング言語では一般的なデータ型ですが、これを再帰的な型の例として探究しましょう。
我々が定義するコンスリストは、再帰を除けば素直です。故に、これから取り掛かる例に現れる概念は、
再帰的な型が関わるもっと複雑な場面に遭遇したときには必ず役に立つでしょう。</p>
<!--
#### More Information About the Cons List
-->
<h4 id="コンスリストについてもっと詳しく"><a class="header" href="#コンスリストについてもっと詳しく">コンスリストについてもっと詳しく</a></h4>
<!--
A *cons list* is a data structure that comes from the Lisp programming language
and its dialects. In Lisp, the `cons` function (short for “construct function”)
constructs a new pair from its two arguments, which usually are a single value
and another pair. These pairs containing pairs form a list.
-->
<p>コンスリストは、Lispプログラミング言語とその方言に由来するデータ構造です。Lispでは、
<code>cons</code>関数（&quot;construct function&quot;の省略形です）は2つの引数から新しいペアを構成します。
この引数は通常、単独の値と別のペアからなります。これらのペアを含むペアがリストをなすのです。</p>
<!--
The cons function concept has made its way into more general functional
programming jargon: “to cons *x* onto *y*” informally means to construct a new
container instance by putting the element *x* at the start of this new
container, followed by the container *y*.
-->
<p>cons関数という概念は、より一般的な関数型プログラミングの俗語にもなっています。&quot;to cons <em>x</em> onto <em>y</em>&quot;はコンテナ<em>y</em>の先頭に要素<em>x</em>を置くことで新しいコンテナのインスタンスを生成することを意味します。</p>
<!--
Each item in a cons list contains two elements: the value of the current item
and the next item. The last item in the list contains only a value called `Nil`
without a next item. A cons list is produced by recursively calling the `cons`
function. The canonical name to denote the base case of the recursion is `Nil`.
Note that this is not the same as the “null” or “nil” concept in Chapter 6,
which is an invalid or absent value.
-->
<p>コンスリストの各要素は、2つの要素を含みます。現在の要素の値と次の要素です。リストの最後の要素は、
<code>Nil</code>と呼ばれる値だけを含み、次の要素を持ちません。コンスリストは、繰り返し<code>cons</code>関数を呼び出すことで生成されます。
繰り返しの基底ケースを示すのに標準的に使われる名前は<code>Nil</code>です。これは第6章の&quot;null&quot;や&quot;nil&quot;の概念とは異なることに注意してください。
&quot;null&quot;や&quot;nil&quot;は、無効だったり存在しない値です。</p>
<!--
Although functional programming languages use cons lists frequently, the cons
list isn't a commonly used data structure in Rust. Most of the time when you
have a list of items in Rust, `Vec<T>` is a better choice to use. Other, more
complext recursive data types *are* useful in various situations, but by
starting with the cons list, we can explore how boxes let us define a recursive
data type without much distraction.
-->
<p>関数型プログラミング言語ではコンスリストは頻繁に使われますが、Rustではあまり使用されないデータ構造です。
Rustで要素のリストがあるときはほとんど、<code>Vec&lt;T&gt;</code>を使用するのがよりよい選択になります。
より複雑な他の再帰的なデータ型は様々な場面で役に立ち<em>ます</em>。しかしコンスリストから始めることで、
ボックスのおかげで再帰的なデータ型を定義できるわけを、あまり気を散らすことなく調べることができるのです。</p>
<!--
Listing 15-2 contains an enum definition for a cons list. Note that this code
won’t compile yet because the `List` type doesn’t have a known size, which
we’ll demonstrate.
-->
<p>リスト15-2には、コンスリストのenum定義が含まれています。このコードはまだコンパイルできないことに注意してください。
<code>List</code>型のサイズが分からないからです。
これについてはこの後説明します。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, List),
    Nil,
}
</code></pre>
<!--
<span class="caption">Listing 15-2: The first attempt at defining an enum to
represent a cons list data structure of `i32` values</span>
-->
<p><span class="caption">リスト15-2: <code>i32</code>値のコンスリストデータ構造を表すenumを定義する最初の試行</span></p>
<!--
Note: We’re implementing a cons list that holds only `i32` values for the
purposes of this example. We could have implemented it using generics, as we
discussed in Chapter 10, to define a cons list type that could store values of
any type.
-->
<blockquote>
<p>注釈: この例のために<code>i32</code>値だけを保持するコンスリストを実装します。第10章で議論したように、
ジェネリクスを使用してどんな型の値も格納できるコンスリストを定義して実装することもできたでしょう。</p>
</blockquote>
<!--
Using the `List` type to store the list `1, 2, 3` would look like the code in
Listing 15-3:
-->
<p>この<code>List</code>型を使用してリスト<code>1, 2, 3</code>を格納すると、リスト15-3のコードのような見た目になるでしょう。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<!--
<span class="caption">Listing 15-3: Using the `List` enum to store the list `1,
2, 3`</span>
-->
<p><span class="caption">リスト15-3: <code>List</code> enumを使用してリスト<code>1, 2, 3</code>を格納する</span></p>
<!--
The first `Cons` value holds `1` and another `List` value. This `List` value is
another `Cons` value that holds `2` and another `List` value. This `List` value
is one more `Cons` value that holds `3` and a `List` value, which is finally
`Nil`, the non-recursive variant that signals the end of the list.
-->
<p>最初の<code>Cons</code>値は、<code>1</code>と別の<code>List</code>値を保持しています。この<code>List</code>値は別の<code>Cons</code>値で、
<code>2</code>とまた別の<code>List</code>値を保持しています。この<code>List</code>値はまたまた別の<code>Cons</code>値で、
<code>3</code>と<code>List</code>値を保持していますが、この<code>List</code>値でついに<code>Nil</code>になります。<code>Nil</code>はリストの終端を通知する非再帰的な列挙子です。</p>
<!--
If we try to compile the code in Listing 15-3, we get the error shown in
Listing 15-4:
-->
<p>リスト15-3のコードをコンパイルしようとすると、リスト15-4に示したエラーが出ます。</p>
<pre><code class="language-text">error[E0072]: recursive type `List` has infinite size
(エラー: 再帰的な型`List`は無限のサイズです)
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ----- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
  (助言: 間接参照(例: `Box`、`Rc`、あるいは`&amp;`)をどこかに挿入して、`List`を表現可能にしてください)
</code></pre>
<!--
<span class="caption">Listing 15-4: The error we get when attempting to define
a recursive enum</span>
-->
<p><span class="caption">リスト15-4: 再帰的なenumを定義しようとすると得られるエラー</span></p>
<!--
The error shows this type “has infinite size.” The reason is that we’ve defined
`List` with a variant that is recursive: it holds another value of itself
directly. As a result, Rust can’t figure out how much space it needs to store a
`List` value. Let’s break down why we get this error a bit. First, let’s look
at how Rust decides how much space it needs to store a value of a non-recursive
type.
-->
<p>エラーは、この型は「無限のサイズである」と表示しています。理由は、再帰的な列挙子を含む<code>List</code>を定義したからです。
つまり、<code>List</code>は自身の別の値を直接保持しているのです。結果として、コンパイラは<code>List</code>値を格納するのに必要な領域が計算できません。
このエラーが出た理由を少し噛み砕きましょう。まず、非再帰的な型の値を格納するのに必要な領域をどうコンパイラが決定しているかを見ましょう。</p>
<!--
#### Computing the Size of a Non-Recursive Type
-->
<h4 id="非再帰的な型のサイズを計算する"><a class="header" href="#非再帰的な型のサイズを計算する">非再帰的な型のサイズを計算する</a></h4>
<!--
Recall the `Message` enum we defined in Listing 6-2 when we discussed enum
definitions in Chapter 6:
-->
<p>第6章でenum定義を議論した時にリスト6-2で定義した<code>Message</code> enumを思い出してください。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">}
</span></code></pre></pre>
<!--
To determine how much space to allocate for a `Message` value, Rust goes
through each of the variants to see which variant needs the most space. Rust
sees that `Message::Quit` doesn’t need any space, `Message::Move` needs enough
space to store two `i32` values, and so forth. Because only one variant will be
used, the most space a `Message` value will need is the space it would take to
store the largest of its variants.
-->
<p><code>Message</code>値一つにメモリを確保するために必要な領域を決定するために、コンパイラは、
各列挙子を見てどの列挙子が最も領域を必要とするかを確認します。コンパイラは、
<code>Message::Quit</code>は全く領域を必要とせず、<code>Message::Move</code>は<code>i32</code>値を2つ格納するのに十分な領域が必要、などと確かめます。
ただ1つの列挙子しか使用されないので、<code>Message</code>値一つが必要とする最大の領域は、
最大の列挙子を格納するのに必要になる領域です。</p>
<!--
Contrast this with what happens when Rust tries to determine how much space a
recursive type like the `List` enum in Listing 15-2 needs. The compiler starts
by looking at the `Cons` variant, which holds a value of type `i32` and a value
of type `List`. Therefore, `Cons` needs an amount of space equal to the size of
an `i32` plus the size of a `List`. To figure out how much memory the `List`
type needs, the compiler looks at the variants, starting with the `Cons`
variant. The `Cons` variant holds a value of type `i32` and a value of type
`List`, and this process continues infinitely, as shown in Figure 15-1.
-->
<p>これをコンパイラがリスト15-2の<code>List</code> enumのような再帰的な型が必要とする領域を決定しようとする時に起こることと比較してください。
コンパイラは<code>Cons</code>列挙子を見ることから始めます。この列挙子には、型<code>i32</code>値が一つと型<code>List</code>の値が一つ保持されます。
故に、<code>Cons</code>は1つの<code>i32</code>と<code>List</code>のサイズに等しい領域を必要とします。<code>List</code>が必要とするメモリ量を計算するのに、
コンパイラは<code>Cons</code>列挙子から列挙子を観察します。<code>Cons</code>列挙子は型<code>i32</code>を1つと型<code>List</code>の値1つを保持し、
この過程は無限に続きます。図15-1のようにですね。</p>
<!--
<img alt="An infinite Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
-->
<img alt="無限のコンスリスト" src="img/trpl15-01.svg" class="center" style="width: 50%;" />
<!--
<span class="caption">Figure 15-1: An infinite `List` consisting of infinite
`Cons` variants</span>
-->
<p><span class="caption">図15-1: 無限の<code>Cons</code>列挙子からなる無限の<code>List</code></span></p>
<!--
#### Using `Box<T>` to Get a Recursive Type with a Known Size
-->
<h4 id="boxtで既知のサイズの再帰的な型を得る"><a class="header" href="#boxtで既知のサイズの再帰的な型を得る"><code>Box&lt;T&gt;</code>で既知のサイズの再帰的な型を得る</a></h4>
<!--
Rust can’t figure out how much space to allocate for recursively defined types,
so the compiler gives the error in Listing 15-4. But the error does include
this helpful suggestion:
-->
<p>コンパイラは、再帰的に定義された型に必要なメモリ量を計算できないので、リスト15-4ではエラーを返します。
しかし、エラーにはこんな役立つ提案が含まれているのです。</p>
<pre><code class="language-text">  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
</code></pre>
<!--
In this suggestion, “indirection” means that instead of storing a value
directly, we’ll change the data structure to store the value indirectly by
storing a pointer to the value instead.
-->
<p>この提案において「間接参照」は、値を直接格納するのではなく、データ構造を変更して値を間接的に格納することを意味します。これは値の代わりに値へのポインタを格納することによって可能になります。</p>
<!--
Because a `Box<T>` is a pointer, Rust always knows how much space a `Box<T>`
needs: a pointer’s size doesn’t change based on the amount of data it’s
pointing to. This means we can put a `Box<T>` inside the `Cons` variant instead
of another `List` value directly. The `Box<T>` will point to the next `List`
value that will be on the heap rather than inside the `Cons` variant.
Conceptually, we still have a list, created with lists “holding” other lists,
but this implementation is now more like placing the items next to one another
rather than inside one another.
-->
<p><code>Box&lt;T&gt;</code>はポインタなので、コンパイラには<code>Box&lt;T&gt;</code>が必要とする領域が必ずわかります。すなわち、ポインタのサイズは指しているデータの量に左右されません。つまり、別の<code>List</code>値を直接置く代わりに、
<code>Cons</code>列挙子の中に<code>Box&lt;T&gt;</code>を配置することができます。<code>Box&lt;T&gt;</code>は、
<code>Cons</code>列挙子の中ではなく、ヒープに置かれる次の<code>List</code>値を指します。概念的には、
依然として我々のリストは他のリストを「保持する」リストによって作られたものです。
しかし、今やこの実装は、要素をお互いの中に配置するというより、隣り合うように配置するような感じになります。</p>
<!--
We can change the definition of the `List` enum in Listing 15-2 and the usage
of the `List` in Listing 15-3 to the code in Listing 15-5, which will compile:
-->
<p>リスト15-2の<code>List</code> enumの定義とリスト15-3の<code>List</code>の使用をリスト15-5のコードに変更することができ、
これはコンパイルが通ります。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-5: Definition of `List` that uses `Box<T>` in
order to have a known size</span>
-->
<p><span class="caption">リスト15-5: 既知のサイズにするために<code>Box&lt;T&gt;</code>を使用する<code>List</code>の定義</span></p>
<!--
The `Cons` variant will need the size of an `i32` plus the space to store the
box’s pointer data. The `Nil` variant stores no values, so it needs less space
than the `Cons` variant. We now know that any `List` value will take up the
size of an `i32` plus the size of a box’s pointer data. By using a box, we’ve
broken the infinite, recursive chain, so the compiler can figure out the size
it needs to store a `List` value. Figure 15-2 shows what the `Cons` variant
looks like now.
-->
<p><code>Cons</code>列挙子は、1つの<code>i32</code>のサイズに加えてボックスのポインタデータを格納する領域を必要とするでしょう。
<code>Nil</code>列挙子は値を格納しないので、<code>Cons</code>列挙子よりも必要な領域は小さいです。これで、
どんな<code>List</code>値も<code>i32</code>1つのサイズに加えてボックスのポインタデータのサイズを必要とすることがわかりました。
ボックスを使うことで無限に続く再帰の連鎖を断ち切ったので、コンパイラは<code>List</code>値を格納するのに必要なサイズを計算できます。
図15-2は、<code>Cons</code>列挙子の今の見た目を示しています。</p>
<!--
<img alt="A finite Cons list" src="img/trpl15-02.svg" class="center" />
-->
<img alt="有限のコンスリスト" src="img/trpl15-02.svg" class="center" />
<!--
<span class="caption">Figure 15-2: A `List` that is not infinitely sized
because `Cons` holds a `Box`</span>
-->
<p><span class="caption">図15-2: <code>Cons</code>が<code>Box</code>を保持しているので、無限にサイズがあるわけではない<code>List</code></span></p>
<!--
Boxes provide only the indirection and heap allocation; they don’t have any
other special capabilities, like those we’ll see with the other smart pointer
types. They also don’t have any performance overhead that these special
capabilities incur, so they can be useful in cases like the cons list where the
indirection is the only feature we need. We’ll look at more use cases for boxes
in Chapter 17, too.
-->
<p>ボックスは、間接参照とヒープメモリ確保だけを提供します。他のスマートポインタ型に見られるような別の特別な能力は何もありません。
これらの特別な能力が招くパフォーマンスのオーバーヘッドもないので、
コンスリストのように間接参照だけが必要な機能である場合には便利でしょう。
より多くのボックスのユースケースは第17章でもお見かけするでしょう。</p>
<!--
The `Box<T>` type is a smart pointer because it implements the `Deref` trait,
which allows `Box<T>` values to be treated like references. When a `Box<T>`
value goes out of scope, the heap data that the box is pointing to is cleaned
up as well because of the `Drop` trait implementation. Let’s explore these two
traits in more detail. These two traits will be even more important to the
functionality provided by the other smart pointer types we’ll discuss in the
rest of this chapter.
-->
<p><code>Box&lt;T&gt;</code>型がスマートポインタなのは、<code>Deref</code>トレイトを実装しているからです。
このトレイトにより<code>Box&lt;T&gt;</code>の値を参照のように扱うことができます。
<code>Box&lt;T&gt;</code>値がスコープを抜けると、ボックスが参照しているヒープデータも片付けられます。これは<code>Drop</code>トレイト実装のおかげです。
これら2つのトレイトをより詳しく探究しましょう。これら2つのトレイトは、他のスマートポインタ型が提供する機能にとってさらに重要なものです。それらついてはこの章の残りで議論します。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Treating Smart Pointers Like Regular References with the `Deref` Trait
-->
<h2 id="derefトレイトでスマートポインタを普通の参照のように扱う"><a class="header" href="#derefトレイトでスマートポインタを普通の参照のように扱う"><code>Deref</code>トレイトでスマートポインタを普通の参照のように扱う</a></h2>
<!--
Implementing the `Deref` trait allows you to customize the behavior of the
*dereference operator*, `*` (as opposed to the multiplication or glob
operator). By implementing `Deref` in such a way that a smart pointer can be
treated like a regular reference, you can write code that operates on
references and use that code with smart pointers too.
-->
<p><code>Deref</code>トレイトを実装することで、<em>参照外し演算子</em>の<code>*</code>（掛け算やグロブ演算子とは違います）の振る舞いをカスタマイズできます。
<code>Deref</code>を実装してスマートポインタを普通の参照みたいに扱えるようにすれば、
参照に対して処理を行うコードを書いて、そのコードをスマートポインタに対しても使うことができるのです。</p>
<!--
Let’s first look at how dereference operator works with regular references.
Then we'll try to define a custom type that behaves like `Box<T>`, and see why
the dereference operator doesn't work like a reference on our newly defined
type. We’ll explore how implementing the `Deref` trait makes it possible for
smart pointers to work in a similar way as references. Then we’ll look at
Rust’s *deref coercion* feature and how it lets us work with either references
or smart pointers.
-->
<p>まずは、参照外し演算子が普通の参照に対して動作するところを見ましょう。それから、<code>Box&lt;T&gt;</code>のように振る舞う独自の型を定義してみましょう。
参照とは異なり、新しく定義した型には参照外し演算子を使えません。その理由を確認します。
<code>Deref</code>トレイトを実装すればスマートポインタは参照と同じように機能するので、そのやり方を調べましょう。
そして、Rustには<em>参照外し型強制</em>という機能があり、その機能のおかげで参照やスマートポインタをうまく使うことができるので、それに目を向けてみましょう。</p>
<!--
### Following the Pointer to the Value with the Dereference Operator
-->
<h3 id="参照外し演算子で値までポインタを追いかける"><a class="header" href="#参照外し演算子で値までポインタを追いかける">参照外し演算子で値までポインタを追いかける</a></h3>
<!--
A regular reference is a type of pointer, and one way to think of a pointer is
as an arrow to a value stored somewhere else. In Listing 15-6, we create a
reference to an `i32` value and then use the dereference operator to follow the
reference to the data:
-->
<p>普通の参照は1種のポインタであり、ポインタはどこか他の場所に格納された値への矢印と見なすことができます。
リスト15-6では、<code>i32</code>値への参照を生成してから参照外し演算子を使ってデータまで参照を辿ります。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-6: Using the dereference operator to follow a
reference to an `i32` value</span>
-->
<p><span class="caption">リスト15-6: 参照外し演算子を使用して参照を<code>i32</code>値まで追いかける</span></p>
<!--
The variable `x` holds an `i32` value, `5`. We set `y` equal to a reference to
`x`. We can assert that `x` is equal to `5`. However, if we want to make an
assertion about the value in `y`, we have to use `*y` to follow the reference
to the value it’s pointing to (hence *dereference*). Once we dereference `y`,
we have access to the integer value `y` is pointing to that we can compare with
`5`.
-->
<p>変数<code>x</code>は<code>i32</code>値の<code>5</code>を保持しています。<code>y</code>は<code>x</code>への参照として設定します。<code>x</code>は<code>5</code>に等しいとアサートできます。
しかしながら、<code>y</code>の値に関するアサートを行いたい場合、<code>*y</code>を使用して参照が指している値まで追いかけなければなりません（そのため<em>参照外し</em>です）。
一旦<code>y</code>の参照を外せば、<code>y</code>が指している整数値にアクセスできます。これは<code>5</code>と比較可能です。</p>
<!--
If we tried to write `assert_eq!(5, y);` instead, we would get this compilation
error:
-->
<p>代わりに<code>assert_eq!(5, y);</code>と書こうとしたら、こんなコンパイルエラーが出るでしょう。</p>
<pre><code class="language-text">error[E0277]: the trait bound `{integer}: std::cmp::PartialEq&lt;&amp;{integer}&gt;` is
not satisfied
(エラー: トレイト境界`{integer}: std::cmp::PartialEq&lt;&amp;{integer}&gt;`は満たされていません)
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ can't compare `{integer}` with `&amp;{integer}`
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for
  `{integer}`
  (助言: トレイト`std::cmp::PartialEq&lt;&amp;{integer}&gt;`は`{integer}`に対して実装されていません)
</code></pre>
<!--
Comparing a number and a reference to a number isn’t allowed because they’re
different types. We must use the dereference operator to follow the reference
to the value it's pointing to.
-->
<p>数値と数値への参照の比較は許されていません。これらは異なる型だからです。参照外し演算子を使用して、
参照が指している値まで追いかけなければならないのです。</p>
<!--
### Using `Box<T>` Like a Reference
-->
<h3 id="boxtを参照のように使う"><a class="header" href="#boxtを参照のように使う"><code>Box&lt;T&gt;</code>を参照のように使う</a></h3>
<!--
We can rewrite the code in Listing 15-6 to use a `Box<T>` instead of a
reference; the dereference operator will work as shown in Listing 15-7:
-->
<p>リスト15-6のコードを、参照の代わりに<code>Box&lt;T&gt;</code>を使うように書き直すことができます。
参照外し演算子は、リスト15-7に示したように動くでしょう。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-7: Using the dereference operator on a
`Box<i32>`</span>
-->
<p><span class="caption">リスト15-7: <code>Box&lt;i32&gt;</code>に対して参照外し演算子を使用する</span></p>
<!--
The only difference between Listing 15-7 and Listing 15-6 is that here we set
`y` to be an instance of a box pointing to the value in `x` rather than a
reference pointing to the value of `x`. In the last assertion, we can use the
dereference operator to follow the box’s pointer in the same way that we did
when `y` was a reference. Next, we’ll explore what is special about `Box<T>`
that enables us to use the dereference operator by defining our own box type.
-->
<p>リスト15-7とリスト15-6の唯一の違いは、ここでは<code>y</code>が、<code>x</code>の値を指す参照ではなく、
<code>x</code>の値を指すボックスのインスタンスとして設定されている点にあります。
最後のアサートでは、参照外し演算子を使ってボックスのポインタを辿ることができます。これは<code>y</code>が参照だった時と同じやり方です。
参照外し演算子が使える以上<code>Box&lt;T&gt;</code>には特別な何かがあるので、次はそれについて調べることにします。そのために、独自にボックス型を定義します。</p>
<!--
### Defining Our Own Smart Pointer
-->
<h3 id="独自のスマートポインタを定義する"><a class="header" href="#独自のスマートポインタを定義する">独自のスマートポインタを定義する</a></h3>
<!--
Let’s build a smart pointer similar to the `Box<T>` type provided by the
standard library to experience how smart pointers behave differently than
references by default. Then we’ll look at how to add the ability to use the
dereference operator.
-->
<p>標準ライブラリが提供している<code>Box&lt;T&gt;</code>型に似たスマートポインタを作りましょう。そうすれば、スマートポインタがそのままだと
参照と同じ様には振る舞わないことがわかります。それから、どうすれば参照外し演算子を使えるようになるのか見てみましょう。</p>
<!--
The `Box<T>` type is ultimately defined as a tuple struct with one element, so
Listing 15-8 defines a `MyBox<T>` type in the same way. We’ll also define a
`new` function to match the `new` function defined on `Box<T>`.
-->
<p><code>Box&lt;T&gt;</code>型は突き詰めると（訳註：データがヒープに置かれることを無視すると）1要素のタプル構造体のような定義になります。なのでリスト15-8ではそのように<code>MyBox&lt;T&gt;</code>型を定義しています。
また、<code>Box&lt;T&gt;</code>に定義された<code>new</code>関数に対応する<code>new</code>関数も定義しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-8: Defining a `MyBox<T>` type</span>
-->
<p><span class="caption">リスト15-8: <code>MyBox&lt;T&gt;</code>型を定義する</span></p>
<!--
We define a struct named `MyBox` and declare a generic parameter `T`, because
we want our type to hold values of any type. The `MyBox` type is a tuple struct
with one element of type `T`. The `MyBox::new` function takes one parameter of
type `T` and returns a `MyBox` instance that holds the value passed in.
-->
<p><code>MyBox</code>という構造体を定義し、ジェネリック引数の<code>T</code>を宣言しています。この型にどんな型の値も持たせたいからです。
<code>MyBox</code>型は型<code>T</code>の要素を1つ持つタプル構造体です。<code>MyBox::new</code>関数は型<code>T</code>の引数を1つ取り、
渡した値を持つ<code>MyBox</code>のインスタンスを返します。</p>
<!--
Let’s try adding the `main` function in Listing 15-7 to Listing 15-8 and
changing it to use the `MyBox<T>` type we’ve defined instead of `Box<T>`. The
code in Listing 15-9 won’t compile because Rust doesn’t know how to dereference
`MyBox`.
-->
<p>試しにリスト15-7の<code>main</code>関数をリスト15-8に追加し、定義した<code>MyBox&lt;T&gt;</code>型を<code>Box&lt;T&gt;</code>の代わりに使うよう変更してみてください。
コンパイラは<code>MyBox</code>を参照外しする方法がわからないので、リスト15-9のコードはコンパイルできません。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<!--
<span class="caption">Listing 15-9: Attempting to use `MyBox<T>` in the same
way we used references and `Box<T>`</span>
-->
<p><span class="caption">リスト15-9: 参照と<code>Box&lt;T&gt;</code>を使ったのと同じように<code>MyBox&lt;T&gt;</code>を使おうとする</span></p>
<!--
Here’s the resulting compilation error:
-->
<p>こちらが結果として出るコンパイルエラーです。</p>
<pre><code class="language-text">error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
(エラー: 型`MyBox&lt;{integer}&gt;`は参照外しできません)
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
</code></pre>
<!--
Our `MyBox<T>` type can’t be dereferenced because we haven’t implemented that
ability on our type. To enable dereferencing with the `*` operator, we
implement the `Deref` trait.
-->
<p><code>MyBox&lt;T&gt;</code>の参照を外すことはできません。そのための実装を与えていないからです。<code>*</code>演算子で参照外しできるようにするには、
<code>Deref</code>トレイトを実装します。</p>
<!--
### Treating a Type Like a Reference by Implementing the `Deref` Trait
-->
<h3 id="derefトレイトを実装して型を参照のように扱う"><a class="header" href="#derefトレイトを実装して型を参照のように扱う"><code>Deref</code>トレイトを実装して型を参照のように扱う</a></h3>
<!--
As discussed in Chapter 10, to implement a trait, we need to provide
implementations for the trait’s required methods. The `Deref` trait, provided
by the standard library, requires us to implement one method named `deref` that
borrows `self` and returns a reference to the inner data. Listing 15-10
contains an implementation of `Deref` to add to the definition of `MyBox`:
-->
<p>第10章で議論したように、トレイトを実装するにはトレイトの必須メソッドに実装を与える必要があります。
<code>Deref</code>トレイトは標準ライブラリで提供されており、<code>deref</code>という1つのメソッドの実装を要求します。<code>deref</code>は<code>self</code>を借用し、
内部のデータへの参照を返すメソッドです。
リスト15-10には、<code>MyBox</code>の定義に付け足す<code>Deref</code>の実装が含まれています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Deref;

<span class="boring">struct MyBox&lt;T&gt;(T);
</span>impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-10: Implementing `Deref` on `MyBox<T>`</span>
-->
<p><span class="caption">リスト15-10: <code>MyBox&lt;T&gt;</code>に<code>Deref</code>を実装する</span></p>
<!--
The `type Target = T;` syntax defines an associated type for the `Deref` trait
to use. Associated types are a slightly different way of declaring a generic
parameter, but you don’t need to worry about them for now; we’ll cover them in
more detail in Chapter 19.
-->
<p><code>type Target = T;</code>という記法は、<code>Deref</code>トレイトが使用する関連型を定義しています。関連型はまた少し違ったやり方でジェネリック引数を宣言するためのものですが、今は気にする必要はありません。第19章でより詳しく扱います。</p>
<!--
We fill in the body of the `deref` method with `&self.0` so `deref` returns a
reference to the value we want to access with the `*` operator. The `main`
function in Listing 15-9 that calls `*` on the `MyBox<T>` value now compiles,
and the assertions pass!
-->
<p><code>deref</code>メソッドの本体は<code>&amp;self.0</code>だけなので、<code>deref</code>が返すのは私達が<code>*</code>演算子でアクセスしたい値への参照なわけです。
リスト15-9の<code>MyBox&lt;T&gt;</code>に<code>*</code>を呼び出す<code>main</code>関数はこれでコンパイルでき、アサートも通ります！</p>
<!--
Without the `Deref` trait, the compiler can only dereference `&` references.
The `deref` method gives the compiler the ability to take a value of any type
that implements `Deref` and call the `deref` method to get a `&` reference that
it knows how to dereference.
-->
<p><code>Deref</code>トレイトがないと、コンパイラは<code>&amp;</code>参照しか参照外しできません。
<code>deref</code>メソッドのおかげで、コンパイラは<code>Deref</code>を実装している型の値を取り、<code>deref</code>メソッドを呼ぶことで、参照外しが可能な<code>&amp;</code>参照を得られるようになります。</p>
<!--
When we entered `*y` in Listing 15-9, behind the scenes Rust actually ran this
code:
-->
<p>リスト15-9に<code>*y</code>を入力した時、水面下でRustは実際にはこのようなコードを走らせていました。</p>
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<!--
Rust substitutes the `*` operator with a call to the `deref` method and then a
plain dereference so we don’t have to think about whether or not we need to
call the `deref` method. This Rust feature lets us write code that functions
identically whether we have a regular reference or a type that implements
`Deref`.
-->
<p>Rustが<code>*</code>演算子を<code>deref</code>メソッドの呼び出しと普通の参照外しへと置き換えてくれるので、
私達は<code>deref</code>メソッドを呼び出す必要があるかどうかを考えなくて済むわけです。このRustの機能により、
普通の参照か<code>Deref</code>を実装した型であるかどうかに関わらず、等しく機能するコードを書くことができます。</p>
<!--
The reason the `deref` method returns a reference to a value and that the plain
dereference outside the parentheses in `*(y.deref())` is still necessary is the
ownership system. If the `deref` method returned the value directly instead of
a reference to the value, the value would be moved out of `self`. We don't want
to take ownership of the inner value inside `MyBox<T>` in this case or in most
cases where we use the dereference operator.
-->
<p><code>deref</code>メソッドが値への参照を返し、<code>*(y.deref())</code>のかっこの外にある普通の参照外しがそれでも必要になるのは、
所有権システムがあるからです。<code>deref</code>メソッドが値への参照ではなく値を直接返したら、値は<code>self</code>から外にムーブされてしまいます。
今回もそうですが、参照外し演算子を使用するときはほとんどの場合、<code>MyBox&lt;T&gt;</code>の中の値の所有権を奪いたくはありません。</p>
<!--
Note that the `*` operator is replaced with a call to the `deref` method and
then a call to `*` operator just once, each time we type a `*` in our code.
Because the substitution of the `*` operator does not recurse infinitely, we
end up with data of type `i32`, which matches the `5` in `assert_eq!` in
Listing 15-9.
-->
<p><code>*</code>演算子が<code>deref</code>メソッドの呼び出しと<code>*</code>演算子の呼び出しに置き換えられるのは、コード内で<code>*</code>を打つ毎にただ1回だけ、という点に注意して下さい。
<code>*</code>演算子の置き換えは無限に繰り返されないので、型<code>i32</code>のデータに行き着きます。これはリスト15-9で<code>assert_eq!</code>の<code>5</code>と合致します。</p>
<!--
### Implicit Deref Coercions with Functions and Methods
-->
<h3 id="関数やメソッドで暗黙的な参照外し型強制"><a class="header" href="#関数やメソッドで暗黙的な参照外し型強制">関数やメソッドで暗黙的な参照外し型強制</a></h3>
<!--
*Deref coercion* is a convenience that Rust performs on arguments to functions
and methods. Deref coercion converts a reference to a type that implements
`Deref` into a reference to a type that `Deref` can convert the original type
into. Deref coercion happens automatically when we pass a reference to a
particular type’s value as an argument to a function or method that doesn’t
match the parameter type in the function or method definition. A sequence of
calls to the `deref` method converts the type we provided into the type the
parameter needs.
-->
<p><em>参照外し型強制</em>は、コンパイラが関数やメソッドの実引数に行う便利なものです。参照外し型強制は、
<code>Deref</code>を実装する型への参照を<code>Deref</code>が元の型を変換できる型への参照に変換します。参照外し型強制は、
特定の型の値への参照を関数やメソッド定義の引数型と一致しない引数として関数やメソッドに渡すときに自動的に発生します。
一連の<code>deref</code>メソッドの呼び出しが、提供した型を引数が必要とする型に変換します。</p>
<!--
2行目、add as many ... asのようにも見えるが、add [as many ...]ということと思われる
-->
<!--
Deref coercion was added to Rust so that programmers writing function and
method calls don’t need to add as many explicit references and dereferences
with `&` and `*`. The deref coercion feature also lets us write more code that
can work for either references or smart pointers.
-->
<p>参照外し型強制は、関数やメソッド呼び出しを書くプログラマが<code>&amp;</code>や<code>*</code>を多くの明示的な参照や参照外しとして追記する必要がないように、
Rustに追加されました。また、参照外し型強制のおかげで参照あるいはスマートポインタのどちらかで動くコードをもっと書くことができます。</p>
<!--
To see deref coercion in action, let’s use the `MyBox<T>` type we defined in
Listing 15-8 as well as the implementation of `Deref` that we added in Listing
15-10. Listing 15-11 shows the definition of a function that has a string slice
parameter:
-->
<p>参照外し型強制が実際に動いていることを確認するため、リスト15-8で定義した<code>MyBox&lt;T&gt;</code>と、
リスト15-10で追加した<code>Deref</code>の実装を使用しましょう。リスト15-11は、
文字列スライス引数のある関数の定義を示しています:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-11: A `hello` function that has the parameter
`name` of type `&str`</span>
-->
<p><span class="caption">リスト15-11: 型<code>&amp;str</code>の引数<code>name</code>のある<code>hello</code>関数</span></p>
<!--
We can call the `hello` function with a string slice as an argument, such as
`hello("Rust");` for example. Deref coercion makes it possible to call `hello`
with a reference to a value of type `MyBox<String>`, as shown in Listing 15-12:
-->
<p><code>hello</code>関数は、文字列スライスを引数として呼び出すことができます。例えば、<code>hello(&quot;Rust&quot;)</code>などです。
参照外し型強制により、<code>hello</code>を型<code>MyBox&lt;String&gt;</code>の値への参照とともに呼び出すことができます。リスト15-12のようにですね:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {}!&quot;, name);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-12: Calling `hello` with a reference to a
`MyBox<String>` value, which works because of deref coercion</span>
-->
<p><span class="caption">リスト15-12: <code>hello</code>を<code>MyBox&lt;String&gt;</code>値とともに呼び出し、参照外し型強制のおかげで動く</span></p>
<!--
Here we’re calling the `hello` function with the argument `&m`, which is a
reference to a `MyBox<String>` value. Because we implemented the `Deref` trait
on `MyBox<T>` in Listing 15-10, Rust can turn `&MyBox<String>` into `&String`
by calling `deref`. The standard library provides an implementation of `Deref`
on `String` that returns a string slice, and this is in the API documentation
for `Deref`. Rust calls `deref` again to turn the `&String` into `&str`, which
matches the `hello` function’s definition.
-->
<p>ここで、<code>hello</code>関数を引数<code>&amp;m</code>とともに呼び出しています。この引数は、<code>MyBox&lt;String&gt;</code>値への参照です。
リスト15-10で<code>MyBox&lt;T&gt;</code>に<code>Deref</code>トレイトを実装したので、コンパイラは<code>deref</code>を呼び出すことで、
<code>&amp;MyBox&lt;String&gt;</code>を<code>&amp;String</code>に変換できるのです。標準ライブラリは、<code>String</code>に文字列スライスを返す<code>Deref</code>の実装を提供していて、
この実装は、<code>Deref</code>のAPIドキュメンテーションに載っています。コンパイラはさらに<code>deref</code>を呼び出して、
<code>&amp;String</code>を<code>&amp;str</code>に変換し、これは<code>hello</code>関数の定義と合致します。</p>
<!--
If Rust didn’t implement deref coercion, we would have to write the code in
Listing 15-13 instead of the code in Listing 15-12 to call `hello` with a value
of type `&MyBox<String>`.
-->
<p>Rustに参照外し型強制が実装されていなかったら、リスト15-12のコードの代わりにリスト15-13のコードを書き、
型<code>&amp;MyBox&lt;String&gt;</code>の値で<code>hello</code>を呼び出さなければならなかったでしょう。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {}!&quot;, name);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-13: The code we would have to write if Rust
didn’t have deref coercion</span>
-->
<p><span class="caption">リスト15-13: Rustに参照外し型強制がなかった場合に書かなければならないであろうコード</span></p>
<!--
The `(*m)` dereferences the `MyBox<String>` into a `String`. Then the `&` and
`[..]` take a string slice of the `String` that is equal to the whole string to
match the signature of `hello`. The code without deref coercions is harder to
read, write, and understand with all of these symbols involved. Deref coercion
allows Rust to handle these conversions for us automatically.
-->
<p><code>(*m)</code>が<code>MyBox&lt;String&gt;</code>を<code>String</code>に参照外ししています。そして、<code>&amp;</code>と<code>[..]</code>により、
文字列全体と等しい<code>String</code>の文字列スライスを取り、<code>hello</code>のシグニチャと一致するわけです。
参照外し型強制のないコードは、これらの記号が関係するので、読むのも書くのも理解するのもより難しくなります。
参照外し型強制により、コンパイラはこれらの変換を自動的に扱えるのです。</p>
<!--
When the `Deref` trait is defined for the types involved, Rust will analyze the
types and use `Deref::deref` as many times as necessary to get a reference to
match the parameter’s type. The number of times that `Deref::deref` needs to be
inserted is resolved at compile time, so there is no runtime penalty for taking
advantage of deref coercion!
-->
<p><code>Deref</code>トレイトが関係する型に定義されていると、コンパイラは、型を分析し必要なだけ<code>Deref::deref</code>を使用して、
参照を得、引数の型と一致させます。<code>Deref::deref</code>が挿入される必要のある回数は、コンパイル時に解決されるので、
参照外し型強制を活用するための実行時の代償は何もありません。</p>
<!--
### How Deref Coercion Interacts with Mutability
-->
<h3 id="参照外し型強制が可変性と相互作用する方法"><a class="header" href="#参照外し型強制が可変性と相互作用する方法">参照外し型強制が可変性と相互作用する方法</a></h3>
<!--
Similar to how we use the `Deref` trait to override `*` operator on
immutable references, you can use the `DerefMut` trait to override the `*`
operator on mutable references.
-->
<p><code>Deref</code>トレイトを使用して不変参照に対して<code>*</code>をオーバーライドするように、
<code>DerefMut</code>トレイトを使用して可変参照の<code>*</code>演算子をオーバーライドできます。</p>
<!--
Rust does deref coercion when it finds types and trait implementations in three
cases:
-->
<p>以下の3つの場合に型やトレイト実装を見つけた時にコンパイラは、参照外し型強制を行います:</p>
<!--
* From `&T` to `&U` when `T: Deref<Target=U>`
* From `&mut T` to `&mut U` when `T: DerefMut<Target=U>`
* From `&mut T` to `&U` when `T: Deref<Target=U>`
-->
<ul>
<li><code>T: Deref&lt;Target=U&gt;</code>の時、<code>&amp;T</code>から<code>&amp;U</code></li>
<li><code>T: DerefMut&lt;Target=U&gt;</code>の時、<code>&amp;mut T</code>から<code>&amp;mut U</code></li>
<li><code>T: Deref&lt;Target=U&gt;</code>の時、<code>&amp;mut T</code>から<code>&amp;U</code></li>
</ul>
<!--
The first two cases are the same except for mutability. The first case states
that if you have a `&T`, and `T` implements `Deref` to some type `U`, you can
get a `&U` transparently. The second case states that the same deref coercion
happens for mutable references.
-->
<p>前者2つは、可変性を除いて一緒です。最初のケースは、<code>&amp;T</code>があり、<code>T</code>が何らかの型<code>U</code>への<code>Deref</code>を実装しているなら、
透過的に<code>&amp;U</code>を得られると述べています。2番目のケースは、同じ参照外し型強制が可変参照についても起こることを述べています。</p>
<!--
8行目後半、andだが、逆説で訳した
-->
<!--
The third case is trickier: Rust will also coerce a mutable reference to an
immutable one. But the reverse is *not* possible: immutable references will
never coerce to mutable references. Because of the borrowing rules, if you have
a mutable reference, that mutable reference must be the only reference to that
data (otherwise, the program wouldn’t compile). Converting one mutable
reference to one immutable reference will never break the borrowing rules.
Converting an immutable reference to a mutable reference would require that
there is only one immutable reference to that data, and the borrowing rules
don’t guarantee that. Therefore, Rust can’t make the assumption that converting
an immutable reference to a mutable reference is possible.
-->
<p>3番目のケースはもっと巧妙です: Rustはさらに、可変参照を不変参照にも型強制するのです。ですが、逆はできま<em>せん</em>:
不変参照は、絶対に可変参照に型強制されないのです。借用規則により、可変参照があるなら、
その可変参照がそのデータへの唯一の参照に違いありません(でなければ、プログラムはコンパイルできません)。
1つの可変参照を1つの不変参照に変換することは、借用規則を絶対に破壊しません。
不変参照を可変参照にするには、そのデータへの不変参照がたった1つしかないことが必要ですが、
借用規則はそれを保証してくれません。故に、不変参照を可変参照に変換することが可能であるという前提を敷けません。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Running Code on Cleanup with the `Drop` Trait
-->
<h2 id="dropトレイトで片付け時にコードを走らせる"><a class="header" href="#dropトレイトで片付け時にコードを走らせる"><code>Drop</code>トレイトで片付け時にコードを走らせる</a></h2>
<!--
The second trait important to the smart pointer pattern is `Drop`, which lets
you customize what happens when a value is about to go out of scope. You can
provide an implementation for the `Drop` trait on any type, and the code you
specify can be used to release resources like files or network connections.
We’re introducing `Drop` in the context of smart pointers because the
functionality of the `Drop` trait is almost always used when implementing a
smart pointer. For example, `Box<T>` customizes `Drop` to deallocate the space
on the heap that the box points to.
-->
<p>スマートポインタパターンにとって重要な2番目のトレイトは、<code>Drop</code>であり、
これのおかげで値がスコープを抜けそうになった時に起こることをカスタマイズできます。
どんな型に対しても<code>Drop</code>トレイトの実装を提供することができ、指定したコードは、
ファイルやネットワーク接続などのリソースを解放するのに活用できます。
<code>Drop</code>をスマートポインタの文脈で導入しています。<code>Drop</code>トレイトの機能は、ほぼ常にスマートポインタを実装する時に使われるからです。
例えば、<code>Box&lt;T&gt;</code>は<code>Drop</code>をカスタマイズしてボックスが指しているヒープの領域を解放しています。</p>
<!--
In some languages, the programmer must call code to free memory or resources
every time they finish using an instance of a smart pointer. If they forget,
the system might become overloaded and crash. In Rust, you can specify that a
particular bit of code be run whenever a value goes out of scope, and the
compiler will insert this code automatically. As a result, we don’t need to be
careful about placing cleanup code everywhere in a program that an instance of
a particular type is finished with-you still won’t leak resources!
-->
<p>ある言語では、プログラマがスマートポインタのインスタンスを使い終わる度にメモリやリソースを解放するコードを呼ばなければなりません。
忘れてしまったら、システムは詰め込みすぎになりクラッシュする可能性があります。Rustでは、
値がスコープを抜ける度に特定のコードが走るよう指定でき、コンパイラはこのコードを自動的に挿入します。
結果として、特定の型のインスタンスを使い終わったプログラムの箇所全部にクリーンアップコードを配置するのに配慮する必要はありません。
それでもリソースをリークすることはありません。</p>
<!--
Specify the code to run when a value goes out of scope by implementing the
`Drop` trait. The `Drop` trait requires you to implement one method named
`drop` that takes a mutable reference to `self`. To see when Rust calls `drop`,
let's implement `drop` with `println!` statements for now.
-->
<p><code>Drop</code>トレイトを実装することで値がスコープを抜けた時に走るコードを指定してください。
<code>Drop</code>トレイトは、<code>self</code>への可変参照を取る<code>drop</code>という1つのメソッドを実装する必要があります。
いつRustが<code>drop</code>を呼ぶのか確認するために、今は<code>println!</code>文のある<code>drop</code>を実装しましょう。</p>
<!--
Listing 15-14 shows a `CustomSmartPointer` struct whose only custom
functionality is that it will print `Dropping CustomSmartPointer!` when the
instance goes out of scope. This example demonstrates when Rust runs the `drop`
function.
-->
<p>リスト15-14は、唯一の独自の機能が、インスタンスがスコープを抜ける時に<code>Dropping CustomSmartPointer!</code>と出力するだけの、
<code>CustomSmartPointer</code>構造体です。この例は、コンパイラがいつ<code>drop</code>関数を走らせるかをデモしています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        // CustomSmartPointerをデータ`{}`とともにドロップするよ
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;my stuff&quot;) };      // 俺のもの
    let d = CustomSmartPointer { data: String::from(&quot;other stuff&quot;) };   // 別のもの
    println!(&quot;CustomSmartPointers created.&quot;);                           // CustomSmartPointerが生成された
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-14: A `CustomSmartPointer` struct that
implements the `Drop` trait where we would put our cleanup code</span>
-->
<p><span class="caption">リスト15-14: クリーンアップコードを配置する<code>Drop</code>トレイトを実装する<code>CustomSmartPointer</code>構造体</span></p>
<!--
The `Drop` trait is included in the prelude, so we don’t need to import it. We
implement the `Drop` trait on `CustomSmartPointer` and provide an
implementation for the `drop` method that calls `println!`. The body of the
`drop` function is where you would place any logic that you wanted to run when
an instance of your type goes out of scope. We’re printing some text here to
demonstrate when Rust will call `drop`.
-->
<p><code>Drop</code>トレイトは、初期化処理に含まれるので、インポートする必要はありません。
<code>CustomSmartPointer</code>に<code>Drop</code>トレイトを実装し、<code>println!</code>を呼び出す<code>drop</code>メソッドの実装を提供しています。
<code>drop</code>関数の本体は、自分の型のインスタンスがスコープを抜ける時に走らせたいあらゆるロジックを配置する場所です。
ここで何らかのテキストを出力し、コンパイラがいつ<code>drop</code>を呼ぶのかデモしています。</p>
<!--
In `main`, we create two instances of `CustomSmartPointer` and then print
`CustomSmartPointers created.`. At the end of `main`, our instances of
`CustomSmartPointer` will go out of scope, and Rust will call the code we put
in the `drop` method, printing our final message. Note that we didn’t need to
call the `drop` method explicitly.
-->
<p><code>main</code>で、<code>CustomSmartPointer</code>のインスタンスを2つ作り、それから<code>CustomSmartPointers created.</code>と出力しています。
<code>main</code>の最後で、<code>CustomSmartPointer</code>のインスタンスはスコープを抜け、コンパイラは最後のメッセージを出力しながら、
<code>drop</code>メソッドに置いたコードを呼び出します。<code>drop</code>メソッドを明示的に呼び出す必要はなかったことに注意してください。</p>
<!--
When we run this program, we’ll see the following output:
-->
<p>このプログラムを実行すると、以下のような出力が出ます:</p>
<pre><code class="language-text">CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<!--
Rust automatically called `drop` for us when our instances went out of scope,
calling the code we specified. Variables are dropped in the reverse order of
their creation, so `d` was dropped before `c`. This example gives you a visual
guide to how the `drop` method works; usually you would specify the cleanup
code that your type needs to run rather than a print message.
-->
<p>インスタンスがスコープを抜けた時に指定したコードを呼び出しながらコンパイラは、<code>drop</code>を自動的に呼び出してくれました。
変数は、生成されたのと逆の順序でドロップされるので、<code>d</code>は<code>c</code>より先にドロップされました。
この例は、<code>drop</code>メソッドの動き方を見た目で案内するだけですが、通常は、メッセージ出力ではなく、
自分の型が走らせる必要のあるクリーンアップコードを指定するでしょう。</p>
<!--
### Dropping a Value Early with `std::mem::drop`
-->
<h3 id="stdmemdropで早期に値をドロップする"><a class="header" href="#stdmemdropで早期に値をドロップする"><code>std::mem::drop</code>で早期に値をドロップする</a></h3>
<!--
Unfortunately, it’s not straightforward to disable the automatic `drop`
functionality. Disabling `drop` isn’t usually necessary; the whole point of the
`Drop` trait is that it’s taken care of automatically. Occasionally, however
you might want to clean up a value early. One example is when using smart
pointers that manage locks: you might want to force the `drop` method that
releases the lock to run so other code in the same scope can acquire the lock.
Rust doesn't let you call the `Drop` trait’s `drop` method manually; instead
you have to call the `std::mem::drop` function provided by the standard library
if you want to force a value to be dropped before the end of its scope.
-->
<p>残念ながら、自動的な<code>drop</code>機能を無効化することは、単純ではありません。通常、<code>drop</code>を無効化する必要はありません;
<code>Drop</code>トレイトの最重要な要点は、自動的に考慮されることです。ですが、時として、値を早期に片付けたくなる可能性があります。
一例は、ロックを管理するスマートポインタを使用する時です: 同じスコープの他のコードがロックを獲得できるように、
ロックを解放する<code>drop</code>メソッドを強制的に走らせたくなる可能性があります。Rustは、
<code>Drop</code>トレイトの<code>drop</code>メソッドを手動で呼ばせてくれません; スコープが終わる前に値を強制的にドロップさせたいなら、
代わりに標準ライブラリが提供する<code>std::mem::drop</code>関数を呼ばなければなりません。</p>
<!--
If we try to call the `Drop` trait's `drop` method manually by modifying the
`main` function in Listing 15-14, as shown in Listing 15-15, we'll get a
compiler error:
-->
<p>リスト15-14の<code>main</code>関数を変更して手動で<code>Drop</code>トレイトの<code>drop</code>メソッドを呼び出そうとしたら、
コンパイルエラーになるでしょう。リスト15-15のようにですね:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    c.drop();
    // mainの終端の前にCustomSmartPointerがドロップされた
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre>
<!--
<span class="caption">Listing 15-15: Attempting to call the `drop` method from
the `Drop` trait manually to clean up early</span>
-->
<p><span class="caption">リスト15-15: <code>Drop</code>トレイトから<code>drop</code>メソッドを手動で呼び出し、早期に片付けようとする</span></p>
<!--
When we try to compile this code, we’ll get this error:
-->
<p>このコードをコンパイルしてみようとすると、こんなエラーが出ます:</p>
<pre><code class="language-text">error[E0040]: explicit use of destructor method
(エラー: デストラクタメソッドを明示的に使用しています)
  --&gt; src/main.rs:14:7
   |
14 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
</code></pre>
<!--
This error message states that we’re not allowed to explicitly call `drop`. The
error message uses the term *destructor*, which is the general programming term
for a function that cleans up an instance. A *destructor* is analogous to a
*constructor*, which creates an instance. The `drop` function in Rust is one
particular destructor.
-->
<p>明示的に<code>drop</code>を呼び出すことは許されていないことをこのエラーメッセージは述べています。
エラーメッセージは<em>デストラクタ</em>という専門用語を使っていて、これは、
インスタンスを片付ける関数の一般的なプログラミング専門用語です。<em>デストラクタ</em>は、
<em>コンストラクタ</em>に類似していて、これはインスタンスを生成します。Rustの<code>drop</code>関数は、
1種の特定のデストラクタです。</p>
<!--
Rust doesn’t let us call `drop` explicitly because Rust would still
automatically call `drop` on the value at the end of `main`. This would be a
*double free* error because Rust would be trying to clean up the same value
twice.
-->
<p>コンパイラはそれでも、<code>main</code>の終端で値に対して自動的に<code>drop</code>を呼び出すので、<code>drop</code>を明示的に呼ばせてくれません。
コンパイラが2回同じ値を片付けようとするので、これは<em>二重解放</em>エラーになるでしょう。</p>
<!--
We can’t disable the automatic insertion of `drop` when a value goes out of
scope, and we can’t call the `drop` method explicitly. So, if we need to force
a value to be cleaned up early, we can use the `std::mem::drop` function.
-->
<p>値がスコープを抜けるときに<code>drop</code>が自動的に挿入されるのを無効化できず、<code>drop</code>メソッドを明示的に呼ぶこともできません。
よって、値を早期に片付けさせる必要があるなら、<code>std::mem::drop</code>関数を使用できます。</p>
<!--
The `std::mem::drop` function is different than the `drop` method in the `Drop`
trait. We call it by passing the value we want to force to be dropped early as
an argument. The function is in the prelude, so we can modify `main` in Listing
15-15 to call the `drop` function, as shown in Listing 15-16:
-->
<p><code>std::mem::drop</code>関数は、<code>Drop</code>トレイトの<code>drop</code>メソッドとは異なります。
早期に強制的にドロップさせたい値を引数で渡すことで呼びます。この関数は初期化処理に含まれているので、
リスト15-15の<code>main</code>を変更して<code>drop</code>関数を呼び出せます。リスト15-16のようにですね:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Dropping CustomSmartPointer!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c);
    // CustomSmartPointerはmainが終わる前にドロップされた
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-16: Calling `std::mem::drop` to explicitly
drop a value before it goes out of scope</span>
-->
<p><span class="caption">リスト15-16: 値がスコープを抜ける前に明示的にドロップするために<code>std::mem::drop</code>を呼び出す</span></p>
<!--
Running this code will print the following:
-->
<p>このコードを実行すると、以下のように出力されます:</p>
<pre><code class="language-text">CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<!--
The text ```Dropping CustomSmartPointer with data `some data`!``` is printed
between the `CustomSmartPointer created.` and `CustomSmartPointer dropped
before the end of main.` text, showing that the `drop` method code is called to
drop `c` at that point.
-->
<p><code>Dropping CustomSmartPointer with data `some data`!</code>というテキストが、
<code>CustomSmartPointer created.</code>と<code>CustomSmartPointer dropped before the end of main.</code>テキストの間に出力されるので、
<code>drop</code>メソッドのコードがその時点で呼び出されて<code>c</code>をドロップしたことを示しています。</p>
<!--
3行目のwithを...があれば、と訳している。多分辞書にも載っている
-->
<!--
You can use code specified in a `Drop` trait implementation in many ways to
make cleanup convenient and safe: for instance, we could use it to create your
own memory allocator! With the `Drop` trait and Rust’s ownership system, you
don't have to remember to clean up because Rust does it automatically.
-->
<p><code>Drop</code>トレイト実装で指定されたコードをいろんな方法で使用し、片付けを便利で安全にすることができます:
例を挙げれば、これを使用して独自のメモリアロケータを作ることもできるでしょう！<code>Drop</code>トレイトとRustの所有権システムがあれば、
コンパイラが自動的に行うので、片付けを覚えておく必要はなくなります。</p>
<!--
You also don’t have to worry about problems resulting from accidentally
cleaning up values still in use: the ownership system that makes sure
references are always valid also ensures that `drop` gets called only once when
the value is no longer being used.
-->
<p>まだ使用中の値を間違って片付けてしまうことに起因する問題を心配する必要もなくて済みます:
参照が常に有効であると確認してくれる所有権システムが、値が最早使用されなくなった時に<code>drop</code>が1回だけ呼ばれることを保証してくれるのです。</p>
<!--
Now that we’ve examined `Box<T>` and some of the characteristics of smart
pointers, let’s look at a few other smart pointers defined in the standard
library.
-->
<p>これで<code>Box&lt;T&gt;</code>とスマートポインタの特徴の一部を調査したので、標準ライブラリに定義されている他のスマートポインタをいくつか見ましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## `Rc<T>`, the Reference Counted Smart Pointer
-->
<h2 id="rctは参照カウント方式のスマートポインタ"><a class="header" href="#rctは参照カウント方式のスマートポインタ"><code>Rc&lt;T&gt;</code>は、参照カウント方式のスマートポインタ</a></h2>
<!--
In the majority of cases, ownership is clear: you know exactly which variable
owns a given value. However, there are cases when a single value might have
multiple owners. For example, in graph data structures, multiple edges might
point to the same node, and that node is conceptually owned by all of the edges
that point to it. A node shouldn’t be cleaned up unless it doesn’t have any
edges pointing to it.
-->
<p>大多数の場合、所有権は明らかです: 一体どの変数が与えられた値を所有しているかわかるのです。
ところが、単独の値が複数の所有者を持つ可能性のある場合もあります。例えば、グラフデータ構造では、
複数の辺が同じノードを指す可能性があり、概念的にそのノードはそれを指す全ての辺に所有されるわけです。
指す辺がなくならない限り、ノードは片付けられるべきではありません。</p>
<!--
To enable multiple ownership, Rust has a type called `Rc<T>`, which is an
abbreviation for *reference counting*. The `Rc<T>` type keeps track of the
number of references to a value which determines whether or not a value is
still in use. If there are zero references to a value, the value can be cleaned
up without any references becoming invalid.
-->
<p>複数の所有権を可能にするため、Rustには<code>Rc&lt;T&gt;</code>という型があり、これは、<em>reference counting</em>(参照カウント)の省略形です。
<code>Rc&lt;T&gt;</code>型は、値がまだ使用中かどうか決定する値への参照の数を追跡します。値への参照が0なら、どの参照も無効にすることなく、
値は片付けられます。</p>
<!--
Imagine `Rc<T>` as a TV in a family room. When one person enters to watch TV,
they turn it on. Others can come into the room and watch the TV. When the last
person leaves the room, they turn off the TV because it’s no longer being used.
If someone turns off the TV while others are still watching it, there would be
uproar from the remaining TV watchers!
-->
<p><code>Rc&lt;T&gt;</code>を家族部屋のテレビと想像してください。1人がテレビを見に部屋に入ったら、テレビをつけます。
他の人も部屋に入ってテレビを観ることができます。最後の人が部屋を離れる時、
もう使用されていないので、テレビを消します。他の人がまだ観ているのに誰かがテレビを消したら、
残りのテレビ視聴者が騒ぐでしょう！</p>
<!--
We use the `Rc<T>` type when we want to allocate some data on the heap for
multiple parts of our program to read and we can’t determine at compile time
which part will finish using the data last. If we knew which part would finish
last, we could just make that part the data’s owner, and the normal ownership
rules enforced at compile time would take effect.
-->
<p>ヒープにプログラムの複数箇所で読む何らかのデータを確保したいけれど、
コンパイル時にはどの部分が最後にデータを使用し終わるか決定できない時に<code>Rc&lt;T&gt;</code>型を使用します。
どの部分が最後に終わるかわかっているなら、
単にその部分をデータの所有者にして、コンパイル時に強制される普通の所有権ルールが効果を発揮するでしょう。</p>
<!--
Note that `Rc<T>` is only for use in single-threaded scenarios. When we discuss
concurrency in Chapter 16, we’ll cover how to do reference counting in
multithreaded programs.
-->
<p><code>Rc&lt;T&gt;</code>は、シングルスレッドの筋書きで使用するためだけのものであることに注意してください。
第16章で並行性について議論する時に、マルチスレッドプログラムで参照カウントをする方法を講義します。</p>
<!--
### Using `Rc<T>` to Share Data
-->
<h3 id="rctでデータを共有する"><a class="header" href="#rctでデータを共有する"><code>Rc&lt;T&gt;</code>でデータを共有する</a></h3>
<!--
Let’s return to our cons list example in Listing 15-5. Recall that we defined
it using `Box<T>`. This time, we’ll create two lists that both share ownership
of a third list. Conceptually, this looks similar to Figure 15-3:
-->
<p>リスト15-5のコンスリストの例に回帰しましょう。<code>Box&lt;T&gt;</code>を使って定義したことを思い出してください。
今回は、両方とも3番目のリストの所有権を共有する2つのリストを作成します。
これは概念的には図15-3のような見た目になります:</p>
<!--
<img alt="Two lists that share ownership of a third list" src="img/trpl15-03.svg" class="center" />
-->
<img alt="3番目のリストの所有権を共有する2つのリスト" src="img/trpl15-03.svg" class="center" />
<!--
<span class="caption">Figure 15-3: Two lists, `b` and `c`, sharing ownership of
a third list, `a`</span>
-->
<p><span class="caption">図15-3: 3番目のリスト、<code>a</code>の所有権を共有する2つのリスト、<code>b</code>と<code>c</code></span></p>
<!--
We’ll create list `a` that contains 5 and then 10. Then we’ll make two more
lists: `b` that starts with 3 and `c` that starts with 4. Both `b` and `c`
lists will then continue on to the first `a` list containing 5 and 10. In other
words, both lists will share the first list containing 5 and 10.
-->
<p>5と10を含むリスト<code>a</code>を作ります。さらにもう2つリストを作ります: 3で始まる<code>b</code>と4で始まる<code>c</code>です。
<code>b</code>と<code>c</code>のどちらもそれから5と10を含む最初の<code>a</code>リストに続きます。換言すれば、
どちらのリストも5と10を含む最初のリストを共有しています。</p>
<!--
Trying to implement this scenario using our definition of `List` with `Box<T>`
won’t work, as shown in Listing 15-17:
-->
<p><code>List</code>の定義を使用して<code>Box&lt;T&gt;</code>とともにこの筋書きを実装しようとしても、うまくいきません。
リスト15-17のようにですね:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<!--
<span class="caption">Listing 15-17: Demonstrating we’re not allowed to have
two lists using `Box<T>` that try to share ownership of a third list</span>
-->
<p><span class="caption">リスト15-17: 3番目のリストの所有権を共有しようとする<code>Box&lt;T&gt;</code>を使った2つのリストを存在させることはできないとデモする</span></p>
<!--
When we compile this code, we get this error:
-->
<p>このコードをコンパイルすると、こんなエラーが出ます:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait
</code></pre>
<!--
The `Cons` variants own the data they hold, so when we create the `b` list, `a`
is moved into `b` and `b` owns `a`. Then, when we try to use `a` again when
creating `c`, we’re not allowed to because `a` has been moved.
-->
<p><code>Cons</code>列挙子は、保持しているデータを所有するので、<code>b</code>リストを作成する時に、
<code>a</code>が<code>b</code>にムーブされ、<code>b</code>が<code>a</code>を所有します。それから<code>c</code>を作る際に再度<code>a</code>を使用しようとすると、
<code>a</code>はムーブ済みなので、できないわけです。</p>
<!--
We could change the definition of `Cons` to hold references instead, but then
we would have to specify lifetime parameters. By specifying lifetime
parameters, we would be specifying that every element in the list will live at
least as long as the entire list. The borrow checker wouldn’t let us compile
`let a = Cons(10, &Nil);` for example, because the temporary `Nil` value would
be dropped before `a` could take a reference to it.
-->
<p><code>Cons</code>の定義を代わりに参照を保持するように変更することもできますが、そうしたら、
ライフタイム引数を指定しなければなりません。ライフタイム引数を指定することで、
リストの各要素が最低でもリスト全体と同じ期間だけ生きることを指定することになります。
例えば、借用チェッカーは<code>let a = Cons(10, &amp;Nil);</code>をコンパイルさせてくれません。
一時的な<code>Nil</code>値が、<code>a</code>が参照を得られるより前にドロップされてしまうからです。</p>
<!--
Instead, we’ll change our definition of `List` to use `Rc<T>` in place of
`Box<T>`, as shown in Listing 15-18. Each `Cons` variant will now hold a value
and an `Rc<T>` pointing to a `List`. When we create `b`, instead of taking
ownership of `a`, we’ll clone the `Rc<List>` that `a` is holding, thereby
increasing the number of references from one to two and letting `a` and `b`
share ownership of the data in that `Rc<List>`. We’ll also clone `a` when
creating `c`, increasing the number of references from two to three. Every time
we call `Rc::clone`, the reference count to the data within the `Rc<List>` will
increase, and the data won’t be cleaned up unless there are zero references to
it.
-->
<p>代わりに、<code>List</code>の定義をリスト15-18のように、<code>Box&lt;T&gt;</code>の箇所に<code>Rc&lt;T&gt;</code>を使うように変更します。
これで各<code>Cons</code>列挙子は、値と<code>List</code>を指す<code>Rc&lt;T&gt;</code>を保持するようになりました。<code>b</code>を作る際、
<code>a</code>の所有権を奪うのではなく、<code>a</code>が保持している<code>Rc&lt;List&gt;</code>をクローンします。それによって、
参照の数が1から2に増え、<code>a</code>と<code>b</code>にその<code>Rc&lt;List&gt;</code>にあるデータの所有権を共有させます。
また、<code>c</code>を生成する際にも<code>a</code>をクローンするので、参照の数は2から3になります。<code>Rc::clone</code>を呼ぶ度に、
<code>Rc&lt;List&gt;</code>内のデータの参照カウントが増え、参照が0にならない限りデータは片付けられません。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-18: A definition of `List` that uses
`Rc<T>`</span>
-->
<p><span class="caption">リスト15-18: <code>Rc&lt;T&gt;</code>を使用する<code>List</code>の定義</span></p>
<!--
We need to add a `use` statement to bring `Rc<T>` into scope because it’s not
in the prelude. In `main`, we create the list holding 5 and 10 and store it in
a new `Rc<List>` in `a`. Then when we create `b` and `c`, we call the
`Rc::clone` function and pass a reference to the `Rc<List>` in `a` as an
argument.
-->
<p>初期化処理に含まれていないので、<code>use</code>文を追加して<code>Rc&lt;T&gt;</code>をスコープに導入する必要があります。
<code>main</code>で5と10を保持するリストを作成し、<code>a</code>の新しい<code>Rc&lt;List&gt;</code>に格納しています。それから、
<code>b</code>と<code>c</code>を作成する際に、<code>Rc::clone</code>関数を呼び出し、引数として<code>a</code>の<code>Rc&lt;List&gt;</code>への参照を渡しています。</p>
<!--
We could have called `a.clone()` rather than `Rc::clone(&a)`, but Rust’s
convention is to use `Rc::clone` in this case. The implementation of
`Rc::clone` doesn’t make a deep copy of all the data like most types’
implementations of `clone` do. The call to `Rc::clone` only increments the
reference count, which doesn’t take much time. Deep copies of data can take a
lot of time. By using `Rc::clone` for reference counting, we can visually
distinguish between the deep-copy kinds of clones and the kinds of clones that
increase the reference count. When looking for performance problems in the
code, we only need to consider the deep-copy clones and can disregard calls to
`Rc::clone`.
-->
<p><code>Rc::clone(&amp;a)</code>ではなく、<code>a.clone()</code>を呼ぶこともできますが、Rustのしきたりは、この場合<code>Rc::clone</code>を使うことです。
<code>Rc::clone</code>の実装は、多くの型の<code>clone</code>実装のように、全てのデータのディープコピーをすることではありません。
<code>Rc::clone</code>の呼び出しは、参照カウントをインクリメントするだけであり、時間はかかりません。
データのディープコピーは時間がかかることもあります。参照カウントに<code>Rc::clone</code>を使うことで、
視覚的にディープコピーをする類のクローンと参照カウントを増やす種類のクローンを区別することができます。
コード内でパフォーマンスの問題を探す際、ディープコピーのクローンだけを考慮し、<code>Rc::clone</code>の呼び出しを無視できるのです。</p>
<!--
### Cloning an `Rc<T>` Increases the Reference Count
-->
<h3 id="rctをクローンすると参照カウントが増える"><a class="header" href="#rctをクローンすると参照カウントが増える"><code>Rc&lt;T&gt;</code>をクローンすると、参照カウントが増える</a></h3>
<!--
Let’s change our working example in Listing 15-18 so we can see the reference
counts changing as we create and drop references to the `Rc<List>` in `a`.
-->
<p><code>a</code>の<code>Rc&lt;List&gt;</code>への参照を作ったりドロップする毎に参照カウントが変化するのが確かめられるように、
リスト15-18の動く例を変更しましょう。</p>
<!--
In Listing 15-19, we’ll change `main` so it has an inner scope around list `c`;
then we can see how the reference count changes when `c` goes out of scope.
-->
<p>リスト15-19で、リスト<code>c</code>を囲む内側のスコープができるよう<code>main</code>を変更します;
そうすれば、<code>c</code>がスコープを抜けるときに参照カウントがどう変化するか確認できます。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    // a生成後のカウント = {}
    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    // b生成後のカウント = {}
    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        // c生成後のカウント = {}
        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    // cがスコープを抜けた後のカウント = {}
    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-19: Printing the reference count</span>
-->
<p><span class="caption">リスト15-19: 参照カウントを出力する</span></p>
<!--
At each point in the program where the reference count changes, we print the
reference count, which we can get by calling the `Rc::strong_count` function.
This function is named `strong_count` rather than `count` because the `Rc<T>`
type also has a `weak_count`; we’ll see what `weak_count` is used for in the
“Preventing Reference Cycles” section.
-->
<p>プログラム内で参照カウントが変更される度に、参照カウントを出力します。参照カウントは、
<code>Rc::strong_count</code>関数を呼び出すことで得られます。<code>Rc&lt;T&gt;</code>型には<code>weak_count</code>もあるので、
この関数は<code>count</code>ではなく<code>strong_count</code>と命名されています; <code>weak_count</code>の使用目的は、
「循環参照を回避する」節で確かめます。</p>
<!--
This code prints the following:
-->
<p>このコードは、以下の出力をします:</p>
<pre><code class="language-text">count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<!--
We can see that the `Rc<List>` in `a` has an initial reference count of 1; then
each time we call `clone`, the count goes up by 1. When `c` goes out of scope,
the count goes down by 1. We don’t have to call a function to decrease the
reference count like we have to call `Rc::clone` to increase the reference
count: the implementation of the `Drop` trait decreases the reference count
automatically when an `Rc<T>` value goes out of scope.
-->
<p><code>a</code>の<code>Rc&lt;List&gt;</code>は最初1という参照カウントであることがわかります; そして、<code>clone</code>を呼び出す度に、
カウントは1ずつ上がります。<code>c</code>がスコープを抜けると、カウントは1下がります。参照カウントを増やすのに、
<code>Rc::clone</code>を呼ばなければいけなかったみたいに参照カウントを減らすのに関数を呼び出す必要はありません:
<code>Rc&lt;T&gt;</code>値がスコープを抜けるときに<code>Drop</code>トレイトの実装が自動的に参照カウントを減らします。</p>
<!--
What we can’t see in this example is that when `b` and then `a` go out of scope
at the end of `main`, the count is then 0, and the `Rc<List>` is cleaned up
completely at that point. Using `Rc<T>` allows a single value to have
multiple owners, and the count ensures that the value remains valid as long as
any of the owners still exist.
-->
<p>この例でわからないことは、<code>b</code>そして<code>a</code>が、<code>main</code>の終端でスコープを抜ける時に、カウントが0になり、
その時点で<code>Rc&lt;List&gt;</code>が完全に片付けられることです。<code>Rc&lt;T&gt;</code>を使用すると、単独の値に複数の所有者を持たせることができ、
所有者のいずれかが存在している限り、値が有効であり続けることをカウントは保証します。</p>
<!--
Via immutable references, `Rc<T>` allows you to share data between multiple
parts of our program for reading only. If `Rc<T>` allowed you to have multiple
mutable references too, you might violate one of the borrowing rules discussed
in Chapter 4: multiple mutable borrows to the same place can cause data races
and inconsistencies. But being able to mutate data is very useful! In the next
section, we’ll discuss the interior mutability pattern and the `RefCell<T>`
type that you can use in conjunction with an `Rc<T>` to work with this
immutability restriction.
-->
<p>不変参照経由で、<code>Rc&lt;T&gt;</code>は読み取り専用にプログラムの複数箇所間でデータを共有させてくれます。
<code>Rc&lt;T&gt;</code>が複数の可変参照を存在させることも許可してくれたら、第4章で議論した借用ルールの1つを侵害する<ruby>虞<rp>(</rp><rt>おそれ</rt><rp>)</rp></ruby>があります:
同じ場所への複数の可変借用は、データ競合や矛盾を引き起こすことがあるのです。しかし、
データを可変化する能力はとても有用です！次の節では、内部可変性パターンと、
<code>Rc&lt;T&gt;</code>と絡めて使用してこの不変性制限を手がけられる<code>RefCell&lt;T&gt;</code>型について議論します。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## `RefCell<T>` and the Interior Mutability Pattern
-->
<h2 id="refcelltと内部可変性パターン"><a class="header" href="#refcelltと内部可変性パターン"><code>RefCell&lt;T&gt;</code>と内部可変性パターン</a></h2>
<!--
*Interior mutability* is a design pattern in Rust that allows you to mutate
data even when there are immutable references to that data; normally, this
action is disallowed by the borrowing rules. To mutate data, the pattern uses
`unsafe` code inside a data structure to bend Rust’s usual rules that govern
mutation and borrowing. We haven’t yet covered unsafe code; we will in
Chapter 19. We can use types that use the interior mutability pattern when we
can ensure that the borrowing rules will be followed at runtime, even though
the compiler can’t guarantee that. The `unsafe` code involved is then wrapped
in a safe API, and the outer type is still immutable.
-->
<p>内部可変性は、そのデータへの不変参照がある時でさえもデータを可変化できるRustでのデザインパターンです:
普通、この行動は借用規則により許可されません。データを可変化するために、このパターンは、データ構造内で<code>unsafe</code>コードを使用して、
可変性と借用を支配するRustの通常の規則を捻じ曲げています。まだ、unsafeコードについては講義していません;
第19章で行います。たとえ、コンパイラが保証できなくても、借用規則に実行時に従うことが保証できる時、
内部可変性パターンを使用した型を使用できます。関係する<code>unsafe</code>コードはそうしたら、安全なAPIにラップされ、
外側の型は、それでも不変です。</p>
<!--
Let’s explore this concept by looking at the `RefCell<T>` type that follows the
interior mutability pattern.
-->
<p>内部可変性パターンに従う<code>RefCell&lt;T&gt;</code>型を眺めてこの概念を探究しましょう。</p>
<!--
### Enforcing Borrowing Rules at Runtime with `RefCell<T>`
-->
<h3 id="refcelltで実行時に借用規則を強制する"><a class="header" href="#refcelltで実行時に借用規則を強制する"><code>RefCell&lt;T&gt;</code>で実行時に借用規則を強制する</a></h3>
<!--
Unlike `Rc<T>`, the `RefCell<T>` type represents single ownership over the data
it holds. So, what makes `RefCell<T>` different from a type like `Box<T>`?
Recall the borrowing rules you learned in Chapter 4:
-->
<p><code>Rc&lt;T&gt;</code>と異なり、<code>RefCell&lt;T&gt;</code>型は、保持するデータに対して単独の所有権を表します。では、
どうして<code>RefCell&lt;T&gt;</code>が<code>Box&lt;T&gt;</code>のような型と異なるのでしょうか？第4章で学んだ借用規則を思い出してください:</p>
<!--
* At any given time, you can have *either* (but not both of) one mutable
reference or any number of immutable references.
* References must always be valid.
-->
<ul>
<li>いかなる時も(以下の両方ではなく、)1つの可変参照かいくつもの不変参照の<em>どちらか</em>が可能になる</li>
<li>参照は常に有効でなければならない。</li>
</ul>
<!--
With references and `Box<T>`, the borrowing rules’ invariants are enforced at
compile time. With `RefCell<T>`, these invariants are enforced *at runtime*.
With references, if you break these rules, you’ll get a compiler error. With
`RefCell<T>`, if you break these rules, your program will panic and exit.
-->
<p>参照と<code>Box&lt;T&gt;</code>では、借用規則の不変条件は、コンパイル時に強制されています。<code>RefCell&lt;T&gt;</code>では、
これらの不変条件は、<em>実行時に</em>強制されます。参照でこれらの規則を破ったら、コンパイルエラーになりました。
<code>RefCell&lt;T&gt;</code>でこれらの規則を破ったら、プログラムはパニックし、終了します。</p>
<!--
1行目、are that がどこまでかかるか不明だが、3行目最後、For those reasonsとあるので、最後までかかるように訳す
-->
<!--
The advantages of checking the borrowing rules at compile time are that errors
will be caught sooner in the development process, and there is no impact on
runtime performance because all the analysis is completed beforehand. For those
reasons, checking the borrowing rules at compile time is the best choice in the
majority of cases, which is why this is Rust’s default.
-->
<p>コンパイル時に借用規則を精査することの利点は、エラーが開発過程の早い段階で捕捉されることと、
あらかじめ全ての分析が終わるので、実行パフォーマンスへの影響がないことです。それらの理由により、
多くの場合でコンパイル時に借用規則を精査することが最善の選択肢であり、これがRustの既定になっているのです。</p>
<!--
The advantage of checking the borrowing rules at runtime instead is that
certain memory-safe scenarios are then allowed, whereas they are disallowed by
the compile-time checks. Static analysis, like the Rust compiler, is inherently
conservative. Some properties of code are impossible to detect by analyzing the
code: the most famous example is the Halting Problem, which is beyond the scope
of this book but is an interesting topic to research.
-->
<p>借用規則を実行時に代わりに精査する利点は、コンパイル時の精査では許容されない特定のメモリ安全な筋書きが許容されることです。
Rustコンパイラのような静的解析は、本質的に保守的です。コードの特性には、コードを解析するだけでは検知できないものもあります:
最も有名な例は停止性問題であり、この本の範疇を超えていますが、調べると面白い話題です。</p>
<!--
Because some analysis is impossible, if the Rust compiler can’t be sure the
code complies with the ownership rules, it might reject a correct program; in
this way, it’s conservative. If Rust accepted an incorrect program, users
wouldn’t be able to trust in the guarantees Rust makes. However, if Rust
rejects a correct program, the programmer will be inconvenienced, but nothing
catastrophic can occur. The `RefCell<T>` type is useful when you’re sure your
code follows the borrowing rules but the compiler is unable to understand and
guarantee that.
-->
<p>不可能な分析もあるので、Rustのコンパイラが、コードが所有権規則に応じていると確証を得られない場合、
正しいプログラムを拒否する可能性があります; このように、保守的なのです。コンパイラが不正なプログラムを受け入れたら、
ユーザは、コンパイラが行う保証を信じることはできなくなるでしょう。しかしながら、
コンパイラが正当なプログラムを拒否するのなら、プログラマは不便に思うでしょうが、悲劇的なことは何も起こり得ません。
コードが借用規則に従っているとプログラマは確証を得ているが、コンパイラがそれを理解し保証することができない時に
<code>RefCell&lt;T&gt;</code>型は有用です。</p>
<!--
Similar to `Rc<T>`, `RefCell<T>` is only for use in single-threaded scenarios
and will give you a compile-time error if you try using it in a multithreaded
context. We’ll talk about how to get the functionality of `RefCell<T>` in a
multithreaded program in Chapter 16.
-->
<p><code>Rc&lt;T&gt;</code>と類似して、<code>RefCell&lt;T&gt;</code>もシングルスレッドの筋書きで使用するためのものであり、
試しにマルチスレッドの文脈で使ってみようとすると、コンパイルエラーを出します。
<code>RefCell&lt;T&gt;</code>の機能をマルチスレッドのプログラムで得る方法については、第16章で語ります。</p>
<!--
Here is a recap of the reasons to choose `Box<T>`, `Rc<T>`, or `RefCell<T>`:
-->
<p>こちらに<code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>を選択する理由を要約しておきます:</p>
<!--
* `Rc<T>` enables multiple owners of the same data; `Box<T>` and `RefCell<T>`
have single owners.
* `Box<T>` allows immutable or mutable borrows checked at compile time; `Rc<T>`
allows only immutable borrows checked at compile time; `RefCell<T>` allows
immutable or mutable borrows checked at runtime.
* Because `RefCell<T>` allows mutable borrows checked at runtime, you can
mutate the value inside the `RefCell<T>` even when the `RefCell<T>` is
immutable.
-->
<ul>
<li><code>Rc&lt;T&gt;</code>は、同じデータに複数の所有者を持たせてくれる; <code>Box&lt;T&gt;</code>と<code>RefCell&lt;T&gt;</code>は単独の所有者。</li>
<li><code>Box&lt;T&gt;</code>では、不変借用も可変借用もコンパイル時に精査できる; <code>Rc&lt;T&gt;</code>では不変借用のみがコンパイル時に精査できる;
<code>RefCell&lt;T&gt;</code>では、不変借用も可変借用も実行時に精査される。</li>
<li><code>RefCell&lt;T&gt;</code>は実行時に精査される可変借用を許可するので、<code>RefCell&lt;T&gt;</code>が不変でも、
<code>RefCell&lt;T&gt;</code>内の値を可変化できる。</li>
</ul>
<!--
Mutating the value inside an immutable value is the *interior mutability*
pattern. Let’s look at a situation in which interior mutability is useful and
examine how it’s possible.
-->
<p>不変な値の中の値を可変化することは、<em>内部可変性</em>パターンです。内部可変性が有用になる場面を見て、
それが可能になる方法を調査しましょう。</p>
<!--
### Interior Mutability: A Mutable Borrow to an Immutable Value
-->
<h3 id="内部可変性-不変値への可変借用"><a class="header" href="#内部可変性-不変値への可変借用">内部可変性: 不変値への可変借用</a></h3>
<!--
A consequence of the borrowing rules is that when you have an immutable value,
you can’t borrow it mutably. For example, this code won’t compile:
-->
<p>借用規則の結果は、不変値がある時、可変で借用することはできないということです。
例えば、このコードはコンパイルできません:</p>
<pre><code class="language-rust ignore">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<!--
If you tried to compile this code, you'd get the following error:
-->
<p>このコードをコンパイルしようとしたら、以下のようなエラーが出るでしょう:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable local variable `x` as mutable
(エラー: 不変なローカル変数`x`を可変で借用することはできません)
 --&gt; src/main.rs:3:18
  |
2 |     let x = 5;
  |         - consider changing this to `mut x`
3 |     let y = &amp;mut x;
  |                  ^ cannot borrow mutably
</code></pre>
<!--
However, there are situations in which it would be useful for a value to mutate
itself in its methods but appear immutable to other code. Code outside the
value’s methods would not be able to mutate the value. Using `RefCell<T>` is
one way to get the ability to have interior mutability. But `RefCell<T>`
doesn’t get around the borrowing rules completely: the borrow checker in the
compiler allows this interior mutability, and the borrowing rules are checked
at runtime instead. If you violate the rules, you’ll get a `panic!` instead of
a compiler error.
-->
<p>ですが、メソッド内で値が自身を可変化するけれども、他のコードにとっては、
不変に見えることが有用な場面もあります。その値のメソッドの外のコードは、その値を可変化することはできないでしょう。
<code>RefCell&lt;T&gt;</code>を使うことは、内部可変性を取得する能力を得る1つの方法です。しかし、
<code>RefCell&lt;T&gt;</code>は借用規則を完全に回避するものではありません: コンパイラの借用チェッカーは、内部可変性を許可し、
借用規則は代わりに実行時に精査されます。この規則を侵害したら、コンパイルエラーではなく<code>panic!</code>になるでしょう。</p>
<!--
Let’s work through a practical example where we can use `RefCell<T>` to mutate
an immutable value and see why that is useful.
-->
<p><code>RefCell&lt;T&gt;</code>を使用して不変値を可変化する実践的な例に取り組み、それが役に立つ理由を確認しましょう。</p>
<!--
#### A Use Case for Interior Mutability: Mock Objects
-->
<h4 id="内部可変性のユースケース-モックオブジェクト"><a class="header" href="#内部可変性のユースケース-モックオブジェクト">内部可変性のユースケース: モックオブジェクト</a></h4>
<!--
A *test double* is the general programming concept for a type used in place of
another type during testing. *Mock objects* are specific types of test doubles
that record what happens during a test so you can assert that the correct
actions took place.
-->
<p><em>テストダブル</em>は、テスト中に別の型の代わりに使用される型の一般的なプログラミングの概念です。
<em>モックオブジェクト</em>は、テスト中に起きることを記録するテストダブルの特定の型なので、
正しい動作が起きたことをアサートできます。</p>
<blockquote>
<p><code>編注</code>: テストダブルとは、ソフトウェアテストにおいて、テスト対象が依存しているコンポーネントを置き換える代用品のこと。</p>
</blockquote>
<!--
Rust doesn’t have objects in the same sense as other languages have objects,
and Rust doesn’t have mock object functionality built into the standard library
as some other languages do. However, you can definitely create a struct that
will serve the same purposes as a mock object.
-->
<p>Rustには、他の言語でいうオブジェクトは存在せず、また、他の言語のように標準ライブラリにモックオブジェクトの機能が組み込まれてもいません。
ですが、同じ目的をモックオブジェクトとして提供する構造体を作成することは確実にできます。</p>
<!--
Here’s the scenario we’ll test: we’ll create a library that tracks a value
against a maximum value and sends messages based on how close to the maximum
value the current value is. This library could be used to keep track of a
user’s quota for the number of API calls they’re allowed to make, for example.
-->
<p>以下が、テストを行う筋書きです: 値を最大値に対して追跡し、現在値がどれくらい最大値に近いかに基づいてメッセージを送信するライブラリを作成します。
このライブラリは、ユーザが行うことのできるAPIコールの数の割り当てを追跡するのに使用することができるでしょう。</p>
<!--
Our library will only provide the functionality of tracking how close to the
maximum a value is and what the messages should be at what times. Applications
that use our library will be expected to provide the mechanism for sending the
messages: the application could put a message in the application, send an
email, send a text message, or something else. The library doesn’t need to know
that detail. All it needs is something that implements a trait we’ll provide
called `Messenger`. Listing 15-20 shows the library code:
-->
<p>作成するライブラリは、値がどれくらい最大に近いかと、いつどんなメッセージになるべきかを追いかける機能を提供するだけです。
このライブラリを使用するアプリケーションは、メッセージを送信する機構を提供すると期待されるでしょう:
アプリケーションは、アプリケーションにメッセージを置いたり、メールを送ったり、テキストメッセージを送るなどできるでしょう。
ライブラリはその詳細を知る必要はありません。必要なのは、提供する<code>Messenger</code>と呼ばれるトレイトを実装している何かなのです。
リスト15-20は、ライブラリのコードを示しています:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: 'a + Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
    where T: Messenger {
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 0.75 &amp;&amp; percentage_of_max &lt; 0.9 {
            // 警告: 割り当ての75％以上を使用してしまいました
            self.messenger.send(&quot;Warning: You've used up over 75% of your quota!&quot;);
        } else if percentage_of_max &gt;= 0.9 &amp;&amp; percentage_of_max &lt; 1.0 {
            // 切迫した警告: 割り当ての90%以上を使用してしまいました
            self.messenger.send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
        } else if percentage_of_max &gt;= 1.0 {
            // エラー: 割り当てを超えています
            self.messenger.send(&quot;Error: You are over your quota!&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-20: A library to keep track of how close a
value is to a maximum value and warn when the value is at certain levels</span>
-->
<p><span class="caption">リスト15-20: 値が最大値にどれくらい近いかを追跡し、特定のレベルの時に警告するライブラリ</span></p>
<!--
One important part of this code is that the `Messenger` trait has one method
called `send` that takes an immutable reference to `self` and the text of the
message. This is the interface our mock object needs to have. The other
important part is that we want to test the behavior of the `set_value` method
on the `LimitTracker`. We can change what we pass in for the `value` parameter,
but `set_value` doesn’t return anything for us to make assertions on. We want
to be able to say that if we create a `LimitTracker` with something that
implements the `Messenger` trait and a particular value for `max`, when we pass
different numbers for `value`, the messenger is told to send the appropriate
messages.
-->
<p>このコードの重要な部分の1つは、<code>Messenger</code>トレイトには、<code>self</code>への不変参照とメッセージのテキストを取る<code>send</code>というメソッドが1つあることです。
これが、モックオブジェクトが持つ必要のあるインターフェイスなのです。もう1つの重要な部分は、
<code>LimitTracker</code>の<code>set_value</code>メソッドの振る舞いをテストしたいということです。<code>value</code>引数に渡すものを変えることができますが、
<code>set_value</code>はアサートを行えるものは何も返してくれません。<code>LimitTracker</code>を<code>Messenger</code>トレイトを実装する何かと、
<code>max</code>の特定の値で生成したら、<code>value</code>に異なる数値を渡した時にメッセンジャーは適切なメッセージを送ると指示されると言えるようになりたいです。</p>
<!--
We need a mock object that, instead of sending an email or text message when we
call `send`, will only keep track of the messages it’s told to send. We can
create a new instance of the mock object, create a `LimitTracker` that uses the
mock object, call the `set_value` method on `LimitTracker`, and then check that
the mock object has the messages we expect. Listing 15-21 shows an attempt to
implement a mock object to do just that, but the borrow checker won’t allow it:
-->
<p><code>send</code>を呼び出す時にメールやテキストメッセージを送る代わりに送ると指示されたメッセージを追跡するだけのモックオブジェクトが必要です。
モックオブジェクトの新規インスタンスを生成し、モックオブジェクトを使用する<code>LimitTracker</code>を生成し、
<code>LimitTracker</code>の<code>set_value</code>を呼び出し、それからモックオブジェクトに期待しているメッセージがあることを確認できます。
リスト15-21は、それだけをするモックオブジェクトを実装しようとするところを示しますが、借用チェッカーが許可してくれません:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: vec![] }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-21: An attempt to implement a `MockMessenger`
that isn’t allowed by the borrow checker</span>
-->
<p><span class="caption">リスト15-21: 借用チェッカーが許可してくれない<code>MockMessenger</code>を実装しようとする</span></p>
<!--
This test code defines a `MockMessenger` struct that has a `sent_messages`
field with a `Vec` of `String` values to keep track of the messages it’s told
to send. We also define an associated function `new` to make it convenient to
create new `MockMessenger` values that start with an empty list of messages. We
then implement the `Messenger` trait for `MockMessenger` so we can give a
`MockMessenger` to a `LimitTracker`. In the definition of the `send` method, we
take the message passed in as a parameter and store it in the `MockMessenger`
list of `sent_messages`.
-->
<p>このテストコードは<code>String</code>の<code>Vec</code>で送信すると指示されたメッセージを追跡する<code>sent_messages</code>フィールドのある<code>MockMessenger</code>構造体を定義しています。
また、空のメッセージリストから始まる新しい<code>MockMessenger</code>値を作るのを便利にしてくれる関連関数の<code>new</code>も定義しています。
それから<code>MockMessenger</code>に<code>Messenger</code>トレイトを実装しているので、<code>LimitTracker</code>に<code>MockMessenger</code>を与えられます。
<code>send</code>メソッドの定義で引数として渡されたメッセージを取り、<code>sent_messages</code>の<code>MockMessenger</code>リストに格納しています。</p>
<!--
In the test, we’re testing what happens when the `LimitTracker` is told to set
`value` to something that is more than 75 percent of the `max` value. First, we
create a new `MockMessenger`, which will start with an empty list of messages.
Then we create a new `LimitTracker` and give it a reference to the new
`MockMessenger` and a `max` value of 100. We call the `set_value` method on the
`LimitTracker` with a value of 80, which is more than 75 percent of 100. Then
we assert that the list of messages that the `MockMessenger` is keeping track
of should now have one message in it.
-->
<p>テストでは、<code>max</code>値の75%以上になる何かに<code>value</code>をセットしろと<code>LimitTracker</code>が指示される時に起きることをテストしています。
まず、新しい<code>MockMessenger</code>を生成し、空のメッセージリストから始まります。そして、
新しい<code>LimitTracker</code>を生成し、新しい<code>MockMessenger</code>の参照と100という<code>max</code>値を与えます。
<code>LimitTracker</code>の<code>set_value</code>メソッドは80という値で呼び出し、これは100の75%を上回っています。
そして、<code>MockMessenger</code>が追いかけているメッセージのリストが、今は1つのメッセージを含んでいるはずとアサートします。</p>
<!--
However, there’s one problem with this test, as shown here:
-->
<p>ところが、以下のようにこのテストには1つ問題があります:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable
(エラー: 不変なフィールド`self.sent_messages`を可変で借用できません)
  --&gt; src/lib.rs:52:13
   |
51 |         fn send(&amp;self, message: &amp;str) {
   |                 ----- use `&amp;mut self` here to make mutable
52 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable field
</code></pre>
<!--
We can’t modify the `MockMessenger` to keep track of the messages, because the
`send` method takes an immutable reference to `self`. We also can’t take the
suggestion from the error text to use `&mut self` instead, because then the
signature of `send` wouldn’t match the signature in the `Messenger` trait
definition (feel free to try and see what error message you get).
-->
<p><code>send</code>メソッドは<code>self</code>への不変参照を取るので、<code>MockMessenger</code>を変更してメッセージを追跡できないのです。
代わりに<code>&amp;mut self</code>を使用するというエラーテキストからの提言を選ぶこともできないのです。
そうしたら、<code>send</code>のシグニチャが、<code>Messenger</code>トレイト定義のシグニチャと一致しなくなるからです(気軽に試してエラーメッセージを確認してください)。</p>
<!--
This is a situation in which interior mutability can help! We’ll store the
`sent_messages` within a `RefCell<T>`, and then the `send` message will be
able to modify `sent_messages` to store the messages we’ve seen. Listing 15-22
shows what that looks like:
-->
<p>これは、内部可変性が役に立つ場面なのです！<code>sent_messages</code>を<code>RefCell&lt;T&gt;</code>内部に格納し、
そうしたら<code>send</code>メッセージは、<code>sent_messages</code>を変更して見かけたメッセージを格納できるようになるでしょう。
リスト15-22は、それがどんな感じかを示しています:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: RefCell::new(vec![]) }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">        limit_tracker.set_value(75);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 15-22: Using `RefCell<T>` to mutate an inner
value while the outer value is considered immutable</span>
-->
<p><span class="caption">リスト15-22: 外側の値は不変と考えられる一方で<code>RefCell&lt;T&gt;</code>で内部の値を可変化する</span></p>
<!--
The `sent_messages` field is now of type `RefCell<Vec<String>>` instead of
`Vec<String>`. In the `new` function, we create a new `RefCell<Vec<String>>`
instance around the empty vector.
-->
<p>さて、<code>sent_messages</code>フィールドは、<code>Vec&lt;String&gt;</code>ではなく、型<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>になりました。
<code>new</code>関数で、空のベクタの周りに<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>を新しく作成しています。</p>
<!--
For the implementation of the `send` method, the first parameter is still an
immutable borrow of `self`, which matches the trait definition. We call
`borrow_mut` on the `RefCell<Vec<String>>` in `self.sent_messages` to get a
mutable reference to the value inside the `RefCell<Vec<String>>`, which is
the vector. Then we can call `push` on the mutable reference to the vector to
keep track of the messages sent during the test.
-->
<p><code>send</code>メソッドの実装については、最初の引数はそれでも<code>self</code>への不変借用で、トレイト定義と合致しています。
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>の<code>borrow_mut</code>を<code>self.sent_messages</code>に呼び出し、
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>の中の値への可変参照を得て、これはベクタになります。
それからベクタへの可変参照に<code>push</code>を呼び出して、テスト中に送られるメッセージを追跡しています。</p>
<!--
The last change we have to make is in the assertion: to see how many items are
in the inner vector, we call `borrow` on the `RefCell<Vec<String>>` to get an
immutable reference to the vector.
-->
<p>行わなければならない最後の変更は、アサート内部にあります: 内部のベクタにある要素の数を確認するため、
<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>に<code>borrow</code>を呼び出し、ベクタへの不変参照を得ています。</p>
<!--
Now that you’ve seen how to use `RefCell<T>`, let’s dig into how it works!
-->
<p><code>RefCell&lt;T&gt;</code>の使用法を見かけたので、動作の仕方を深掘りしましょう！</p>
<!--
#### Keeping track of Borrows at Runtime with `RefCell<T>`
-->
<h4 id="refcelltで実行時に借用を追いかける"><a class="header" href="#refcelltで実行時に借用を追いかける"><code>RefCell&lt;T&gt;</code>で実行時に借用を追いかける</a></h4>
<!--
When creating immutable and mutable references, we use the `&` and `&mut`
syntax, respectively. With `RefCell<T>`, we use the `borrow` and `borrow_mut`
methods, which are part of the safe API that belongs to `RefCell<T>`. The
`borrow` method returns the smart pointer type `Ref<T>`, and `borrow_mut`
returns the smart pointer type `RefMut<T>`. Both types implement `Deref`, so we
can treat them like regular references.
-->
<p>不変および可変参照を作成する時、それぞれ<code>&amp;</code>と<code>&amp;mut</code>記法を使用します。<code>RefCell&lt;T&gt;</code>では、
<code>borrow</code>と<code>borrow_mut</code>メソッドを使用し、これらは<code>RefCell&lt;T&gt;</code>に所属する安全なAPIの一部です。
<code>borrow</code>メソッドは、スマートポインタ型の<code>Ref&lt;T&gt;</code>を返し、<code>borrow_mut</code>はスマートポインタ型の<code>RefMut&lt;T&gt;</code>を返します。
どちらの型も<code>Deref</code>を実装しているので、普通の参照のように扱うことができます。</p>
<!--
The `RefCell<T>` keeps track of how many `Ref<T>` and `RefMut<T>` smart
pointers are currently active. Every time we call `borrow`, the `RefCell<T>`
increases its count of how many immutable borrows are active. When a `Ref<T>`
value goes out of scope, the count of immutable borrows goes down by one. Just
like the compile-time borrowing rules, `RefCell<T>` lets us have many immutable
borrows or one mutable borrow at any point in time.
-->
<p><code>RefCell&lt;T&gt;</code>は、現在活動中の<code>Ref&lt;T&gt;</code>と<code>RefMut&lt;T&gt;</code>スマートポインタの数を追いかけます。
<code>borrow</code>を呼び出す度に、<code>RefCell&lt;T&gt;</code>は活動中の不変参照の数を増やします。<code>Ref&lt;T&gt;</code>の値がスコープを抜けたら、
不変参照の数は1下がります。コンパイル時の借用規則と全く同じように、<code>RefCell&lt;T&gt;</code>はいかなる時も、
複数の不変借用または1つの可変借用を持たせてくれるのです。</p>
<!--
If we try to violate these rules, rather than getting a compiler error as we
would with references, the implementation of `RefCell<T>` will panic at
runtime. Listing 15-23 shows a modification of the implementation of `send` in
Listing 15-22. We’re deliberately trying to create two mutable borrows active
for the same scope to illustrate that `RefCell<T>` prevents us from doing this
at runtime.
-->
<p>これらの規則を侵害しようとすれば、参照のようにコンパイルエラーになるのではなく、
<code>RefCell&lt;T&gt;</code>の実装は実行時にパニックするでしょう。リスト15-23は、リスト15-22の<code>send</code>実装に対する変更を示しています。
同じスコープで2つの可変借用が活動するようわざと生成し、<code>RefCell&lt;T&gt;</code>が実行時にこれをすることを阻止してくれるところを説明しています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Messenger for MockMessenger {
    fn send(&amp;self, message: &amp;str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
</code></pre>
<!--
<span class="caption">Listing 15-23: Creating two mutable references in the
same scope to see that `RefCell<T>` will panic</span>
-->
<p><span class="caption">リスト15-23: 同じスコープで2つの可変参照を生成して<code>RefCell&lt;T&gt;</code>がパニックすることを確かめる</span></p>
<!--
We create a variable `one_borrow` for the `RefMut<T>` smart pointer returned
from `borrow_mut`. Then we create another mutable borrow in the same way in the
variable `two_borrow`. This makes two mutable references in the same scope,
which isn’t allowed. When we run the tests for our library, the code in Listing
15-23 will compile without any errors, but the test will fail:
-->
<p><code>borrow_mut</code>から返ってきた<code>RefMut&lt;T&gt;</code>スマートポインタに対して変数<code>one_borrow</code>を生成しています。
そして、同様にして変数<code>two_borrow</code>にも別の可変借用を生成しています。これにより同じスコープで2つの可変参照ができ、
これは許可されないことです。このテストを自分のライブラリ用に走らせると、リスト15-23のコードはエラーなくコンパイルできますが、
テストは失敗するでしょう:</p>
<pre><code class="language-text">---- tests::it_sends_an_over_75_percent_warning_message stdout ----
	thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at
'already borrowed: BorrowMutError', src/libcore/result.rs:906:4
  (スレッド'tests::it_sends_an_over_75_percent_warning_message'は、
'すでに借用されています: BorrowMutError', src/libcore/result.rs:906:4でパニックしました)
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<!--
Notice that the code panicked with the message `already borrowed:
BorrowMutError`. This is how `RefCell<T>` handles violations of the borrowing
rules at runtime.
-->
<p>コードは、<code>already borrowed: BorrowMutError</code>というメッセージとともにパニックしたことに注目してください。
このようにして<code>RefCell&lt;T&gt;</code>は実行時に借用規則の侵害を扱うのです。</p>
<!--
Catching borrowing errors at runtime rather than compile time means that you
would find a mistake in your code later in the development process and possibly
not until our code was deployed to production. Also, your code will incur a
small runtime performance penalty as a result of keeping track of the borrows
at runtime rather than compile time. However, using `RefCell<T>` makes it
possible to write a mock object that can modify itself to keep track of the
messages it has seen while you're using it in a context where only immutable
values are allowed. You can use `RefCell<T>` despite its trade-offs to get more
functionality than regular references provide.
-->
<p>コンパイル時ではなく実行時に借用エラーをキャッチするということは、開発過程の遅い段階でコードのミスを発見し、
コードをプロダクションにデプロイする時まで発見しない可能性もあることを意味します。また、
コンパイル時ではなく、実行時に借用を追いかける結果として、少し実行時にパフォーマンスを犠牲にするでしょう。
しかしながら、<code>RefCell&lt;T&gt;</code>を使うことで、不変値のみが許可される文脈で使用しつつ、
自身を変更して見かけたメッセージを追跡するモックオブジェクトを書くことが可能になります。
代償はありますが、<code>RefCell&lt;T&gt;</code>を使用すれば、普通の参照よりも多くの機能を得ることができるわけです。</p>
<!--
### Having Multiple Owners of Mutable Data by Combining `Rc<T>` and `RefCell<T>`
-->
<h3 id="rctとrefcelltを組み合わせることで可変なデータに複数の所有者を持たせる"><a class="header" href="#rctとrefcelltを組み合わせることで可変なデータに複数の所有者を持たせる"><code>Rc&lt;T&gt;</code>と<code>RefCell&lt;T&gt;</code>を組み合わせることで可変なデータに複数の所有者を持たせる</a></h3>
<!--
A common way to use `RefCell<T>` is in combination with `Rc<T>`. Recall that
`Rc<T>` lets you have multiple owners of some data, but it only gives immutable
access to that data. If you have an `Rc<T>` that holds a `RefCell<T>`, you can
get a value that can have multiple owners *and* that you can mutate!
-->
<p><code>RefCell&lt;T&gt;</code>の一般的な使用法は、<code>Rc&lt;T&gt;</code>と組み合わせることにあります。<code>Rc&lt;T&gt;</code>は何らかのデータに複数の所有者を持たせてくれるけれども、
そのデータに不変のアクセスしかさせてくれないことを思い出してください。<code>RefCell&lt;T&gt;</code>を抱える<code>Rc&lt;T&gt;</code>があれば、
複数の所有者を持ち<em>そして</em>、可変化できる値を得ることができるのです。</p>
<!--
For example, recall the cons list example in Listing 15-18 where we used
`Rc<T>` to allow multiple lists to share ownership of another list. Because
`Rc<T>` holds only immutable values, we can’t change any of the values in the
list once we’ve created them. Let’s add in `RefCell<T>` to gain the ability to
change the values in the lists. Listing 15-24 shows that by using a
`RefCell<T>` in the `Cons` definition, we can modify the value stored in all
the lists:
-->
<p>例を挙げれば、<code>Rc&lt;T&gt;</code>を使用して複数のリストに別のリストの所有権を共有させたリスト15-18のコンスリストの例を思い出してください。
<code>Rc&lt;T&gt;</code>は不変値だけを抱えるので、一旦生成したら、リストの値はどれも変更できません。<code>RefCell&lt;T&gt;</code>を含めて、
リストの値を変更する能力を得ましょう。<code>RefCell&lt;T&gt;</code>を<code>Cons</code>定義で使用することで、
リスト全てに格納されている値を変更できることをリスト15-24は示しています:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-24: Using `Rc<RefCell<i32>>` to create a
`List` that we can mutate</span>
-->
<p><span class="caption">リスト15-24: <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>で可変化できる<code>List</code>を生成する</span></p>
<!--
We create a value that is an instance of `Rc<RefCell<i32>>` and store it in a
variable named `value` so we can access it directly later. Then we create a
`List` in `a` with a `Cons` variant that holds `value`. We need to clone
`value` so both `a` and `value` have ownership of the inner `5` value rather
than transferring ownership from `value` to `a` or having `a` borrow from
`value`.
-->
<p><code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>のインスタンスの値を生成し、<code>value</code>という名前の変数に格納しているので、
直接後ほどアクセスすることができます。そして、<code>a</code>に<code>value</code>を持つ<code>Cons</code>列挙子で<code>List</code>を生成しています。
<code>value</code>から<code>a</code>に所有権を移したり、<code>a</code>が<code>value</code>から借用するのではなく、<code>a</code>と<code>value</code>どちらにも中の<code>5</code>の値の所有権を持たせるよう、
<code>value</code>をクローンする必要があります。</p>
<!--
We wrap the list `a` in an `Rc<T>` so when we create lists `b` and `c`, they
can both refer to `a`, which is what we did in Listing 15-18.
-->
<p>リスト<code>a</code>を<code>Rc&lt;T&gt;</code>に包んでいるので、リスト<code>b</code>と<code>c</code>を生成する時に、どちらも<code>a</code>を参照できます。
リスト15-18ではそうしていました。</p>
<!--
After we’ve created the lists in `a`, `b`, and `c`, we add 10 to the value in
`value`. We do this by calling `borrow_mut` on `value`, which uses the
automatic dereferencing feature we discussed in Chapter 5 (see the section
“Where’s the `->` Operator?”) to dereference the `Rc<T>` to the inner
`RefCell<T>` value. The `borrow_mut` method returns a `RefMut<T>` smart
pointer, and we use the dereference operator on it and change the inner value.
-->
<p><code>a</code>、<code>b</code>、<code>c</code>のリストを作成した後、<code>value</code>の値に10を足しています。これを<code>value</code>の<code>borrow_mut</code>を呼び出すことで行い、
これは、第5章で議論した自動参照外し機能(「<code>-&gt;</code>演算子はどこに行ったの？」節をご覧ください)を使用して、
<code>Rc&lt;T&gt;</code>を内部の<code>RefCell&lt;T&gt;</code>値に参照外ししています。<code>borrow_mut</code>メソッドは、
<code>RefMut&lt;T&gt;</code>スマートポインタを返し、それに対して参照外し演算子を使用し、中の値を変更します。</p>
<!--
When we print `a`, `b`, and `c`, we can see that they all have the modified
value of 15 rather than 5:
-->
<p><code>a</code>、<code>b</code>、<code>c</code>を出力すると、全て5ではなく、変更された15という値になっていることがわかります。</p>
<pre><code class="language-text">a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<!--
This technique is pretty neat! By using `RefCell<T>`, we have an outwardly
immutable `List` value. But we can use the methods on `RefCell<T>` that provide
access to its interior mutability so we can modify our data when we need to.
The runtime checks of the borrowing rules protect us from data races, and it’s
sometimes worth trading a bit of speed for this flexibility in our data
structures.
-->
<p>このテクニックは非常に綺麗です！<code>RefCell&lt;T&gt;</code>を使用することで表面上は不変な<code>List</code>値を持てます。
しかし、内部可変性へのアクセスを提供する<code>RefCell&lt;T&gt;</code>のメソッドを使用できるので、必要な時にはデータを変更できます。
借用規則を実行時に精査することでデータ競合を防ぎ、時としてデータ構造でちょっとのスピードを犠牲にこの柔軟性を得るのは価値があります。</p>
<!--
The standard library has other types that provide interior mutability, such as
`Cell<T>`, which is similar except that instead of giving references to the
inner value, the value is copied in and out of the `Cell<T>`. There’s also
`Mutex<T>`, which offers interior mutability that’s safe to use across threads;
we’ll discuss its use in Chapter 16. Check out the standard library docs for
more details on the differences between these types.
-->
<p>標準ライブラリには、<code>Cell&lt;T&gt;</code>などの内部可変性を提供する他の型もあり、この型は、内部値への参照を与える代わりに、
値は<code>Cell&lt;T&gt;</code>の内部や外部へコピーされる点を除き似ています。また<code>Mutex&lt;T&gt;</code>もあり、
これはスレッド間で使用するのが安全な内部可変性を提供します; 第16章でその使いみちについて議論しましょう。
これらの型の違いをより詳しく知るには、標準ライブラリのドキュメンテーションをチェックしてください。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Reference Cycles Can Leak Memory
-->
<h2 id="循環参照はメモリをリークすることもある"><a class="header" href="#循環参照はメモリをリークすることもある">循環参照は、メモリをリークすることもある</a></h2>
<!--
Rust’s memory safety guarantees make it difficult, but not impossible, to
accidentally create memory that is never cleaned up (known as a *memory leak*).
Preventing memory leaks entirely is not one of Rust’s guarantees in the same
way that disallowing data races at compile time is, meaning memory leaks are
memory safe in Rust. We can see that Rust allows memory leaks by using `Rc<T>`
and `RefCell<T>`: it’s possible to create references where items refer to each
other in a cycle. This creates memory leaks because the reference count of each
item in the cycle will never reach 0, and the values will never be dropped.
-->
<p>Rustのメモリ安全保証により誤って絶対に片付けられることのないメモリ(<em>メモリリーク</em>として知られています)を生成してしまいにくくなりますが、
不可能にはなりません。コンパイル時にデータ競合を防ぐのと同じようにメモリリークを完全に回避することは、
Rustの保証の一つではなく、メモリリークはRustにおいてはメモリ安全であることを意味します。
Rustでは、<code>Rc&lt;T&gt;</code>と<code>RefCell&lt;T&gt;</code>を使用してメモリリークを許可するとわかります:
要素がお互いに循環して参照する参照を生成することも可能ということです。循環の各要素の参照カウントが絶対に0にならないので、
これはメモリリークを起こし、値は絶対にドロップされません。</p>
<!--
### Creating a Reference Cycle
-->
<h3 id="循環参照させる"><a class="header" href="#循環参照させる">循環参照させる</a></h3>
<!--
Let’s look at how a reference cycle might happen and how to prevent it,
starting with the definition of the `List` enum and a `tail` method in Listing
15-25:
-->
<p>リスト15-25の<code>List</code> enumの定義と<code>tail</code>メソッドから始めて、どう循環参照が起こる可能性があるのかとその回避策を見ましょう:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<!-- Hidden fn main is here to disable the automatic wrapping in fn main that
doc tests do; the `use List` fails if this listing is put within a main -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span>use std::rc::Rc;
use std::cell::RefCell;
use List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match *self {
            Cons(_, ref item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-25: A cons list definition that holds a
`RefCell<T>` so we can modify what a `Cons` variant is referring to</span>
-->
<p><span class="caption">リスト15-25: <code>Cons</code>列挙子が参照しているものを変更できるように<code>RefCell&lt;T&gt;</code>を抱えているコンスリストの定義</span></p>
<!--
We’re using another variation of the `List` definition in Listing 15-5. The
second element in the `Cons` variant is now `RefCell<Rc<List>>`, meaning that
instead of having the ability to modify the `i32` value as we did in Listing
15-24, we want to modify which `List` value a `Cons` variant is pointing to.
We're also adding a `tail` method to make it convenient for us to access the
second item if we have a `Cons` variant.
-->
<p>リスト15-5の<code>List</code>定義の別バリエーションを使用しています。<code>Cons</code>列挙子の2番目の要素はこれで<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>になり、
リスト15-24のように<code>i32</code>値を変更する能力があるのではなく、<code>Cons</code>列挙子が指している<code>List</code>値の先を変えたいということです。
また、<code>tail</code>メソッドを追加して<code>Cons</code>列挙子があるときに2番目の要素にアクセスするのが便利になるようにしています。</p>
<!--
In Listing 15-26, we’re adding a `main` function that uses the definitions in
Listing 15-25. This code creates a list in `a` and a list in `b` that points to
the list in `a`. Then it modifies the list in `a` to point to `b`, creating a
reference cycle. There are `println!` statements along the way to show what the
reference counts are at various points in this process.
-->
<p>リスト15-26でリスト15-25の定義を使用する<code>main</code>関数を追加しています。このコードは、<code>a</code>にリストを、
<code>b</code>に<code>a</code>のリストを指すリストを作成します。それから<code>a</code>のリストを変更して<code>b</code>を指し、循環参照させます。
その流れの中に過程のいろんな場所での参照カウントを示す<code>println!</code>文が存在しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match *self {
</span><span class="boring">            Cons(_, ref item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    // aの最初の参照カウント = {}
    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    // aの次の要素は = {:?}
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    // b作成後のaの参照カウント = {}
    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    // bの最初の参照カウント = {}
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    // bの次の要素 = {:?}
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    // aを変更後のbの参照カウント = {}
    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    // aを変更後のaの参照カウント = {}
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // 次の行のコメントを外して循環していると確認してください; スタックオーバーフローします
    // println!(&quot;a next item = {:?}&quot;, a.tail());        // aの次の要素 = {:?}
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-26: Creating a reference cycle of two `List`
values pointing to each other</span>
-->
<p><span class="caption">リスト15-26: 2つの<code>List</code>値がお互いを指して循環参照する</span></p>
<!--
in the variable `a` or `b`がかかる先が不明瞭だが、コード例を見る限り、この訳が合っているようだ
-->
<!--
We create an `Rc<List>` instance holding a `List` value in the variable `a`
with an initial list of `5, Nil`. We then create an `Rc<List>` instance
holding another `List` value in the variable `b` that contains the value 10 and
points to the list in `a`.
-->
<p>最初のリストが<code>5, Nil</code>の<code>List</code>値を保持する<code>Rc&lt;List&gt;</code>インスタンスを変数<code>a</code>に生成します。
そして、値10と<code>a</code>のリストを指す別の<code>List</code>値を保持する<code>Rc&lt;List&gt;</code>インスタンスを変数<code>b</code>に生成します。</p>
<!--
We modify `a` so it points to `b` instead of `Nil`, creating a cycle. We
do that by using the `tail` method to get a reference to the
`RefCell<Rc<List>>` in `a`, which we put in the variable `link`. Then we use
the `borrow_mut` method on the `RefCell<Rc<List>>` to change the value inside
from an `Rc<List>` that holds a `Nil` value to the `Rc<List>` in `b`.
-->
<p><code>a</code>が<code>Nil</code>ではなく<code>b</code>を指すように変更して、循環させます。<code>tail</code>メソッドを使用して、
<code>a</code>の<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>への参照を得ることで循環させて、この参照は変数<code>link</code>に配置します。
それから<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>の<code>borrow_mut</code>メソッドを使用して中の値を<code>Nil</code>値を持つ<code>Rc&lt;List&gt;</code>から、
<code>b</code>の<code>Rc&lt;List&gt;</code>に変更します。</p>
<!--
When we run this code, keeping the last `println!` commented out for the
moment, we’ll get this output:
-->
<p>最後の<code>println!</code>を今だけコメントアウトしたまま、このコードを実行すると、こんな出力が得られます:</p>
<pre><code class="language-text">a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<!--
The reference count of the `Rc<List>` instances in both `a` and `b` are 2
after we change the list in `a` to point to `b`. At the end of `main`, Rust
will try to drop `b` first, which will decrease the count in each of the
`Rc<List>` instances in `a` and `b` by 1.
-->
<p><code>a</code>のリストを<code>b</code>を指すように変更した後の<code>a</code>と<code>b</code>の<code>Rc&lt;List&gt;</code>インスタンスの参照カウントは2です。
<code>main</code>の終端で、コンパイラはまず<code>b</code>をドロップしようとし、<code>a</code>と<code>b</code>の各<code>Rc&lt;List&gt;</code>インスタンスのカウントを1減らします。</p>
<!--
However, because `a` is still referencing the `Rc<List>` that was in `b`, that
`Rc<List>` has a count of 1 rather than 0, so the memory the `Rc<List>` has on
the heap won’t be dropped. The memory will just sit there with a count of 1,
forever. To visualize this reference cycle, we’ve created a diagram in Figure
15-4:
-->
<p>しかしながら、それでも<code>a</code>は<code>b</code>にあった<code>Rc&lt;List&gt;</code>を参照しているので、その<code>Rc&lt;List&gt;</code>のカウントは0ではなく1になり、
その<code>Rc&lt;List&gt;</code>がヒープに確保していたメモリはドロップされません。メモリはただ、カウント1のままそこに永遠に居座るのです。
この循環参照を可視化するために、図15-4に図式を作成しました:</p>
<!--
<img alt="Reference cycle of lists" src="img/trpl15-04.svg" class="center" />
-->
<img alt="リストの循環参照" src="img/trpl15-04.svg" class="center" />
<!--
<span class="caption">Figure 15-4: A reference cycle of lists `a` and `b`
pointing to each other</span>
-->
<p><span class="caption">図15-4: お互いを指すリスト<code>a</code>と<code>b</code>の循環参照</span></p>
<!--
If you uncomment the last `println!` and run the program, Rust will try to
print this cycle with `a` pointing to `b` pointing to `a` and so forth until it
overflows the stack.
-->
<p>最後の<code>println!</code>のコメントを外してプログラムを実行したら、<code>a</code>が<code>b</code>を指して、<code>b</code>が<code>a</code>を指してと、
スタックがオーバーフローするまでコンパイラはこの循環を出力しようとするでしょう。</p>
<!--
In this case, right after we create the reference cycle, the program ends. The
consequences of this cycle aren’t very dire. However, if a more complex program
allocated lots of memory in a cycle and held onto it for a long time, the
program would use more memory than it needed and might overwhelm the system,
causing it to run out of available memory.
-->
<p>この場合、循環参照を作る直後にプログラムは終了します。この循環の結果は、それほど悲壮なものではありません。しかしながら、
より複雑なプログラムが多くのメモリを循環で確保し長い間その状態を保ったら、プログラムは必要以上のメモリを使用し、
使用可能なメモリを枯渇させてシステムを参らせてしまう可能性があります。</p>
<!--
Creating reference cycles is not easily done, but it’s not impossible either.
If you have `RefCell<T>` values that contain `Rc<T>` values or similar nested
combinations of types with interior mutability and reference counting, you must
ensure that you don’t create cycles; you can’t rely on Rust to catch them.
Creating a reference cycle would be a logic bug in your program that you should
use automated tests, code reviews, and other software development practices to
minimize.
-->
<p>循環参照は簡単にできることではありませんが、不可能というわけでもありません。
<code>Rc&lt;T&gt;</code>値を含む<code>RefCell&lt;T&gt;</code>値があるなどの内部可変性と参照カウントのある型がネストして組み合わさっていたら、
循環していないことを保証しなければなりません; コンパイラがそれを捕捉することを信頼できないのです。
循環参照をするのは、自動テストやコードレビューなどの他のソフトウェア開発手段を使用して最小化すべきプログラム上のロジックバグでしょう。</p>
<!--
Another solution for avoiding reference cycles is reorganizing your data
structures so that some references express ownership and some references don’t.
As a result, you can have cycles made up of some ownership relationships and
some non-ownership relationships, and only the ownership relationships affect
whether or not a value can be dropped. In Listing 15-25, we always want `Cons`
variants to own their list, so reorganizing the data structure isn’t possible.
Let’s look at an example using graphs made up of parent nodes and child nodes
to see when non-ownership relationships are an appropriate way to prevent
reference cycles.
-->
<p>循環参照を回避する別の解決策は、ある参照は所有権を表現して他の参照はしないというようにデータ構造を再構成することです。
結果として、所有権のある関係と所有権のない関係からなる循環ができ、所有権のある関係だけが、値がドロップされうるかどうかに影響します。
リスト15-25では、常に<code>Cons</code>列挙子にリストを所有してほしいので、データ構造を再構成することはできません。
親ノードと子ノードからなるグラフを使った例に目を向けて、どんな時に所有権のない関係が循環参照を回避するのに適切な方法になるか確認しましょう。</p>
<!--
### Preventing Reference Cycles: Turning an `Rc<T>` into a `Weak<T>`
-->
<h3 id="循環参照を回避する-rctをweaktに変換する"><a class="header" href="#循環参照を回避する-rctをweaktに変換する">循環参照を回避する: <code>Rc&lt;T&gt;</code>を<code>Weak&lt;T&gt;</code>に変換する</a></h3>
<!--
So far, we’ve demonstrated that calling `Rc::clone` increases the
`strong_count` of an `Rc<T>` instance, and an `Rc<T>` instance is only cleaned
up if its `strong_count` is 0. You can also create a *weak reference* to the
value within an `Rc<T>` instance by calling `Rc::downgrade` and passing a
reference to the `Rc<T>`. When you call `Rc::downgrade`, you get a smart
pointer of type `Weak<T>`. Instead of increasing the `strong_count` in the
`Rc<T>` instance by 1, calling `Rc::downgrade` increases the `weak_count` by 1.
The `Rc<T>` type uses `weak_count` to keep track of how many `Weak<T>`
references exist, similar to `strong_count`. The difference is the `weak_count`
doesn’t need to be 0 for the `Rc<T>` instance to be cleaned up.
-->
<p>ここまで、<code>Rc::clone</code>を呼び出すと<code>Rc&lt;T&gt;</code>インスタンスの<code>strong_count</code>が増えることと、
<code>strong_count</code>が0になった時に<code>Rc&lt;T&gt;</code>インスタンスは片付けられることをデモしてきました。
<code>Rc::downgrade</code>を呼び出し、<code>Rc&lt;T&gt;</code>への参照を渡すことで、<code>Rc&lt;T&gt;</code>インスタンス内部の値への<em>弱い参照</em>(weak reference)を作ることもできます。
<code>Rc::downgrade</code>を呼び出すと、型<code>Weak&lt;T&gt;</code>のスマートポインタが得られます。
<code>Rc&lt;T&gt;</code>インスタンスの<code>strong_count</code>を1増やす代わりに、<code>Rc::downgrade</code>を呼び出すと、<code>weak_count</code>が1増えます。
<code>strong_count</code>同様、<code>Rc&lt;T&gt;</code>型は<code>weak_count</code>を使用して、幾つの<code>Weak&lt;T&gt;</code>参照が存在しているかを追跡します。
違いは、<code>Rc&lt;T&gt;</code>が片付けられるのに、<code>weak_count</code>が0である必要はないということです。</p>
<!--
Strong references are how you can share ownership of an `Rc<T>` instance. Weak
references don’t express an ownership relationship. They won’t cause a
reference cycle because any cycle involving some weak references will be broken
once the strong reference count of values involved is 0.
-->
<p>強い参照は、<code>Rc&lt;T&gt;</code>インスタンスの所有権を共有する方法です。弱い参照は、所有権関係を表現しません。
ひとたび、関係する値の強い参照カウントが0になれば、弱い参照が関わる循環はなんでも破壊されるので、
循環参照にはなりません。</p>
<!--
Because the value that `Weak<T>` references might have been dropped, to do
anything with the value that a `Weak<T>` is pointing to, you must make sure the
value still exists. Do this by calling the `upgrade` method on a `Weak<T>`
instance, which will return an `Option<Rc<T>>`. You’ll get a result of `Some`
if the `Rc<T>` value has not been dropped yet and a result of `None` if the
`Rc<T>` value has been dropped. Because `upgrade` returns an `Option<T>`, Rust
will ensure that the `Some` case and the `None` case are handled, and there
won't be an invalid pointer.
-->
<p><code>Weak&lt;T&gt;</code>が参照する値はドロップされてしまっている可能性があるので、<code>Weak&lt;T&gt;</code>が指す値に何かをするには、
値がまだ存在することを確認しなければなりません。<code>Weak&lt;T&gt;</code>の<code>upgrade</code>メソッドを呼び出すことでこれをしてください。
このメソッドは<code>Option&lt;Rc&lt;T&gt;&gt;</code>を返します。<code>Rc&lt;T&gt;</code>値がまだドロップされていなければ、<code>Some</code>の結果が、
<code>Rc&lt;T&gt;</code>値がドロップ済みなら、<code>None</code>の結果が得られます。<code>upgrade</code>が<code>Option&lt;T&gt;</code>を返すので、
コンパイラは、<code>Some</code>ケースと<code>None</code>ケースが扱われていることを確かめてくれ、無効なポインタは存在しません。</p>
<!--
As an example, rather than using a list whose items know only about the next
item, we’ll create a tree whose items know about their children items *and*
their parent items.
-->
<p>例として、要素が次の要素を知っているだけのリストを使うのではなく、要素が子要素<em>と</em>親要素を知っている木を作りましょう。</p>
<!--
#### Creating a Tree Data Structure: a `Node` with Child Nodes
-->
<h4 id="木データ構造を作る-子ノードのあるnode"><a class="header" href="#木データ構造を作る-子ノードのあるnode">木データ構造を作る: 子ノードのある<code>Node</code></a></h4>
<!--
To start, we’ll build a tree with nodes that know about their child nodes.
We’ll create a struct named `Node` that holds its own `i32` value as well as
references to its children `Node` values:
-->
<p>手始めに子ノードを知っているノードのある木を構成します。独自の<code>i32</code>値と子供の<code>Node</code>値への参照を抱える<code>Node</code>という構造体を作ります:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<!--
We want a `Node` to own its children, and we want to share that ownership with
variables so we can access each `Node` in the tree directly. To do this, we
define the `Vec<T>` items to be values of type `Rc<Node>`. We also want to
modify which nodes are children of another node, so we have a `RefCell<T>` in
`children` around the `Vec<Rc<Node>>`.
-->
<p><code>Node</code>に子供を所有してほしく、木の各<code>Node</code>に直接アクセスできるよう、その所有権を変数と共有したいです。
こうするために、<code>Vec&lt;T&gt;</code>要素を型<code>Rc&lt;Node&gt;</code>の値になるよう定義しています。どのノードが他のノードの子供になるかも変更したいので、
<code>Vec&lt;Rc&lt;Node&gt;&gt;</code>の周りの<code>children</code>を<code>RefCell&lt;T&gt;</code>にしています。</p>
<!--
Next, we’ll use our struct definition and create one `Node` instance named
`leaf` with the value 3 and no children, and another instance named `branch`
with the value 5 and `leaf` as one of its children, as shown in Listing 15-27:
-->
<p>次にこの構造体定義を使って値3と子供なしの<code>leaf</code>という1つの<code>Node</code>インスタンスと、
値5と<code>leaf</code>を子要素の一つとして持つ<code>branch</code>という別のインスタンスを作成します。
リスト15-27のようにですね:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">   children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-27: Creating a `leaf` node with no children
and a `branch` node with `leaf` as one of its children</span>
-->
<p><span class="caption">リスト15-27: 子供なしの<code>leaf</code>ノードと<code>leaf</code>を子要素に持つ<code>branch</code>ノードを作る</span></p>
<!--
We clone the `Rc<Node>` in `leaf` and store that in `branch`, meaning the
`Node` in `leaf` now has two owners: `leaf` and `branch`. We can get from
`branch` to `leaf` through `branch.children`, but there’s no way to get from
`leaf` to `branch`. The reason is that `leaf` has no reference to `branch` and
doesn’t know they’re related. We want `leaf` to know that `branch` is its
parent. We’ll do that next.
-->
<p><code>leaf</code>の<code>Rc&lt;Node&gt;</code>をクローンし、<code>branch</code>に格納しているので、<code>leaf</code>の<code>Node</code>は<code>leaf</code>と<code>branch</code>という2つの所有者を持つことになります。
<code>branch.children</code>を通して<code>branch</code>から<code>leaf</code>へ辿ることはできるものの、<code>leaf</code>から<code>branch</code>へ辿る方法はありません。
理由は、<code>leaf</code>には<code>branch</code>への参照がなく、関係していることを知らないからです。<code>leaf</code>に<code>branch</code>が親であることを知ってほしいです。
次はそれを行います。</p>
<!--
#### Adding a Reference from a Child to Its Parent
-->
<h4 id="子供から親に参照を追加する"><a class="header" href="#子供から親に参照を追加する">子供から親に参照を追加する</a></h4>
<!--
To make the child node aware of its parent, we need to add a `parent` field to
our `Node` struct definition. The trouble is in deciding what the type of
`parent` should be. We know it can’t contain an `Rc<T>`, because that would
create a reference cycle with `leaf.parent` pointing to `branch` and
`branch.children` pointing to `leaf`, which would cause their `strong_count`
values to never be 0.
-->
<p>子供に親の存在を気付かせるために、<code>Node</code>構造体定義に<code>parent</code>フィールドを追加する必要があります。
<code>parent</code>の型を決める際に困ったことになります。<code>Rc&lt;T&gt;</code>を含むことができないのはわかります。
そうしたら、<code>leaf.parent</code>が<code>branch</code>を指し、<code>branch.children</code>が<code>leaf</code>を指して循環参照になり、
<code>strong_count</code>値が絶対に0にならなくなってしまうからです。</p>
<!--
Thinking about the relationships another way, a parent node should own its
children: if a parent node is dropped, its child nodes should be dropped as
well. However, a child should not own its parent: if we drop a child node, the
parent should still exist. This is a case for weak references!
-->
<p>この関係を別の方法で捉えると、親ノードは子供を所有すべきです: 親ノードがドロップされたら、
子ノードもドロップされるべきなのです。ですが、子供は親を所有するべきではありません:
子ノードをドロップしても、親はまだ存在するべきです。弱い参照を使う場面ですね！</p>
<!--
So instead of `Rc<T>`, we’ll make the type of `parent` use `Weak<T>`,
specifically a `RefCell<Weak<Node>>`. Now our `Node` struct definition looks
like this:
-->
<p>従って、<code>Rc&lt;T&gt;</code>の代わりに<code>parent</code>の型を<code>Weak&lt;T&gt;</code>を使ったもの、具体的には<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>にします。
さあ、<code>Node</code>構造体定義はこんな見た目になりました:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<!--
A node will be able to refer to its parent node but doesn’t own its parent.
In Listing 15-28, we update `main` to use this new definition so the `leaf`
node will have a way to refer to its parent, `branch`:
-->
<p>ノードは親ノードを参照できるものの、所有はしないでしょう。リスト15-28で、
<code>leaf</code>ノードが親の<code>branch</code>を参照できるよう、この新しい定義を使用するように<code>main</code>を更新します:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    // leafの親 = {:?}
    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-28: A `leaf` node with a weak reference to its
parent node `branch`</span>
-->
<p><span class="caption">リスト15-28: 親ノードの<code>branch</code>への弱い参照がある<code>leaf</code>ノード</span></p>
<!--
Creating the `leaf` node looks similar to how creating the `leaf` node looked
in Listing 15-27 with the exception of the `parent` field: `leaf` starts out
without a parent, so we create a new, empty `Weak<Node>` reference instance.
-->
<p><code>leaf</code>ノードを作成することは、<code>parent</code>フィールドの例外を除いてリスト15-27での<code>leaf</code>ノードの作成法の見た目に似ています:
<code>leaf</code>は親なしで始まるので、新しく空の<code>Weak&lt;Node&gt;</code>参照インスタンスを作ります。</p>
<!--
At this point, when we try to get a reference to the parent of `leaf` by using
the `upgrade` method, we get a `None` value. We see this in the output from the
first `println!` statement:
-->
<p>この時点で<code>upgrade</code>メソッドを使用して<code>leaf</code>の親への参照を得ようとすると、<code>None</code>値になります。
このことは、最初の<code>println!</code>文の出力でわかります:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<!--
When we create the `branch` node, it will also have a new `Weak<Node>`
reference in the `parent` field, because `branch` doesn’t have a parent node.
We still have `leaf` as one of the children of `branch`. Once we have the
`Node` instance in `branch`, we can modify `leaf` to give it a `Weak<Node>`
reference to its parent. We use the `borrow_mut` method on the
`RefCell<Weak<Node>>` in the `parent` field of `leaf`, and then we use the
`Rc::downgrade` function to create a `Weak<Node>` reference to `branch` from
the `Rc<Node>` in `branch.`
-->
<p><code>branch</code>ノードを作る際、<code>branch</code>には親ノードがないので、こちらも<code>parent</code>フィールドには新しい<code>Weak&lt;Node&gt;</code>参照が入ります。
それでも、<code>leaf</code>は<code>branch</code>の子供になっています。一旦<code>branch</code>に<code>Node</code>インスタンスができたら、
<code>leaf</code>を変更して親への<code>Weak&lt;Node&gt;</code>参照を与えることができます。<code>leaf</code>の<code>parent</code>フィールドには、
<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>の<code>borrow_mut</code>メソッドを使用して、それから<code>Rc::downgrade</code>関数を使用して、
<code>branch</code>の<code>Rc&lt;Node&gt;</code>から<code>branch</code>への<code>Weak&lt;Node&gt;</code>参照を作ります。</p>
<!--
When we print the parent of `leaf` again, this time we’ll get a `Some` variant
holding `branch`: now `leaf` can access its parent! When we print `leaf`, we
also avoid the cycle that eventually ended in a stack overflow like we had in
Listing 15-26; the `Weak<Node>` references are printed as `(Weak)`:
-->
<p>再度<code>leaf</code>の親を出力すると、今度は<code>branch</code>を保持する<code>Some</code>列挙子が得られます: これで<code>leaf</code>が親にアクセスできるようになったのです！
<code>leaf</code>を出力すると、リスト15-26で起こっていたような最終的にスタックオーバーフローに行き着く循環を避けることもできます;
<code>Weak&lt;Node&gt;</code>参照は、<code>(Weak)</code>と出力されます:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<!--
The lack of infinite output indicates that this code didn’t create a reference
cycle. We can also tell this by looking at the values we get from calling
`Rc::strong_count` and `Rc::weak_count`.
-->
<p>無限の出力が欠けているということは、このコードは循環参照しないことを示唆します。
このことは、<code>Rc::strong_count</code>と<code>Rc::weak_count</code>を呼び出すことで得られる値を見てもわかります。</p>
<!--
#### Visualizing Changes to `strong_count` and `weak_count`
-->
<h4 id="strong_countとweak_countへの変更を可視化する"><a class="header" href="#strong_countとweak_countへの変更を可視化する"><code>strong_count</code>と<code>weak_count</code>への変更を可視化する</a></h4>
<!--
Let’s look at how the `strong_count` and `weak_count` values of the `Rc<Node>`
instances change by creating a new inner scope and moving the creation of
`branch` into that scope. By doing so, we can see what happens when `branch` is
created and then dropped when it goes out of scope. The modifications are shown
in Listing 15-29:
-->
<p>新しい内部スコープを作り、<code>branch</code>の作成をそのスコープに移動することで、
<code>Rc&lt;Node&gt;</code>インスタンスの<code>strong_count</code>と<code>weak_count</code>値がどう変化するかを眺めましょう。
そうすることで、<code>branch</code>が作成され、それからスコープを抜けてドロップされる時に起こることが確認できます。
変更は、リスト15-29に示してあります:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        // leafのstrong_count = {}, weak_count = {}
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            // branchのstrong_count = {}, weak_count = {}
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre></pre>
<!--
<span class="caption">Listing 15-29: Creating `branch` in an inner scope and
examining strong and weak reference counts</span>
-->
<p><span class="caption">リスト15-29: 内側のスコープで<code>branch</code>を作成し、強弱参照カウントを調査する</span></p>
<!--
4行目後半、カッコ内、forは接続詞の用法かと思ったが、文ではなかった。for S to Vのように訳した
通常forの後は、名詞が来るため、そう書いているだけだろうか
-->
<!--
After `leaf` is created, its `Rc<Node>` has a strong count of 1 and a weak
count of 0. In the inner scope, we create `branch` and associate it with
`leaf`, at which point when we print the counts, the `Rc<Node>` in `branch`
will have a strong count of 1 and a weak count of 1 (for `leaf.parent` pointing
to `branch` with a `Weak<Node>`). When we print the counts in `leaf`, we’ll see
it will have a strong count of 2, because `branch` now has a clone of the
`Rc<Node>` of `leaf` stored in `branch.children`, but will still have a weak
count of 0.
-->
<p><code>leaf</code>作成後、その<code>Rc&lt;Node&gt;</code>の強カウントは1、弱カウントは0になります。内側のスコープで<code>branch</code>を作成し、
<code>leaf</code>に紐付け、この時点でカウントを出力すると、<code>branch</code>の<code>Rc&lt;Node&gt;</code>の強カウントは1、
弱カウントも1になります(<code>leaf.parent</code>が<code>Weak&lt;Node&gt;</code>で<code>branch</code>を指しているため)。
<code>leaf</code>のカウントを出力すると、強カウントが2になっていることがわかります。<code>branch</code>が今は、
<code>branch.children</code>に格納された<code>leaf</code>の<code>Rc&lt;Node&gt;</code>のクローンを持っているからですが、
それでも弱カウントは0でしょう。</p>
<!--
When the inner scope ends, `branch` goes out of scope and the strong count of
the `Rc<Node>` decreases to 0, so its `Node` is dropped. The weak count of 1
from `leaf.parent` has no bearing on whether or not `Node` is dropped, so we
don’t get any memory leaks!
-->
<p>内側のスコープが終わると、<code>branch</code>はスコープを抜け、<code>Rc&lt;Node&gt;</code>の強カウントは0に減るので、
この<code>Node</code>はドロップされます。<code>leaf.parent</code>からの弱カウント1は、<code>Node</code>がドロップされるか否かには関係ないので、
メモリリークはしないのです！</p>
<!--
If we try to access the parent of `leaf` after the end of the scope, we’ll get
`None` again. At the end of the program, the `Rc<Node>` in `leaf` has a strong
count of 1 and a weak count of 0, because the variable `leaf` is now the only
reference to the `Rc<Node>` again.
-->
<p>このスコープの終端以後に<code>leaf</code>の親にアクセスしようとしたら、再び<code>None</code>が得られます。
プログラムの終端で<code>leaf</code>の<code>Rc&lt;Node&gt;</code>の強カウントは1、弱カウントは0です。
変数<code>leaf</code>が今では<code>Rc&lt;Node&gt;</code>への唯一の参照に再度なったからです。</p>
<!--
All of the logic that manages the counts and value dropping is built into
`Rc<T>` and `Weak<T>` and their implementations of the `Drop` trait. By
specifying that the relationship from a child to its parent should be a
`Weak<T>` reference in the definition of `Node`, you’re able to have parent
nodes point to child nodes and vice versa without creating a reference cycle
and memory leaks.
-->
<p>カウントや値のドロップを管理するロジックは全て、<code>Rc&lt;T&gt;</code>や<code>Weak&lt;T&gt;</code>とその<code>Drop</code>トレイトの実装に組み込まれています。
<code>Node</code>の定義で子供から親への関係は<code>Weak&lt;T&gt;</code>参照になるべきと指定することで、
循環参照やメモリリークを引き起こさずに親ノードに子ノードを参照させたり、その逆を行うことができます。</p>
<!--
## Summary
-->
<h2 id="まとめ-14"><a class="header" href="#まとめ-14">まとめ</a></h2>
<!--
This chapter covered how to use smart pointers to make different guarantees and
trade-offs than those Rust makes by default with regular references. The
`Box<T>` type has a known size and points to data allocated on the heap. The
`Rc<T>` type keeps track of the number of references to data on the heap so
that data can have multiple owners. The `RefCell<T>` type with its interior
mutability gives us a type that we can use when we need an immutable type but
need to change an inner value of that type; it also enforces the borrowing
rules at runtime instead of at compile time.
-->
<p>この章は、スマートポインタを使用してRustが既定で普通の参照に対して行うのと異なる保証や代償を行う方法を講義しました。
<code>Box&lt;T&gt;</code>型は、既知のサイズで、ヒープに確保されたデータを指します。<code>Rc&lt;T&gt;</code>型は、ヒープのデータへの参照の数を追跡するので、
データは複数の所有者を保有できます。内部可変性のある<code>RefCell&lt;T&gt;</code>型は、不変型が必要だけれども、
その型の中の値を変更する必要がある時に使用できる型を与えてくれます; また、コンパイル時ではなく実行時に借用規則を強制します。</p>
<!--
Also discussed were the `Deref` and `Drop` traits, which enable a lot of the
functionality of smart pointers. We explored reference cycles that can cause
memory leaks and how to prevent them using `Weak<T>`.
-->
<p><code>Deref</code>と<code>Drop</code>トレイトについても議論しましたね。これらは、スマートポインタの多くの機能を可能にしてくれます。
メモリリークを引き起こす循環参照と<code>Weak&lt;T&gt;</code>でそれを回避する方法も探究しました。</p>
<!--
If this chapter has piqued your interest and you want to implement your own
smart pointers, check out [“The Rustonomicon”][nomicon] for more useful
information.
-->
<p>この章で興味をそそられ、独自のスマートポインタを実装したくなったら、もっと役に立つ情報を求めて、
<a href="https://doc.rust-lang.org/stable/nomicon/">“The Rustonomicon”</a>をチェックしてください。</p>
<blockquote>
<p>訳注: 日本語版のThe Rustonomiconは<a href="https://doc.rust-jp.rs/rust-nomicon-ja/index.html">こちら</a>です。</p>
</blockquote>
<!--
Next, we’ll talk about concurrency in Rust. You’ll even learn about a few new
smart pointers.
-->
<p>次は、Rustでの並行性について語ります。もういくつか新しいスマートポインタについてさえも学ぶでしょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Fearless Concurrency
-->
<h1 id="恐れるな並行性"><a class="header" href="#恐れるな並行性">恐れるな！並行性</a></h1>
<!--
Handling concurrent programming safely and efficiently is another of Rust’s
major goals. *Concurrent programming*, where different parts of a program
execute independently, and *parallel programming*, where different parts of a
program execute at the same time, are becoming increasingly important as more
computers take advantage of their multiple processors. Historically,
programming in these contexts has been difficult and error prone: Rust hopes to
change that.
-->
<p>並行性を安全かつ効率的に扱うことは、Rustの別の主な目標です。<em>並行プログラミング</em>は、プログラムの異なる部分が独立して実行することであり、
<em>並列プログラミング</em>はプログラムの異なる部分が同時に実行することですが、多くのコンピュータが複数のプロセッサの利点を生かすようになるにつれ、
重要度を増しています。歴史的に、これらの文脈で行うプログラミングは困難で、エラーが起きやすいものでした:
Rustはこれを変えると願っています。</p>
<!--
Initially, the Rust team thought that ensuring memory safety and preventing
concurrency problems were two separate challenges to be solved with different
methods. Over time, the team discovered that the ownership and type systems are
a powerful set of tools to help manage memory safety *and* concurrency
problems! By leveraging ownership and type checking, many concurrency errors
are compile-time errors in Rust rather than runtime errors. Therefore, rather
than making you spend lots of time trying to reproduce the exact circumstances
under which a runtime concurrency bug occurs, incorrect code will refuse to
compile and present an error explaining the problem. As a result, you can fix
your code while you’re working on it rather than potentially after it has been
shipped to production. We’ve nicknamed this aspect of Rust *fearless*
*concurrency*. Fearless concurrency allows you to write code that is free of
subtle bugs and is easy to refactor without introducing new bugs.
-->
<p>当初、Rustチームは、メモリ安全性を保証することと、並行性問題を回避することは、
異なる方法で解決すべき別々の課題だと考えていました。時間とともに、チームは、所有権と型システムは、
メモリ安全性<em>と</em>並行性問題を管理する役に立つ一連の強力な道具であることを発見しました。
所有権と型チェックを活用することで、多くの並行性エラーは、実行時エラーではなくコンパイル時エラーになります。
故に、実行時に並行性のバグが起きた状況と全く同じ状況を再現しようと時間を浪費させるよりも、
不正なコードはコンパイルを拒み、問題を説明するエラーを提示するでしょう。結果として、
プロダクトになった後でなく、作業中にコードを修正できます。
Rustのこの方向性を<em>恐れるな！並行性</em>とニックネーム付けしました。これにより、潜在的なバグがなく、かつ、
新しいバグを導入することなく簡単にリファクタリングできるコードを書くことができます。</p>
<!--
Note: For simplicity’s sake, we’ll refer to many of the problems as
*concurrent* rather than being more precise by saying *concurrent and/or
parallel*. If this book were about concurrency and/or parallelism, we'd be
more specific. For this chapter, please mentally substitute *concurrent
and/or parallel* whenever we use *concurrent*.
-->
<blockquote>
<p>注釈: 簡潔性のため、並行または並列と述べることで正確を期するのではなく、
多くの問題を<em>並行</em>と割り切ってしまいます。この本がもし<em>並行性あるいは並列性</em>に関した本ならば、
詳述していたでしょう。この章に対しては、<em>並行</em>を使ったら、
脳内で<em>並行または並列</em>と置き換えてください。</p>
</blockquote>
<!--
Many languages are dogmatic about the solutions they offer for handling
concurrent problems. For example, Erlang has elegant functionality for
message-passing concurrency but has only obscure ways to share state between
threads. Supporting only a subset of possible solutions is a reasonable
strategy for higher-level languages, because a higher-level language promises
benefits from giving up some control to gain abstractions. However, lower-level
languages are expected to provide the solution with the best performance in any
given situation and have fewer abstractions over the hardware. Therefore, Rust
offers a variety of tools for modeling problems in whatever way is appropriate
for your situation and requirements.
-->
<p>多くの言語は、自分が提供する並行性問題を扱う解決策について独断的です。例えば、Erlangには、
メッセージ受け渡しの並行性に関する素晴らしい機能がありますが、スレッド間で状態を共有することに関しては、
曖昧な方法しかありません。可能な解決策の一部のみをサポートすることは、高級言語にとっては合理的な施策です。
なぜなら、高級言語は一部の制御を失う代わりに抽象化することから恩恵を受けるからです。ところが、
低級言語は、どんな場面でも最高のパフォーマンスで解決策を提供すると想定され、ハードウェアに関してほとんど抽象化はしません。
そのため、Rustは、自分の状況と必要性に適した方法が何であれ、問題をモデル化するためのいろんな道具を備えています。</p>
<!--
Here are the topics we’ll cover in this chapter:
-->
<p>こちらが、この章で講義する話題です:</p>
<!--
* How to create threads to run multiple pieces of code at the same time
* *Message-passing* concurrency, where channels send messages between threads
* *Shared-state* concurrency, where multiple threads have access to some piece
of data
* The `Sync` and `Send` traits, which extend Rust’s concurrency guarantees to
user-defined types as well as types provided by the standard library
-->
<ul>
<li>スレッドを生成して、複数のコードを同時に走らせる方法</li>
<li>チャンネルがスレッド間でメッセージを送る<em>メッセージ受け渡し</em>並行性</li>
<li>複数のスレッドが何らかのデータにアクセスする<em>状態共有</em>並行性</li>
<li>標準ライブラリが提供する型だけでなく、ユーザが定義した型に対してもRustの並行性の安全保証を拡張する<code>Sync</code>と<code>Send</code>トレイト</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
## Using Threads to Run Code Simultaneously
-->
<h2 id="スレッドを使用してコードを同時に走らせる"><a class="header" href="#スレッドを使用してコードを同時に走らせる">スレッドを使用してコードを同時に走らせる</a></h2>
<!--
In most current operating systems, an executed program’s code is run in a
*process*, and the operating system manages multiple processes at once. Within
your program, you can also have independent parts that run simultaneously. The
features that run these independent parts are called *threads*.
-->
<p>多くの現代のOSでは、実行中のプログラムのコードは<em>プロセス</em>で走り、OSは同時に複数のプロセスを管理します。
自分のプログラム内で、独立した部分を同時に実行できます。これらの独立した部分を走らせる機能を<em>スレッド</em>と呼びます。</p>
<!--
Splitting the computation in your program into multiple threads can improve
performance because the program does multiple tasks at the same time, but it
also adds complexity. Because threads can run simultaneously, there’s no
inherent guarantee about the order in which parts of your code on different
threads will run. This can lead to problems, such as:
-->
<p>プログラム内の計算を複数のスレッドに分けると、パフォーマンスが改善します。プログラムが同時に複数の作業をするからですが、
複雑度も増します。スレッドは同時に走らせることができるので、異なるスレッドのコードが走る順番に関して、
本来的に保証はありません。これは例えば以下のような問題を招きます:</p>
<!--
* Race conditions, where threads are accessing data or resources in an
inconsistent order
* Deadlocks, where two threads are waiting for each other to finish using a
resource the other thread has, preventing both threads from continuing
* Bugs that happen only in certain situations and are hard to reproduce and fix
reliably
-->
<ul>
<li>スレッドがデータやリソースに矛盾した順番でアクセスする競合状態</li>
<li>2つのスレッドがお互いにもう一方が持っているリソースを使用し終わるのを待ち、両者が継続するのを防ぐデッドロック</li>
<li>特定の状況でのみ起き、確実な再現や修正が困難なバグ</li>
</ul>
<!--
Rust attempts to mitigate the negative effects of using threads, but
programming in a multithreaded context still takes careful thought and requires
a code structure that is different from programs that run in a single
thread.
-->
<p>Rustは、スレッドを使用する際の悪影響を軽減しようとしていますが、それでも、マルチスレッドの文脈でのプログラミングでは、
注意深い思考とシングルスレッドで走るプログラムとは異なるコード構造が必要です。</p>
<!--
Programming languages implement threads in a few different ways. Many operating
systems provide an API for creating new threads. This model where a language
calls the operating system APIs to create threads is sometimes called *1:1*,
meaning one operating system thread per one language thread.
-->
<p>プログラミング言語によってスレッドはいくつかの方法で実装されています。多くのOSで、新規スレッドを生成するAPIが提供されています。
言語がOSのAPIを呼び出してスレッドを生成するこのモデルを時に<em>1:1</em>と呼び、1つのOSスレッドに対して1つの言語スレッドを意味します。</p>
<!--
Many programming languages provide their own special implementation of threads.
Programming language-provided threads are known as *green* threads, and
languages that use these green threads will execute them in the context of a
different number of operating system threads. For this reason, the
green-threaded model is called the *M:N* model: there are `M` green threads per
`N` operating system threads, where `M` and `N` are not necessarily the same
number.
-->
<p>多くのプログラミング言語がスレッドの独自の特別な実装を提供しています。プログラミング言語が提供するスレッドは、
<em>グリーン</em>スレッドとして知られ、このグリーンスレッドを使用する言語は、それを異なる数のOSスレッドの文脈で実行します。
このため、グリーンスレッドのモデルは<em>M:N</em>モデルと呼ばれます: <code>M</code>個のグリーンスレッドに対して、
<code>N</code>個のOSスレッドがあり、<code>M</code>と<code>N</code>は必ずしも同じ数字ではありません。</p>
<!--
Each model has its own advantages and trade-offs, and the trade-off most
important to Rust is runtime support. *Runtime* is a confusing term and can
have different meanings in different contexts.
-->
<p>各モデルには、それだけの利点と代償があり、Rustにとって最も重要な代償は、ランタイムのサポートです。
<em>ランタイム</em>は、混乱しやすい用語で文脈によって意味も変わります。</p>
<!--
In this context, by *runtime* we mean code that is included by the language in
every binary. This code can be large or small depending on the language, but
every non-assembly language will have some amount of runtime code. For that
reason, colloquially when people say a language has “no runtime,” they often
mean “small runtime.” Smaller runtimes have fewer features but have the
advantage of resulting in smaller binaries, which make it easier to combine the
language with other languages in more contexts. Although many languages are
okay with increasing the runtime size in exchange for more features, Rust needs
to have nearly no runtime and cannot compromise on being able to call into C to
maintain performance.
-->
<p>この文脈での<em>ランタイム</em>とは、言語によって全てのバイナリに含まれるコードのことを意味します。
言語によってこのコードの大小は決まりますが、非アセンブリ言語は全てある量の実行時コードを含みます。
そのため、口語的に誰かが「ノーランタイム」と言ったら、「小さいランタイム」のことを意味することがしばしばあります。
ランタイムが小さいと機能も少ないですが、バイナリのサイズも小さくなるという利点があり、
その言語を他の言語とより多くの文脈で組み合わせることが容易になります。多くの言語では、
より多くの機能と引き換えにランタイムのサイズが膨れ上がるのは、受け入れられることですが、
Rustにはほとんどゼロのランタイムが必要でパフォーマンスを維持するためにCコードを呼び出せることを妥協できないのです。</p>
<!--
The green-threading M:N model requires a larger language runtime to manage
threads. As such, the Rust standard library only provides an implementation of
1:1 threading. Because Rust is such a low-level language, there are crates that
implement M:N threading if you would rather trade overhead for aspects such as
more control over which threads run when and lower costs of context switching,
for example.
-->
<p>M:Nのグリーンスレッドモデルは、スレッドを管理するのにより大きな言語ランタイムが必要です。よって、
Rustの標準ライブラリは、1:1スレッドの実装のみを提供しています。Rustはそのような低級言語なので、
例えば、むしろどのスレッドがいつ走るかのより詳細な制御や、より低コストの文脈切り替えなどの一面をオーバーヘッドと引き換えるなら、
M:Nスレッドの実装をしたクレートもあります。</p>
<!--
Now that we’ve defined threads in Rust, let’s explore how to use the
thread-related API provided by the standard library.
-->
<p>今やRustにおけるスレッドを定義したので、標準ライブラリで提供されているスレッド関連のAPIの使用法を探究しましょう。</p>
<!--
### Creating a New Thread with `spawn`
-->
<h3 id="spawnで新規スレッドを生成する"><a class="header" href="#spawnで新規スレッドを生成する"><code>spawn</code>で新規スレッドを生成する</a></h3>
<!--
To create a new thread, we call the `thread::spawn` function and pass it a
closure (we talked about closures in Chapter 13) containing the code we want to
run in the new thread. The example in Listing 16-1 prints some text from a main
thread and other text from a new thread:
-->
<p>新規スレッドを生成するには、<code>thread::spawn</code>関数を呼び出し、
新規スレッドで走らせたいコードを含むクロージャ(クロージャについては第13章で語りました)を渡します。
リスト16-1の例は、メインスレッドと新規スレッドからテキストを出力します:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            // やあ！立ち上げたスレッドから数字{}だよ！
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        // メインスレッドから数字{}だよ！
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-1: Creating a new thread to print one thing
while the main thread prints something else</span>
-->
<p><span class="caption">リスト16-1: メインスレッドが別のものを出力する間に新規スレッドを生成して何かを出力する</span></p>
<!--
Note that with this function, the new thread will be stopped when the main
thread ends, whether or not it has finished running. The output from this
program might be a little different every time, but it will look similar to the
following:
-->
<p>この関数では、新しいスレッドは、実行が終わったかどうかにかかわらず、メインスレッドが終了したら停止することに注意してください。
このプログラムからの出力は毎回少々異なる可能性がありますが、だいたい以下のような感じでしょう:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<!--
The calls to `thread::sleep` force a thread to stop its execution for a short
duration, allowing a different thread to run. The threads will probably take
turns, but that isn’t guaranteed: it depends on how your operating system
schedules the threads. In this run, the main thread printed first, even though
the print statement from the spawned thread appears first in the code. And even
though we told the spawned thread to print until `i` is 9, it only got to 5
before the main thread shut down.
-->
<p><code>thread::sleep</code>を呼び出すと、少々の間、スレッドの実行を止め、違うスレッドを走らせることができます。
スレッドはおそらく切り替わるでしょうが、保証はありません: OSがスレッドのスケジュールを行う方法によります。
この実行では、コード上では立ち上げられたスレッドのprint文が先に現れているのに、メインスレッドが先に出力しています。また、
立ち上げたスレッドには<code>i</code>が9になるまで出力するよう指示しているのに、メインスレッドが終了する前の5までしか到達していません。</p>
<!--
If you run this code and only see output from the main thread, or don’t see any
overlap, try increasing the numbers in the ranges to create more opportunities
for the operating system to switch between the threads.
-->
<p>このコードを実行してメインスレッドの出力しか目の当たりにできなかったり、オーバーラップがなければ、
範囲の値を増やしてOSがスレッド切り替えを行う機会を増やしてみてください。</p>
<!--
### Waiting for All Threads to Finish Using `join` Handles
-->
<h3 id="joinハンドルで全スレッドの終了を待つ"><a class="header" href="#joinハンドルで全スレッドの終了を待つ"><code>join</code>ハンドルで全スレッドの終了を待つ</a></h3>
<!--
The code in Listing 16-1 not only stops the spawned thread prematurely most of
the time due to the main thread ending, but also can’t guarantee that the
spawned thread will get to run at all. The reason is that there is no guarantee
on the order in which threads run!
-->
<p>リスト16-1のコードは、メインスレッドが終了するためにほとんどの場合、立ち上げたスレッドがすべて実行されないだけでなく、
立ち上げたスレッドが実行されるかどうかも保証できません。原因は、スレッドの実行順に保証がないからです。</p>
<!--
We can fix the problem of the spawned thread not getting to run, or not getting
to run completely, by saving the return value of `thread::spawn` in a variable.
The return type of `thread::spawn` is `JoinHandle`. A `JoinHandle` is an owned
value that, when we call the `join` method on it, will wait for its thread to
finish. Listing 16-2 shows how to use the `JoinHandle` of the thread we created
in Listing 16-1 and call `join` to make sure the spawned thread finishes before
`main` exits:
-->
<p><code>thread::spawn</code>の戻り値を変数に保存することで、立ち上げたスレッドが実行されなかったり、
完全には実行されなかったりする問題を修正することができます。<code>thread::spawn</code>の戻り値の型は<code>JoinHandle</code>です。
<code>JoinHandle</code>は、その<code>join</code>メソッドを呼び出したときにスレッドの終了を待つ所有された値です。
リスト16-2は、リスト16-1で生成したスレッドの<code>JoinHandle</code>を使用し、<code>join</code>を呼び出して、
<code>main</code>が終了する前に、立ち上げたスレッドが確実に完了する方法を示しています:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-2: Saving a `JoinHandle` from `thread::spawn`
to guarantee the thread is run to completion</span>
-->
<p><span class="caption">リスト16-2: <code>thread::spawn</code>の<code>JoinHandle</code>を保存してスレッドが完了するのを保証する</span></p>
<!--
Calling `join` on the handle blocks the thread currently running until the
thread represented by the handle terminates. *Blocking* a thread means that
thread is prevented from performing work or exiting. Because we’ve put the call
to `join` after the main thread’s `for` loop, running Listing 16-2 should
produce output similar to this:
-->
<p>ハンドルに対して<code>join</code>を呼び出すと、ハンドルが表すスレッドが終了するまで現在実行中のスレッドをブロックします。
スレッドを<em>ブロック</em>するとは、そのスレッドが動いたり、終了したりすることを防ぐことです。
<code>join</code>の呼び出しをメインスレッドの<code>for</code>ループの後に配置したので、リスト16-2を実行すると、
以下のように出力されるはずです:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<!--
The two threads continue alternating, but the main thread waits because of the
call to `handle.join()` and does not end until the spawned thread is finished.
-->
<p>2つのスレッドが代わる代わる実行されていますが、<code>handle.join()</code>呼び出しのためにメインスレッドは待機し、
立ち上げたスレッドが終了するまで終わりません。</p>
<!--
But let’s see what happens when we instead move `handle.join()` before the
`for` loop in `main`, like this:
-->
<p>ですが、代わりに<code>handle.join()</code>を<code>for</code>ループの前に移動したらどうなるのか確認しましょう。こんな感じに:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<!--
The main thread will wait for the spawned thread to finish and then run its
`for` loop, so the output won’t be interleaved anymore, as shown here:
-->
<p>メインスレッドは、立ち上げたスレッドが終了するまで待ち、それから<code>for</code>ループを実行するので、
以下のように出力はもう混ざらないでしょう:</p>
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<!--
Small details, such as where `join` is called, can affect whether or not your
threads run at the same time.
-->
<p>どこで<code>join</code>を呼ぶかといったほんの些細なことが、スレッドが同時に走るかどうかに影響することもあります。</p>
<!--
### Using `move` Closures with Threads
-->
<h3 id="スレッドでmoveクロージャを使用する"><a class="header" href="#スレッドでmoveクロージャを使用する">スレッドで<code>move</code>クロージャを使用する</a></h3>
<!--
The `move` closure is often used alongside `thread::spawn` because it allows
you to use data from one thread in another thread.
-->
<p><code>move</code>クロージャは、<code>thread::spawn</code>とともによく使用されます。
あるスレッドのデータを別のスレッドで使用できるようになるからです。</p>
<!--
In Chapter 13, we mentioned we can use the `move` keywrod before the parameter
list of a closure to force the closure to take ownership of the values it uses
in the environment. This technique is especially useful when creating new
threads in order to transfer ownership of values from one thread to another.
-->
<p>第13章で、クロージャの引数リストの前に<code>move</code>キーワードを使用して、
クロージャに環境で使用している値の所有権を強制的に奪わせることができると述べました。
このテクニックは、あるスレッドから別のスレッドに値の所有権を移すために新しいスレッドを生成する際に特に有用です。</p>
<!--
Notice in Listing 16-1 that the closure we pass to `thread::spawn` takes no
arguments: we’re not using any data from the main thread in the spawned
thread’s code. To use data from the main thread in the spawned thread, the
spawned thread’s closure must capture the values it needs. Listing 16-3 shows
an attempt to create a vector in the main thread and use it in the spawned
thread. However, this won’t yet work, as you’ll see in a moment:
-->
<p>リスト16-1において、<code>thread::spawn</code>に渡したクロージャには引数がなかったことに注目してください:
立ち上げたスレッドのコードでメインスレッドからのデータは何も使用していないのです。
立ち上げたスレッドでメインスレッドのデータを使用するには、立ち上げるスレッドのクロージャは、
必要な値をキャプチャしなければなりません。リスト16-3は、メインスレッドでベクタを生成し、
立ち上げたスレッドで使用する試みを示しています。しかしながら、すぐにわかるように、これはまだ動きません:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        // こちらがベクタ: {:?}
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre>
<!--
<span class="caption">Listing 16-3: Attempting to use a vector created by the
main thread in another thread</span>
-->
<p><span class="caption">リスト16-3: 別のスレッドでメインスレッドが生成したベクタを使用しようとする</span></p>
<!--
The closure uses `v`, so it will capture `v` and make it part of the closure’s
environment. Because `thread::spawn` runs this closure in a new thread, we
should be able to access `v` inside that new thread. But when we compile this
example, we get the following error:
-->
<p>クロージャは<code>v</code>を使用しているので、<code>v</code>をキャプチャし、クロージャの環境の一部にしています。
<code>thread::spawn</code>はこのクロージャを新しいスレッドで走らせるので、
その新しいスレッド内で<code>v</code>にアクセスできるはずです。しかし、このコードをコンパイルすると、
以下のようなエラーが出ます:</p>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows `v`,
which is owned by the current function
(エラー: クロージャは現在の関数よりも長生きするかもしれませんが、現在の関数が所有している
`v`を借用しています)
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
(助言: `v`(や他の参照されている変数)の所有権をクロージャに奪わせるには、`move`キーワードを使用してください)
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<!--
Rust *infers* how to capture `v`, and because `println!` only needs a reference
to `v`, the closure tries to borrow `v`. However, there’s a problem: Rust can’t
tell how long the spawned thread will run, so it doesn’t know if the reference
to `v` will always be valid.
-->
<p>Rustは<code>v</code>のキャプチャ方法を<em>推論</em>し、<code>println!</code>は<code>v</code>への参照のみを必要とするので、クロージャは、
<code>v</code>を借用しようとします。ですが、問題があります: コンパイラには、立ち上げたスレッドがどのくらいの期間走るのかわからないので、
<code>v</code>への参照が常に有効であるか把握できないのです。</p>
<!--
Listing 16-4 provides a scenario that’s more likely to have a reference to `v`
that won’t be valid:
-->
<p>リスト16-4は、<code>v</code>への参照がより有効でなさそうな筋書きです:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    // いや〜！
    drop(v); // oh no!

    handle.join().unwrap();
}
</code></pre>
<!--
<span class="caption">Listing 16-4: A thread with a closure that attempts to
capture a reference to `v` from a main thread that drops `v`</span>
-->
<p><span class="caption">リスト16-4: <code>v</code>をドロップするメインスレッドから<code>v</code>への参照をキャプチャしようとするクロージャを伴うスレッド</span></p>
<!--
If we were allowed to run this code, there’s a possibility the spawned thread
would be immediately put in the background without running at all. The spawned
thread has a reference to `v` inside, but the main thread immediately drops
`v`, using the `drop` function we discussed in Chapter 15. Then, when the
spawned thread starts to execute, `v` is no longer valid, so a reference to it
is also invalid. Oh no!
-->
<p>このコードを実行できてしまうなら、立ち上げたスレッドはまったく実行されることなく即座にバックグラウンドに置かれる可能性があります。
立ち上げたスレッドは内部に<code>v</code>への参照を保持していますが、メインスレッドは、第15章で議論した<code>drop</code>関数を使用して、
即座に<code>v</code>をドロップしています。そして、立ち上げたスレッドが実行を開始する時には、<code>v</code>はもう有効ではなく、
参照も不正になるのです。あちゃー！</p>
<!--
To fix the compiler error in Listing 16-3, we can use the error message’s
advice:
-->
<p>リスト16-3のコンパイルエラーを修正するには、エラーメッセージのアドバイスを活用できます:</p>
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<!--
By adding the `move` keyword before the closure, we force the closure to take
ownership of the values it’s using rather than allowing Rust to infer that it
should borrow the values. The modification to Listing 16-3 shown in Listing
16-5 will compile and run as we intend:
-->
<p>クロージャの前に<code>move</code>キーワードを付することで、コンパイラに値を借用すべきと推論させるのではなく、
クロージャに使用している値の所有権を強制的に奪わせます。リスト16-5に示したリスト16-3に対する変更は、
コンパイルでき、意図通りに動きます:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-5: Using the `move` keyword to force a closure
to take ownership of the values it uses</span>
-->
<p><span class="caption">リスト16-5: <code>move</code>キーワードを使用してクロージャに使用している値の所有権を強制的に奪わせる</span></p>
<!--
What would happen to the code in Listing 16-4 where the main thread called
`drop` if we use a `move` closure? Would `move` fix that case? Unfortunately,
no; we would get a different error because what Listing 16-4 is trying to do
isn’t allowed for a different reason. If we added `move` to the closure, we
would move `v` into the closure’s environment, and we could no longer call
`drop` on it in the main thread. We would get this compiler error instead:
-->
<p><code>move</code>クロージャを使用していたら、メインスレッドが<code>drop</code>を呼び出すリスト16-4のコードはどうなるのでしょうか？
<code>move</code>で解決するのでしょうか？残念ながら、違います; リスト16-4が試みていることは別の理由によりできないので、
違うエラーが出ます。クロージャに<code>move</code>を付与したら、<code>v</code>をクロージャの環境にムーブするので、
最早メインスレッドで<code>drop</code>を呼び出すことは叶わなくなるでしょう。代わりにこのようなコンパイルエラーが出るでしょう:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `v`
(エラー: ムーブされた値の使用: `v`)
  --&gt; src/main.rs:10:10
   |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
10 |     drop(v); // oh no!
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does
   not implement the `Copy` trait
   (注釈: `v`の型が`std::vec::Vec&lt;i32&gt;`のためムーブが起きました。この型は、`Copy`トレイトを実装していません)
</code></pre>
<!--
Rust’s ownership rules have saved us again! We got an error from the code in
Listing 16-3 because Rust was being conservative and only borrowing `v` for the
thread, which meant the main thread could theoretically invalidate the spawned
thread’s reference. By telling Rust to move ownership of `v` to the spawned
thread, we’re guaranteeing Rust that the main thread won’t use `v` anymore. If
we change Listing 16-4 in the same way, we’re then violating the ownership
rules when we try to use `v` in the main thread. The `move` keyword overrides
Rust’s conservative default of borrowing; it doesn’t let us violate the
ownership rules.
-->
<p>再三Rustの所有権規則が救ってくれました！リスト16-3のコードはエラーになりました。
コンパイラが一時的に保守的になり、スレッドに対して<code>v</code>を借用しただけだったからで、
これは、メインスレッドは理論上、立ち上げたスレッドの参照を不正化する可能性があることを意味します。
<code>v</code>の所有権を立ち上げたスレッドに移動するとコンパイラに指示することで、
メインスレッドはもう<code>v</code>を使用しないとコンパイラに保証しているのです。リスト16-4も同様に変更したら、
メインスレッドで<code>v</code>を使用しようとする際に所有権の規則に違反することになります。
<code>move</code>キーワードにより、Rustの保守的な借用のデフォルトが上書きされるのです; 
所有権の規則を侵害させてくれないのです。</p>
<!--
With a basic understanding of threads and the thread API, let’s look at what we
can *do* with threads.
-->
<p>スレッドとスレッドAPIの基礎知識を得たので、スレッドで<em>できる</em>ことを見ていきましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Using Message Passing to Transfer Data Between Threads
-->
<h2 id="メッセージ受け渡しを使ってスレッド間でデータを転送する"><a class="header" href="#メッセージ受け渡しを使ってスレッド間でデータを転送する">メッセージ受け渡しを使ってスレッド間でデータを転送する</a></h2>
<!--
One increasingly popular approach to ensuring safe concurrency is *message
passing*, where threads or actors communicate by sending each other messages
containing data. Here’s the idea in a slogan from [the Go language
documentation](http://golang.org/doc/effective_go.html): “Do not communicate by
sharing memory; instead, share memory by communicating.”
-->
<p>人気度を増してきている安全な並行性を保証する一つのアプローチが<em>メッセージ受け渡し</em>で、
スレッドやアクターがデータを含むメッセージを相互に送り合うことでやり取りします。
こちらが、<a href="http:golang.org/doc/effective_go.html">Go言語のドキュメンテーション</a>のスローガンにある考えです:
「メモリを共有することでやり取りするな; 代わりにやり取りすることでメモリを共有しろ」</p>
<!--
One major tool Rust has for accomplishing message-sending concurrency is the
*channel*, a programming concept that Rust’s standard library provides an
implementation of. You can imagine a channel in programming as being like a
channel of water, such as a stream or a river. If you put something like a
rubber duck or a boat into a stream, it will travel downstream to the end of the
waterway.
-->
<p>メッセージ送信並行性を達成するためにRustに存在する一つの主な道具は、<em>チャンネル</em>で、
Rustの標準ライブラリが実装を提供しているプログラミング概念です。プログラミングのチャンネルは、
水の流れのように考えることができます。小川とか川ですね。アヒルのおもちゃやボートみたいなものを流れに置いたら、
水路の終端まで下流に流れていきます。</p>
<!--
5行目終わり、for arriving messagesは本来ならfor messages arrivingのような気がするが、その想定で訳してある
これは自動詞を形容詞のように前からかけているだけと思われる
-->
<!--
A channel in programming has two halves: a transmitter and a receiver. The
transmitter half is the upstream location where you put rubber ducks into the
river, and the receiver half is where the rubber duck ends up downstream. One
part of our code calls methods on the transmitter with the data you want to
send, and another part checks the receiving end for arriving messages. A
channel is said to be *closed* if either the transmitter or receiver half is
dropped.
-->
<p>プログラミングにおけるチャンネルは、2分割できます: 転送機と受信機です。転送機はアヒルのおもちゃを川に置く上流になり、
受信機は、アヒルのおもちゃが行き着く下流になります。コードのある箇所が送信したいデータとともに転送機のメソッドを呼び出し、
別の部分がメッセージが到着していないか受信側を調べます。転送機と受信機のどちらかがドロップされると、
チャンネルは<em>閉じられた</em>と言います。</p>
<!--
Here, we’ll work up to a program that has one thread to generate values and
send them down a channel, and another thread that will receive the values and
print them out. We’ll be sending simple values between threads using a channel
to illustrate the feature. Once you’re familiar with the technique, you could
use channels to implement a chat system or a system where many threads perform
parts of a calculation and send the parts to one thread that aggregates the
results.
-->
<p>ここで、1つのスレッドが値を生成し、それをチャンネルに送信し、別のスレッドがその値を受け取り、
出力するプログラムに取り掛かります。チャンネルを使用してスレッド間に単純な値を送り、
機能の説明を行います。一旦、そのテクニックに慣れてしまえば、チャンネルを使用してチャットシステムや、
多くのスレッドが計算の一部を担い、結果をまとめる1つのスレッドにその部分を送るようなシステムを実装できるでしょう。</p>
<!--
First, in Listing 16-6, we’ll create a channel but not do anything with it.
Note that this won’t compile yet because Rust can’t tell what type of values we
want to send over the channel.
-->
<p>まず、リスト16-6において、チャンネルを生成するものの、何もしません。
チャンネル越しにどんな型の値を送りたいのかコンパイラがわからないため、
これはまだコンパイルできないことに注意してください。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
<span class="boring">    tx.send(()).unwrap();
</span>}
</code></pre></pre>
<!--
<span class="caption">Listing 16-6: Creating a channel and assigning the two
halves to `tx` and `rx`</span>
-->
<p><span class="caption">リスト16-6: チャンネルを生成し、2つの部品を<code>tx</code>と<code>rx</code>に代入する</span></p>
<!--
We create a new channel using the `mpsc::channel` function; `mpsc` stands for
*multiple producer, single consumer*. In short, the way Rust’s standard library
implements channels means a channel can have multiple *sending* ends that
produce values but only one *receiving* end that consumes those values. Imagine
multiple streams flowing together into one big river: everything sent down any
of the streams will end up in one river at the end. We’ll start with a single
producer for now, but we’ll add multiple producers when we get this example
working.
-->
<p><code>mpsc::channel</code>関数で新しいチャンネルを生成しています; <code>mpsc</code>は<em>multiple producer, single consumer</em>を表しています。
簡潔に言えば、Rustの標準ライブラリがチャンネルを実装している方法は、1つのチャンネルが値を生成する複数の<em>送信</em>側と、
その値を消費するたった1つの<em>受信</em>側を持つことができるということを意味します。
複数の小川が互いに合わさって1つの大きな川になるところを想像してください: 
どの小川を通っても、送られたものは最終的に1つの川に行き着きます。今は、1つの生成器から始めますが、
この例が動作するようになったら、複数の生成器を追加します。</p>
<!--
NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199
-->
<!--
The `mpsc::channel` function returns a tuple, the first element of which is the
sending end and the second element is the receiving end. The abbreviations `tx`
and `rx` are traditionally used in many fields for *transmitter* and *receiver*
respectively, so we name our variables as such to indicate each end. We’re
using a `let` statement with a pattern that destructures the tuples; we’ll
discuss the use of patterns in `let` statements and destructuring in
Chapter 18. Using a `let` statement this way is a convenient approach to
extract the pieces of the tuple returned by `mpsc::channel`.
-->
<p><code>mpsc::channel</code>関数はタプルを返し、1つ目の要素は、送信側、2つ目の要素は受信側になります。
<code>tx</code>と<code>rx</code>という略称は、多くの分野で伝統的に<em>転送機</em>と<em>受信機</em>にそれぞれ使用されているので、
変数をそのように名付けて、各終端を示します。タプルを分配するパターンを伴う<code>let</code>文を使用しています;
<code>let</code>文でパターンを使用することと分配については、第18章で議論しましょう。このように<code>let</code>文を使うと、
<code>mpsc::channel</code>で返ってくるタプルの部品を抽出するのが便利になります。</p>
<!--
Let’s move the transmitting end into a spawned thread and have it send one
string so the spawned thread is communicating with the main thread, as shown in
Listing 16-7. This is like putting a rubber duck in the river upstream or
sending a chat message from one thread to another.
-->
<p>立ち上げたスレッドがメインスレッドとやり取りするように、転送機を立ち上げたスレッドに移動し、
1文字列を送らせましょう。リスト16-7のようにですね。川の上流にアヒルのおもちゃを置いたり、
チャットのメッセージをあるスレッドから別のスレッドに送るみたいですね。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-7: Moving `tx` to a spawned thread and sending
“hi”</span>
-->
<p><span class="caption">リスト16-7: <code>tx</code>を立ち上げたスレッドに移動し、「やあ」を送る</span></p>
<!--
Again, we’re using `thread::spawn` to create a new thread and then using `move`
to move `tx` into the closure so the spawned thread owns `tx`. The spawned
thread needs to own the transmitting end of the channel to be able to send
messages through the channel.
-->
<p>今回も、<code>thread::spawn</code>を使用して新しいスレッドを生成し、それから<code>move</code>を使用して、
立ち上げたスレッドが<code>tx</code>を所有するようにクロージャに<code>tx</code>をムーブしています。立ち上げたスレッドは、
メッセージをチャンネルを通して送信できるように、チャンネルの送信側を所有する必要があります。</p>
<!--
The transmitting end has a `send` method that takes the value we want to send.
The `send` method returns a `Result<T, E>` type, so if the receiving end has
already been dropped and there’s nowhere to send a value, the send operation
will return an error. In this example, we’re calling `unwrap` to panic in case
of an error. But in a real application, we would handle it properly: return to
Chapter 9 to review strategies for proper error handling.
-->
<p>転送側には、送信したい値を取る<code>send</code>メソッドがあります。<code>send</code>メソッドは<code>Result&lt;T, E&gt;</code>型を返すので、
既に受信側がドロップされ、値を送信する場所がなければ、送信処理はエラーを返します。
この例では、エラーの場合には、パニックするように<code>unwrap</code>を呼び出しています。ですが、実際のアプリケーションでは、
ちゃんと扱うでしょう: 第9章に戻ってちゃんとしたエラー処理の方法を再確認してください。</p>
<!--
In Listing 16-8, we’ll get the value from the receiving end of the channel in
the main thread. This is like retrieving the rubber duck from the water at the
end of the river or like getting a chat message.
-->
<p>リスト16-8において、メインスレッドのチャンネルの受信側から値を得ます。
アヒルのおもちゃを川の終端で水から回収したり、チャットメッセージを取得するみたいですね。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    // 値は{}です
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-8: Receiving the value “hi” in the main thread
and printing it</span>
-->
<p><span class="caption">リスト16-8: 「やあ」の値をメインスレッドで受け取り、出力する</span></p>
<!--
The receiving end of a channel has two useful methods: `recv` and `try_recv`.
We’re using `recv`, short for *receive*, which will block the main thread’s
execution and wait until a value is sent down the channel. Once a value is
sent, `recv` will return it in a `Result<T, E>`. When the sending end of the
channel closes, `recv` will return an error to signal that no more values will
be coming.
-->
<p>チャンネルの受信側には有用なメソッドが2つあります: <code>recv</code>と<code>try_recv</code>です。
<em>receive</em>の省略形である<code>recv</code>を使っています。これは、メインスレッドの実行をブロックし、
値がチャンネルを流れてくるまで待機します。一旦値が送信されたら、<code>recv</code>はそれを<code>Result&lt;T, E&gt;</code>に含んで返します。
チャンネルの送信側が閉じたら、<code>recv</code>はエラーを返し、もう値は来ないと通知します。</p>
<!--
The `try_recv` method doesn’t block, but will instead return a `Result<T, E>`
immediately: an `Ok` value holding a message if one is available and an `Err`
value if there aren’t any messages this time. Using `try_recv` is useful if
this thread has other work to do while waiting for messages: we could write a
loop that calls `try_recv` every so often, handles a message if one is
available, and otherwise does other work for a little while until checking
again.
-->
<p><code>try_recv</code>メソッドはブロックせず、代わりに即座に<code>Result&lt;T, E&gt;</code>を返します: 
メッセージがあったら、それを含む<code>Ok</code>値、今回は何もメッセージがなければ、<code>Err</code>値です。
メッセージを待つ間にこのスレッドにすることが他にあれば、<code>try_recv</code>は有用です:
<code>try_recv</code>を頻繁に呼び出し、メッセージがあったら処理し、それ以外の場合は、
再度チェックするまでちょっとの間、他の作業をするループを書くことができるでしょう。</p>
<!--
We’ve used `recv` in this example for simplicity; we don’t have any other work
for the main thread to do other than wait for messages, so blocking the main
thread is appropriate.
-->
<p>この例では、簡潔性のために<code>recv</code>を使用しました; メッセージを待つこと以外にメインスレッドがすべき作業はないので、
メインスレッドをブロックするのは適切です。</p>
<!--
When we run the code in Listing 16-8, we’ll see the value printed from the main
thread:
-->
<p>リスト16-8のコードを実行したら、メインスレッドから値が出力されるところを目撃するでしょう:</p>
<pre><code class="language-text">Got: hi
</code></pre>
<!--
Perfect!
-->
<p>完璧です！</p>
<!--
### Channels and Ownership Transference
-->
<h3 id="チャンネルと所有権の転送"><a class="header" href="#チャンネルと所有権の転送">チャンネルと所有権の転送</a></h3>
<!--
The ownership rules play a vital role in message sending because they help you
write safe, concurrent code. Preventing errors in concurrent programming is the
advantage of thinking about ownership throughout your Rust program. Let's do
an experiment to show how channels and ownership work together to prevent
problems: we’ll try to use a `val` value in the spawned thread *after* we’ve
sent it down the channel. Try compiling the code in Listing 16-9 to see why
this code isn’t allowed:
-->
<p>安全な並行コードを書く手助けをしてくれるので、所有権規則は、メッセージ送信で重要な役割を担っています。
並行プログラミングでエラーを回避することは、Rustプログラム全体で所有権について考える利点です。
実験をしてチャンネルと所有権がともに動いて、どう問題を回避するかをお見せしましょう:
<code>val</code>値を立ち上げたスレッドで、チャンネルに送った<em>後</em>に使用を試みます。
リスト16-9のコードのコンパイルを試みて、このコードが許容されない理由を確認してください:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        // valは{}
        println!(&quot;val is {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre>
<!--
<span class="caption">Listing 16-9: Attempting to use `val` after we’ve sent it
down the channel</span>
-->
<p><span class="caption">リスト16-9: チャンネルに送信後に<code>val</code>の使用を試みる</span></p>
<!--
Here, we try to print `val` after we’ve sent it down the channel via `tx.send`.
Allowing this would be a bad idea: once the value has been sent to another
thread, that thread could modify or drop it before we try to use the value
again. Potentially, the other thread's modifications could cause errors or
unexpected results due to inconsistent or nonexistent data. However, Rust gives
us an error if we try to compile the code in Listing 16-9:
-->
<p>ここで、<code>tx.send</code>経由でチャンネルに送信後に<code>val</code>を出力しようとしています。これを許可するのは、悪い考えです:
一旦、値が他のスレッドに送信されたら、再度値を使用しようとする前にそのスレッドが変更したりドロップできてしまいます。
可能性として、その別のスレッドの変更により、矛盾していたり存在しないデータのせいでエラーが発生したり、
予期しない結果になるでしょう。ですが、リスト16-9のコードのコンパイルを試みると、Rustはエラーを返します:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `val`
  --&gt; src/main.rs:10:31
   |
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {}&quot;, val);
   |                               ^^^ value used here after move
   |
   = note: move occurs because `val` has type `std::string::String`, which does
not implement the `Copy` trait
</code></pre>
<!--
Our concurrency mistake has caused a compile time error. The `send` function
takes ownership of its parameter, and when the value is moved, the receiver
takes ownership of it. This stops us from accidentally using the value again
after sending it; the ownership system checks that everything is okay.
-->
<p>並行性のミスがコンパイルエラーを招きました。<code>send</code>関数は引数の所有権を奪い、
値がムーブされると、受信側が所有権を得るのです。これにより、送信後に誤って再度値を使用するのを防いでくれます;
所有権システムが、万事問題ないことを確認してくれます。</p>
<!--
### Sending Multiple Values and Seeing the Receiver Waiting
-->
<h3 id="複数の値を送信し受信側が待機するのを確かめる"><a class="header" href="#複数の値を送信し受信側が待機するのを確かめる">複数の値を送信し、受信側が待機するのを確かめる</a></h3>
<!--
The code in Listing 16-8 compiled and ran, but it didn’t clearly show us that
two separate threads were talking to each other over the channel. In Listing
16-10 we’ve made some modifications that will prove the code in Listing 16-8 is
running concurrently: the spawned thread will now send multiple messages and
pause for a second between each message.
-->
<p>リスト16-8のコードはコンパイルでき、動きましたが、2つの個別のスレッドがお互いにチャンネル越しに会話していることは、
明瞭に示されませんでした。リスト16-10において、リスト16-8のコードが並行に動いていることを証明する変更を行いました:
立ち上げたスレッドは、複数のメッセージを送信し、各メッセージ間で、1秒待機します。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        // スレッドからやあ(hi from the thread)
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-10: Sending multiple messages and pausing
between each</span>
-->
<p><span class="caption">リスト16-10: 複数のメッセージを送信し、メッセージ間で停止する</span></p>
<!--
This time, the spawned thread has a vector of strings that we want to send to
the main thread. We iterate over them, sending each individually, and pause
between each by calling the `thread::sleep` function with a `Duration` value of
1 second.
-->
<p>今回は、メインスレッドに送信したい文字列のベクタを立ち上げたスレッドが持っています。
それらを繰り返し、各々個別に送信し、<code>Duration</code>の値1秒とともに<code>thread::sleep</code>関数を呼び出すことで、
メッセージ間で停止します。</p>
<!--
In the main thread, we’re not calling the `recv` function explicitly anymore:
instead, we’re treating `rx` as an iterator. For each value received, we’re
printing it. When the channel is closed, iteration will end.
-->
<p>メインスレッドにおいて、最早<code>recv</code>関数を明示的に呼んではいません: 代わりに、
<code>rx</code>をイテレータとして扱っています。受信した値それぞれを出力します。
チャンネルが閉じられると、繰り返しも終わります。</p>
<!--
When running the code in Listing 16-10, you should see the following output
with a 1-second pause in between each line:
-->
<p>リスト16-10のコードを走らせると、各行の間に1秒の待機をしつつ、以下のような出力を目の当たりにするはずです:</p>
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<!--
Because we don’t have any code that pauses or delays in the `for` loop in the
main thread, we can tell that the main thread is waiting to receive values from
the spawned thread.
-->
<p>メインスレッドの<code>for</code>ループには停止したり、遅れせたりするコードは何もないので、
メインスレッドが立ち上げたスレッドから値を受け取るのを待機していることがわかります。</p>
<!--
### Creating Multiple Producers by Cloning the Transmitter
-->
<h3 id="転送機をクローンして複数の生成器を作成する"><a class="header" href="#転送機をクローンして複数の生成器を作成する">転送機をクローンして複数の生成器を作成する</a></h3>
<!--
Earlier we mentioned that `mpsc` was an acronym for *multiple producer,
single consumer*. Let’s put `mpsc` to use and expand the code in Listing 16-10
to create multiple threads that all send values to the same receiver. We can do
so by cloning the transmitting half of the channel, as shown in Listing 16-11:
-->
<p><code>mpsc</code>は、<em>mutiple producer, single consumer</em>の頭字語であると前述しました。
<code>mpsc</code>を使い、リスト16-10のコードを拡張して、全ての値を同じ受信機に送信する複数のスレッドを生成しましょう。
チャンネルの転送の片割れをクローンすることでそうすることができます。リスト16-11のようにですね:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>// --snip--

let (tx, rx) = mpsc::channel();

let tx1 = mpsc::Sender::clone(&amp;tx);
thread::spawn(move || {
    let vals = vec![
        String::from(&quot;hi&quot;),
        String::from(&quot;from&quot;),
        String::from(&quot;the&quot;),
        String::from(&quot;thread&quot;),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    // 君のためにもっとメッセージを(more messages for you)
    let vals = vec![
        String::from(&quot;more&quot;),
        String::from(&quot;messages&quot;),
        String::from(&quot;for&quot;),
        String::from(&quot;you&quot;),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

for received in rx {
    println!(&quot;Got: {}&quot;, received);
}

// --snip--
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 16-11: Sending multiple messages from multiple
producers</span>
-->
<p><span class="caption">リスト16-11: 複数の生成器から複数のメッセージを送信する</span></p>
<!--
This time, before we create the first spawned thread, we call `clone` on the
sending end of the channel. This will give us a new sending handle we can pass
to the first spawned thread. We pass the original sending end of the channel to
a second spawned thread. This gives us two threads, each sending different
messages to the receiving end of the channel.
-->
<p>今回、最初のスレッドを立ち上げる前に、チャンネルの送信側に対して<code>clone</code>を呼び出しています。
これにより、最初に立ち上げたスレッドに渡せる新しい送信ハンドルが得られます。
元のチャンネルの送信側は、2番目に立ち上げたスレッドに渡します。これにより2つスレッドが得られ、
それぞれチャンネルの受信側に異なるメッセージを送信します。</p>
<!--
When you run the code, your output should look something like this:
-->
<p>コードを実行すると、出力は以下のようなものになるはずです:</p>
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<!--
You might see the values in another order; it depends on your system. This is
what makes concurrency interesting as well as difficult. If you experiment with
`thread::sleep`, giving it various values in the different threads, each run
will be more nondeterministic and create different output each time.
-->
<p>別の順番で値が出る可能性もあります; システム次第です。並行性が面白いと同時に難しい部分でもあります。
異なるスレッドで色々な値を与えて<code>thread::sleep</code>で実験をしたら、走らせるたびにより非決定的になり、
毎回異なる出力をするでしょう。</p>
<!--
Now that we’ve looked at how channels work, let’s look at a different method of
concurrency.
-->
<p>チャンネルの動作方法を見たので、他の並行性に目を向けましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Shared-State Concurrency
-->
<h2 id="状態共有並行性"><a class="header" href="#状態共有並行性">状態共有並行性</a></h2>
<!--
Message passing is a fine way of handling concurrency, but it’s not the only
one. Consider this part of the slogan from the Go language documentation again:
“communicate by sharing memory.”
-->
<p>メッセージ受け渡しは、並行性を扱う素晴らしい方法ですが、唯一の方法ではありません。
Go言語ドキュメンテーションのスローガンのこの部分を再び考えてください:
「メモリを共有することでやり取りする。」</p>
<!--
What would communicating by sharing memory look like? In addition, why would
message-passing enthusiasts not use it and do the opposite instead?
-->
<p>メモリを共有することでやり取りするとはどんな感じなのでしょうか？さらに、
なぜメッセージ受け渡しに熱狂的な人は、それを使わず、代わりに全く反対のことをするのでしょうか？</p>
<!--
In a way, channels in any programming language are similar to single ownership,
because once you transfer a value down a channel, you should no longer use that
value. Shared memory concurrency is like multiple ownership: multiple threads
can access the same memory location at the same time. As you saw in Chapter 15,
where smart pointers made multiple ownership possible, multiple ownership can
add complexity because these different owners need managing. Rust’s type system
and ownership rules greatly assist in getting this management correct. For an
example, let’s look at mutexes, one of the more common concurrency primitives
for shared memory.
-->
<p>ある意味では、どんなプログラミング言語のチャンネルも単独の所有権に類似しています。
一旦チャンネルに値を転送したら、その値は最早使用することがないからです。
メモリ共有並行性は、複数の所有権に似ています: 複数のスレッドが同時に同じメモリ位置にアクセスできるのです。
第15章でスマートポインタが複数の所有権を可能にするのを目の当たりにしたように、
異なる所有者を管理する必要があるので、複数の所有権は複雑度を増させます。
Rustの型システムと所有権規則は、この管理を正しく行う大きな助けになります。
例として、メモリ共有を行うより一般的な並行性の基本型の一つであるミューテックスを見てみましょう。</p>
<!--
### Using Mutexes to Allow Access to Data from One Thread at a Time
-->
<h3 id="ミューテックスを使用して一度に1つのスレッドからデータにアクセスすることを許可する"><a class="header" href="#ミューテックスを使用して一度に1つのスレッドからデータにアクセスすることを許可する">ミューテックスを使用して一度に1つのスレッドからデータにアクセスすることを許可する</a></h3>
<!--
1行目、as in,が肝だが、inの後は普通名詞に相当するものが来るはずだが、文になっている
-->
<!--
*Mutex* is an abbreviation for “mutual exclusion,” as in, a mutex allows only
one thread to access some data at any given time. To access the data in a
mutex, a thread must first signal that it wants access by asking to acquire the
mutex's *lock*. The lock is a data structure that is part of the mutex that
keeps track of who currently has exclusive access to the data. Therefore, the
mutex is described as *guarding* the data it holds via the locking system.
-->
<p>ミューテックスは、どんな時も1つのスレッドにしかなんらかのデータへのアクセスを許可しないというように、
&quot;mutual exclusion&quot;(相互排他)の省略形です。ミューテックスにあるデータにアクセスするには、
ミューテックスのロックを所望することでアクセスしたいことをまず、スレッドは通知しなければなりません。
ロックとは、現在誰がデータへの排他的アクセスを行なっているかを追跡するミューテックスの一部をなすデータ構造です。
故に、ミューテックスはロックシステム経由で保持しているデータを<em>死守する</em>(guarding)と解説されます。</p>
<!--
Mutexes have a reputation for being difficult to use because you have to
remember two rules:
-->
<p>ミューテックスは、2つの規則を覚えておく必要があるため、難しいという評判があります:</p>
<!--
* You must attempt to acquire the lock before using the data.
* When you’re done with the data that the mutex guards, you must unlock the
data so other threads can acquire the lock.
-->
<ul>
<li>データを使用する前にロックの獲得を試みなければならない。</li>
<li>ミューテックスが死守しているデータの使用が終わったら、他のスレッドがロックを獲得できるように、
データをアンロックしなければならない。</li>
</ul>
<!--
For a real-world metaphor for a mutex, imagine a panel discussion at a
conference with only one microphone. Before a panelist can speak, they have to
ask or signal that they want to use the microphone. When they get the
microphone, they can talk for as long as they want to and then hand the
microphone to the next panelist who requests to speak. If a panelist forgets to
hand the microphone off when they’re finished with it, no one else is able to
speak. If management of the shared microphone goes wrong, the panel won’t work
as planned!
-->
<p>ミューテックスを現実世界の物で例えるなら、マイクが1つしかない会議のパネルディスカッションを思い浮かべてください。
パネリストが発言できる前に、マイクを使用したいと申し出たり、通知しなければなりません。マイクを受け取ったら、
話したいだけ話し、それから次に発言を申し出たパネリストにマイクを手渡します。パネリストが発言し終わった時に、
マイクを手渡すのを忘れていたら、誰も他の人は発言できません。共有されているマイクの管理がうまくいかなければ、
パネルは予定通りに機能しないでしょう！</p>
<!--
Management of mutexes can be incredibly tricky to get right, which is why so
many people are enthusiastic about channels. However, thanks to Rust’s type
system and ownership rules, you can’t get locking and unlocking wrong.
-->
<p>ミューテックスの管理は、正しく行うのに著しく技巧を要することがあるので、多くの人がチャンネルに熱狂的になるわけです。
しかしながら、Rustの型システムと所有権規則のおかげで、ロックとアンロックをおかしくすることはありません。</p>
<!--
#### The API of `Mutex<T>`
-->
<h4 id="mutextのapi"><a class="header" href="#mutextのapi"><code>Mutex&lt;T&gt;</code>のAPI</a></h4>
<!--
As an example of how to use a mutex, let’s start by using a mutex in a
single-threaded context, as shown in Listing 16-12:
-->
<p>ミューテックスの使用方法の例として、ミューテックスをシングルスレッドの文脈で使うことから始めましょう。
リスト16-12のようにですね:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-12: Exploring the API of `Mutex<T>` in a
single-threaded context for simplicity</span>
-->
<p><span class="caption">リスト16-12: 簡潔性のために<code>Mutex&lt;T&gt;</code>のAPIをシングルスレッドの文脈で探究する</span></p>
<!--
As with many types, we create a `Mutex<T>` using the associated function `new`.
To access the data inside the mutex, we use the `lock` method to acquire the
lock. This call will block the current thread so it can’t do any work until
it’s our turn to have the lock.
-->
<p>多くの型同様、<code>new</code>という関連関数を使用して<code>Mutex&lt;T&gt;</code>を生成します。ミューテックス内部のデータにアクセスするには、
<code>lock</code>メソッドを使用してロックを獲得します。この呼び出しは、現在のスレッドをブロックするので、
ロックを得られる順番が来るまで何も作業はできません。</p>
<!--
The call to `lock` would fail if another thread holding the lock panicked. In
that case, no one would ever be able to get the lock, so we’ve chosen to
`unwrap` and have this thread panic if we’re in that situation.
-->
<p>ロックを保持している他のスレッドがパニックしたら、<code>lock</code>の呼び出しは失敗するでしょう。その場合、
誰もロックを取得することは叶わないので、<code>unwrap</code>すると決定し、そのような状況になったら、
このスレッドをパニックさせます。</p>
<!--
After we’ve acquired the lock, we can treat the return value, named `num` in
this case, as a mutable reference to the data inside. The type system ensures
that we acquire a lock before using the value in `m`: `Mutex<i32>` is not an
`i32`, so we *must* acquire the lock to be able to use the `i32` value. We
can’t forget; the type system won’t let us access the inner `i32` otherwise.
-->
<p>ロックを獲得した後、今回の場合、<code>num</code>と名付けられていますが、戻り値を中に入っているデータへの可変参照として扱うことができます。
型システムにより、<code>m</code>の値を使用する前にロックを獲得していることが確認されます: <code>Mutex&lt;i32&gt;</code>は<code>i32</code>ではないので、
<code>i32</code>を使用できるようにするには、ロックを獲得し<em>なければならない</em>のです。忘れることはあり得ません;
型システムにより、それ以外の場合に内部の<code>i32</code>にアクセスすることは許されません。</p>
<!--
As you might suspect, `Mutex<T>` is a smart pointer. More accurately, the call
to `lock` *returns* a smart pointer called `MutexGuard`. This smart pointer
implements `Deref` to point at our inner data; the smart pointer also has a
`Drop` implementation that releases the lock automatically when a `MutexGuard`
goes out of scope, which happens at the end of the inner scope in Listing
16-12. As a result, we don’t risk forgetting to release the lock and blocking
the mutex from being used by other threads because the lock release happens
automatically.
-->
<p>お察しかもしれませんが、<code>Mutex&lt;T&gt;</code>はスマートポインタです。より正確を期すなら、
<code>lock</code>の呼び出しが<code>MutexGuard</code>というスマートポインタを<em>返却</em>します。このスマートポインタが、
内部のデータを指す<code>Deref</code>を実装しています; このスマートポインタはさらに<code>MutexGuard</code>がスコープを外れた時に、
自動的にロックを解除する<code>Drop</code>実装もしていて、これがリスト16-12の内部スコープの終わりで発生します。
結果として、ロックの解除が自動的に行われるので、ロックの解除を忘れ、
ミューテックスが他のスレッドで使用されるのを阻害するリスクを負いません。</p>
<!--
After dropping the lock, we can print the mutex value and see that we were able
to change the inner `i32` to 6.
-->
<p>ロックをドロップした後、ミューテックスの値を出力し、内部の<code>i32</code>の値を6に変更できたことが確かめられるのです。</p>
<!--
#### Sharing a `Mutex<T>` Between Multiple Threads
-->
<h4 id="複数のスレッド間でmutextを共有する"><a class="header" href="#複数のスレッド間でmutextを共有する">複数のスレッド間で<code>Mutex&lt;T&gt;</code>を共有する</a></h4>
<!--
Now, let’s try to share a value between multiple threads using `Mutex<T>`.
We’ll spin up 10 threads and have them each increment a counter value by 1, so
the counter goes from 0 to 10. Note that the next few examples will have
compiler errors, and we’ll use those errors to learn more about using
`Mutex<T>` and how Rust helps us use it correctly. Listing 16-13 has our
starting example:
-->
<p>さて、<code>Mutex&lt;T&gt;</code>を使って複数のスレッド間で値を共有してみましょう。10個のスレッドを立ち上げ、
各々カウンタの値を1ずつインクリメントさせるので、カウンタは0から10まで上がります。
以下の数例は、コンパイルエラーになることに注意し、そのエラーを使用して<code>Mutex&lt;T&gt;</code>の使用法と、
コンパイラがそれを正しく活用する手助けをしてくれる方法について学びます。リスト16-13が最初の例です:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<!--
<span class="caption">Listing 16-13: Ten threads each increment a counter
guarded by a `Mutex<T>`</span>
-->
<p><span class="caption">リスト16-13: <code>Mutex&lt;T&gt;</code>により死守されているカウンタを10個のスレッドがそれぞれインクリメントする</span></p>
<!--
We create a `counter` variable to hold an `i32` inside a `Mutex<T>`, as we
did in Listing 16-12. Next, we create 10 threads by mapping over a range
of numbers. We use `thread::spawn` and give all the threads the same closure,
one that moves the counter into the thread, acquires a lock on the `Mutex<T>`
by calling the `lock` method, and then adds 1 to the value in the mutex. When a
thread finishes running its closure, `num` will go out of scope and release the
lock so another thread can acquire it.
-->
<p>リスト16-12のように、<code>counter</code>変数を生成して<code>Mutex&lt;T&gt;</code>の内部に<code>i32</code>を保持しています。
次に、数値の範囲をマッピングして10個のスレッドを生成しています。<code>thread::spawn</code>を使用して、
全スレッドに同じクロージャを与えています。このクロージャは、スレッド内にカウンタをムーブし、
<code>lock</code>メソッドを呼ぶことで<code>Mutex&lt;T&gt;</code>のロックを獲得し、それからミューテックスの値に1を足します。
スレッドがクロージャを実行し終わったら、<code>num</code>はスコープ外に出てロックを解除するので、
他のスレッドが獲得できるわけです。</p>
<!--
In the main thread, we collect all the join handles. Then, as we did in Listing
16-2, we call `join` on each to make sure all the threads finish. At
that point, the main thread will acquire the lock and print the result of this
program.
-->
<p>メインスレッドで全てのjoinハンドルを収集します。それからリスト16-2のように、各々に対して<code>join</code>を呼び出し、
全スレッドが終了するのを確かめています。その時点で、メインスレッドはロックを獲得し、このプログラムの結果を出力します。</p>
<!--
We hinted that this example wouldn’t compile. Now let’s find out why!
-->
<p>この例はコンパイルできないでしょうと仄めかしました。では、理由を探りましょう！</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
(エラー: ムーブされた値をキャプチャしています: `counter`)
  --&gt; src/main.rs:10:27
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
10 |             let mut num = counter.lock().unwrap();
   |                           ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
...
21 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
(エラー: 前述の2つのエラーによりアボート)
</code></pre>
<!--
The error message states that the `counter` value is moved into the closure and
then captured when we call `lock`. That description sounds like what we wanted,
but it’s not allowed!
-->
<p>エラーメッセージは、<code>counter</code>値はクロージャにムーブされ、それから<code>lock</code>を呼び出したときにキャプチャされていると述べています。
その説明は、所望した動作のように聞こえますが、許可されていないのです！</p>
<!--
Let’s figure this out by simplifying the program. Instead of making 10 threads
in a `for` loop, let’s just make two threads without a loop and see what
happens. Replace the first `for` loop in Listing 16-13 with this code instead:
-->
<p>プログラムを単純化してこれを理解しましょう。<code>for</code>ループで10個スレッドを生成する代わりに、
ループなしで2つのスレッドを作るだけにしてどうなるか確認しましょう。
リスト16-13の最初の<code>for</code>ループを代わりにこのコードと置き換えてください:</p>
<pre><code class="language-rust ignore">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    let handle = thread::spawn(move || {
        let mut num = counter.lock().unwrap();

        *num += 1;
    });
    handles.push(handle);

    let handle2 = thread::spawn(move || {
        let mut num2 = counter.lock().unwrap();

        *num2 += 1;
    });
    handles.push(handle2);

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<!--
We make two threads and change the variable names used with the second thread
to `handle2` and `num2`. When we run the code this time, compiling gives us the
following:
-->
<p>2つのスレッドを生成し、2番目のスレッドの変数名を<code>handle2</code>と<code>num2</code>に変更しています。
今回このコードを走らせると、コンパイラは以下の出力をします:</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt; src/main.rs:16:24
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
16 |         let mut num2 = counter.lock().unwrap();
   |                        ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:26:29
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
26 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<!--
Aha! The first error message indicates that `counter` is moved into the closure
for the thread associated with `handle`. That move is preventing us from
capturing `counter` when we try to call `lock` on it and store the result in
`num2` in the second thread! So Rust is telling us that we can’t move ownership
of `counter` into multiple threads. This was hard to see earlier because our
threads were in a loop, and Rust can’t point to different threads in different
iterations of the loop. Let’s fix the compiler error with a multiple-ownership
method we discussed in Chapter 15.
-->
<p>なるほど！最初のエラーメッセージは、<code>handle</code>に紐づけられたスレッドのクロージャに<code>counter</code>がムーブされていることを示唆しています。
そのムーブにより、それに対して<code>lock</code>を呼び出し、結果を2番目のスレッドの<code>num2</code>に保持しようとした時に、
<code>counter</code>をキャプチャすることを妨げています！ゆえに、コンパイラは、<code>counter</code>の所有権を複数のスレッドに移すことはできないと教えてくれています。
これは、以前では確認しづらかったことです。なぜなら、スレッドはループの中にあり、
ループの違う繰り返しにある違うスレッドをコンパイラは指し示せないからです。
第15章で議論した複数所有権メソッドによりコンパイルエラーを修正しましょう。</p>
<!--
#### Multiple Ownership with Multiple Threads
-->
<h4 id="複数のスレッドで複数の所有権"><a class="header" href="#複数のスレッドで複数の所有権">複数のスレッドで複数の所有権</a></h4>
<!--
In Chapter 15, we gave a value multiple owners by using the smart pointer
`Rc<T>` to create a reference counted value. Let’s do the same here and see
what happens. We’ll wrap the `Mutex<T>` in `Rc<T>` in Listing 16-14 and clone
the `Rc<T>` before moving ownership to the thread. Now that we’ve seen the
errors, we’ll also switch back to using the `for` loop, and we’ll keep the
`move` keyword with the closure.
-->
<p>第15章で、スマートポインタの<code>Rc&lt;T&gt;</code>を使用して参照カウントの値を作ることで、1つの値に複数の所有者を与えました。
同じことをここでもして、どうなるか見ましょう。リスト16-14で<code>Rc&lt;T&gt;</code>に<code>Mutex&lt;T&gt;</code>を包含し、
所有権をスレッドに移す前に<code>Rc&lt;T&gt;</code>をクローンします。今やエラーを確認したので、
<code>for</code>ループの使用に立ち戻り、クロージャに<code>move</code>キーワードを使用し続けます。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<!--
<span class="caption">Listing 16-14: Attempting to use `Rc<T>` to allow
multiple threads to own the `Mutex<T>`</span>
-->
<p><span class="caption">リスト16-14: <code>Rc&lt;T&gt;</code>を使用して複数のスレッドに<code>Mutex&lt;T&gt;</code>を所有させようとする</span></p>
<!--
Once again, we compile and get... different errors! The compiler is teaching us
a lot.
-->
<p>再三、コンパイルし……別のエラーが出ました！コンパイラはいろんなことを教えてくれています。</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;:
std::marker::Send` is not satisfied in `[closure@src/main.rs:11:36:
15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
(エラー: トレイト境界`std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;:
std::marker::Send`は`[closure@src/main.rs:11:36:15:10
counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`で満たされていません)
  --&gt; src/main.rs:11:22
   |
11 |         let handle = thread::spawn(move || {
   |                      ^^^^^^^^^^^^^ `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
cannot be sent between threads safely
                          (`std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`は、スレッド間で安全に送信できません)
   |
   = help: within `[closure@src/main.rs:11:36: 15:10
counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`, the trait `std::marker::Send` is
not implemented for `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
     (ヘルプ: `[closure@src/main.rs:11:36 15:10
     counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`内でトレイト`std::marker::Send`は、
     `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`に対して実装されていません)
   = note: required because it appears within the type
`[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
     (注釈: 型`[closure@src/main.rs:11:36 15:10
     counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`内に出現するので必要です)
   = note: required by `std::thread::spawn`
     (注釈: `std::thread::spawn`により必要とされています)
</code></pre>
<!--
Wow, that error message is very wordy! Here are some important parts to focus
on: the first inline error says `` `std::rc::Rc<std::sync::Mutex<i32>>` cannot
be sent between threads safely ``. The reason for this is in the next important
part to focus on, the error message. The distilled error message says `` the
trait bound `Send` is not satisfied ``. We’ll talk about `Send` in the next
section: it’s one of the traits that ensures the types we use with threads are
meant for use in concurrent situations.
-->
<p>おお、このエラーメッセージはとても長ったらしいですね！こちらが、注目すべき重要な部分です:
最初のインラインエラーは<code> `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>と述べています。この理由は、エラーメッセージの次に注目すべき重要な部分にあります。
洗練されたエラーメッセージは、<code> the trait bound `Send` is not satisfied</code>と述べています。
<code>Send</code>については、次の節で語ります:
スレッドとともに使用している型が並行な場面で使われることを意図したものであることを保証するトレイトの1つです。</p>
<!--
Unfortunately, `Rc<T>` is not safe to share across threads. When `Rc<T>`
manages the reference count, it adds to the count for each call to `clone` and
subtracts from the count when each clone is dropped. But it doesn’t use any
concurrency primitives to make sure that changes to the count can’t be
interrupted by another thread. This could lead to wrong counts—subtle bugs that
could in turn lead to memory leaks or a value being dropped before we’re done
with it. What we need is a type exactly like `Rc<T>` but one that makes changes
to the reference count in a thread-safe way.
-->
<p>残念ながら、<code>Rc&lt;T&gt;</code>はスレッド間で共有するには安全ではないのです。<code>Rc&lt;T&gt;</code>が参照カウントを管理する際、
<code>clone</code>が呼び出されるたびにカウントを追加し、クローンがドロップされるたびにカウントを差し引きます。
しかし、並行基本型を使用してカウントの変更が別のスレッドに妨害されないことを確認していないのです。
これは間違ったカウントにつながる可能性があり、今度はメモリリークや、使用し終わる前に値がドロップされることにつながる可能性のある潜在的なバグです。
必要なのは、いかにも<code>Rc&lt;T&gt;</code>のようだけれども、参照カウントへの変更をスレッドセーフに行うものです。</p>
<!--
#### Atomic Reference Counting with `Arc<T>`
-->
<h4 id="arctで原子的な参照カウント"><a class="header" href="#arctで原子的な参照カウント"><code>Arc&lt;T&gt;</code>で原子的な参照カウント</a></h4>
<!--
Fortunately, `Arc<T>` *is* a type like `Rc<T>` that is safe to use in
concurrent situations. The *a* stands for *atomic*, meaning it’s an *atomically
reference counted* type. Atomics are an additional kind of concurrency
primitive that we won’t cover in detail here: see the standard library
documentation for `std::sync::atomic` for more details. At this point, you just
need to know that atomics work like primitive types but are safe to share
across threads.
-->
<p>幸いなことに、<code>Arc&lt;T&gt;</code>は<code>Rc&lt;T&gt;</code>のような並行な状況で安全に使用できる型<em>です</em>。
<em>a</em>は<em>atomic</em>を表し、原子的に参照カウントする型を意味します。アトミックは、
ここでは詳しく講義しない並行性の別の基本型です: 詳細は、
<code>std::sync::atomic</code>の標準ライブラリドキュメンテーションを参照されたし。現時点では、
アトミックは、基本型のように動くけれども、スレッド間で共有しても安全なことだけ知っていれば良いです。</p>
<!--
You might then wonder why all primitive types aren’t atomic and why standard
library types aren’t implemented to use `Arc<T>` by default. The reason is that
thread safety comes with a performance penalty that you only want to pay when
you really need to. If you’re just performing operations on values within a
single thread, your code can run faster if it doesn’t have to enforce the
guarantees atomics provide.
-->
<p>そうしたらあなたは、なぜ全ての基本型がアトミックでなく、標準ライブラリの型も標準で<code>Arc&lt;T&gt;</code>を使って実装されていないのか疑問に思う可能性があります。
その理由は、スレッド安全性が、本当に必要な時だけ支払いたいパフォーマンスの犠牲とともに得られるものだからです。
シングルスレッドで値に処理を施すだけなら、アトミックが提供する保証を強制する必要がない方がコードはより速く走るのです。</p>
<!--
Let’s return to our example: `Arc<T>` and `Rc<T>` have the same API, so we fix
our program by changing the `use` line, the call to `new`, and the call to
`clone`. The code in Listing 16-15 will finally compile and run:
-->
<p>例に回帰しましょう: <code>Arc&lt;T&gt;</code>と<code>Rc&lt;T&gt;</code>のAPIは同じなので、<code>use</code>行と<code>new</code>の呼び出しと<code>clone</code>の呼び出しを変更して、
プログラムを修正します。リスト16-15は、ようやくコンパイルでき、動作します:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<!--
<span class="caption">Listing 16-15: Using an `Arc<T>` to wrap the `Mutex<T>`
to be able to share ownership across multiple threads</span>
-->
<p><span class="caption">リスト16-15: <code>Arc&lt;T&gt;</code>を使用して<code>Mutex&lt;T&gt;</code>をラップし、所有権を複数のスレッド間で共有できるようにする</span></p>
<!--
This code will print the following:
-->
<p>このコードは、以下のように出力します:</p>
<pre><code class="language-text">Result: 10
</code></pre>
<!--
We did it! We counted from 0 to 10, which may not seem very impressive, but it
did teach us a lot about `Mutex<T>` and thread safety. You could also use this
program’s structure to do more complicated operations than just incrementing a
counter. Using this strategy, you can divide a calculation into independent
parts, split those parts across threads, and then use a `Mutex<T>` to have each
thread update the final result with its part.
-->
<p>やりました！0から10まで数え上げました。これは、あまり印象的ではないように思えるかもしれませんが、
本当に<code>Mutex&lt;T&gt;</code>とスレッド安全性についていろんなことを教えてくれました。このプログラムの構造を使用して、
カウンタをインクリメントする以上の複雑な処理を行うこともできるでしょう。この手法を使えば、
計算を独立した部分に小分けにし、その部分をスレッドに分割し、それから<code>Mutex&lt;T&gt;</code>を使用して、
各スレッドに最終結果を更新させることができます。</p>
<!--
### Similarities Between `RefCell<T>`/`Rc<T>` and `Mutex<T>`/`Arc<T>`
-->
<h3 id="refcelltrctとmutextarctの類似性"><a class="header" href="#refcelltrctとmutextarctの類似性"><code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code>と<code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code>の類似性</a></h3>
<!--
You might have noticed that `counter` is immutable but we could get a mutable
reference to the value inside it; this means `Mutex<T>` provides interior
mutability, as the `Cell` family does. In the same way we used `RefCell<T>` in
Chapter 15 to allow us to mutate contents inside an `Rc<T>`, we use `Mutex<T>`
to mutate contents inside an `Arc<T>`.
-->
<p><code>counter</code>は不変なのに、その内部にある値への可変参照を得ることができたことに気付いたでしょうか;
つまり、<code>Mutex&lt;T&gt;</code>は、<code>Cell</code>系のように内部可変性を提供するわけです。
第15章で<code>RefCell&lt;T&gt;</code>を使用して<code>Rc&lt;T&gt;</code>の内容を可変化できるようにしたのと同様に、
<code>Mutex&lt;T&gt;</code>を使用して<code>Arc&lt;T&gt;</code>の内容を可変化しているのです。</p>
<!--
Another detail to note is that Rust can’t protect you from all kinds of logic
errors when you use `Mutex<T>`. Recall in Chapter 15 that using `Rc<T>` came
with the risk of creating reference cycles, where two `Rc<T>` values refer to
each other, causing memory leaks. Similarly, `Mutex<T>` comes with the risk of
creating *deadlocks*. These occur when an operation needs to lock two resources
and two threads have each acquired one of the locks, causing them to wait for
each other forever. If you’re interested in deadlocks, try creating a Rust
program that has a deadlock; then research deadlock mitigation strategies for
mutexes in any language and have a go at implementing them in Rust. The
standard library API documentation for `Mutex<T>` and `MutexGuard` offers
useful information.
-->
<p>気付いておくべき別の詳細は、<code>Mutex&lt;T&gt;</code>を使用する際にあらゆる種類のロジックエラーからは、
コンパイラは保護してくれないということです。第15章で<code>Rc&lt;T&gt;</code>は、循環参照を生成してしまうリスクを伴い、
そうすると、2つの<code>Rc&lt;T&gt;</code>の値がお互いを参照し合い、メモリリークを引き起こしてしまうことを思い出してください。
同様に、<code>Mutex&lt;T&gt;</code>は<em>デッドロック</em>を生成するリスクを伴っています。これは、処理が2つのリソースをロックする必要があり、
2つのスレッドがそれぞれにロックを1つ獲得して永久にお互いを待ちあってしまうときに起こります。
デッドロックに興味があるのなら、デッドロックのあるRustプログラムを組んでみてください;
それからどんな言語でもいいので、ミューテックスに対してデッドロックを緩和する方法を調べて、
Rustで是非、それを実装してみてください。<code>Mutex&lt;T&gt;</code>と<code>MutexGuard</code>に関する標準ライブラリのAPIドキュメンテーションは、
役に立つ情報を提供してくれます。</p>
<!--
We’ll round out this chapter by talking about the `Send` and `Sync` traits and
how we can use them with custom types.
-->
<p><code>Send</code>と<code>Sync</code>トレイトと、それらを独自の型で使用する方法について語って、この章を締めくくります。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Extensible Concurrency with the `Sync` and `Send` Traits
-->
<h2 id="syncとsendトレイトで拡張可能な並行性"><a class="header" href="#syncとsendトレイトで拡張可能な並行性"><code>Sync</code>と<code>Send</code>トレイトで拡張可能な並行性</a></h2>
<!--
Interestingly, the Rust language has *very* few concurrency features. Almost
every concurrency feature we’ve talked about so far in this chapter has been
part of the standard library, not the language. Your options for handling
concurrency are not limited to the language or the standard library; you can
write your own concurrency features or use those written by others.
-->
<p>面白いことに、Rust言語には、<em>寡</em>少な並行性機能があります。この章でここまでに語った並行性機能のほとんどは、
標準ライブラリの一部であり、言語ではありません。並行性を扱う選択肢は、言語や標準ライブラリに制限されません;
独自の並行性機能を書いたり、他人が書いたものを利用したりできるのです。</p>
<!--
However, two concurrency concepts are embedded in the language: the
`std::marker` traits `Sync` and `Send`.
-->
<p>ですが、2つの並行性概念が言語に埋め込まれています: <code>std::marker</code>トレイトの<code>Sync</code>と<code>Send</code>です。</p>
<!--
### Allowing Transference of Ownership Between Threads with `Send`
-->
<h3 id="sendでスレッド間の所有権の転送を許可する"><a class="header" href="#sendでスレッド間の所有権の転送を許可する"><code>Send</code>でスレッド間の所有権の転送を許可する</a></h3>
<!--
最後から2行目、single-threaded situationsのsituationsを環境と訳すのが自然なのでそうしている
-->
<!--
The `Send` marker trait indicates that ownership of the type implementing
`Send` can be transferred between threads. Almost every Rust type is `Send`,
but there are some exceptions, including `Rc<T>`: this cannot be `Send` because
if you cloned an `Rc<T>` value and tried to transfer ownership of the clone to
another thread, both threads might update the reference count at the same time.
For this reason, `Rc<T>` is implemented for use in single-threaded situations
where you don’t want to pay the thread-safe performance penalty.
-->
<p><code>Send</code>マーカートレイトは、<code>Send</code>を実装した型の所有権をスレッド間で転送できることを示唆します。
Rustのほとんどの型は<code>Send</code>ですが、<code>Rc&lt;T&gt;</code>を含めて一部例外があります: この型は、<code>Rc&lt;T&gt;</code>の値をクローンし、
クローンしたものの所有権を別のスレッドに転送しようとしたら、両方のスレッドが同時に参照カウントを更新できてしまうので、
<code>Send</code>になり得ません。このため、<code>Rc&lt;T&gt;</code>はスレッド安全性のためのパフォーマンスの犠牲を支払わなくても済む、
シングルスレッド環境で使用するために実装されているわけです。</p>
<!--
Therefore, Rust’s type system and trait bounds ensure that you can never
accidentally send an `Rc<T>` value across threads unsafely. When we tried to do
this in Listing 16-14, we got the error `the trait Send is not implemented for
Rc<Mutex<i32>>`. When we switched to `Arc<T>`, which is `Send`, the code
compiled.
-->
<p>故に、Rustの型システムとトレイト境界により、<code>Rc&lt;T&gt;</code>の値を不安全にスレッド間で誤って送信することが絶対ないよう保証してくれるのです。
リスト16-14でこれを試みた時には、<code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>というエラーが出ました。
<code>Send</code>の<code>Arc&lt;T&gt;</code>に切り替えたら、コードはコンパイルできたわけです。</p>
<!--
Any type composed entirely of `Send` types is automatically marked as `Send` as
well. Almost all primitive types are `Send`, aside from raw pointers, which
we’ll discuss in Chapter 19.
-->
<p>完全に<code>Send</code>の型からなる型も全て自動的に<code>Send</code>と印付けされます。生ポインタを除くほとんどの基本型も<code>Send</code>で、
生ポインタについては第19章で議論します。</p>
<!--
### Allowing Access from Multiple Threads with `Sync`
-->
<h3 id="syncで複数のスレッドからのアクセスを許可する"><a class="header" href="#syncで複数のスレッドからのアクセスを許可する"><code>Sync</code>で複数のスレッドからのアクセスを許可する</a></h3>
<!--
The `Sync` marker trait indicates that it is safe for the type implementing
`Sync` to be referenced from multiple threads. In other words, any type `T` is
`Sync` if `&T` (a reference to `T`) is `Send`, meaning the reference can be
sent safely to another thread. Similar to `Send`, primitive types are `Sync`,
and types composed entirely of types that are `Sync` are also `Sync`.
-->
<p><code>Sync</code>マーカートレイトは、<code>Sync</code>を実装した型は、複数のスレッドから参照されても安全であることを示唆します。
言い換えると、<code>&amp;T</code>(<code>T</code>への参照)が<code>Send</code>なら、型<code>T</code>は<code>Sync</code>であり、参照が他のスレッドに安全に送信できることを意味します。
<code>Send</code>同様、基本型は<code>Sync</code>であり、<code>Sync</code>の型からのみ構成される型もまた<code>Sync</code>です。</p>
<!--
The smart pointer `Rc<T>` is also not `Sync` for the same reasons that it’s not
`Send`. The `RefCell<T>` type (which we talked about in Chapter 15) and the
family of related `Cell<T>` types are not `Sync`. The implementation of borrow
checking that `RefCell<T>` does at runtime is not thread-safe. The smart
pointer `Mutex<T>` is `Sync` and can be used to share access with multiple
threads as you saw in the “Sharing a `Mutex<T>` Between Multiple Threads”
section.
-->
<p><code>Send</code>ではなかったのと同じ理由で、スマートポインタの<code>Rc&lt;T&gt;</code>もまた<code>Sync</code>ではありません。
<code>RefCell&lt;T&gt;</code>型(これについては第15章で話しました)と関連する<code>Cell&lt;T&gt;</code>系についても<code>Sync</code>ではありません。
<code>RefCell&lt;T&gt;</code>が実行時に行う借用チェックの実装は、スレッド安全ではないのです。
スマートポインタの<code>Mutex&lt;T&gt;</code>は<code>Sync</code>で、「複数のスレッド間で<code>Mutex&lt;T&gt;</code>を共有する」節で見たように、
複数のスレッドでアクセスを共有するのに使用することができます。</p>
<!--
### Implementing `Send` and `Sync` Manually Is Unsafe
-->
<h3 id="sendとsyncを手動で実装するのは非安全である"><a class="header" href="#sendとsyncを手動で実装するのは非安全である"><code>Send</code>と<code>Sync</code>を手動で実装するのは非安全である</a></h3>
<!--
Because types that are made up of `Send` and `Sync` traits are automatically
also `Send` and `Sync`, we don’t have to implement those traits manually. As
marker traits, they don’t even have any methods to implement. They’re just
useful for enforcing invariants related to concurrency.
-->
<p><code>Send</code>と<code>Sync</code>トレイトから構成される型は自動的に<code>Send</code>と<code>Sync</code>にもなるので、
それらのトレイトを手動で実装する必要はありません。マーカートレイトとして、
実装すべきメソッドさえも何もありません。並行性に関連する不変条件を強制することに役立つだけなのです。</p>
<!--
Manually implementing these traits involves implementing unsafe Rust code.
We’ll talk about using unsafe Rust code in Chapter 19; for now, the important
information is that building new concurrent types not made up of `Send` and
`Sync` parts requires careful thought to uphold the safety guarantees.
[The Rustonomicon] has more information about these guarantees and how to
uphold them.
-->
<p>これらのトレイトを手動で実装するには、unsafeなRustコードを実装することが関わってきます。
unsafeなRustコードを使用することについては第19章で語ります; とりあえず、重要な情報は、
<code>Send</code>と<code>Sync</code>ではない部品からなる新しい並行な型を構成するには、安全性保証を保持するために、
注意深い思考が必要になるということです。<a href="https://doc.rust-lang.org/stable/nomicon/">The Rustonomicon</a>には、
これらの保証とそれを保持する方法についての情報がより多くあります。</p>
<blockquote>
<p>訳注: 日本語版のThe Rustonomiconは<a href="https://doc.rust-jp.rs/rust-nomicon-ja/index.html">こちら</a>です。</p>
</blockquote>
<!--
## Summary
-->
<h2 id="まとめ-15"><a class="header" href="#まとめ-15">まとめ</a></h2>
<!--
This isn’t the last you’ll see of concurrency in this book: the project in
Chapter 20 will use the concepts in this chapter in a more realistic situation
than the smaller examples discussed here.
-->
<p>この本において並行性を見かけるのは、これで最後ではありません: 第20章のプロジェクトでは、
この章の概念をここで議論した微小な例よりもより現実的な場面で使用するでしょう。</p>
<!--
最後はmutithreaded situationsとなっているが、situationを環境と訳した方が自然なので、そうしている
-->
<!--
As mentioned earlier, because very little of how Rust handles concurrency is
part of the language, many concurrency solutions are implemented as crates.
These evolve more quickly than the standard library, so be sure to search
online for the current, state-of-the-art crates to use in multithreaded
situations.
-->
<p>前述のように、Rustによる並行性の取扱いのごく一部のみが言語仕様なので、多くの並行性の解決策は
クレートとして実装されています。これらは標準ライブラリよりも迅速に進化するので、
マルチスレッド環境で使用すべき現在の最先端のクレートを必ずネットで検索してください。</p>
<!--
The Rust standard library provides channels for message passing and smart
pointer types, such as `Mutex<T>` and `Arc<T>`, that are safe to use in
concurrent contexts. The type system and the borrow checker ensure that the
code using these solutions won’t end up with data races or invalid references.
Once you get our code to compile, you can rest assured that it will happily
run on multiple threads without the kinds of hard-to-track-down bugs common in
other languages. Concurrent programming is no longer a concept to be afraid of:
go forth and make your programs concurrent, fearlessly!
-->
<p>Rustの標準ライブラリは、メッセージ受け渡しにチャンネルを、並行の文脈で安全に使用できる、
<code>Mutex&lt;T&gt;</code>や<code>Arc&lt;T&gt;</code>などのスマートポインタ型を提供しています。型システムと借用チェッカーにより、
これらの解決策を使用するコードがデータ競合や無効な参照に行き着かないことを保証してくれます。
一旦コードをコンパイルすることができたら、他の言語ではありふれている追跡困難な類のバグなしに、
複数のスレッドでも喜んで動くので安心できます。並行プログラミングは、もはや恐れるべき概念ではありません:
恐れることなく前進し、プログラムを並行にしてください！</p>
<!--
Next, we’ll talk about idiomatic ways to model problems and structure solutions
as your Rust programs get bigger. In addition, we’ll discuss how Rust’s idioms
relate to those you might be familiar with from object oriented programming.
-->
<p>次は、Rustプログラムが肥大化するにつれて問題をモデル化し、解決策を構造化する慣例的な方法について話します。
さらに、Rustのイディオムがオブジェクト指向プログラミングで馴染み深いかもしれないイディオムにどのように関連しているかについても議論します。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Object-Oriented Programming Features of Rust
-->
<h1 id="rustのオブジェクト指向プログラミング機能"><a class="header" href="#rustのオブジェクト指向プログラミング機能">Rustのオブジェクト指向プログラミング機能</a></h1>
<!--
Object-oriented programming (OOP) is a way of modeling programs. Objects came
from Simula in the 1960s. Those objects influenced Alan Kay’s programming
architecture in which objects pass messages to each other. He coined the term
*object-oriented programming* in 1967 to describe this architecture. Many
competing definitions describe what OOP is; some definitions would classify
Rust as object oriented, but other definitions would not. In this chapter,
we'll explore certain characteristics that are commonly considered object
oriented and how those characteristics translate to idiomatic Rust. We’ll then
show you how to implement an object-oriented design pattern in Rust and discuss
the trade-offs of doing so versus implementing a solution using some of Rust’s
strengths instead.
-->
<p>オブジェクト指向プログラミング(OOP)は、プログラムをモデル化する手段です。オブジェクトは、
1960年代のSimulaに端緒を発しています。このオブジェクトは、
お互いにメッセージを渡し合うというアラン・ケイ(Alan Kay)のプログラミングアーキテクチャに影響を及ぼしました。
彼は、このアーキテクチャを解説するために、<em>オブジェクト指向プログラミング</em>という用語を造語しました。
多くの競合する定義がOOPが何かを解説しています; Rustをオブジェクト指向と区分する定義もありますし、
しない定義もあります。この章では、広くオブジェクト指向と捉えられる特定の特徴と、
それらの特徴がこなれたRustでどう表現されるかを探究します。それからオブジェクト指向のデザインパターンをRustで実装する方法を示し、
そうすることとRustの強みを活用して代わりの解決策を実装する方法の代償を議論します。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Characteristics of Object-Oriented Languages
-->
<h2 id="オブジェクト指向言語の特徴"><a class="header" href="#オブジェクト指向言語の特徴">オブジェクト指向言語の特徴</a></h2>
<!--
There is no consensus in the programming community about what features a
language must have to be considered object oriented. Rust is influenced by many
programming paradigms, including OOP; for example, we explored the features
that came from functional programming in Chapter 13. Arguably, OOP languages
share certain common characteristics, namely objects, encapsulation, and
inheritance. Let’s look at what each of those characteristics mean and whether
Rust supports them.
-->
<p>言語がオブジェクト指向と考えられるのになければならない機能について、プログラミングコミュニティ内での総意はありません。
RustはOOPを含めた多くのプログラミングパラダイムに影響を受けています; 例えば、
第13章で関数型プログラミングに由来する機能を探究しました。議論はあるかもしれませんが、
OOP言語は特定の一般的な特徴を共有しています。具体的には、オブジェクトやカプセル化、
継承などです。それらの個々の特徴が意味するものとRustがサポートしているかを見ましょう。</p>
<!--
### Objects Contain Data and Behavior
-->
<h3 id="オブジェクトはデータと振る舞いを含む"><a class="header" href="#オブジェクトはデータと振る舞いを含む">オブジェクトは、データと振る舞いを含む</a></h3>
<!--
The book *Design Patterns: Elements of Reusable Object-Oriented Software* by
Enoch Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wasley
Professional, 1994) colloquially referred to as *The Gang of Four book*, is a
catlog of object-oriented design patterns. It defines OOP this way:
-->
<p>エーリヒ・ガンマ(Enoch Gamma)、リチャード・ヘルム(Richard Helm)、ラルフ・ジョンソン(Ralph Johnson)、
ジョン・ブリシディース(John Vlissides)(アディソン・ワズリー・プロ)により、
1994年に書かれた<em>デザインパターン: 再利用可能なオブジェクト指向ソフトウェアの要素</em>という本は、
俗に<em>4人のギャングの本</em>(<code>訳注</code>: the Gang of Four book; GoFとよく略される)と呼ばれ、オブジェクト指向デザインパターンのカタログです。
そこでは、OOPは以下のように定義されています:</p>
<!--
> Object-oriented programs are made up of objects. An *object* packages both
> data and the procedures that operate on that data. The procedures are
> typically called *methods* or *operations*.
-->
<blockquote>
<p>オブジェクト指向プログラムは、オブジェクトで構成される。オブジェクトは、
データとそのデータを処理するプロシージャを梱包している。このプロシージャは、
典型的に<em>メソッド</em>または<em>オペレーション</em>と呼ばれる。</p>
</blockquote>
<!--
Using this definition, Rust is object oriented: structs and enums have data,
and `impl` blocks provide methods on structs and enums. Even though structs and
enums with methods aren’t *called* objects, they provide the same
functionality, according to the Gang of Four’s definition of objects.
-->
<p>この定義を使用すれば、Rustはオブジェクト指向です: 構造体とenumにはデータがありますし、
<code>impl</code>ブロックが構造体とenumにメソッドを提供します。メソッドのある構造体とenumは、
オブジェクトとは呼ばれないものの、GoFのオブジェクト定義によると、同じ機能を提供します。</p>
<!--
### Encapsulation that Hides Implementation Details
-->
<h3 id="カプセル化は実装詳細を隠蔽する"><a class="header" href="#カプセル化は実装詳細を隠蔽する">カプセル化は、実装詳細を隠蔽する</a></h3>
<!--
Another aspect commonly associated with OOP is the idea of *encapsulation*,
which means that the implementation details of an object aren’t accessible to
code using that object. Therefore, the only way to interact with an object is
through its public API; code using the object shouldn’t be able to reach into
the object’s internals and change data or behavior directly. This enables the
programmer to change and refactor an object’s internals without needing to
change the code that uses the object.
-->
<p>OOPとよく紐づけられる別の側面は、カプセル化の思想です。これは、オブジェクトの実装詳細は、
そのオブジェクトを使用するコードにはアクセスできないことを意味します。故に、
オブジェクトと相互作用する唯一の手段は、その公開APIを通してです; オブジェクトを使用するコードは、
オブジェクトの内部に到達して、データや振る舞いを直接変更できるべきではありません。
このために、プログラマはオブジェクトの内部をオブジェクトを使用するコードを変更する必要なく、
変更しリファクタリングできます。</p>
<!--
We discussed how to control encapsulation in Chapter 7: we can use the `pub`
keyword to decide which modules, types, functions, and methods in our code
should be public, and by default everything else is private. For example, we
can define a struct `AveragedCollection` that has a field containing a vector
of `i32` values. The struct can also have a field that contains the average of
the values in the vector, meaning the average doesn’t have to be computed
on demand whenever anyone needs it. In other words, `AveragedCollection` will
cache the calculated average for us. Listing 17-1 has the definition of the
`AveragedCollection` struct:
-->
<p>カプセル化を制御する方法は、第7章で議論しました: <code>pub</code>キーワードを使用して、
自分のコードのどのモジュールや型、関数、メソッドを公開するか決められ、
既定ではそれ以外のものは全て非公開になります。例えば、
<code>i32</code>値のベクタを含むフィールドのある<code>AveragedCollection</code>という構造体を定義できます。
この構造体はさらに、ベクタの値の平均を含むフィールドを持てます。つまり、平均は誰かが必要とする度に、
オンデマンドで計算する必要はないということです。言い換えれば、<code>AveragedCollection</code>は、
計算した平均をキャッシュしてくれるわけです。リスト17-1には、<code>AveragedCollection</code>構造体の定義があります:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-1: An `AveragedCollection` struct that
maintains a list of integers and the average of the items in the
collection</span>
-->
<p><span class="caption">リスト17-1: 整数のリストとコレクションの要素の平均を管理する<code>AveragedCollection</code>構造体</span></p>
<!--
The struct is marked `pub` so that other code can use it, but the fields within
the struct remain private. This is important in this case because we want to
ensure that whenever a value is added or removed from the list, the average is
also updated. We do this by implementing `add`, `remove`, and `average` methods
on the struct, as shown in Listing 17-2:
-->
<p>構造体は、他のコードが使用できるように<code>pub</code>で印づけされていますが、構造体のフィールドは非公開のままです。
値が追加されたりリストから削除される度に、平均も更新されることを保証したいので、今回の場合重要です。
<code>add</code>や<code>remove</code>、<code>average</code>メソッドを構造体に実装することでこれをします。リスト17-2のようにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            },
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-2: Implementations of the public methods
`add`, `remove`, and `average` on `AveragedCollection`</span>
-->
<p><span class="caption">リスト17-2: <code>AveragedCollection</code>の<code>add</code>、<code>remove</code>、<code>average</code>公開メソッドの実装</span></p>
<!--
The public methods `add`, `remove`, and `average` are the only ways to modify
an instance of `AveragedCollection`. When an item is added to `list` using the
`add` method or removed using the `remove` method, the implementations of each
call the private `update_average` method that handles updating the `average`
field as well.
-->
<p><code>add</code>、<code>remove</code>、<code>average</code>の公開メソッドが<code>AveragedCollection</code>のインスタンスを変更する唯一の方法になります。
要素が<code>add</code>メソッドを使用して<code>list</code>に追加されたり、<code>remove</code>メソッドを使用して削除されたりすると、
各メソッドの実装が<code>average</code>フィールドの更新を扱う非公開の<code>update_average</code>メソッドも呼び出します。</p>
<!--
We leave the `list` and `average` fields private so there is no way for
external code to add or remove items to the `list` field directly; otherwise,
the `average` field might become out of sync when the `list` changes. The
`average` method returns the value in the `average` field, allowing external
code to read the `average` but not modify it.
-->
<p><code>list</code>と<code>average</code>フィールドを非公開のままにしているので、外部コードが要素を<code>list</code>フィールドに直接追加したり削除したりする方法はありません;
そうでなければ、<code>average</code>フィールドは、<code>list</code>が変更された時に同期されなくなる可能性があります。
<code>average</code>メソッドは<code>average</code>フィールドの値を返し、外部コードに<code>average</code>を読ませるものの、
変更は許可しません。</p>
<!--
Because we’ve encapsulated the implementation details of the struct
`AveragedCollection`, we can easily change aspects, such as the data structure,
in the future. For instance, we could use a `HashSet<i32>` instead of a
`Vec<i32>` for the `list` field. As long as the signatures of the `add`
`remove`, and `average` public methods stay the same, code using
`AveragedCollection` wouldn’t need to change. If we made `list` public instead,
this wouldn’t necessarily be the case: `HashSet<i32>` and `Vec<i32>` have
different methods for adding and removing items, so the external code would
likely have to change if it were modifying `list` directly.
-->
<p>構造体<code>AveragedCollection</code>の実装詳細をカプセル化したので、データ構造などの側面を将来容易に変更することができます。
例を挙げれば、<code>list</code>フィールドに<code>Vec&lt;i32&gt;</code>ではなく<code>HashSet&lt;i32&gt;</code>を使うこともできます。
<code>add</code>、<code>remove</code>、<code>average</code>といった公開メソッドのシグニチャが同じである限り、<code>AveragedCollection</code>を使用するコードは変更する必要がないでしょう。
代わりに<code>list</code>を公開にしたら、必ずしもこうはならないでしょう: <code>HashSet&lt;i32&gt;</code>と<code>Vec&lt;i32&gt;</code>は、
要素の追加と削除に異なるメソッドを持っているので、外部コードが直接<code>list</code>を変更しているなら、
外部コードも変更しなければならない可能性が高いでしょう。</p>
<!--
If encapsulation is a required aspect for a language to be considered object
oriented, then Rust meets that requirement. The option to use `pub` or not for
different parts of code enables encapsulation of implementation details.
-->
<p>カプセル化が、言語がオブジェクト指向と考えられるのに必要な側面ならば、Rustはその条件を満たしています。
コードの異なる部分で<code>pub</code>を使用するかしないかという選択肢のおかげで、実装詳細をカプセル化することが可能になります。</p>
<!--
### Inheritance as a Type System and as Code Sharing
-->
<h3 id="型システムおよびコード共有としての継承"><a class="header" href="#型システムおよびコード共有としての継承">型システム、およびコード共有としての継承</a></h3>
<!--
*Inheritance* is a mechanism whereby an object can inherit from another
object’s definition, thus gaining the parent object’s data and behavior without
you having to define them again.
-->
<p><em>継承</em>は、それによってオブジェクトが他のオブジェクトの定義から受け継ぐことができる機構であり、
それ故に、再定義する必要なく、親オブジェクトのデータと振る舞いを得ます。</p>
<!--
If a language must have inheritance to be an object-oriented language, then
Rust is not one. There is no way to define a struct that inherits the parent
struct’s fields and method implementations. However, if you’re used to having
inheritance in your programming toolbox, you can use other solutions in Rust,
depending on your reason for reaching for inheritance in the first place.
-->
<p>言語がオブジェクト指向言語であるために継承がなければならないのならば、Rustは違います。
親構造体のフィールドとメソッドの実装を受け継ぐ構造体を定義する方法はありません。しかしながら、
継承がプログラミング道具箱にあることに慣れていれば、そもそも継承に手を伸ばす理由によって、
Rustで他の解決策を使用することができます。</p>
<!--
You choose inheritance for two main reasons. One is for reuse of code: you can
implement particular behavior for one type, and inheritance enables you to
reuse that implementation for a different type. You can share Rust code using
default trait method implementations instead, which you saw in Listing 10-14
when we added a default implementation of the `summarize` method on the
`Summary` trait. Any type implementing the `Summary` trait would have the
`summarize` method available on it without any further code. This is similar to
a parent class having an implementation of a method and an inheriting child
class also having the implementation of the method. We can also override the
default implementation of the `summarize` method when we implement the
`Summary` trait, which is similar to a child class overriding the
implementation of a method inherited from a parent class.
-->
<p>継承を選択する理由は主に2つあります。1つ目は、コードの再利用です: ある型に特定の振る舞いを実装し、
継承により、その実装を他の型にも再利用できるわけです。デフォルトのトレイトメソッド実装を代わりに使用して、
Rustコードを共有でき、これは、リスト10-14で<code>Summary</code>トレイトに<code>summarize</code>メソッドのデフォルト実装を追加した時に見かけました。
<code>Summary</code>トレイトを実装する型は全て、追加のコードなく<code>summarize</code>メソッドが使用できます。
これは、親クラスにメソッドの実装があり、継承した子クラスにもそのメソッドの実装があることと似ています。
また、<code>Summary</code>トレイトを実装する時に、<code>summarize</code>メソッドのデフォルト実装を上書きすることもでき、
これは、親クラスから継承したメソッドの実装を子クラスが上書きすることに似ています。</p>
<!--
The other reason to use inheritance relates to the type system: to enable a
child type to be used in the same places as the parent type. This is also
called *polymorphism*, which means that you can substitute multiple objects for
each other at runtime if they share certain characteristics.
-->
<p>継承を使用するもう1つの理由は、型システムに関連しています: 親の型と同じ箇所で子供の型を使用できるようにです。
これは、<em>多相性</em>(polymorphism)とも呼ばれ、複数のオブジェクトが特定の特徴を共有しているなら、
実行時にお互いに代用できることを意味します。</p>
<!--
> ### Polymorphism
>
> To many people, polymorphism is synonymous with inheritance. But it’s
> actually a more general concept that refers to code that can work with data
> of multiple types. For inheritance, those types are generally subclasses.
>
> Rust instead uses generics to abstract over different possible types and
> trait bounds to impose constraints on what those types must provide. This is
> sometimes called *bounded parametric polymorphism*.
-->
<blockquote>
<h3 id="多相性"><a class="header" href="#多相性">多相性</a></h3>
<p>多くの人にとって、多相性は、継承の同義語です。ですが、実際には複数の型のデータを取り扱えるコードを指すより一般的な概念です。
継承について言えば、それらの型は一般的にはサブクラスです。</p>
<p>Rustは代わりにジェネリクスを使用して様々な可能性のある型を抽象化し、トレイト境界を使用してそれらの型が提供するものに制約を課します。
これは時に、<em>パラメータ境界多相性</em>(bounded parametric polymorphism)と呼ばれます。</p>
</blockquote>
<!--
Inheritance has recently fallen out of favor as a programming design solution
in many programming languages because it’s often at risk of sharing more code
than necessary. Subclasses shouldn’t always share all characteristics of their
parent class but will do so with inheritance. This can make a program’s design
less flexible. It also introduces the possibility of calling methods on
subclasses that don’t make sense or that cause errors because the methods don’t
apply to the subclass. Some languages will also only allow a subclass
to inherit from one class, further restricting the flexibility of a program’s
design.
-->
<p>継承は、近年、多くのプログラミング言語において、プログラムの設計解決策としては軽んじられています。
というのも、しばしば必要以上にコードを共有してしまう危険性があるからです。サブクラスは、
必ずしも親クラスの特徴を全て共有するべきではないのに、継承ではそうなってしまうのです。
これにより、プログラムの設計の柔軟性を失わせることもあります。また、道理に合わなかったり、メソッドがサブクラスには適用されないために、
エラーを発生させるようなサブクラスのメソッドの呼び出しを引き起こす可能性が出てくるのです。
さらに、サブクラスに1つのクラスからだけ継承させる言語もあり、さらにプログラムの設計の柔軟性が制限されます。</p>
<!--
For these reasons, Rust takes a different approach, using trait objects instead
of inheritance. Let’s look at how trait objects enable polymorphism in Rust.
-->
<p>これらの理由により、継承ではなくトレイトオブジェクトを使用してRustは異なるアプローチを取っています。
Rustにおいて、トレイトオブジェクトがどう多相性を可能にするかを見ましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Using Trait Objects that Allow for Values of Different Types
-->
<h2 id="トレイトオブジェクトで異なる型の値を許容する"><a class="header" href="#トレイトオブジェクトで異なる型の値を許容する">トレイトオブジェクトで異なる型の値を許容する</a></h2>
<!--
In Chapter 8, we mentioned that one limitation of vectors is that they can
store elements of only one type. We created a workaround in Listing 8-10 where
we defined a `SpreadsheetCell` enum that had variants to hold integers, floats,
and text. This meant we could store different types of data in each cell and
still have a vector that represented a row of cells. This is a perfectly good
solution when our interchangeable items are a fixed set of types that we know
when our code is compiled.
-->
<p>第8章で、ベクタの1つの制限は、たった1つの型の要素を保持することしかできないことだと述べました。
リスト8-10で整数、浮動小数点数、テキストを保持する列挙子のある<code>SpreadsheetCell</code> enumを定義して、
これを回避しました。つまり、各セルに異なる型のデータを格納しつつ、1行のセルを表すベクタを保持するということです。
コンパイル時にわかるある固定されたセットの型にしか取り替え可能な要素がならない場合には、
完璧な解決策です。</p>
<!--
However, sometimes we want our library user to be able to extend the set of
types that are valid in a particular situation. To show how we might achieve
this, we’ll create an example graphical user interface (GUI) tool that iterates
through a list of items, calling a `draw` method on each one to draw it to the
screen—a common technique for GUI tools. We’ll create a library crate called
`gui` that contains the structure of a GUI library. This crate might include
some types for people to use, such as `Button` or `TextField`. In addition,
`gui` users will want to create their own types that can be drawn: for
instance, one programmer might add an `Image` and another might add a
`SelectBox`.
-->
<p>ところが、時として、ライブラリの使用者が特定の場面で合法になる型のセットを拡張できるようにしたくなることがあります。
これをどう実現する可能性があるか示すために、各アイテムに<code>draw</code>メソッドを呼び出してスクリーンに描画するという、
GUIツールで一般的なテクニックをしてあるリストの要素を走査する例のGUIツールを作ります。
GUIライブラリの構造を含む<code>gui</code>と呼ばれるライブラリクレートを作成します。
このクレートには、他人が使用できる<code>Button</code>や<code>TextField</code>などの型が包含されるかもしれません。
さらに、<code>gui</code>の使用者は、描画可能な独自の型を作成したくなるでしょう: 例えば、
ある人は<code>Image</code>を追加し、別の人は<code>SelectBox</code>を追加するかもしれません。</p>
<!--
We won’t implement a fully fledged GUI library for this example but will show
how the pieces would fit together. At the time of writing the library, we can’t
know and define all the types other programmers might want to create. But we do
know that `gui` needs to keep track of many values of different types, and it
needs to call a `draw` method on each of these differently typed values. It
doesn’t need to know exactly what will happen when we call the `draw` method,
just that the value will have that method available for us to call.
-->
<p>この例のために本格的なGUIライブラリは実装するつもりはありませんが、部品がどう組み合わさるかは示します。
ライブラリの記述時点では、他のプログラマが作成したくなる可能性のある型全てを知る由もなければ、定義することもできません。
しかし、<code>gui</code>は異なる型の多くの値を追いかけ、この異なる型の値に対して<code>draw</code>メソッドを呼び出す必要があることは、
確かにわかっています。<code>draw</code>メソッドを呼び出した時に正確に何が起きるかを知っている必要はありません。
値にそのメソッドが呼び出せるようあることだけわかっていればいいのです。</p>
<!--
To do this in a language with inheritance, we might define a class named
`Component` that has a method named `draw` on it. The other classes, such as
`Button`, `Image`, and `SelectBox`, would inherit from `Component` and thus
inherit the `draw` method. They could each override the `draw` method to define
their custom behavior, but the framework could treat all of the types as if
they were `Component` instances and call `draw` on them. But because Rust
doesn’t have inheritance, we need another way to structure the `gui` library to
allow users to extend it with new types.
-->
<p>継承のある言語でこれを行うには、<code>draw</code>という名前のメソッドがある<code>Component</code>というクラスを定義するかもしれません。
<code>Button</code>、<code>Image</code>、<code>SelectBox</code>などの他のクラスは、<code>Component</code>を継承し、故に<code>draw</code>メソッドを継承します。
個々に<code>draw</code>メソッドをオーバーライドして、独自の振る舞いを定義するものの、フレームワークは、
<code>Component</code>インスタンスであるかのようにその型全部を扱い、この型に対して<code>draw</code>を呼び出します。
ですが、Rustに継承は存在しないので、使用者に新しい型で拡張してもらうために<code>gui</code>ライブラリを構成する他の方法が必要です。</p>
<!--
### Defining a Trait for Common Behavior
-->
<h3 id="一般的な振る舞いにトレイトを定義する"><a class="header" href="#一般的な振る舞いにトレイトを定義する">一般的な振る舞いにトレイトを定義する</a></h3>
<!--
To implement the behavior we want `gui` to have, we’ll define a trait named
`Draw` that will have one method named `draw`. Then we can define a vector that
takes a *trait object*. A trait object points to an instance of a type that
implements the trait we specify. We create a trait object by specifying some
sort of pointer, such as a `&` reference or a `Box<T>` smart pointer, and then
specifying the relevant trait. (we’ll talk about the reason trait objects must
use a pointer in Chapter 19 in the section “Dynamically Sized Types & Sized”.)
We can use trait objects in place of a generic or concrete type. Wherever we
use a trait object, Rust’s type system will ensure at compile time that any
value used in that context will implement the trait object’s trait.
Consequently, we don’t need to know all the possible types at compile time.
-->
<p><code>gui</code>に欲しい振る舞いを実装するには、<code>draw</code>という1つのメソッドを持つ<code>Draw</code>というトレイトを定義します。
それから<em>トレイトオブジェクト</em>を取るベクタを定義できます。トレイトオブジェクトは、
指定したトレイトを実装するある型のインスタンスを指します。<code>&amp;</code>参照や<code>Box&lt;T&gt;</code>スマートポインタなどの、
何らかのポインタを指定し、それから関係のあるトレイトを指定する(トレイトオブジェクトがポインタを使用しなければならない理由については、
第19章の「動的サイズ決定型とSizedトレイト」節で語ります)ことでトレイトオブジェクトを作成します。
ジェネリックまたは具体的な型があるところにトレイトオブジェクトは使用できます。どこでトレイトオブジェクトを使用しようと、
Rustの型システムは、コンパイル時にその文脈で使用されているあらゆる値がそのトレイトオブジェクトのトレイトを実装していることを保証します。
結果としてコンパイル時に可能性のある型を全て知る必要はなくなるのです。</p>
<!--
We’ve mentioned that in Rust, we refrain from calling structs and enums
“objects” to distinguish them from other languages’ objects. In a struct or
enum, the data in the struct fields and the behavior in `impl` blocks are
separated, whereas in other languages, the data and behavior combined into one
concept is often labeled an object. However, trait objects *are* more like
objects in other languages in the sense that they combine data and behavior.
But trait objects differ from traditional objects in that we can’t add data to
a trait object. Trait objects aren’t as generally useful as objects in other
languages: their specific purpose is to allow abstraction across common
behavior.
-->
<p>Rustでは、構造体とenumを他の言語のオブジェクトと区別するために「オブジェクト」と呼ぶことを避けていることに触れましたね。
構造体やenumにおいて、構造体のフィールドのデータや<code>impl</code>ブロックの振る舞いは区分けされているものの、
他の言語では1つの概念に押し込められるデータと振る舞いは、しばしばオブジェクトと分類されます。
しかしながら、トレイトオブジェクトは、データと振る舞いをごちゃ混ぜにするという観点で他の言語のオブジェクトに近い<em>です</em>。
しかし、トレイトオブジェクトは、データを追加できないという点で伝統的なオブジェクトと異なっています。
トレイトオブジェクトは、他の言語のオブジェクトほど一般的に有用ではありません:
その特定の目的は、共通の振る舞いに対して抽象化を行うことです。</p>
<!--
Listing 17-3 shows how to define a trait named `Draw` with one method named
`draw`:
-->
<p>リスト17-3は、<code>draw</code>という1つのメソッドを持つ<code>Draw</code>というトレイトを定義する方法を示しています:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Draw {
    fn draw(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-3: Definition of the `Draw` trait</span>
-->
<p><span class="caption">リスト17-3: <code>Draw</code>トレイトの定義</span></p>
<!--
This syntax should look familiar from our discussions on how to define traits
in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named
`Screen` that holds a vector named `components`. This vector is of type
`Box<Draw>`, which is a trait object; it’s a stand-in for any type inside a
`Box` that implements the `Draw` trait.
-->
<p>この記法は、第10章のトレイトの定義方法に関する議論で馴染み深いはずです。その次は、新しい記法です:
リスト17-4では、<code>components</code>というベクタを保持する<code>Screen</code>という名前の構造体を定義しています。
このベクタの型は<code>Box&lt;Draw&gt;</code>で、これはトレイトオブジェクトです; <code>Draw</code>トレイトを実装する<code>Box</code>内部の任意の型に対する代役です。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-4: Definition of the `Screen` struct with a
`components` field holding a vector of trait objects that implement the `Draw`
trait</span>
-->
<p><span class="caption">リスト17-4: <code>Draw</code>トレイトを実装するトレイトオブジェクトのベクタを保持する<code>components</code>フィールドがある
<code>Screen</code>構造体の定義</span></p>
<!--
On the `Screen` struct, we’ll define a method named `run` that will call the
`draw` method on each of its `components`, as shown in Listing 17-5:
-->
<p><code>Screen</code>構造体に、<code>components</code>の各要素に対して<code>draw</code>メソッドを呼び出す<code>run</code>というメソッドを定義します。
リスト17-5のようにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-5: A `run` method on `Screen` that calls the
`draw` method on each component</span>
-->
<p><span class="caption">リスト17-5: 各コンポーネントに対して<code>draw</code>メソッドを呼び出す<code>Screen</code>の<code>run</code>メソッド</span></p>
<!--
This works differently than defining a struct that uses a generic type
parameter with trait bounds. A generic type parameter can only be substituted
with one concrete type at a time, whereas trait objects allow for multiple
concrete types to fill in for the trait object at runtime. For example, we
could have defined the `Screen` struct using a generic type and a trait bound
as in Listing 17-6:
-->
<p>これは、トレイト境界を伴うジェネリックな型引数を使用する構造体を定義するのとは異なる動作をします。
ジェネリックな型引数は、一度に1つの具体型にしか置き換えられないのに対して、トレイトオブジェクトは、
実行時にトレイトオブジェクトに対して複数の具体型で埋めることができます。例として、
ジェネリックな型とトレイト境界を使用してリスト17-6のように<code>Screen</code>構造体を定義することもできました:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
    where T: Draw {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-6: An alternate implementation of the `Screen`
struct and its `run` method using generics and trait bounds</span>
-->
<p><span class="caption">リスト17-6: ジェネリクスとトレイト境界を使用した<code>Screen</code>構造体と<code>run</code>メソッドの対立的な実装</span></p>
<!--
This restricts us to a `Screen` instance that has a list of components all of
type `Button` or all of type `TextField`. If you’ll only ever have homogeneous
collections, using generics and trait bounds is preferable because the
definitions will be monomorphized at compile time to use the concrete types.
-->
<p>こうすると、全てのコンポーネントの型が<code>Button</code>だったり、<code>TextField</code>だったりする<code>Screen</code>のインスタンスに制限されてしまいます。
絶対に同種のコレクションしか持つ予定がないのなら、ジェネリクスとトレイト境界は、
定義がコンパイル時に具体的な型を使用するように単相化されるので、望ましいです。</p>
<!--
On the other hand, with the method using trait objects, one `Screen` instance
can hold a `Vec<T>` that contains a `Box<Button>` as well as a
`Box<TextField>`. Let’s look at how this works, and then we’ll talk about the
runtime performance implications.
-->
<p>一方で、メソッドがトレイトオブジェクトを使用すると、1つの<code>Screen</code>インスタンスが、
<code>Box&lt;Button&gt;</code>と<code>Box&lt;TextField&gt;</code>を含む<code>Vec&lt;T&gt;</code>を保持できます。
この動作方法を見、それから実行時性能の裏の意味について語りましょう。</p>
<!--
### Implementing the Trait
-->
<h3 id="トレイトを実装する"><a class="header" href="#トレイトを実装する">トレイトを実装する</a></h3>
<!--
Now we’ll add some types that implement the `Draw` trait. We’ll provide the
`Button` type. Again, actually implementing a GUI library is beyond the scope
of this book, so the `draw` method won’t have any useful implementation in its
body. To imagine what the implementation might look like, a `Button` struct
might have fields for `width`, `height`, and `label`, as shown in Listing 17-7:
-->
<p>さて、<code>Draw</code>トレイトを実装する型を追加しましょう。<code>Button</code>型を提供します。ここも、実際にGUIライブラリを実装することは、
この本の範疇を超えているので、<code>draw</code>メソッドの本体は、何も有用な実装はしません。実装がどんな感じになるか想像するために、
<code>Button</code>構造体は、<code>width</code>、<code>height</code>、<code>label</code>フィールドを持っている可能性があります。
リスト17-7に示したようにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
        // 実際にボタンを描画するコード
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-7: A `Button` struct that implements the
`Draw` trait</span>
-->
<p><span class="caption">リスト17-7: <code>Draw</code>トレイトを実装するある<code>Button</code>構造体</span></p>
<!--
The `width`, `height`, and `label` fields on `Button` will differ from the
fields on other components, such as a `TextField` type, that might have those
fields plus a `placeholder` field instead. Each of the types we want to draw on
the screen will implement the `Draw` trait but will use different code in the
`draw` method to define how to draw that particular type, as `Button` has here
(without the actual GUI code that is beyond the scope of this chapter). The
`Button` type, for instance, might have an additional `impl` block containing
methods related to what happens when a user clicks the button. These kinds of
methods won’t apply to types like `TextField`.
-->
<p><code>Button</code>の<code>width</code>、<code>height</code>、<code>label</code>フィールドは、<code>TextField</code>型のように、
それらのフィールドプラス<code>placeholder</code>フィールドを代わりに持つ可能性のある他のコンポーネントのフィールドとは異なるでしょう。
スクリーンに描画したい型のコンポーネントはそれぞれ<code>Draw</code>トレイトを実装しますが、
<code>Button</code>がここでしているように、<code>draw</code>メソッドでは異なるコードを使用してその特定の型を描画する方法を定義しています(実際のGUIコードは、
この章の範疇を超えるのでありませんが)。例えば、<code>Button</code>には、ユーザがボタンをクリックした時に起こることに関連するメソッドを含む、
追加の<code>impl</code>ブロックがある可能性があります。この種のメソッドは、<code>TextField</code>のような型には適用されません。</p>
<!--
If someone using our library decides to implement a `SelectBox` struct that has
`width`, `height`, and `options` fields, they implement the `Draw` trait on the
`SelectBox` type as well, as shown in Listing 17-8:
-->
<p>ライブラリの使用者が、<code>width</code>、<code>height</code>、<code>options</code>フィールドのある<code>SelectBox</code>構造体を実装しようと決めたら、
<code>SelectBox</code>型にも<code>Draw</code>トレイトを実装します。リスト17-8のようにですね:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate gui;
use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
        //セレクトボックスを実際に描画するコード
    }
}
</code></pre>
<!--
<span class="caption">Listing 17-8: Another crate using `gui` and implementing
the `Draw` trait on a `SelectBox` struct</span>
-->
<p><span class="caption">リスト17-8: <code>gui</code>を使用し、<code>SelectBox</code>構造体に<code>Draw</code>トレイトを実装する別のクレート</span></p>
<!--
Our library’s user can now write their `main` function to create a `Screen`
instance. To the `Screen` instance, they can add a `SelectBox` and a `Button`
by putting each in a `Box<T>` to become a trait object. They can then call the
`run` method on the `Screen` instance, which will call `draw` on each of the
components. Listing 17-9 shows this implementation:
-->
<p>ライブラリの使用者はもう、<code>main</code>関数を書き、<code>Screen</code>インスタンスを生成できます。<code>Screen</code>インスタンスには、
それぞれを<code>Box&lt;T&gt;</code>に放り込んでトレイトオブジェクト化して<code>SelectBox</code>と<code>Button</code>を追加できます。
それから<code>Screen</code>インスタンスに対して<code>run</code>メソッドを呼び出すことができ、そうすると各コンポーネントの<code>draw</code>が呼び出されます。
リスト17-9は、この実装を示しています:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::{Screen, Button};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    // はい
                    String::from(&quot;Yes&quot;),
                    // 多分
                    String::from(&quot;Maybe&quot;),
                    // いいえ
                    String::from(&quot;No&quot;)
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                // 了解
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<!--
<span class="caption">Listing 17-9: Using trait objects to store values of
different types that implement the same trait</span>
-->
<p><span class="caption">リスト17-9: トレイトオブジェクトを使って同じトレイトを実装する異なる型の値を格納する</span></p>
<!--
When we wrote the library, we didn’t know that someone might add the
`SelectBox` type, but our `Screen` implementation was able to operate on the
new type and draw it because `SelectBox` implements the `Draw` type, which
means it implements the `draw` method.
-->
<p>ライブラリを記述した時点では、誰かが<code>SelectBox</code>型を追加する可能性があるなんて知りませんでしたが、
<code>Screen</code>の実装は、新しい型を処理し、描画することができました。何故なら、<code>SelectBox</code>は<code>Draw</code>型、
つまり、<code>draw</code>メソッドを実装しているからです。</p>
<!--
This concept—of being concerned only with the messages a value responds to
rather than the value’s concrete type—is similar to the concept *duck typing*
in dynamically typed languages: if it walks like a duck and quacks like a duck,
then it must be a duck! In the implementation of `run` on `Screen` in Listing
17-5, `run` doesn’t need to know what the concrete type of each component is.
It doesn’t check whether a component is an instance of a `Button` or a
`SelectBox`, it just calls the `draw` method on the component. By specifying
`Box<Draw>` as the type of the values in the `components` vector, we’ve defined
`Screen` to need values that we can call the `draw` method on.
-->
<p>この値の具体的な型ではなく、値が応答したメッセージにのみ関係するという概念は、
動的型付け言語の<em>ダックタイピング</em>に似た概念です: アヒルのように歩き、鳴くならば、
アヒルに違いないのです！リスト17-5の<code>Screen</code>の<code>run</code>の実装では、<code>run</code>は、
各コンポーネントの実際の型がなんであるか知る必要はありません。コンポーネントが、
<code>Button</code>や<code>SelectBox</code>のインスタンスであるかを確認することはなく、コンポーネントの<code>draw</code>メソッドを呼び出すだけです。
<code>components</code>ベクタで<code>Box&lt;Draw&gt;</code>を値の型として指定することで、<code>Screen</code>を、
<code>draw</code>メソッドを呼び出せる値を必要とするように定義できたのです。</p>
<blockquote>
<h4 id="注釈-ダックタイピングについて"><a class="header" href="#注釈-ダックタイピングについて">注釈: ダックタイピングについて</a></h4>
<p>ご存知かもしれませんが、ダックタイピングについて補足です。ダックタイピングとは、動的型付け言語やC++のテンプレートで使用される、
特定のフィールドやメソッドがあることを想定してコンパイルを行い、実行時に実際にあることを確かめるというプログラミング手法です。
ダック・テストという思考法に由来するそうです。</p>
<p>ダックタイピングの利点は、XMLやJSONなど、厳密なスキーマがないことが多い形式を扱いやすくなること、
欠点は、実行してみるまで動くかどうかわからないことでしょう。</p>
</blockquote>
<!--
The advantage of using trait objects and Rust’s type system to write code
similar to code using duck typing is that we never have to check whether a
value implements a particular method at runtime or worry about getting errors
if a value doesn’t implement a method but we call it anyway. Rust won’t compile
our code if the values don’t implement the traits that the trait objects need.
-->
<p>トレイトオブジェクトとRustの型システムを使用してダックタイピングを活用したコードに似たコードを書くことの利点は、
実行時に値が特定のメソッドを実装しているか確認したり、値がメソッドを実装していない時にエラーになることを心配したりする必要は絶対になく、
とにかく呼び出せることです。コンパイラは、値が、トレイトオブジェクトが必要としているトレイトを実装していなければ、
コンパイルを通さないのです。</p>
<!--
For example, Listing 17-10 shows what happens if we try to create a `Screen`
with a `String` as a component:
-->
<p>例えば、リスト17-10は、コンポーネントに<code>String</code>のある<code>Screen</code>を作成しようとした時に起こることを示しています:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate gui;
use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from(&quot;Hi&quot;)),
        ],
    };

    screen.run();
}
</code></pre>
<!--
<span class="caption">Listing 17-10: Attempting to use a type that doesn’t
implement the trait object’s trait</span>
-->
<p><span class="caption">リスト17-10: トレイトオブジェクトのトレイトを実装しない型の使用を試みる</span></p>
<!--
We’ll get this error because `String` doesn’t implement the `Draw` trait:
-->
<p><code>String</code>は<code>Draw</code>トレイトを実装していないので、このようなエラーが出ます:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: gui::Draw` is not satisfied
  --&gt; src/main.rs:7:13
   |
 7 |             Box::new(String::from(&quot;Hi&quot;)),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait gui::Draw is not
   implemented for `std::string::String`
   |
   = note: required for the cast to the object type `gui::Draw`
</code></pre>
<!--
2行目はandだが、順接の理由で訳している
-->
<!--
This error lets us know that either we’re passing something to `Screen` we
didn’t mean to pass and we should pass a different type or we should implement
`Draw` on `String` so that `Screen` is able to call `draw` on it.
-->
<p>このエラーは、渡すことを意図していないものを<code>Screen</code>に渡しているので、異なる型を渡すべきか、
<code>Screen</code>が<code>draw</code>を呼び出せるように<code>String</code>に<code>Draw</code>を実装するべきのどちらかであることを知らせてくれています。</p>
<!--
### Trait Objects Perform Dynamic Dispatch
-->
<h3 id="トレイトオブジェクトはダイナミックディスパッチを行う"><a class="header" href="#トレイトオブジェクトはダイナミックディスパッチを行う">トレイトオブジェクトは、ダイナミックディスパッチを行う</a></h3>
<!--
Recall in the “Performance of Code Using Generics” section in Chapter 10 our
discussion on the monomorphization process performed by the compiler when we
use trait bounds on generics: the compiler generates nongeneric implementations
of functions and methods for each concrete type that we use in place of a
generic type parameter. The code that results from monomorphization is doing
*static dispatch*, which is when the compiler knows what method you’re calling
at compile time. This is opposed to *dynamic dispatch*, which is when the
compiler can’t tell at compile time which method you’re calling. In dynamic
dispatch cases, the compiler emits code that at runtime will figure out which
method to call.
-->
<p>第10章の「ジェネリクスを使用したコードのパフォーマンス」節でジェネリクスに対してトレイト境界を使用した時に、
コンパイラが行う単相化過程の議論を思い出してください: コンパイラは、関数やメソッドのジェネリックでない実装を、
ジェネリックな型引数の箇所に使用している具体的な型に対して生成するのでした。単相化の結果吐かれるコードは、
<em>スタティックディスパッチ</em>を行い、これは、コンパイル時にコンパイラがどのメソッドを呼び出しているかわかる時のことです。
これは、<em>ダイナミックディスパッチ</em>とは対照的で、この時、コンパイラは、コンパイル時にどのメソッドを呼び出しているのかわかりません。
ダイナミックディスパッチの場合、コンパイラは、どのメソッドを呼び出すか実行時に弾き出すコードを生成します。</p>
<!--
When we use trait objects, Rust must use dynamic dispatch. The compiler doesn’t
know all the types that might be used with the code that is using trait
objects, so it doesn’t know which method implemented on which type to call.
Instead, at runtime, Rust uses the pointers inside the trait object to know
which method to call. There is a runtime cost when this lookup happens that
doesn’t occur with static dispatch. Dynamic dispatch also prevents the compiler
from choosing to inline a method’s code, which in turn prevents some
optimizations. However, we did get extra flexibility in the code that we wrote
in Listing 17-5 and were able to support in Listing 17-9, so it’s a trade-off
to consider.
-->
<p>トレイトオブジェクトを使用すると、コンパイラはダイナミックディスパッチを使用しなければなりません。
コンパイラは、トレイトオブジェクトを使用しているコードで使用される可能性のある型全てを把握しないので、
どの型に実装されたどのメソッドを呼び出すかわからないのです。代わりに実行時に、トレイトオブジェクト内でポインタを使用して、
コンパイラは、どのメソッドを呼ぶか知ります。スタティックディスパッチでは行われないこの検索が起きる時には、
実行時コストがあります。また、ダイナミックディスパッチは、コンパイラがメソッドのコードをインライン化することも妨げ、
そのため、ある種の最適化が不可能になります。ですが、リスト17-5で記述し、
リスト17-9ではサポートできたコードで追加の柔軟性を確かに得られたので、考慮すべき代償です。</p>
<!--
### Object Safety Is Required for Trait Objects
-->
<h3 id="トレイトオブジェクトにはオブジェクト安全性が必要"><a class="header" href="#トレイトオブジェクトにはオブジェクト安全性が必要">トレイトオブジェクトには、オブジェクト安全性が必要</a></h3>
<!--
You can only make *object-safe* traits into trait objects. Some complex rules
govern all the properties that make a trait object safe, but in practice, only
two rules are relevant. A trait is object safe if all the methods defined in
the trait have the following properties:
-->
<p>トレイトオブジェクトには、<em>オブジェクト安全</em>なトレイトしか作成できません。
トレイトオブジェクトを安全にする特性全てを司る複雑な規則がありますが、実際には、2つの規則だけが関係があります。
トレイトは、トレイト内で定義されているメソッド全てに以下の特性があれば、オブジェクト安全になります。</p>
<!--
* The return type isn’t `Self`.
* There are no generic type parameters.
-->
<ul>
<li>戻り値の型が<code>Self</code>でない。</li>
<li>ジェネリックな型引数がない。</li>
</ul>
<!--
The `Self` keyword is an alias for the type we’re implementing the traits or
methods on. Trait objects must be object safe because once you’ve used a trait
object, Rust no longer knows the concrete type that’s implementing that trait.
If a trait method returns the concrete `Self` type, but a trait object forgets
the exact type that `Self` is, there is no way the method can use the original
concrete type. The same is true of generic type parameters that are filled in
with concrete type parameters when the trait is used: the concrete types become
part of the type that implements the trait. When the type is forgotten through
the use of a trait object, there is no way to know what types to fill in the
generic type parameters with.
-->
<p><code>Self</code>キーワードは、トレイトやメソッドを実装しようとしている型の別名です。トレイトオブジェクトは、
一旦、トレイトオブジェクトを使用したら、コンパイラにはそのトレイトを実装している具体的な型を知りようがないので、
オブジェクト安全でなければなりません。トレイトメソッドが具体的な<code>Self</code>型を返すのに、
トレイトオブジェクトが<code>Self</code>の具体的な型を忘れてしまったら、メソッドが元の具体的な型を使用できる手段はなくなってしまいます。
同じことがトレイトを使用する時に具体的な型引数で埋められるジェネリックな型引数に対しても言えます:
具体的な型がトレイトを実装する型の一部になるのです。トレイトオブジェクトの使用を通して型が忘却されたら、
そのジェネリックな型引数を埋める型がなんなのか知る術はないのです。</p>
<!--
An example of a trait whose methods are not object safe is the standard
library’s `Clone` trait. The signature for the `clone` method in the `Clone`
trait looks like this:
-->
<p>メソッドがオブジェクト安全でないトレイトの例は、標準ライブラリの<code>Clone</code>トレイトです。
<code>Clone</code>トレイトの<code>clone</code>メソッドのシグニチャは以下のような感じです:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `String` type implements the `Clone` trait, and when we call the `clone`
method on an instance of `String` we get back an instance of `String`.
Similarly, if we call `clone` on an instance of `Vec<T>`, we get back an
instance of `Vec<T>`. The signature of `clone` needs to know what type will
stand in for `Self`, because that’s the return type.
-->
<p><code>String</code>型は<code>Clone</code>トレイトを実装していて、<code>String</code>のインスタンスに対して<code>clone</code>メソッドを呼び出すと、
<code>String</code>のインスタンスが返ってきます。同様に、<code>Vec&lt;T&gt;</code>のインスタンスに対して<code>clone</code>を呼び出すと、
<code>Vec&lt;T&gt;</code>のインスタンスが返ってきます。<code>clone</code>のシグニチャは、<code>Self</code>の代わりに入る型を知る必要があります。
それが、戻り値の型になるからです。</p>
<!--
The compiler will indicate when you’re trying to do something that violates the
rules of object safety in regard to trait objects. For example, let’s say we
tried to implement the `Screen` struct in Listing 17-4 to hold types that
implement the `Clone` trait instead of the `Draw` trait, like this:
-->
<p>コンパイラは、トレイトオブジェクトに関していつオブジェクト安全の規則を侵害するようなことを試みているかを示唆します。
例えば、リスト17-4で<code>Screen</code>構造体を実装して<code>Draw</code>トレイトではなく、
<code>Clone</code>トレイトを実装した型を保持しようとしたとしましょう。こんな感じで:</p>
<pre><code class="language-rust ignore">pub struct Screen {
    pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
}
</code></pre>
<!--
We would get this error:
-->
<p>こんなエラーになるでしょう:</p>
<pre><code class="language-text">error[E0038]: the trait `std::clone::Clone` cannot be made into an object
(エラー: `std::clone::Clone`トレイトは、オブジェクトにすることはできません)
 --&gt; src/lib.rs:2:5
  |
2 |     pub components: Vec&lt;Box&lt;Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be
made into an object
  |
  = note: the trait cannot require that `Self : Sized`
  (注釈: このトレイトは、`Self : Sized`を満たせません)
</code></pre>
<!--
This error means you can’t use this trait as a trait object in this way. If
you’re interested in more details on object safety, see [Rust RFC 255].
-->
<p>このエラーは、このようにこのトレイトをトレイトオブジェクトとして使用することはできないことを意味しています。
オブジェクト安全性についての詳細に興味があるのなら、<a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">Rust RFC 255</a>を参照されたし。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Implementing an Object-Oriented Design Pattern
-->
<h2 id="オブジェクト指向デザインパターンを実装する"><a class="header" href="#オブジェクト指向デザインパターンを実装する">オブジェクト指向デザインパターンを実装する</a></h2>
<!--
The *state pattern* is an object-oriented design pattern. The crux of the
pattern is that a value has some internal state, which is represented by a set
of *state objects*, and the value’s behavior changes based on the internal
state. The state objects share functionality: in Rust, of course, we use
structs and traits rather than objects and inheritance. Each state object is
responsible for its own behavior and for governing when it should change into
another state. The value that holds a state object knows nothing about the
different behavior of the states or when to transition between states.
-->
<p>ステートパターンは、オブジェクト指向デザインパターンの1つです。このパターンの肝は、
値が一連の<em>ステートオブジェクト</em>で表されるなんらかの内部状態を持ち、
その内部の状態に基づいて値の振る舞いが変化するというものです。ステートオブジェクトは、
機能を共有します: Rustでは、もちろん、オブジェクトと継承ではなく、構造体とトレイトを使用します。
各ステートオブジェクトは、自身の振る舞いと別の状態に変化すべき時を司ることに責任を持ちます。
ステートオブジェクトを保持する値は、状態ごとの異なる振る舞いや、いつ状態が移行するかについては何も知りません。</p>
<!--
Using the state pattern means when the business requirements of the program
change, we won’t need to change the code of the value holding the state or the
code that uses the value. We’ll only need to update the code inside one of the
state objects to change its rules or perhaps add more state objects. Let’s look
at an example of the state design pattern and how to use it in Rust.
-->
<p>ステートパターンを使用することは、プログラムの業務要件が変わる時、状態を保持する値のコードや、
値を使用するコードを変更する必要はないことを意味します。ステートオブジェクトの1つのコードを更新して、
規則を変更したり、あるいはおそらくステートオブジェクトを追加する必要しかないのです。
ステートデザインパターンの例と、そのRustでの使用方法を見ましょう。</p>
<!--
We’ll implement a blog post workflow in an incremental way. The blog’s final
functionality will look like this:
-->
<p>ブログ記事のワークフローを少しずつ実装していきます。ブログの最終的な機能は以下のような感じになるでしょう:</p>
<!--
1. A blog post starts as an empty draft.
2. When the draft is done, a review of the post is requested.
3. When the post is approved, it gets published.
4. Only published blog posts return content to print, so unapproved posts can’t
accidentally be published.
-->
<ol>
<li>ブログ記事は、空の草稿から始まる。</li>
<li>草稿ができたら、査読が要求される。</li>
<li>記事が承認されたら、公開される。</li>
<li>公開されたブログ記事だけが表示する内容を返すので、未承認の記事は、誤って公開されない。</li>
</ol>
<!--
Any other changes attempted on a post should have no effect. For example, if we
try to approve a draft blog post before we’ve requested a review, the post
should remain an unpublished draft.
-->
<p>それ以外の記事に対する変更は、効果を持つべきではありません。例えば、査読を要求する前にブログ記事の草稿を承認しようとしたら、
記事は、非公開の草稿のままになるべきです。</p>
<!--
Listing 17-11 shows this workflow in code form: this is an example usage of the
API we’ll implement in a library crate named `blog`. This won’t compile yet
because we haven’t implemented the `blog` crate yet.
-->
<p>リスト17-11は、このワークフローをコードの形で示しています: これは、
<code>blog</code>というライブラリクレートに実装するAPIの使用例です。まだ<code>blog</code>クレートを実装していないので、
コンパイルはできません。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    // 今日はお昼にサラダを食べた
    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<!--
<span class="caption">Listing 17-11: Code that demonstrates the desired
behavior we want our `blog` crate to have</span>
-->
<p><span class="caption">リスト17-11: <code>blog</code>クレートに欲しい振る舞いをデモするコード</span></p>
<!--
We want to allow the user to create a new draft blog post with `Post::new`.
Then we want to allow text to be added to the blog post while it’s in the draft
state. If we try to get the post’s content immediately, before approval,
nothing should happen because the post is still a draft. We’ve added
`assert_eq!` in the code for demonstration purposes. An excellent unit test for
this would be to assert that a draft blog post returns an empty string from the
`content` method, but we’re not going to write tests for this example.
-->
<p>ユーザが<code>Post::new</code>で新しいブログ記事の草稿を作成できるようにしたいです。それから、
草稿状態の間にブログ記事にテキストを追加できるようにしたいです。承認前に記事の内容を即座に得ようとしたら、
記事はまだ草稿なので、何も起きるべきではありません。デモ目的でコードに<code>assert_eq!</code>を追加しました。
これに対する素晴らしい単体テストは、ブログ記事の草稿が<code>content</code>メソッドから空の文字列を返すことをアサートすることでしょうが、
この例に対してテストを書くつもりはありません。</p>
<!--
Next, we want to enable a request for a review of the post, and we want
`content` to return an empty string while waiting for the review. When the post
receives approval, it should get published, meaning the text of the post will
be returned when `content` is called.
-->
<p>次に、記事の査読を要求できるようにしたく、また査読を待機している間は<code>content</code>に空の文字列を返してほしいです。
記事が承認を受けたら、公開されるべきです。つまり、<code>content</code>を呼んだ時に記事のテキストが返されるということです。</p>
<!--
Notice that the only type we’re interacting with from the crate is the `Post`
type. This type will use the state pattern and will hold a value that will be
one of three state objects representing the various states a post can be
in—draft, waiting for review, or published. Changing from one state to another
will be managed internally within the `Post` type. The states change in
response to the methods called by our library’s users on the `Post` instance,
but they don’t have to manage the state changes directly. Also, users can’t
make a mistake with the states, like publishing a post before it’s reviewed.
-->
<p>クレートから相互作用している唯一の型は、<code>Post</code>だけであることに注意してください。
この型はステートパターンを使用し、記事がなり得る種々の状態を表す3つのステートオブジェクトのうちの1つになる値を保持します。
草稿、査読待ち、公開中です。1つの状態から別の状態への変更は、<code>Post</code>型内部で管理されます。
<code>Post</code>インスタンスのライブラリ使用者が呼び出すメソッドに呼応して状態は変化しますが、
状態の変化を直接管理する必要はありません。また、ユーザは、
査読前に記事を公開するなど状態を誤ることはありません。</p>
<!--
### Defining `Post` and Creating a New Instance in the Draft State
-->
<h3 id="postを定義し草稿状態で新しいインスタンスを生成する"><a class="header" href="#postを定義し草稿状態で新しいインスタンスを生成する"><code>Post</code>を定義し、草稿状態で新しいインスタンスを生成する</a></h3>
<!--
Let’s get started on the implementation of the library! We know we need a
public `Post` struct that holds some content, so we’ll start with the
definition of the struct and an associated public `new` function to create an
instance of `Post`, as shown in Listing 17-12. We’ll also make a private
`State` trait. Then `Post` will hold a trait object of `Box<State>` inside an
`Option` in a private field named `state`. You’ll see why the `Option` is
necessary in a bit.
-->
<p>ライブラリの実装に取り掛かりましょう！なんらかの内容を保持する公開の<code>Post</code>構造体が必要なことはわかるので、
構造体の定義と、関連する公開の<code>Post</code>インスタンスを生成する<code>new</code>関数から始めましょう。リスト17-12のようにですね。
また、非公開の<code>State</code>トレイトも作成します。それから、<code>Post</code>は<code>state</code>という非公開のフィールドに、
<code>Option</code>で<code>Box&lt;State&gt;</code>のトレイトオブジェクトを保持します。<code>Option</code>が必要な理由はすぐわかります。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    state: Option&lt;Box&lt;State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-12: Definition of a `Post` struct and a `new`
function that creates a new `Post` instance, a `State` trait, and a `Draft`
struct</span>
-->
<p><span class="caption">リスト17-12: <code>Post</code>構造体、新規<code>Post</code>インスタンスを生成する<code>new</code>関数、
<code>State</code>トレイト、<code>Draft</code>構造体の定義</span></p>
<!--
The `State` trait defines the behavior shared by different post states, and the
`Draft`, `PendingReview`, and `Published` states will all implement the `State`
trait. For now, the trait doesn’t have any methods, and we’ll start by defining
just the `Draft` state because that is the state we want a post to start in.
-->
<p><code>State</code>トレイトは、異なる記事の状態で共有される振る舞いを定義し、<code>Draft</code>、<code>PendingReview</code>、<code>Published</code>状態は全て、
<code>State</code>トレイトを実装します。今は、トレイトにメソッドは何もなく、<code>Draft</code>が記事の初期状態にしたい状態なので、
その状態だけを定義することから始めます。</p>
<!--
When we create a new `Post`, we set its `state` field to a `Some` value that
holds a `Box`. This `Box` points to a new instance of the `Draft` struct. This
ensures whenever we create a new instance of `Post`, it will start out as a
draft. Because the `state` field of `Post` is private, there is no way to
create a `Post` in any other state! In the `Post::new` function, we set the
`content` field to a new, empty `String`
-->
<p>新しい<code>Post</code>を作る時、<code>state</code>フィールドは、<code>Box</code>を保持する<code>Some</code>値にセットします。
この<code>Box</code>が<code>Draft</code>構造体の新しいインスタンスを指します。これにより、
新しい<code>Post</code>を作る度に、草稿から始まることが保証されます。<code>Post</code>の<code>state</code>フィールドは非公開なので、
<code>Post</code>を他の状態で作成する方法はないのです！<code>Post::new</code>関数では、<code>content</code>フィールドを新しい空の<code>String</code>にセットしています。</p>
<!--
### Storing the Text of the Post Content
-->
<h3 id="記事の内容のテキストを格納する"><a class="header" href="#記事の内容のテキストを格納する">記事の内容のテキストを格納する</a></h3>
<!--
Listing 17-11 showed that we want to be able to call a method named
`add_text` and pass it a `&str` that is then added to the text content of the
blog post. We implement this as a method rather than exposing the `content`
field as `pub`. This means we can implement a method later that will control
how the `content` field’s data is read. The `add_text` method is pretty
straightforward, so let’s add the implementation in Listing 17-13 to the `impl
Post` block:
-->
<p>リスト17-11は、<code>add_text</code>というメソッドを呼び出し、ブログ記事のテキスト内容に追加される<code>&amp;str</code>を渡せるようになりたいことを示しました。
これを<code>content</code>フィールドを<code>pub</code>にして晒すのではなく、メソッドとして実装しています。
これは、後ほど<code>content</code>フィールドデータの読まれ方を制御するメソッドを実装できることを意味しています。
<code>add_text</code>メソッドは非常に素直なので、リスト17-13の実装を<code>impl Post</code>ブロックに追加しましょう:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-13: Implementing the `add_text` method to add
text to a post’s `content`</span>
-->
<p><span class="caption">リスト17-13: 記事の<code>content</code>にテキストを追加する<code>add_text</code>メソッドを実装する</span></p>
<!--
The `add_text` method takes a mutable reference to `self`, because we’re
changing the `Post` instance that we’re calling `add_text` on. We then call
`push_str` on the `String` in `content` and pass the `text` argument to add to
the saved `content`. This behavior doesn’t depend on the state the post is in,
so it’s not part of the state pattern. The `add_text` method doesn’t interact
with the `state` field at all, but it is part of the behavior we want to
support.
-->
<p><code>add_text</code>メソッドは、<code>self</code>への可変参照を取ります。というのも、<code>add_text</code>を呼び出した<code>Post</code>インスタンスを変更しているからです。
それから<code>content</code>の<code>String</code>に対して<code>push_str</code>を呼び出し、<code>text</code>引数を渡して保存された<code>content</code>に追加しています。
この振る舞いは、記事の状態によらないので、ステートパターンの一部ではありません。<code>add_text</code>メソッドは、
<code>state</code>フィールドと全く相互作用しませんが、サポートしたい振る舞いの一部ではあります。</p>
<!--
### Ensuring the Content of a Draft Post Is Empty
-->
<h3 id="草稿の記事の内容は空であることを保証する"><a class="header" href="#草稿の記事の内容は空であることを保証する">草稿の記事の内容は空であることを保証する</a></h3>
<!--
Even after we’ve called `add_text` and added some content to our post, we still
want the `content` method to return an empty string slice because the post is
still in the draft state, as shown on line 8 of Listing 17-11. For now, let’s
implement the `content` method with the simplest thing that will fulfill this
requirement: always returning an empty string slice. We’ll change this later
once we implement the ability to change a post’s state so it can be published.
So far, posts can only be in the draft state, so the post content should always
be empty. Listing 17-14 shows this placeholder implementation:
-->
<p><code>add_text</code>を呼び出して記事に内容を追加した後でさえ、記事はまだ草稿状態なので、
それでも<code>content</code>メソッドには空の文字列スライスを返してほしいです。
リスト17-11の8行目で示したようにですね。とりあえず、この要求を実現する最も単純な方法で<code>content</code>メソッドを実装しましょう:
常に空の文字列スライスを返すことです。一旦、記事の状態を変更する能力を実装したら、公開できるように、
これを後ほど変更します。ここまで、記事は草稿状態にしかなり得ないので、記事の内容は常に空のはずです。
リスト17-14は、この仮の実装を表示しています:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-14: Adding a placeholder implementation for
the `content` method on `Post` that always returns an empty string slice</span>
-->
<p><span class="caption">リスト17-14: <code>Post</code>に常に空の文字列スライスを返す<code>content</code>の仮の実装を追加する</span></p>
<!--
With this added `content` method, everything in Listing 17-11 up to line 8
works as intended.
-->
<p>この追加された<code>content</code>メソッドとともに、リスト17-11の8行目までのコードは、想定通り動きます。</p>
<!--
[Requesting a Review of the Post] Changes ... ともRequesting that [a Review ...]とも読める。どちらがふさわしいだろうか
次の1行目にrequest a review of a post, whichとあるので、前者で訳しておく。
-->
<!--
### Requesting a Review of the Post Changes Its State
-->
<h3 id="記事の査読を要求すると状態が変化する"><a class="header" href="#記事の査読を要求すると状態が変化する">記事の査読を要求すると、状態が変化する</a></h3>
<!--
Next, we need to add functionality to request a review of a post, which should
change its state from `Draft` to `PendingReview`. Listing 17-15 shows this code:
-->
<p>次に、記事の査読を要求する機能を追加する必要があり、これをすると、状態が<code>Draft</code>から<code>PendingReview</code>に変わるはずです。
リスト17-15はこのコードを示しています:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-15: Implementing `request_review` methods on
`Post` and the `State` trait</span>
-->
<p><span class="caption">リスト17-15: <code>Post</code>と<code>State</code>トレイトに<code>request_review</code>メソッドを実装する</span></p>
<!--
We give `Post` a public method named `request_review` that will take a mutable
reference to `self`. Then we call an internal `request_review` method on the
current state of `Post`, and this second `request_review` method consumes the
current state and returns a new state.
-->
<p><code>Post</code>に<code>self</code>への可変参照を取る<code>request_review</code>という公開メソッドを与えます。それから、
<code>Post</code>の現在の状態に対して内部の<code>request_review</code>メソッドを呼び出し、
この2番目の<code>request_review</code>が現在の状態を消費し、新しい状態を返します。</p>
<!--
We’ve added the `request_review` method to the `State` trait; all types that
implement the trait will now need to implement the `request_review` method.
Note that rather than having `self`, `&self`, or `&mut self` as the first
parameter of the method, we have `self: Box<Self>`. This syntax means the
method is only valid when called on a `Box` holding the type. This syntax takes
ownership of `Box<Self>`, invalidating the old state so the state value of the
`Post` can transform into a new state.
-->
<p><code>State</code>トレイトに<code>request_review</code>メソッドを追加しました; このトレイトを実装する型は全て、
これで<code>request_review</code>メソッドを実装する必要があります。メソッドの第1引数に<code>self</code>、<code>&amp;self</code>、<code>&amp;mut self</code>ではなく、
<code>self: Box&lt;Self&gt;</code>としていることに注意してください。この記法は、型を保持する<code>Box</code>に対して呼ばれた時のみ、
このメソッドが合法になることを意味しています。この記法は、<code>Box&lt;Self&gt;</code>の所有権を奪い、古い状態を無効化するので、
<code>Post</code>の状態値は、新しい状態に変形できます。</p>
<!--
To consume the old state, the `request_review` method needs to take ownership
of the state value. This is where the `Option` in the `state` field of `Post`
comes in: we call the `take` method to take the `Some` value out of the `state`
field and leave a `None` in its place, because Rust doesn’t let us have
unpopulated fields in structs. This lets us move the `state` value out of
`Post` rather than borrowing it. Then we’ll set the post’s `state` value to the
result of this operation.
-->
<p>古い状態を消費するために、<code>request_review</code>メソッドは、状態値の所有権を奪う必要があります。
ここで<code>Post</code>の<code>state</code>フィールドの<code>Option</code>が問題になるのです: <code>take</code>メソッドを呼び出して、
<code>state</code>フィールドから<code>Some</code>値を取り出し、その箇所に<code>None</code>を残します。なぜなら、Rustは、
構造体に未代入のフィールドを持たせてくれないからです。これにより、借用するのではなく、
<code>Post</code>の<code>state</code>値をムーブすることができます。それから、記事の<code>state</code>値をこの処理の結果にセットするのです。</p>
<!--
We need to set `state` to `None` temporarily rather than setting it directly
with code like `self.state = self.state.request_review();` to get ownership of
the `state` value. This ensures `Post` can’t use the old `state` value after
we’ve transformed it into a new state.
-->
<p><code>self.state = self.state.request_review();</code>のようなコードで直接<code>state</code>値の所有権を得るよう設定するのではなく、
一時的に<code>None</code>に<code>state</code>をセットする必要があります。これにより、新しい状態に変形した後に、
<code>Post</code>が古い<code>state</code>値を使えないことが保証されるのです。</p>
<!--
The `request_review` method on `Draft` needs to return a new, boxed instance of
a new `PendingReview` struct, which represents the state when a post is waiting
for a review. The `PendingReview` struct also implements the `request_review`
method but doesn’t do any transformations. Rather, it returns itself, because
when we request a review on a post already in the `PendingReview` state, it
should stay in the `PendingReview` state.
-->
<p><code>Draft</code>の<code>request_review</code>メソッドは、新しい<code>PendingReview</code>構造体の新しいボックスのインスタンスを返す必要があり、
これが、記事が査読待ちの時の状態を表します。<code>PendingReview</code>構造体も<code>request_review</code>メソッドを実装しますが、
何も変形はしません。むしろ、自身を返します。というのも、既に<code>PendingReview</code>状態にある記事の査読を要求したら、
<code>PendingReview</code>状態に留まるべきだからです。</p>
<!--
Now we can start seeing the advantages of the state pattern: the
`request_review` method on `Post` is the same no matter its `state` value. Each
state is responsible for its own rules.
-->
<p>ようやくステートパターンの利点が見えてき始めました: <code>state</code>値が何であれ、<code>Post</code>の<code>request_review</code>メソッドは同じです。
各状態は、独自の規則にのみ責任を持ちます。</p>
<!--
We’ll leave the `content` method on `Post` as is, returning an empty string
slice. We can now have a `Post` in the `PendingReview` state as well as in the
`Draft` state, but we want the same behavior in the `PendingReview` state.
Listing 17-11 now works up to line 11!
-->
<p><code>Post</code>の<code>content</code>メソッドを空の文字列スライスを返してそのままにします。
これで<code>Post</code>は<code>PendingReview</code>と<code>Draft</code>状態になり得ますが、<code>PendingReview</code>状態でも、
同じ振る舞いが欲しいです。もうリスト17-11は11行目まで動くようになりました！</p>
<!--
### Adding the `approve` Method that Changes the Behavior of `content`
-->
<h3 id="contentの振る舞いを変化させるapproveメソッドを追加する"><a class="header" href="#contentの振る舞いを変化させるapproveメソッドを追加する"><code>content</code>の振る舞いを変化させる<code>approve</code>メソッドを追加する</a></h3>
<!--
The `approve` method will be similar to the `request_review` method: it will
set `state` to the value that the current state says it should have when that
state is approved, as shown in Listing 17-16:
-->
<p><code>approve</code>メソッドは、<code>request_review</code>メソッドと類似するでしょう: 状態が承認された時に、
現在の状態があるべきと言う値に<code>state</code>をセットします。リスト17-16のようにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;
}

struct Draft {}

impl State for Draft {
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-16: Implementing the `approve` method on
`Post` and the `State` trait</span>
-->
<p><span class="caption">リスト17-16: <code>Post</code>と<code>State</code>トレイトに<code>approve</code>メソッドを実装する</span></p>
<!--
We add the `approve` method to the `State` trait and add a new struct that
implements `State`, the `Published` state.
-->
<p><code>State</code>トレイトに<code>approve</code>メソッドを追加し、<code>Published</code>状態という<code>State</code>を実装する新しい構造体を追加します。</p>
<!--
Similar to `request_review`, if we call the `approve` method on a `Draft`, it
will have no effect because it will return `self`. When we call `approve` on
`PendingReview`, it returns a new, boxed instance of the `Published` struct.
The `Published` struct implements the `State` trait, and for both the
`request_review` method and the `approve` method, it returns itself, because
the post should stay in the `Published` state in those cases.
-->
<p><code>request_review</code>のように、<code>Draft</code>に対して<code>approve</code>メソッドを呼び出したら、<code>self</code>を返すので、
何も効果はありません。<code>PendingReview</code>に対して<code>approve</code>を呼び出すと、
<code>Published</code>構造体の新しいボックス化されたインスタンスを返します。<code>Published</code>構造体は<code>State</code>トレイトを実装し、
<code>request_review</code>メソッドと<code>approve</code>メソッド両方に対して、自身を返します。
そのような場合に記事は、<code>Published</code>状態に留まるべきだからです。</p>
<!--
Now we need to update the `content` method on `Post`: if the state is
`Published`, we want to return the value in the post’s `content` field;
otherwise, we want to return an empty string slice, as shown in Listing 17-17:
-->
<p>さて、<code>Post</code>の<code>content</code>メソッドを更新する必要が出てきました: 状態が<code>Published</code>なら、
記事の<code>content</code>フィールドの値を返したいのです; それ以外なら、空の文字列スライスを返したいです。
リスト17-17のようにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait State {
</span><span class="boring">    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str;
</span><span class="boring">}
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(&amp;self)
    }
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-17: Updating the `content` method on `Post` to
delegate to a `content` method on `State`</span>
-->
<p><span class="caption">リスト17-17: <code>Post</code>の<code>content</code>メソッドを更新して<code>State</code>の<code>content</code>メソッドに委譲する</span></p>
<!--
Because the goal is to keep all these rules inside the structs that implement
`State`, we call a `content` method on the value in `state` and pass the post
instance (that is, `self`) as an argument. Then we return the value that is
returned from using the `content` method on the `state` value.
-->
<p>目的は、これらの規則全てを<code>State</code>を実装する構造体の内部に押し留めることなので、<code>state</code>の値に対して<code>content</code>メソッドを呼び出し、
記事のインスタンス(要するに、<code>self</code>)を引数として渡します。そして、<code>state</code>値の<code>content</code>メソッドを使用したことから返ってきた値を返します。</p>
<!--
We call the `as_ref` method on the `Option` because we want a reference to the
value inside the `Option` rather than ownership of the value. Because `state`
is an `Option<Box<State>>`, when we call `as_ref`, an `Option<&Box<State>>` is
returned. If we didn’t call `as_ref`, we would get an error because we can’t
move `state` out of the borrowed `&self` of the function parameter.
-->
<p><code>Option</code>に対して<code>as_ref</code>メソッドを呼び出します。値の所有権ではなく、<code>Option</code>内部の値への参照が欲しいからです。
<code>state</code>は<code>Option&lt;Box&lt;State&gt;&gt;</code>なので、<code>as_ref</code>を呼び出すと、<code>Option&lt;&amp;Box&lt;State&gt;&gt;</code>が返ってきます。
<code>as_ref</code>を呼ばなければ、<code>state</code>を関数引数の借用した<code>&amp;self</code>からムーブできないので、エラーになるでしょう。</p>
<!--
We then call the `unwrap` method, which we know will never panic, because we
know the methods on `Post` ensure that `state` will always contain a `Some`
value when those methods are done. This is one of the cases we talked about in
the “Cases When You Have More Information Than the Compiler” section of Chapter
9 when we know that a `None` value is never possible, even though the compiler
isn’t able to understand that.
-->
<p>さらに<code>unwrap</code>メソッドを呼び出し、これは絶対にパニックしないことがわかっています。何故なら、
<code>Post</code>のメソッドが、それらのメソッドが完了した際に<code>state</code>は常に<code>Some</code>値を含んでいることを保証するからです。
これは、コンパイラには理解不能であるものの、
<code>None</code>値が絶対にあり得ないとわかる第9章の「コンパイラよりも情報を握っている場合」節で語った一例です。</p>
<!--
At this point, when we call `content` on the `&Box<State>`, deref coercion will
take effect on the `&` and the `Box` so the `content` method will ultimately be
called on the type that implements the `State` trait. That means we need to add
`content` to the `State` trait definition, and that is where we’ll put the
logic for what content to return depending on which state we have, as shown in
Listing 17-18:
-->
<p>この時点で、<code>&amp;Box&lt;State&gt;</code>に対して<code>content</code>を呼び出すと、参照外し型強制が<code>&amp;</code>と<code>Box</code>に働くので、
究極的に<code>content</code>メソッドが<code>State</code>トレイトを実装する型に対して呼び出されることになります。
つまり、<code>content</code>を<code>State</code>トレイト定義に追加する必要があり、そこが現在の状態に応じてどの内容を返すべきかというロジックを配置する場所です。
リスト17-18のようにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String
</span><span class="boring">}
</span>trait State {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
struct Published {}

impl State for Published {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-18: Adding the `content` method to the `State`
trait</span>
-->
<p><span class="caption">リスト17-18: <code>State</code>トレイトに<code>content</code>メソッドを追加する</span></p>
<!--
We add a default implementation for the `content` method that returns an empty
string slice. That means we don’t need to implement `content` on the `Draft`
and `PendingReview` structs. The `Published` struct will override the `content`
method and return the value in `post.content`.
-->
<p>空の文字列スライスを返すデフォルト実装を<code>content</code>メソッドに追加しています。これにより、
<code>Draft</code>と<code>PendingReview</code>構造体に<code>content</code>を実装する必要はありません。<code>Published</code>構造体は、
<code>content</code>メソッドをオーバーライドし、<code>post.content</code>の値を返します。</p>
<!--
Note that we need lifetime annotations on this method, as we discussed in
Chapter 10. We’re taking a reference to a `post` as an argument and returning a
reference to part of that `post`, so the lifetime of the returned reference is
related to the lifetime of the `post` argument.
-->
<p>第10章で議論したように、このメソッドにはライフタイム注釈が必要なことに注意してください。
<code>post</code>への参照を引数として取り、その<code>post</code>の一部への参照を返しているので、
返却される参照のライフタイムは、<code>post</code>引数のライフタイムに関連します。</p>
<!--
And we’re done—all of Listing 17-11 now works! We’ve implemented the state
pattern with the rules of the blog post workflow. The logic related to the
rules lives in the state objects rather than being scattered throughout `Post`.
-->
<p>出来上がりました。要するに、リスト17-11はもう動くようになったのです！ブログ記事ワークフローの規則でステートパターンを実装しました。
その規則に関連するロジックは、<code>Post</code>中に散乱するのではなく、ステートオブジェクトに息づいています。</p>
<!--
### Trade-offs of the State Pattern
-->
<h3 id="ステートパターンの代償"><a class="header" href="#ステートパターンの代償">ステートパターンの代償</a></h3>
<!--
The wayで「・・・の仕方によれば」という意味になるらしい
-->
<!--
We’ve shown that Rust is capable of implementing the object-oriented state
pattern to encapsulate the different kinds of behavior a post should have in
each state. The methods on `Post` know nothing about the various behaviors. The
way we organized the code, we have to look in only one place to know the
different ways a published post can behave: the implementation of the `State`
trait on the `Published` struct.
-->
<p>オブジェクト指向のステートパターンを実装して各状態の時に記事がなり得る異なる種類の振る舞いをカプセル化する能力が、
Rustにあることを示してきました。<code>Post</code>のメソッドは、種々の振る舞いについては何も知りません。
コードを体系化する仕方によれば、公開された記事が振る舞うことのある様々な方法を知るには、1箇所のみを調べればいいのです:
<code>Published</code>構造体の<code>State</code>トレイトの実装です。</p>
<!--
FIX: 5行目末尾がよくわからない。The more ..., the more ...のような感じで訳し文脈には合ってそうだが、合ってる自信がない
つまり、This would only increase, the more states we addedのように訳している
-->
<!--
If we were to create an alternative implementation that didn’t use the state
pattern, we might instead use `match` expressions in the methods on `Post` or
even in the `main` code that checks the state of the post and changes behavior
in those places. That would mean we would have to look in several places to
understand all the implications of a post being in the published state! This
would only increase the more states we added: each of those `match` expressions
would need another arm.
-->
<p>ステートパターンを使用しない対立的な実装を作ることになったら、代わりに<code>Post</code>のメソッドか、
あるいは記事の状態を確認し、それらの箇所(<code>編注</code>: <code>Post</code>のメソッドのことか)の振る舞いを変更する<code>main</code>コードでさえ、
<code>match</code>式を使用したかもしれません。そうなると、複数個所を調べて記事が公開状態にあることの裏の意味全てを理解しなければならなくなります！
これは、追加した状態が増えれば、さらに上がるだけでしょう: 各<code>match</code>式には、別のアームが必要になるのです。</p>
<!--
With the state pattern, the `Post` methods and the places we use `Post` don’t
need `match` expressions, and to add a new state, we would only need to add a
new struct and implement the trait methods on that one struct.
-->
<p>ステートパターンでは、<code>Post</code>のメソッドと<code>Post</code>を使用する箇所で、<code>match</code>式が必要になることはなく、
新しい状態を追加するのにも、新しい構造体を追加し、その1つの構造体にトレイトメソッドを実装するだけでいいわけです。</p>
<!--
The implementation using the state pattern is easy to extend to add more
functionality. To see the simplicity of maintaining code that uses the state
pattern, try a few of these suggestions:
-->
<p>ステートパターンを使用した実装は、拡張して機能を増やすことが容易です。
ステートパターンを使用するコードの管理の単純さを確認するために、以下の提言を試してみてください:</p>
<!--
* Add a `reject` method that changes the post’s state from `PendingReview` back
to `Draft`.
* Require two calls to `approve` before the state can be changed to `Published`.
* Allow users to add text content only when a post is in the `Draft` state.
Hint: have the state object responsible for what might change about the
content but not responsible for modifying the `Post`.
-->
<ul>
<li>記事の状態を<code>PendingReview</code>から<code>Draft</code>に戻す<code>reject</code>メソッドを追加する。</li>
<li>状態が<code>Published</code>に変化させられる前に<code>approve</code>を2回呼び出す必要があるようにする。</li>
<li>記事が<code>Draft</code>状態の時のみテキスト内容をユーザが追加できるようにする。
ヒント: ステートオブジェクトに内容について変わる可能性のあるものの責任を持たせつつも、
<code>Post</code>を変更することには責任を持たせない。</li>
</ul>
<!--
One downside of the state pattern is that, because the states implement the
transitions between states, some of the states are coupled to each other. If we
add another state between `PendingReview` and `Published`, such as `Scheduled`,
we would have to change the code in `PendingReview` to transition to
`Scheduled` instead. It would be less work if `PendingReview` didn’t need to
change with the addition of a new state, but that would mean switching to
another design pattern.
-->
<p>ステートパターンの欠点の1つは、状態が状態間の遷移を実装しているので、状態の一部が密に結合した状態になってしまうことです。
<code>PendingReview</code>と<code>Published</code>の間に、<code>Scheduled</code>のような別の状態を追加したら、
代わりに<code>PendingReview</code>のコードを<code>Scheduled</code>に遷移するように変更しなければならないでしょう。
状態が追加されても<code>PendingReview</code>を変更する必要がなければ、作業が減りますが、
そうすれば別のデザインパターンに切り替えることになるでしょう。</p>
<!--
Another downside is that we’ve duplicated some logic. To eliminate some of the
duplication, we might try to make default implementations for the
`request_review` and `approve` methods on the `State` trait that return `self`;
however, this would violate object safety, because the trait doesn’t know what
the concrete `self` will be exactly. We want to be able to use `State` as a
trait object, so we need its methods to be object safe.
-->
<p>別の欠点は、ロジックの一部を重複させてしまうことです。重複を除くためには、
<code>State</code>トレイトの<code>request_review</code>と<code>approve</code>メソッドに<code>self</code>を返すデフォルト実装を試みる可能性があります;
ですが、これはオブジェクト安全性を侵害するでしょう。というのも、具体的な<code>self</code>が一体なんなのかトレイトには知りようがないからです。
<code>State</code>をトレイトオブジェクトとして使用できるようにしたいので、メソッドにはオブジェクト安全になってもらう必要があるのです。</p>
<!--
Other duplication includes the similar implementations of the `request_review`
and `approve` methods on `Post`. Both methods delegate to the implementation of
the same method on the value in the `state` field of `Option` and set the new
value of the `state` field to the result. If we had a lot of methods on `Post`
that followed this pattern, we might consider defining a macro to eliminate the
repetition (see Appendix D for more on Macros).
-->
<p>他の重複には、<code>Post</code>の<code>request_review</code>と<code>approve</code>メソッドの実装が似ていることが含まれます。
両メソッドは<code>Option</code>の<code>state</code>の値に対する同じメソッドの実装に委譲していて、<code>state</code>フィールドの新しい値を結果にセットします。
このパターンに従う<code>Post</code>のメソッドが多くあれば、マクロを定義して繰り返しを排除することも考慮する可能性があります(マクロについては付録Dを参照)。</p>
<!--
By implementing the state pattern exactly as it’s defined for object-oriented
languages, we’re not taking as full advantage of Rust’s strengths as we could.
Let’s look at some changes we can make to the `blog` crate that can make
invalid states and transitions into compile time errors.
-->
<p>オブジェクト指向言語で定義されている通り忠実にステートパターンを実装することで、
Rustの強みをできるだけ発揮していません。<code>blog</code>クレートに対して行える無効な状態と遷移をコンパイルエラーにできる変更に目を向けましょう。</p>
<!--
#### Encoding States and Behavior as Types
-->
<h4 id="状態と振る舞いを型としてコード化する"><a class="header" href="#状態と振る舞いを型としてコード化する">状態と振る舞いを型としてコード化する</a></h4>
<!--
We’ll show you how to rethink the state pattern to get a different set of
trade-offs. Rather than encapsulating the states and transitions completely so
outside code has no knowledge of them, we’ll encode the states into different
types. Consequently, Rust’s type checking system will prevent attempts to use
draft posts where only published posts are allowed by issuing a compiler error.
-->
<p>ステートパターンを再考して別の代償を得る方法をお見せします。状態と遷移を完全にカプセル化して、
外部のコードに知らせないようにするよりも、状態を異なる型にコード化します。結果的に、
Rustの型検査システムが、公開記事のみが許可される箇所で草稿記事の使用を試みることをコンパイルエラーを発して阻止します。</p>
<!--
Let’s consider the first part of `main` in Listing 17-11:
-->
<p>リスト17-11の<code>main</code>の最初の部分を考えましょう:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
}
</code></pre>
<!--
We still enable the creation of new posts in the draft state using `Post::new`
and the ability to add text to the post’s content. But instead of having a
`content` method on a draft post that returns an empty string, we’ll make it so
draft posts don’t have the `content` method at all. That way, if we try to get
a draft post’s content, we’ll get a compiler error telling us the method
doesn’t exist. As a result, it will be impossible for us to accidentally
display draft post content in production, because that code won’t even compile.
Listing 17-19 shows the definition of a `Post` struct and a `DraftPost` struct,
as well as methods on each:
-->
<p>それでも、<code>Post::new</code>で草稿状態の新しい記事を生成することと記事の内容にテキストを追加する能力は可能にします。
しかし、空の文字列を返す草稿記事の<code>content</code>メソッドを保持する代わりに、草稿記事は、
<code>content</code>メソッドを全く持たないようにします。そうすると、草稿記事の内容を得ようとしたら、
メソッドが存在しないというコンパイルエラーになるでしょう。その結果、
誤ってプロダクションコードで草稿記事の内容を表示することが不可能になります。
そのようなコードは、コンパイルさえできないからです。リスト17-19は<code>Post</code>構造体、<code>DraftPost</code>構造体、
さらにメソッドの定義を示しています:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-19: A `Post` with a `content` method and a
`DraftPost` without a `content` method</span>
-->
<p><span class="caption">リスト17-19: <code>content</code>メソッドのある<code>Post</code>と<code>content</code>メソッドのない<code>DraftPost</code></span></p>
<!--
Both the `Post` and `DraftPost` structs have a private `content` field that
stores the blog post text. The structs no longer have the `state` field because
we’re moving the encoding of the state to the types of the structs. The `Post`
struct will represent a published post, and it has a `content` method that
returns the `content`.
-->
<p><code>Post</code>と<code>DraftPost</code>構造体どちらにもブログ記事のテキストを格納する非公開の<code>content</code>フィールドがあります。
状態のコード化を構造体の型に移動したので、この構造体は最早<code>state</code>フィールドを持ちません。
<code>Post</code>は公開された記事を表し、<code>content</code>を返す<code>content</code>メソッドがあります。</p>
<!--
We still have a `Post::new` function, but instead of returning an instance of
`Post`, it returns an instance of `DraftPost`. Because `content` is private
and there aren’t any functions that return `Post`, it’s not possible to create
an instance of `Post` right now.
-->
<p>それでも<code>Post::new</code>関数はありますが、<code>Post</code>のインスタンスを返すのではなく、<code>DraftPost</code>のインスタンスを返します。
<code>content</code>は非公開であり、<code>Post</code>を返す関数も存在しないので、現状<code>Post</code>のインスタンスを生成することは不可能です。</p>
<!--
The `DraftPost` struct has an `add_text` method, so we can add text to
`content` as before, but note that `DraftPost` does not have a `content` method
defined! So now the program ensures all posts start as draft posts, and draft
posts don’t have their content available for display. Any attempt to get around
these constraints will result in a compiler error.
-->
<p><code>DraftPost</code>構造体には、以前のようにテキストを<code>content</code>に追加できるよう<code>add_text</code>メソッドがありますが、
<code>DraftPost</code>には<code>content</code>メソッドが定義されていないことに注目してください！
従って、これでプログラムは、全ての記事が草稿記事から始まり、草稿記事は表示できる内容がないことを保証します。
この制限をかいくぐる試みは、全てコンパイルエラーに落ち着くでしょう。</p>
<!--
#### Implementing Transitions as Transformations into Different Types
-->
<h4 id="遷移を異なる型への変形として実装する"><a class="header" href="#遷移を異なる型への変形として実装する">遷移を異なる型への変形として実装する</a></h4>
<!--
1行目the rule thatは同格で訳しているが、the rule that a draft post has (the rule) to be...でも意味は通りそう
-->
<!--
So how do we get a published post? We want to enforce the rule that a draft
post has to be reviewed and approved before it can be published. A post in the
pending review state should still not display any content. Let’s implement
these constraints by adding another struct, `PendingReviewPost`, defining the
`request_review` method on `DraftPost` to return a `PendingReviewPost`, and
defining an `approve` method on `PendingReviewPost` to return a `Post`, as
shown in Listing 17-20:
-->
<p>では、どうやって公開された記事を得るのでしょうか？公開される前に草稿記事は査読され、
承認されなければならないという規則を強制したいです。査読待ち状態の記事は、それでも内容を表示するべきではありません。
別の構造体<code>PendingReviewPost</code>を追加し、<code>DraftPost</code>に<code>PendingReviewPost</code>を返す<code>request_review</code>メソッドを定義し、
<code>PendingReviewPost</code>に<code>Post</code>を返す<code>approve</code>メソッドを定義してこれらの制限を実装しましょう。リスト17-20のようにですね:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--

    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 17-20: A `PendingReviewPost` that gets created by
calling `request_review` on `DraftPost` and an `approve` method that turns a
`PendingReviewPost` into a published `Post`</span>
-->
<p><span class="caption">リスト17-20: <code>DraftPost</code>の<code>request_review</code>を呼び出すことで生成される<code>PendingReviewPost</code>と、
<code>PendingReviewPost</code>を公開された<code>Post</code>に変換する<code>approve</code>メソッド</span></p>
<!--
The `request_review` and `approve` methods take ownership of `self`, thus
consuming the `DraftPost` and `PendingReviewPost` instances and transforming
them into a `PendingReviewPost` and a published `Post`, respectively. This way,
we won’t have any lingering `DraftPost` instances after we’ve called
`request_review` on them, and so forth. The `PendingReviewPost` struct doesn’t
have a `content` method defined on it, so attempting to read its content
results in a compiler error, as with `DraftPost`. Because the only way to get a
published `Post` instance that does have a `content` method defined is to call
the `approve` method on a `PendingReviewPost`, and the only way to get a
`PendingReviewPost` is to call the `request_review` method on a `DraftPost`,
we’ve now encoded the blog post workflow into the type system.
-->
<p><code>request_review</code>と<code>approve</code>メソッドは<code>self</code>の所有権を奪い、故に<code>DraftPost</code>と<code>PendingReviewPost</code>インスタンスを消費し、
それぞれ<code>PendingReviewPost</code>と公開された<code>Post</code>に変形します。このように、
<code>DraftPost</code>インスタンスに<code>request_review</code>を呼んだ後には、<code>DraftPost</code>インスタンスは生きながらえず、
以下同様です。<code>PendingReviewPost</code>構造体には、<code>content</code>メソッドが定義されていないので、
<code>DraftPost</code>同様に、その内容を読もうとするとコンパイルエラーに落ち着きます。
<code>content</code>メソッドが確かに定義された公開された<code>Post</code>インスタンスを得る唯一の方法が、
<code>PendingReviewPost</code>に対して<code>approve</code>を呼び出すことであり、<code>PendingReviewPost</code>を得る唯一の方法が、
<code>DraftPost</code>に<code>request_review</code>を呼び出すことなので、これでブログ記事のワークフローを型システムにコード化しました。</p>
<!--
But we also have to make some small changes to `main`. The `request_review` and
`approve` methods return new instances rather than modifying the struct they’re
called on, so we need to add more `let post =` shadowing assignments to save
the returned instances. We also can’t have the assertions about the draft and
pending review post’s contents be empty strings, nor do we need them: we can’t
compile code that tries to use the content of posts in those states any longer.
The updated code in `main` is shown in Listing 17-21:
-->
<p>ですが、さらに<code>main</code>にも多少小さな変更を行わなければなりません。<code>request_review</code>と<code>approve</code>メソッドは、
呼ばれた構造体を変更するのではなく、新しいインスタンスを返すので、<code>let post =</code>というシャドーイング代入をもっと追加し、
返却されたインスタンスを保存する必要があります。また、草稿と査読待ち記事の内容を空の文字列でアサートすることも、
する必要もありません: 最早、その状態にある記事の内容を使用しようとするコードはコンパイル不可能だからです。
<code>main</code>の更新されたコードは、リスト17-21に示されています:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate blog;
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<!--
<span class="caption">Listing 17-21: Modifications to `main` to use the new
implementation of the blog post workflow</span>
-->
<p><span class="caption">リスト17-21: ブログ記事ワークフローの新しい実装を使う<code>main</code>の変更</span></p>
<!--
The changes we needed to make to `main` to reassign `post` mean that this
implementation doesn’t quite follow the object-oriented state pattern anymore:
the transformations between the states are no longer encapsulated entirely
within the `Post` implementation. However, our gain is that invalid states are
now impossible because of the type system and the type checking that happens at
compile time! This ensures that certain bugs, such as display of the content of
an unpublished post, will be discovered before they make it to production.
-->
<p><code>post</code>を再代入するために<code>main</code>に行う必要のあった変更は、この実装がもう、
全くオブジェクト指向のステートパターンに沿っていないことを意味します: 
状態間の変形は最早、<code>Post</code>実装内に完全にカプセル化されていません。
ですが、型システムとコンパイル時に起きる型チェックのおかげでもう無効な状態があり得なくなりました。
これにより、未公開の記事の内容が表示されるなどの特定のバグが、プロダクションコードに移る前に発見されることが保証されます。</p>
<!--
特に2行目中盤、as it is afterがよくわからない
as it is, afterで訳した
-->
<!--
Try the tasks suggested for additional requirements that we mentioned at the
start of this section on the `blog` crate as it is after Listing 17-20 to see
what you think about the design of this version of the code. Note that some of
the tasks might be completed already in this design.
-->
<p><code>blog</code>クレートに関してこの節の冒頭で触れた追加の要求に提言される作業をそのままリスト17-20の後に試してみて、
このバージョンのコードについてどう思うか確かめてください。この設計では、
既に作業の一部が達成されている可能性があることに注意してください。</p>
<!--
We’ve seen that even though Rust is capable of implementing object-oriented
design patterns, other patterns, such as encoding state into the type system,
are also available in Rust. These patterns have different trade-offs. Although
you might be very familiar with object-oriented patterns, rethinking the
problem to take advantage of Rust’s features can provide benefits, such as
preventing some bugs at compile time. Object-oriented patterns won’t always be
the best solution in Rust due to certain features, like ownership, that
object-oriented languages don’t have.
-->
<p>Rustは、オブジェクト指向のデザインパターンを実装する能力があるものの、状態を型システムにコード化するなどの他のパターンも、
Rustでは利用可能なことを確かめました。これらのパターンには、異なる代償があります。
あなたが、オブジェクト指向のパターンには非常に馴染み深い可能性があるものの、問題を再考してRustの機能の強みを活かすと、
コンパイル時に一部のバグを回避できるなどの利益が得られることもあります。オブジェクト指向のパターンは、
オブジェクト指向言語にはない所有権などの特定の機能によりRustでは、必ずしも最善の解決策ではないでしょう。</p>
<!--
## Summary
-->
<h2 id="まとめ-16"><a class="header" href="#まとめ-16">まとめ</a></h2>
<!--
No matter whether or not you think Rust is an object-oriented language after
reading this chapter, you now know that you can use trait objects to get some
object-oriented features in Rust. Dynamic dispatch can give your code some
flexibility in exchange for a bit of runtime performance. You can use this
flexibility to implement object-oriented patterns that can help your code’s
maintainability. Rust also has other features, like ownership, that
object-oriented languages don’t have. An object-oriented pattern won’t always
be the best way to take advantage of Rust’s strengths, but is an available
option.
-->
<p>この章読了後に、あなたがRustはオブジェクト指向言語であると考えるかどうかに関わらず、
もうトレイトオブジェクトを使用してRustでオブジェクト指向の機能の一部を得ることができると知っています。
ダイナミックディスパッチは、多少の実行時性能と引き換えにコードに柔軟性を<ruby>齎<rp>(</rp><rt>もたら</rt><rp>)</rp></ruby>してくれます。
この柔軟性を利用してコードのメンテナンス性に寄与するオブジェクト指向パターンを実装することができます。
Rustにはまた、オブジェクト指向言語にはない所有権などの他の機能もあります。オブジェクト指向パターンは、
必ずしもRustの強みを活かす最善の方法にはなりませんが、利用可能な選択肢の1つではあります。</p>
<!--
Next, we’ll look at patterns, which are another of Rust’s features that enable
lots of flexibility. We’ve looked at them briefly throughout the book but
haven’t seen their full capability yet. Let’s go!
-->
<p>次は、パターンを見ます。パターンも多くの柔軟性を可能にするRustの別の機能です。
本全体を通して僅かに見かけましたが、まだその全能力は目の当たりにしていません。さあ、行きましょう！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Patterns and Matching
-->
<h1 id="パターンとマッチング"><a class="header" href="#パターンとマッチング">パターンとマッチング</a></h1>
<!--
Patterns are a special syntax in Rust for matching against the structure of
types, both complex and simple. Using patterns in conjunction with `match`
expressions and other constructs gives you more control over a program’s
control flow. A pattern consists of some combination of the following:
-->
<p>パターンは、複雑であれ、単純であれ、Rustで型の構造に一致する特別な記法です。<code>match</code>式や他の構文と組み合わせてパターンを使用すると、
プログラムの制御フローをよりコントロールできます。パターンは、以下を組み合わせることで構成されます:</p>
<!--
* Literals
* Destructured arrays, enums, structs, or tuples
* Variables
* Wildcards
* Placeholders
-->
<ul>
<li>リテラル</li>
<li>分配された配列、enum、構造体、タプル</li>
<li>変数</li>
<li>ワイルドカード</li>
<li>プレースホルダー</li>
</ul>
<!--
These components describe the shape of the data we’re working with, which we
then match against values to determine whether our program has the correct data
to continue running a particular piece of code.
-->
<p>これらの要素が取り組んでいるデータの形を説明し、それから値に対してマッチを行い、
プログラムに正しい値があって特定のコードを実行し続けられるかどうかを決定します。</p>
<!--
To use a pattern, we compare it to some value. If the pattern matches the
value, we use the value parts in our code. Recall the `match` expressions in
Chapter 6 that used patterns, such as the coin-sorting machine example. If the
value fits the shape of the pattern, we can use the named pieces. If it
doesn’t, the code associated with the pattern won’t run.
-->
<p>パターンを使用するには、なんらかの値と比較します。パターンが値に合致したら、コードで値の部分を使用します。
コイン並び替えマシンの例のような第6章でパターンを使用した<code>match</code>式を思い出してください。
値がパターンの形に当てはまったら、名前のある部品を使用できます。当てはまらなければ、
パターンに紐づいたコードは実行されません。</p>
<!--
This chapter is a reference on all things related to patterns. We’ll cover the
valid places to use patterns, the difference between refutable and irrefutable
patterns, and the different kinds of pattern syntax that you might see. By the
end of the chapter, you’ll know how to use patterns to express many concepts in
a clear way.
-->
<p>この章は、パターンに関連するあらゆるものの参考文献です。パターンを使用するのが合法な箇所、
<ruby>論駁<rp>(</rp><rt>ろんばく</rt><rp>)</rp></ruby>可能と論駁不可能なパターンの違い、
目撃する可能性のある色々な種類のパターン記法を講義します。章の終わりまでに、
パターンを使用して多くの概念をはっきり表現する方法を知るでしょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## All the Places Patterns Can Be Used
-->
<h2 id="パターンが使用されることのある箇所全部"><a class="header" href="#パターンが使用されることのある箇所全部">パターンが使用されることのある箇所全部</a></h2>
<!--
Patterns pop up in a number of places in Rust, and you’ve been using them a lot
without realizing it! This section dicusses all the places where patterns are
valid.
-->
<p>Rustにおいて、パターンはいろんな箇所に出現し、そうと気づかないうちにたくさん使用してきました！
この節は、パターンが合法な箇所全部を議論します。</p>
<!--
### `match` Arms
-->
<h3 id="matchアーム"><a class="header" href="#matchアーム"><code>match</code>アーム</a></h3>
<!--
As discussed in Chapter 6, we use patterns in the arms of `match` expressions.
Formally, `match` expressions are defined as the keyword `match`, a value to
match on, and one or more match arms that consist of a pattern and an
expression to run if the value matches that arm’s pattern, like this:
-->
<p>第6章で議論したように、パターンを<code>match</code>式のアームで使います。正式には、<code>match</code>式はキーワード<code>match</code>、
マッチ対象の値、パターンとそのアームのパターンに値が合致したら実行される式からなる1つ以上のマッチアームとして定義されます。
以下のように:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<!--
One requirement for `match` expressions is that they need to be *exhaustive* in
the sense that all possibilities for the value in the `match` expression must
be accounted for. One way to ensure you’ve covered every possibility is to have
a catchall pattern for the last arm: for example, a variable name matching any
value can never fail and thus covers every remaining case.
-->
<p><code>match</code>式の必須事項の1つは、<code>match</code>式の値の可能性全てが考慮されなければならないという意味で<em>網羅的</em>である必要があることです。
全可能性をカバーしていると保証する1つの手段は、最後のアームに包括的なパターンを入れることです:
例えば、どんな値にも合致する変数名は失敗することがあり得ないので、故に残りの全ケースをカバーできます。</p>
<!--
A particular pattern `_` will match anything, but it never binds to a variable,
so it’s often used in the last match arm. The `_` pattern can be useful when
you want to ignore any value not specified, for example. We’ll cover the `_`
pattern in more detail in the “Ignoring Values in a Pattern” section later in
this chapter.
-->
<p><code>_</code>という特定のパターンは何にでもマッチしますが、変数には束縛されないので、よく最後のマッチアームに使用されます。
例えば、<code>_</code>パターンは、指定されていないあらゆる値を無視したい時に有用です。
<code>_</code>パターンについて詳しくは、この章の後ほど、「パターンで値を無視する」節で講義します。</p>
<!--
### Conditional `if let` Expressions
-->
<h3 id="条件分岐if-let式"><a class="header" href="#条件分岐if-let式">条件分岐<code>if let</code>式</a></h3>
<!--
In Chapter 6 we discussed how to use `if let` expressions mainly as a shorter
way to write the equivalent of a `match` that only matches one case.
Optionally, `if let` can have a corresponding `else` containing code to run if
the pattern in the `if let` doesn’t match.
-->
<p>第6章で主に<code>if let</code>式を1つの場合にしか合致しない<code>match</code>と同様のものを書く省略法として使用する方法を議論しました。
オプションとして、<code>if let</code>には<code>if let</code>のパターンが合致しない時に走るコードを含む対応する<code>else</code>も用意できます。</p>
<!--
Listing 18-1 shows that it’s also possible to mix and match `if let`, `else
if`, and `else if let` expressions. Doing so gives us more flexibility than a
`match` expression in which we can only express one value to compare with the
patterns. Also, the conditions in a series of `if let`, `else if`, `else if
let` arms aren’t required to relate to each other.
-->
<p>リスト18-1は、<code>if let</code>、<code>else if</code>、<code>else if let</code>式を混ぜてマッチさせることもできることを示しています。
そうすると、パターンと1つの値しか比較することを表現できない<code>match</code>式よりも柔軟性が高くなります。
また、一連の<code>if let</code>、<code>else if</code>、<code>else if let</code>アームの条件は、お互いに関連している必要はありません。</p>
<!--
The code in Listing 18-1 shows a series of checks for several conditions that
decide what the background color should be. For this example, we've created
variables with hardcoded values that a real program might receive from user
input.
-->
<p>リスト18-1のコードは、背景色が何になるべきかを決定するいくつかの条件を連なって確認するところを示しています。
この例では、実際のプログラムではユーザ入力を受け付ける可能性のある変数をハードコードされた値で生成しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        // あなたのお気に入りの色、{}を背景色に使用します
        println!(&quot;Using your favorite color, {}, as the background&quot;, color);
    } else if is_tuesday {
        // 火曜日は緑の日！
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            // 紫を背景色に使用します
            println!(&quot;Using purple as the background color&quot;);
        } else {
            // オレンジを背景色に使用します
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        // 青を背景色に使用します
        println!(&quot;Using blue as the background color&quot;);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-1: Mixing `if let`, `else if`, `else if let`,
and `else`</span>
-->
<p><span class="caption">リスト18-1: <code>if let</code>、<code>else if</code>、<code>else if let</code>、<code>else</code>を混ぜる</span></p>
<!--
If the user specifies a favorite color, that color is the background color. If
today is Tuesday, the background color is green. If the user specifies
their age as a string and we can parse it as a number successfully, the color
is either purple or orange depending on the value of the number. If none of
these conditions apply, the background color is blue:
-->
<p>ユーザがお気に入りの色を指定したら、その色が背景色になります。今日が火曜日なら、背景色は緑です。
ユーザが年齢を文字列で指定し、数値として解析することができたら、背景色は、その数値の値によって紫かオレンジになります。
どの条件も適用できなければ、背景色は青になります:</p>
<!--
This conditional structure lets us support complex requirements. With the
hardcoded values we have here, this example will print `Using purple as the
background color`.
-->
<p>この条件分岐構造により、複雑な要件をサポートさせてくれます。ここにあるハードコードされた値では、
この例は<code>Using purple as the background color</code>と出力するでしょう。</p>
<!--
You can see that `if let` can also introduce shadowed variables in the same way
that `match` arms can: the line `if let Ok(age) = age` introduces a new
shadowed `age` variable that contains the value inside the `Ok` variant. This
means we need to place the `if age > 30` condition within that block: we can’t
combine these two conditions into `if let Ok(age) = age && age > 30`. The
shadowed `age` we want to compare to 30 isn’t valid until the new scope starts
with the curly bracket.
-->
<p><code>match</code>アームのように<code>if let</code>もシャドーイングされた変数を導入できることがわかります:
<code>if let Ok(age) = age</code>の行は、<code>Ok</code>列挙子の中の値を含むシャドーイングされた新しい<code>age</code>変数を導入します。
つまり、<code>if age &gt; 30</code>という条件は、そのブロック内に配置する必要があります: これら2つの条件を組み合わせて、
<code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>とすることはできません。30と比較したいシャドーイングされた<code>age</code>は、
波括弧で新しいスコープが始まるまで有効にならないのです。</p>
<!--
The downside of using `if let` expressions is that the compiler doesn’t check
exhaustiveness, whereas with `match` expressions it does. If we omitted the
last `else` block and therefore missed handling some cases, the compiler would
not alert us to the possible logic bug.
-->
<p><code>if let</code>式を使うことの欠点は、コンパイラが網羅性を確認してくれないことです。一方で<code>match</code>式ではしてくれます。
最後の<code>else</code>ブロックを省略して故に、扱い忘れたケースがあっても、コンパイラは、ロジックバグの可能性を指摘してくれないでしょう。</p>
<!--
### `while let` Conditional Loops
-->
<h3 id="while-let条件分岐ループ"><a class="header" href="#while-let条件分岐ループ"><code>while let</code>条件分岐ループ</a></h3>
<!--
Similar in construction to `if let`, the `while let` conditional loop allows a
`while` loop to run for as long as a pattern continues to match. The example in
Listing 18-2 shows a `while let` loop that uses a vector as a stack and prints
the values in the vector in the opposite order in which they were pushed:
-->
<p><code>if let</code>と構成が似て、<code>while let</code>条件分岐ループは、パターンが合致し続ける限り、<code>while</code>ループを走らせます。
リスト18-2の例は、ベクタをスタックとして使用する<code>while let</code>ループを示し、
ベクタの値をプッシュしたのとは逆順に出力します:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
    println!(&quot;{}&quot;, top);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-2: Using a `while let` loop to print values
for as long as `stack.pop()` returns `Some`</span>
-->
<p><span class="caption">リスト18-2: <code>while let</code>ループを使って<code>stack.pop()</code>が<code>Some</code>を返す限り値を出力する</span></p>
<!--
This example prints 3, 2, and then 1. The `pop` method takes the last element
out of the vector and returns `Some(value)`. If the vector is empty, `pop`
returns `None`. The `while` loop continues running the code in its block as
long as `pop` returns `Some`. When `pop` returns `None`, the loop stops. We can
use `while let` to pop every element off our stack.
-->
<p>この例は、3, 2, そして1と出力します。<code>pop</code>メソッドはベクタの最後の要素を取り出して<code>Some(value)</code>を返します。
ベクタが空なら、<code>pop</code>は<code>None</code>を返します。<code>while</code>ループは<code>pop</code>が<code>Some</code>を返す限り、ブロックのコードを実行し続けます。
<code>pop</code>が<code>None</code>を返すと、ループは停止します。<code>while let</code>を使用してスタックから全ての要素を取り出せるのです。</p>
<!--
### `for` Loops
-->
<h3 id="forループ"><a class="header" href="#forループ"><code>for</code>ループ</a></h3>
<!--
In Chapter 3, we mentioned that the `for` loop is the most common loop
construction in Rust code, but we haven’t yet discussed the pattern that `for`
takes. In a `for` loop, the pattern is the value that directly follows the
keyword `for`, so in `for x in y` the `x` is the pattern.
-->
<p>第3章で、Rustコードにおいては、<code>for</code>ループが最もありふれたループ構造だと述べましたが、
<code>for</code>が取るパターンについてはまだ議論していませんでした。<code>for</code>ループにおいて、
直接キーワード<code>for</code>に続く値がパターンなので、<code>for x in y</code>では、<code>x</code>がパターンになります。</p>
<!--
Listing 18-3 demonstrates how to use a pattern in a `for` loop to destructure,
or break apart, a tuple as part of the `for` loop.
-->
<p>リスト18-3は<code>for</code>ループでパターンを使用して<code>for</code>ループの一部としてタプルを分配あるいは、分解する方法をデモしています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!(&quot;{} is at index {}&quot;, value, index);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-3: Using a pattern in a `for` loop to
destructure a tuple</span>
-->
<p><span class="caption">リスト18-3: <code>for</code>ループでパターンを使用してタプルを分配する</span></p>
<!--
The code in Listing 18-3 will print the following:
-->
<p>リスト18-3のコードは、以下のように出力するでしょう:</p>
<pre><code class="language-text">a is at index 0
b is at index 1
c is at index 2
</code></pre>
<!--
We use the `enumerate` method to adapt an iterator to produce a value and that
value’s index in the iterator, placed into a tuple. The first call to
`enumerate` produces the tuple `(0, 'a')`. When this value is matched to the
pattern `(index, value)`, `index` will be `0` and `value` will be `'a'`,
printing the first line of the output.
-->
<p><code>enumerate</code>メソッドを使用してイテレータを改造し、値とその値のイテレータでの添え字をタプルに配置して生成しています。
<code>enumerate</code>の最初の呼び出しは、タプル<code>(0, 'a')</code>を生成します。この値がパターン<code>(index, value)</code>とマッチさせられると、
<code>index</code>は<code>0</code>、<code>value</code>は<code>'a'</code>になり、出力の最初の行を出力するのです。</p>
<!--
### `let` Statements
-->
<h3 id="let文"><a class="header" href="#let文"><code>let</code>文</a></h3>
<!--
Prior to this chapter, we had only explicitly discussed using patterns with
`match` and `if let`, but in fact, we’ve used patterns in other places as well,
including in `let` statements. For example, consider this straightforward
variable assignment with `let`:
-->
<p>この章に先駆けて、<code>match</code>と<code>if let</code>でパターンを使用することだけ明示的に議論してきましたが、
実は<code>let</code>文を含む他の箇所でもパターンを使用してきたのです。例として、この<code>let</code>での率直な変数代入を考えてください:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<!--
Throughout this book, we’ve used `let` like this hundreds of times, and
although you might not have realized it, you were using patterns! More
formally, a `let` statement looks like this:
-->
<p>この本を通してこのような<code>let</code>を何百回も使用してきて、お気付きではなかったかもしれませんが、
パターンを使用していたのです！より正式には、<code>let</code>文はこんな見た目をしています:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<!--
In statements like `let x = 5;` with a variable name in the `PATTERN` slot, the
variable name is just a particularly simple form of a pattern. Rust compares
the expression against the pattern and assigns any names it finds. So in the
`let x = 5;` example, `x` is a pattern that means “bind what matches here to
the variable `x`.” Because the name `x` is the whole pattern, this pattern
effectively means “bind everything to the variable `x`, whatever the value is.”
-->
<p><code>let x = 5;</code>のような変数名が<code>PATTERN</code>スロットにある文で、変数名は、ただ特に単純な形態のパターンなのです。
Rustは式をパターンと比較し、見つかったあらゆる名前を代入します。故に、<code>let x = 5;</code>の例では、
<code>x</code>は「ここでマッチしたものを変数<code>x</code>に束縛する」ことを意味するパターンです。
名前<code>x</code>がパターンの全容なので、このパターンは実質的に「値が何であれ、全てを変数<code>x</code>に束縛しろ」を意味します。</p>
<!--
To see the pattern matching aspect of `let` more clearly, consider Listing
18-4, which uses a pattern with `let` to destructure a tuple.
-->
<p><code>let</code>のパターンマッチングの観点をよりはっきり確認するためにリスト18-4を考えてください。
これは<code>let</code>でパターンを使用し、タプルを分配します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (x, y, z) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-4: Using a pattern to destructure a tuple and
create three variables at once</span>
-->
<p><span class="caption">リスト18-4: パターンを使用してタプルを分配し、3つの変数を一度に生成する</span></p>
<!--
Here, we match a tuple against a pattern. Rust compares the value `(1, 2, 3)`
to the pattern `(x, y, z)` and sees that the value matches the pattern, so Rust
binds `1` to `x`, `2` to `y`, and `3` to `z`. You can think of this tuple
pattern as nesting three individual variable patterns inside it.
-->
<p>ここでタプルに対してパターンをマッチさせています。Rustは値<code>(1, 2, 3)</code>をパターン<code>(x, y, z)</code>と比較し、
値がパターンに合致すると確認するので、<code>1</code>を<code>x</code>に、<code>2</code>を<code>y</code>に、<code>3</code>を<code>z</code>に束縛します。
このタプルパターンを個別の3つの変数パターンが内部にネストされていると考えることもできます。</p>
<!--
If the number of elements in the pattern doesn’t match the number of elements
in the tuple, the overall type won’t match and we’ll get a compiler error. For
example, Listing 18-5 shows an attempt to destructure a tuple with three
elements into two variables, which won’t work.
-->
<p>パターンの要素数がタプルの要素数と一致しない場合、全体の型が一致せず、コンパイルエラーになるでしょう。
例えば、リスト18-5は、3要素のタプルを2つの変数に分配しようとしているところを表示していて、動きません。</p>
<pre><code class="language-rust ignore">let (x, y) = (1, 2, 3);
</code></pre>
<!--
<span class="caption">Listing 18-5: Incorrectly constructing a pattern whose
variables don’t match the number of elements in the tuple</span>
-->
<p><span class="caption">リスト18-5: 変数がタプルの要素数と一致しないパターンを間違って構成する</span></p>
<!--
Attempting to compile this code results in this type error:
-->
<p>このコードのコンパイルを試みると、このような型エラーに落ち着きます:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |                (3要素のタプルを予期したのに、2要素のタプルが見つかりました)
  |
  = note: expected type `({integer}, {integer}, {integer})`
             found type `(_, _)`
</code></pre>
<!--
If we wanted to ignore one or more of the values in the tuple, we could use `_`
or `..`, as you’ll see in the “Ignoring Values in a Pattern” section. If the
problem is that we have too many variables in the pattern, the solution is to
make the types match by removing variables so the number of variables equals
the number of elements in the tuple.
-->
<p>タプルの値のうち1つ以上を無視したかったら、「パターンで値を無視する」節で見かけるように、
<code>_</code>か<code>..</code>を使用できるでしょう。パターンに変数が多すぎるというのが問題なら、変数の数がタプルの要素数と一致するように変数を減らすことで、
型を一致させることが解決策です。</p>
<!--
### Function Parameters
-->
<h3 id="関数の引数-1"><a class="header" href="#関数の引数-1">関数の引数</a></h3>
<!--
Function parameters can also be patterns. The code in Listing 18-6, which
declares a function named `foo` that takes one parameter named `x` of type
`i32`, should by now look familiar.
-->
<p>関数の引数もパターンにできます。リスト18-6のコードは、型<code>i32</code>の<code>x</code>という引数1つを取る<code>foo</code>という関数を宣言していますが、
これまでに馴染み深くなっているはずです。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: i32) {
    // コードがここに来る
    // code goes here
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-6: A function signature uses patterns in the
parameters</span>
-->
<p><span class="caption">リスト18-6: 関数シグニチャが引数にパターンを使用している</span></p>
<!--
The `x` part is a pattern! As we did with `let`, we could match a tuple in a
function’s arguments to the pattern. Listing 18-7 splits the values in a tuple
as we pass it to a function.
-->
<p><code>x</code>の部分がパターンです！<code>let</code>のように、関数の引数でパターンにタプルを合致させられるでしょう。
リスト18-7では、タプルを関数に渡したのでその中の値を分離しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    // 現在の位置: ({}, {})
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-7: A function with parameters that destructure
a tuple</span>
-->
<p><span class="caption">リスト18-7: タプルを分配する引数を伴う関数</span></p>
<!--
This code prints `Current location: (3, 5)`. The values `&(3, 5)` match the
pattern `&(x, y)`, so `x` is the value `3` and `y` is the value `5`.
-->
<p>このコードは<code>Current location: (3, 5)</code>と出力します。値<code>&amp;(3, 5)</code>はパターン<code>&amp;(x, y)</code>と合致するので、
<code>x</code>は値<code>3</code>、<code>y</code>は値<code>5</code>になります。</p>
<!--
We can also use patterns in closure parameter lists in the same way as in
function parameter lists, because closures are similar to functions, as
discussed in Chapter 13.
-->
<p>また、クロージャの引数リストでも、関数の引数リストのようにパターンを使用することができます。
第13章で議論したように、クロージャは関数に似ているからです。</p>
<!--
At this point, you’ve seen several ways of using patterns, but patterns don’t
work the same in every place we can use them. In some places, the patterns must
be irrefutable; In other circumstances, they can be refutable. We'll discuss
these two concepts next.
-->
<p>この時点で、パターンを使用する方法をいくつか見てきましたが、パターンを使用できる箇所全部で同じ動作をするわけではありません。
パターンが論駁不可能でなければならない箇所もあります。他の状況では、論駁可能にもなり得ます。この2つの概念を次に議論します。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Refutability: Whether a Pattern Might Fail to Match
-->
<h2 id="論駁可能性-パターンが合致しないかどうか"><a class="header" href="#論駁可能性-パターンが合致しないかどうか">論駁可能性: パターンが合致しないかどうか</a></h2>
<!--
Patterns come in two forms: refutable and irrefutable. Patterns that will match
for any possible value passed are *irrefutable*. An example would be `x` in the
statement `let x = 5;` because `x` matches anything and therefore cannot fail
to match. Patterns that can fail to match for some possible value are
*refutable*. An example would be `Some(x)` in the expression `if let Some(x) =
a_value`; because if the value in `a_value` variable is `None` rather than
`Some`, the `Some(x)` pattern will not match.
-->
<p>パターンには2つの形態があります: 論駁可能なものと論駁不可能なものです。渡される可能性のあるあらゆる値に合致するパターンは、
<em>論駁不可能</em>なものです。文<code>let x = 5;</code>の<code>x</code>は一例でしょう。<code>x</code>は何にでも合致し、故に合致に失敗することがあり得ないからです。
なんらかの可能性のある値に対して合致しないことがあるパターンは、<em>論駁可能</em>なものです。
一例は、式<code>if let Some(x) = a_value</code>の<code>Some(x)</code>になるでしょう; <code>a_value</code>変数の値が<code>Some</code>ではなく、
<code>None</code>なら、<code>Some(x)</code>パターンは合致しないでしょうから。</p>
<!--
Function parameters, `let` statements, and `for` loops can only accept
irrefutable patterns, because the program cannot do anything meaningful when
values don’t match. The `if let` and `while let` expressions only accept
refutable patterns, because by definition they’re intended to handle possible
failure: the functionality of a conditional is in its ability to perform
differently depending on success or failure.
-->
<p>関数の引数、<code>let</code>文、<code>for</code>ループは、値が合致しなかったら何も意味のあることをプログラムが実行できないので、
論駁不可能なパターンしか受け付けられません。<code>if let</code>と<code>while let</code>式は、定義により失敗する可能性を処理することを意図したものなので、
論駁可能なパターンのみを受け付けます: 条件式の機能は、成功か失敗によって異なる振る舞いをする能力にあるのです。</p>
<!--
In general, you shouldn’t have to worry about the distinction between refutable
and irrefutable patterns; however, you do need to be familiar with the concept
of refutability so you can respond when you see it in an error message. In
those cases, you’ll need to change either the pattern or the construct you’re
using the pattern with, depending on the intended behavior of the code.
-->
<p>一般的に、論駁可能と論駁不可能なパターンの差異について心配しなくてもいいはずです; しかしながら、
エラーメッセージで見かけた際に対応できるように、論駁可能性の概念に確かに慣れておく必要があります。
そのような場合には、コードの意図した振る舞いに応じて、パターンかパターンを使用している構文を変える必要があるでしょう。</p>
<!--
Let’s look at an example of what happens when we try to use a refutable pattern
where Rust requires an irrefutable pattern and vice versa. Listing 18-8 shows a
`let` statement, but for the pattern we’ve specified `Some(x)`, a refutable
pattern. As you might expect, this code will not compile.
-->
<p>コンパイラが論駁不可能なパターンを必要とする箇所で論駁可能なパターンを使用しようとしたら、何が起きるかとその逆の例を見ましょう。
リスト18-8は<code>let</code>文を示していますが、パターンには<code>Some(x)</code>と指定し、論駁可能なパターンです。
ご想像通りかもしれませんが、このコードはコンパイルできません。</p>
<pre><code class="language-rust ignore">let Some(x) = some_option_value;
</code></pre>
<!--
<span class="caption">Listing 18-8: Attempting to use a refutable pattern with
`let`</span>
-->
<p><span class="caption">リスト18-8: <code>let</code>で論駁可能なパターンを使用しようとする</span></p>
<!--
If `some_option_value` was a `None` value, it would fail to match the pattern
`Some(x)`, meaning the pattern is refutable. However, the `let` statement can
only accept an irrefutable pattern because there is nothing valid the code can
do with a `None` value. At compile time, Rust will complain that we’ve tried to
use a refutable pattern where an irrefutable pattern is required:
-->
<p><code>some_option_value</code>が<code>None</code>値だったなら、パターン<code>Some(x)</code>に合致しないことになり、パターンが論駁可能であることを意味します。
ですが、<code>let</code>文は論駁不可能なパターンしか受け付けられません。<code>None</code>値に対してコードができる合法なことは何もないからです。
コンパイル時にコンパイラは、論駁不可能なパターンが必要な箇所に論駁可能なパターンを使用しようとしたと文句を言うでしょう:</p>
<pre><code class="language-text">error[E0005]: refutable pattern in local binding: `None` not covered
(エラー: ローカル束縛に論駁可能なパターン: `None`がカバーされていません)
 --&gt;
  |
3 | let Some(x) = some_option_value;
  |     ^^^^^^^ pattern `None` not covered
</code></pre>
<!--
Because we didn’t cover (and couldn’t cover!) every valid value with the
pattern `Some(x)`, Rust rightfully produces a compiler error.
-->
<p>パターン<code>Some(x)</code>で全ての合法な値をカバーしなかった(できませんでした！)ので、
コンパイラは当然、コンパイルエラーを生成します。</p>
<!--
To fix the problem where we have a refutable pattern where an irrefutable
pattern is needed, we can change the code that uses the pattern: instead of
using `let`, we can use `if let`. Then if the pattern doesn’t match, the code
will just skip the code in the curly brackets, giving it a way to continue
validly. Listing 18-9 shows how to fix the code in Listing 18-8.
-->
<p>論駁不可能なパターンが必要な箇所に論駁可能なパターンがある問題を修正するには、パターンを使用するコードを変えればいいのです:
<code>let</code>の代わりに<code>if let</code>を使用できます。そして、パターンが合致しなかったら、コードは合法に継続する手段を残して、
波括弧内のコードを飛ばすだけでしょう。リスト18-9は、リスト18-8のコードの修正方法を示しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let some_option_value: Option&lt;i32&gt; = None;
</span>if let Some(x) = some_option_value {
    println!(&quot;{}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-9: Using `if let` and a block with refutable
patterns instead of `let`</span>
-->
<p><span class="caption">リスト18-9: <code>let</code>ではなく、<code>if let</code>と論駁可能なパターンを含むブロックを使用する</span></p>
<!--
We’ve given the code an out! This code is perfectly valid, although it means we
cannot use an irrefutable pattern without receiving an error. If we give `if
let` a pattern that will always match, such as `x`, as shown in Listing 18-10,
it will not compile.
-->
<p>コードに逃げ道を与えました！このコードは完全に合法ですが、エラーを受け取らないで論駁不可能なパターンを使用することはできないことを意味します。
リスト18-10のように、<code>x</code>のような常にマッチするパターンを<code>if let</code>に与えたら、コンパイルできないでしょう。</p>
<pre><code class="language-rust ignore">if let x = 5 {
    println!(&quot;{}&quot;, x);
};
</code></pre>
<!--
<span class="caption">Listing 18-10: Attempting to use an irrefutable pattern
with `if let`</span>
-->
<p><span class="caption">リスト18-10: <code>if let</code>で論駁不可能なパターンを使用してみる</span></p>
<!--
Rust complains that it doesn’t make sense to use `if let` with an irrefutable
pattern:
-->
<p>コンパイラは、論駁不可能なパターンと<code>if let</code>を使用するなんて道理が通らないと文句を言います:</p>
<pre><code class="language-text">error[E0162]: irrefutable if-let pattern
(エラー: 論駁不可能なif-letパターン)
 --&gt; &lt;anon&gt;:2:8
  |
2 | if let x = 5 {
  |        ^ irrefutable pattern
</code></pre>
<!--
For this reason, match arms must use refutable patterns, except for the last
arm, which should match any remaining values with an irrefutable pattern. Rust
allows us to use an irrefutable pattern in a `match` with only one arm, but
this syntax isn’t particularly useful and could be replaced with a simpler
`let` statement.
-->
<p>このため、マッチアームは、論駁不可能なパターンで残りのあらゆる値に合致すべき最後のアームを除いて、
論駁可能なパターンを使用しなければなりません。コンパイラは、たった1つしかアームのない<code>match</code>で論駁不可能なパターンを使用させてくれますが、
この記法は特別有用なわけではなく、より単純な<code>let</code>文に置き換えることもできるでしょう。</p>
<!--
Now that you know where to use patterns and the difference between refutable
and irrefutable patterns, let’s cover all the syntax we can use to create
patterns.
-->
<p>今やパターンを使用すべき箇所と論駁可能と論駁不可能なパターンの違いを知ったので、
パターンを生成するために使用できる全ての記法を講義しましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Pattern Syntax
-->
<h2 id="パターン記法"><a class="header" href="#パターン記法">パターン記法</a></h2>
<!--
Throughout the book, you’ve seen examples of many kinds of patterns. In this
section, we gather all the syntax valid in patterns and discuss why you might
want to use each of them.
-->
<p>本全体で、多くの種類のパターンの例を見かけてきました。この節では、パターンで合法な記法全てを集め、
それぞれを使用したくなる可能性がある理由について議論します。</p>
<!--
### Matching Literals
-->
<h3 id="リテラルにマッチする"><a class="header" href="#リテラルにマッチする">リテラルにマッチする</a></h3>
<!--
As you saw in Chapter 6, you can match patterns against literals directly. The
following code gives some examples:
-->
<p>第6章で目撃したように、パターンを直接リテラルに合致させられます。以下のコードが例を挙げています:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),       // 1
    2 =&gt; println!(&quot;two&quot;),       // 2
    3 =&gt; println!(&quot;three&quot;),     // 3
    _ =&gt; println!(&quot;anything&quot;),  // なんでも
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code prints `one` because the value in `x` is 1. This syntax is useful
when you want your code to take an action if it gets a particular concrete
value.
-->
<p>このコードは、<code>x</code>の値が1なので、<code>one</code>を出力します。この記法は、コードが特定の具体的な値を得た時に行動を起こしてほしい時に有用です。</p>
<!--
### Matching Named Variables
-->
<h3 id="名前付き変数にマッチする"><a class="header" href="#名前付き変数にマッチする">名前付き変数にマッチする</a></h3>
<!--
Named variables are irrefutable patterns that match any value, and we’ve used
them many times in the book. However, there is a complication when you use
named variables in `match` expressions. Because `match` starts a new scope,
variables declared as part of a pattern inside the `match` expression will
shadow those with the same name outside the `match` construct, as is the case
with all variables. In Listing 18-11, we declare a variable named `x` with the
value `Some(5)` and a variable `y` with the value `10`. We then create a
`match` expression on the value `x`. Look at the patterns in the match arms and
`println!` at the end, and try to figure out what the code will print before
running this code or reading further.
-->
<p>名前付き変数はどんな値にも合致する論駁不可能なパターンであり、この本の中で何度も使用してきました。
ですが、名前付き変数を<code>match</code>式で使うと、厄介な問題があります。<code>match</code>は新しいスコープを開始するので、
<code>match</code>式内のパターンの一部として宣言された変数は、あらゆる変数同様に<code>match</code>構文外部の同じ名前の変数を覆い隠します。
リスト18-11で、値<code>Some(5)</code>の<code>x</code>という変数と値<code>10</code>の変数<code>y</code>を宣言しています。それから値<code>x</code>に対して<code>match</code>式を生成します。
マッチアームのパターンと最後の<code>println!</code>を見て、このコードを実行したり、先まで読み進める前にこのコードが何を出力するか推測してみてください。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        // 50だったよ
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        // マッチしたよ
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        // 既定のケース
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    // 最後にはx = {}, y = {}
    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-11: A `match` expression with an arm that
introduces a shadowed variable `y`</span>
-->
<p><span class="caption">リスト18-11: シャドーイングされた変数<code>y</code>を導入するアームのある<code>match</code>式</span></p>
<!--
Let’s walk through what happens when the `match` expression runs. The pattern
in the first match arm doesn’t match the defined value of `x`, so the code
continues.
-->
<p><code>match</code>式を実行した時に起こることを見ていきましょう。最初のマッチアームのパターンは、<code>x</code>の定義された値に合致しないので、
コードは継続します。</p>
<!--
The pattern in the second match arm introduces a new variable named `y` that
will match any value inside a `Some` value. Because we’re in a new scope inside
the `match` expression, this is a new `y` variable, not the `y` we declared at
the beginning with the value 10. This new `y` binding will match any value
inside a `Some`, which is what we have in `x`. Therefore, this new `y` binds to
the inner value of the `Some` in `x`. That value is `5`, so the expression for
that arm executes and prints `Matched, y = 5`.
-->
<p>2番目のマッチアームのパターンは、<code>Some</code>値内部のあらゆる値に合致する新しい<code>y</code>という変数を導入します。
<code>match</code>式内の新しいスコープ内にいるので、これは新しい<code>y</code>変数であり、最初に値10で宣言した<code>y</code>ではありません。
この新しい<code>y</code>束縛は、<code>Some</code>内のあらゆる値に合致し、<code>x</code>にあるものはこれです。故に、この新しい<code>y</code>は、
<code>x</code>の中身の値に束縛されます。その値は<code>5</code>なので、そのアームの式が実行され、<code>Matched, y = 5</code>と出力されます。</p>
<!--
If `x` had been a `None` value instead of `Some(5)`, the patterns in the first
two arms wouldn’t have matched, so the value would have matched to the
underscore. We didn’t introduce the `x` variable in the pattern of the
underscore arm, so the `x` in the expression is still the outer `x` that hasn’t
been shadowed. In this hypothetical case, the `match` would print `Default
case, x = None`.
-->
<p><code>x</code>が<code>Some(5)</code>ではなく<code>None</code>値だったなら、最初の2つのアームのパターンはマッチしなかったので、
値はアンダースコアに合致したでしょう。アンダースコアのアームのパターンでは<code>x</code>変数を導入しなかったので、
その式の<code>x</code>は、まだシャドーイングされない外側の<code>x</code>のままです。この架空の場合、
<code>match</code>は<code>Default case, x = None</code>と出力するでしょう。</p>
<!--
When the `match` expression is done, its scope ends, and so does the scope of
the inner `y`. The last `println!` produces `at the end: x = Some(5), y = 10`.
-->
<p><code>match</code>式が完了すると、スコープが終わるので、中の<code>y</code>のスコープも終わります。
最後の<code>println!</code>は<code>at the end: x = Some(5), y = 10</code>を生成します。</p>
<!--
To create a `match` expression that compares the values of the outer `x` and
`y`, rather than introducing a shadowed variable, we would need to use a match
guard conditional instead. We’ll talk about match guards later in the “Extra
Conditionals with Match Guards” section.
-->
<p>シャドーイングされた変数を導入するのではなく、外側の<code>x</code>と<code>y</code>の値を比較する<code>match</code>式を生成するには、
代わりにマッチガード条件式を使用する必要があるでしょう。マッチガードについては、後ほど、
「マッチガードで追加の条件式」節で語ります。</p>
<!--
### Multiple Patterns
-->
<h3 id="複数のパターン"><a class="header" href="#複数のパターン">複数のパターン</a></h3>
<!--
In `match` expressions, you can match multiple patterns using the `|` syntax,
which means *or*. For example, the following code matches the value of `x`
against the match arms, the first of which has an *or* option, meaning if the
value of `x` matches either of the values in that arm, that arm’s code will
run:
-->
<p><code>match</code>式で<code>|</code>記法で複数のパターンに合致させることができ、これは<em>or</em>を意味します。例えば、以下のコードは<code>x</code>の値をマッチアームに合致させ、
最初のマッチアームには<em>or</em>選択肢があり、<code>x</code>の値がそのアームのどちらかの値に合致したら、そのアームのコードが走ることを意味します:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    // 1か2
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    // 3
    3 =&gt; println!(&quot;three&quot;),
    // なんでも
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code prints `one or two`.
-->
<p>このコードは、<code>one or two</code>を出力します。</p>
<!--
### Matching Ranges of Values with `..=`
-->
<h3 id="で値の範囲に合致させる"><a class="header" href="#で値の範囲に合致させる"><code>..=</code>で値の範囲に合致させる</a></h3>
<!--
The `..=` syntax allows us to match to an inclusive range of values. In the
following code, when a pattern matches any of the values within the range, that
arm will execute:
-->
<p><code>..=</code>記法により、限度値を含む値の範囲にマッチさせることができます。以下のコードでは、
パターンが範囲内のどれかの値に合致すると、そのアームが実行されます:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;

match x {
    // 1から5まで
    1..=5 =&gt; println!(&quot;one through five&quot;),
    // それ以外
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<!--
If `x` is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more
convenient than using the `|` operator to express the same idea; instead of `1..=5`,
we would have to specify `1 | 2 | 3 | 4 | 5` if we used `|`. Specifying
a range is much shorter, especially if we want to match, say, any number
between 1 and 1,000!
-->
<p><code>x</code>が1、2、3、4か5なら、最初のアームが合致します。この記法は、<code>|</code>演算子を使用して同じ考えを表現するより便利です;
<code>1..=5</code>ではなく、<code>|</code>を使用したら、<code>1 | 2 | 3 | 4 | 5</code>と指定しなければならないでしょう。
範囲を指定する方が遥かに短いのです。特に1から1000までの値と合致させたいとかなら！</p>
<!--
Ranges are only allowed with numeric values or `char` values, because the
compiler checks that the range isn’t empty at compile time. The only types for
which Rust can tell if a range is empty or not are `char` and numeric values.
-->
<p>範囲は、数値か<code>char</code>値でのみ許可されます。コンパイラがコンパイル時に範囲が空でないことを確認しているからです。
範囲が空かそうでないかコンパイラにわかる唯一の型が<code>char</code>か数値なのです。</p>
<!--
Here is an example using ranges of `char` values:
-->
<p>こちらは、<code>char</code>値の範囲を使用する例です:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 'c';

match x {
    // ASCII文字前半
    'a'..='j' =&gt; println!(&quot;early ASCII letter&quot;),
    // ASCII文字後半
    'k'..='z' =&gt; println!(&quot;late ASCII letter&quot;),
    // それ以外
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<!--
Rust can tell that `'c'` is within the first pattern’s range and prints `early
ASCII letter`.
-->
<p>コンパイラには<code>'c'</code>が最初のパターンの範囲にあることがわかり、<code>early ASCII letter</code>と出力されます。</p>
<!--
### Destructuring to Break Apart Values
-->
<h3 id="分配して値を分解する"><a class="header" href="#分配して値を分解する">分配して値を分解する</a></h3>
<!--
We can also use patterns to destructure structs, enums, tuples, and references
to use different parts of these values. Let’s walk through each value.
-->
<p>また、パターンを使用して構造体、enum、タプル、参照を分配し、これらの値の異なる部分を使用することもできます。
各値を見ていきましょう。</p>
<!--
#### Destructuring Structs
-->
<h4 id="構造体を分配する"><a class="header" href="#構造体を分配する">構造体を分配する</a></h4>
<!--
Listing 18-12 shows a `Point` struct with two fields, `x` and `y`, that we can
break apart using a pattern with a `let` statement.
-->
<p>リスト18-12は、<code>let</code>文でパターンを使用して分解できる2つのフィールド<code>x</code>と<code>y</code>のある<code>Point</code>構造体を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-12: Destructuring a struct’s fields into
separate variables</span>
-->
<p><span class="caption">リスト18-12: 構造体のフィールドを個別の変数に分配する</span></p>
<!--
This code creates the variables `a` and `b` that match the values of the `x`
and `y` fields of the `p` variable. This example shows that the names of the
variables in the pattern don’t have to match the field names of the struct. But
it’s common to want the variable names to match the field names to make it
easier to remember which variables came from which fields.
-->
<p>このコードは、<code>p</code>変数の<code>x</code>と<code>y</code>フィールドの値に合致する変数<code>a</code>と<code>b</code>を生成します。この例は、
パターンの変数の名前は、構造体のフィールド名と合致する必要はないことを示しています。しかし、
変数名をフィールド名と一致させてどの変数がどのフィールド由来のものなのか覚えやすくしたくなることは一般的なことです。</p>
<!--
Because having variable names match the fields is common and because writing
`let Point { x: x, y: y } = p;` contains a lot of duplication, there is a
shorthand for patterns that match struct fields: you only need to list the name
of the struct field, and the variables created from the pattern will have the
same names. Listing 18-13 shows code that behaves in the same way as the code
in Listing 18-12, but the variables created in the `let` pattern are `x` and
`y` instead of `a` and `b`.
-->
<p>変数名をフィールドに一致させることは一般的であり、<code>let Point{ x: x, y: y } = p;</code>と書くことは多くの重複を含むので、
構造体のフィールドと一致するパターンには省略法があります: 構造体のフィールドの名前を列挙するだけで、
パターンから生成される変数は同じ名前になるのです。リスト18-13は、リスト18-12と同じ振る舞いをするコードを表示していますが、
<code>let</code>パターンで生成される変数は<code>a</code>と<code>b</code>ではなく、<code>x</code>と<code>y</code>です。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-13: Destructuring struct fields using struct
field shorthand</span>
-->
<p><span class="caption">リスト18-13: 構造体フィールド省略法で構造体のフィールドを分配する</span></p>
<!--
This code creates the variables `x` and `y` that match the `x` and `y` fields
of the `p` variable. The outcome is that the variables `x` and `y` contain the
values from the `p` struct.
-->
<p>このコードは、<code>p</code>変数の<code>x</code>と<code>y</code>フィールドに一致する変数<code>x</code>と<code>y</code>を生成します。
結果は、変数<code>x</code>と<code>y</code>が<code>p</code>構造体の値を含むというものです。</p>
<!--
We can also destructure with literal values as part of the struct pattern
rather than creating variables for all the fields. Doing so allows us to test
some of the fields for particular values while creating variables to
destructure the other fields.
-->
<p>また、全フィールドに対して変数を生成するのではなく、リテラル値を構造体パターンの一部にして分配することもできます。
そうすることで他のフィールドは分配して変数を生成しつつ、一部のフィールドは特定の値と一致するか確認できます。</p>
<!--
Listing 18-14 shows a `match` expression that separates `Point` values into
three cases: points that lie directly on the `x` axis (which is true when `y =
0`), on the `y` axis (`x = 0`), or neither.
-->
<p>リスト18-14は、<code>Point</code>値を3つの場合に区別する<code>match</code>式を表示しています: <code>x</code>軸上の点(<code>y = 0</code>ならそうなる)、
<code>y</code>軸上の点(<code>x = 0</code>)、あるいはどちらでもありません。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        // x軸上の{}
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        // y軸上の{}
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        // どちらの軸上でもない: ({}, {})
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-14: Destructuring and matching literal values
in one pattern</span>
-->
<p><span class="caption">リスト18-14: 分配とリテラル値との一致を1つのパターンで</span></p>
<!--
The first arm will match any point that lies on the `x` axis by specifying that
the `y` field matches if its value matches the literal `0`. The pattern still
creates an `x` variable that we can use in the code for this arm.
-->
<p>最初のアームは、<code>y</code>フィールドの値がリテラル<code>0</code>と一致するならマッチすると指定することで、<code>x</code>軸上にあるどんな点とも一致します。
このパターンはそれでも、このアームのコードで使用できる<code>x</code>変数を生成します。</p>
<!--
Similarly, the second arm matches any point on the `y` axis by specifying that
the `x` field matches if its value is `0` and creates a variable `y` for the
value of the `y` field. The third arm doesn’t specify any literals, so it
matches any other `Point` and creates variables for both the `x` and `y` fields.
-->
<p>同様に、2番目のアームは、<code>x</code>フィールドが<code>0</code>ならマッチすると指定することで<code>y</code>軸上のどんな点とも一致し、
<code>y</code>フィールドの値には変数<code>y</code>を生成します。3番目のアームは何もリテラルを指定しないので、
それ以外のあらゆる<code>Point</code>に合致し、<code>x</code>と<code>y</code>フィールド両方に変数を生成します。</p>
<!--
In this example, the value `p` matches the second arm by virtue of `x`
containing a 0, so this code will print `On the y axis at 7`.
-->
<p>この例で、値<code>p</code>は0を含む<code>x</code>の力で2番目のアームに一致するので、このコードは<code>On the y axis at 7</code>と出力します。</p>
<!--
#### Destructuring Enums
-->
<h4 id="enumを分配する"><a class="header" href="#enumを分配する">enumを分配する</a></h4>
<!--
We’ve destructured enums earlier in this book, for example, when we
destructured `Option<i32>` in Listing 6-5 in Chapter 6. One detail we haven’t
mentioned explicitly is that the pattern to destructure an enum should
correspond to the way the data stored within the enum is defined. As an
example, in Listing 18-15 we use the `Message` enum from Listing 6-2 and write
a `match` with patterns that will destructure each inner value.
-->
<p>例えば、第6章のリスト6-5で<code>Option&lt;i32&gt;</code>を分配するなどこの本の前半でenumを分配しました。
明示的に触れなかった詳細の1つは、enumを分配するパターンは、enum内に格納されているデータが定義されている手段に対応すべきということです。
例として、リスト18-15では、リスト6-2から<code>Message</code> enumを使用し、内部の値それぞれを分配するパターンを伴う<code>match</code>を書いています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            // Quit列挙子には分配すべきデータがない
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        },
        Message::Move { x, y } =&gt; {
            println!(
                // x方向に{}、y方向に{}だけ動く
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x,
                y
            );
        }
        // テキストメッセージ: {}
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; {
            println!(
                // 色を赤{}, 緑{}, 青{}に変更
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        }
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-15: Destructuring enum variants that hold
different kinds of values</span>
-->
<p><span class="caption">リスト18-15: 異なる種類の値を保持するenumの列挙子を分配する</span></p>
<!--
This code will print `Change the color to red 0, green 160, and blue 255`. Try
changing the value of `msg` to see the code from the other arms run.
-->
<p>このコードは、<code>Change the color to red 0, green 160, blue 255</code>と出力します。
試しに<code>msg</code>の値を変更して、他のアームのコードが走るところを確認してください。</p>
<!--
For enum variants without any data, like `Message::Quit`, we can’t destructure
the value any further. We can only match on the literal `Message::Quit` value,
and no variables are in that pattern.
-->
<p><code>Message::Quit</code>のようなデータのないenum列挙子については、それ以上値を分配することができません。
リテラル<code>Message::Quit</code>値にマッチするだけで、変数はそのパターンに存在しません。</p>
<!--
For struct-like enum variants, such as `Message::Move`, we can use a pattern
similar to the pattern we specify to match structs. After the variant name, we
place curly brackets and then list the fields with variables so we break apart
the pieces to use in the code for this arm. Here we use the shorthand form as
we did in Listing 18-13.
-->
<p><code>Message::Move</code>のような構造体に似たenumの列挙子については、構造体と一致させるために指定するパターンと似たパターンを使用できます。
列挙子の名前の後に波括弧を配置し、それから変数とともにフィールドを列挙するので、部品を分解してこのアームのコードで使用します。
ここでは、リスト18-13のように省略形態を使用しています。</p>
<!--
For tuple-like enum variants, like `Message::Write` that holds a tuple with one
element and `Message::ChangeColor` that holds a tuple with three elements, the
pattern is similar to the pattern we specify to match tuples. The number of
variables in the pattern must match the number of elements in the variant we’re
matching.
-->
<p>1要素タプルを保持する<code>Message::Write</code>や、3要素タプルを保持する<code>Message::ChangeColor</code>のようなタプルに似たenumの列挙子について、
パターンは、タプルと一致させるために指定するパターンと類似しています。パターンの変数の数は、
マッチ対象の列挙子の要素数と一致しなければなりません。</p>
<!--
#### Destructuring References
-->
<h4 id="参照を分配する"><a class="header" href="#参照を分配する">参照を分配する</a></h4>
<!--
When the value we’re matching to our pattern contains a reference, we need to
destructure the reference from the value, which we can do by specifying a `&`
in the pattern. Doing so lets us get a variable holding the value that the
reference points to rather than getting a variable that holds the reference.
This technique is especially useful in closures where we have iterators that
iterate over references, but we want to use the values in the closure rather
than the references.
-->
<p>パターンとマッチさせている値に参照が含まれる場合、値から参照を分配する必要があり、
パターンに<code>&amp;</code>を指定することでそうすることができます。そうすることで参照を保持する変数を得るのではなく、
参照が指している値を保持する変数が得られます。このテクニックは、参照を走査するイテレータがあるクロージャで特に役に立ちますが、
そのクロージャで参照ではなく、値を使用したいです。</p>
<!--
The example in Listing 18-16 iterates over references to `Point` instances in a
vector, destructuring the reference and the struct so we can perform
calculations on the `x` and `y` values easily.
-->
<p>リスト18-16の例は、ベクタの<code>Point</code>インスタンスへの参照を走査し、<code>x</code>と<code>y</code>値に簡単に計算を行えるように、
参照と構造体を分配します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>let points = vec![
    Point { x: 0, y: 0 },
    Point { x: 1, y: 5 },
    Point { x: 10, y: -3 },
];

let sum_of_squares: i32 = points
    .iter()
    .map(|&amp;Point { x, y }| x * x + y * y)
    .sum();
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-16: Destructuring a reference to a struct into
the struct field values</span>
-->
<p><span class="caption">リスト18-16: 構造体への参照を構造体のフィールド値に分配する</span></p>
<!--
This code gives us the variable `sum_of_squares` holding the value 135, which
is the result of squaring the `x` value and the `y` value, adding those
together, and then adding the result for each `Point` in the `points` vector to
get one number.
-->
<p>このコードは、値135を保持する変数<code>sum_of_squares</code>を返してきて、これは、<code>x</code>値と<code>y</code>値を2乗し、足し合わせ、
<code>points</code>ベクタの<code>Point</code>それぞれの結果を足して1つの数値にした結果です。</p>
<!--
If we had not included the `&` in `&Point { x, y }`, we’d get a type mismatch
error, because `iter` would then iterate over references to the items in the
vector rather than the actual values. The error would look like this:
-->
<p><code>&amp;Point { x, y }</code>に<code>&amp;</code>が含まれていなかったら、型不一致エラーが発生していたでしょう。
<code>iter</code>はそうすると、実際の値ではなく、ベクタの要素への参照を走査するからです。そのエラーはこんな見た目でしょう:</p>
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt;
   |
14 |         .map(|Point { x, y }| x * x + y * y)
   |               ^^^^^^^^^^^^ expected &amp;Point, found struct `Point`
   |
   = note: expected type `&amp;Point`
              found type `Point`
</code></pre>
<!--
This error indicates that Rust was expecting our closure to match `&Point`, but
we tried to match directly to a `Point` value, not a reference to a `Point`.
-->
<p>このエラーは、コンパイラがクロージャに<code>&amp;Point</code>と一致することを期待しているのに、
<code>Point</code>への参照ではなく、<code>Point</code>値に直接一致させようとしたことを示唆しています。</p>
<!--
#### Destructuring Structs and Tuples
-->
<h4 id="構造体とタプルを分配する"><a class="header" href="#構造体とタプルを分配する">構造体とタプルを分配する</a></h4>
<!--
We can mix, match, and nest destructuring patterns in even more complex ways.
The following example shows a complicated destructure where we nest structs and
tuples inside a tuple and destructure all the primitive values out:
-->
<p>分配パターンをさらに複雑な方法で混ぜてマッチさせ、ネストすることができます。以下の例は、
構造体とタプルをタプルにネストし、全ての基本的な値を取り出している複雑な分配を表示しています:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<!--
This code lets us break complex types into their component parts so we can use
the values we’re interested in separately.
-->
<p>このコードは、複雑な型を構成する部品に分配させてくれるので、興味のある値を個別に使用できます。</p>
<!--
Destructuring with patterns is a convenient way to use pieces of values, such
as the value from each field in a struct, separately from each other.
-->
<p>パターンで分配することは、構造体の各フィールドからの値のように、複数の値をお互いに区別して使用する便利な方法です。</p>
<!--
### Ignoring Values in a Pattern
-->
<h3 id="パターンの値を無視する"><a class="header" href="#パターンの値を無視する">パターンの値を無視する</a></h3>
<!--
You’ve seen that it’s sometimes useful to ignore values in a pattern, such as
in the last arm of a `match`, to get a catchall that doesn’t actually do
anything but does account for all remaining possible values. There are a few
ways to ignore entire values or parts of values in a pattern: using the `_`
pattern (which you’ve seen), using the `_` pattern within another pattern,
using a name that starts with an underscore, or using `..` to ignore remaining
parts of a value. Let’s explore how and why to use each of these patterns.
-->
<p><code>match</code>の最後のアームのように、パターンの値を無視して実際には何もしないけれども、
残りの全ての値の可能性を考慮する包括的なものを得ることは、時として有用であると認識しましたね。
値全体やパターンの一部の値を無視する方法はいくつかあります: <code>_</code>パターンを使用すること(もう見かけました)、
他のパターン内で<code>_</code>パターンを使用すること、アンダースコアで始まる名前を使用すること、<code>..</code>を使用して値の残りの部分を無視することです。
これらのパターンそれぞれを使用する方法と理由を探究しましょう。</p>
<!--
#### Ignoring an Entire Value with `_`
-->
<h4 id="_で値全体を無視する"><a class="header" href="#_で値全体を無視する"><code>_</code>で値全体を無視する</a></h4>
<!--
We’ve used the underscore (`_`) as a wildcard pattern that will match any value
but not bind to the value. Although the underscore `_` pattern is especially
useful as the last arm in a `match` expression, we can use it in any pattern,
including function parameters, as shown in Listing 18-17.
-->
<p>どんな値にも一致するけれども、値を束縛しないワイルドカードパターンとしてアンダースコア、<code>_</code>を使用してきました。
アンダースコア、<code>_</code>パターンは特に<code>match</code>式の最後のアームとして役に立ちますが、
関数の引数も含めてあらゆるパターンで使えます。リスト18-17に示したようにですね。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn foo(_: i32, y: i32) {
    // このコードは、y引数を使うだけです: {}
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-17: Using `_` in a function signature</span>
-->
<p><span class="caption">リスト18-17: 関数シグニチャで<code>_</code>を使用する</span></p>
<!--
This code will completely ignore the value passed as the first argument, `3`,
and will print `This code only uses the y parameter: 4`.
-->
<p>このコードは、最初の引数として渡された値<code>3</code>を完全に無視し、<code>This code only uses the y parameter: 4</code>と出力します。</p>
<!--
In most cases when you no longer need a particular function parameter, you
would change the signature so it doesn’t include the unused parameter. Ignoring
a function parameter can be especially useful in some cases, for example, when
implementing a trait when you need a certain type signature but the function
body in your implementation doesn’t need one of the parameters. The compiler
will then not warn about unused function parameters, as it would if you used a
name instead.
-->
<p>特定の関数の引数が最早必要ないほとんどの場合、未使用の引数が含まれないようにシグニチャを変更するでしょう。
関数の引数を無視することが特に有用なケースもあり、例えば、トレイトを実装する際、
特定の型シグニチャが必要だけれども、自分の実装の関数本体では引数の1つが必要ない時などです。
そうすれば、代わりに名前を使った場合のようには、未使用関数引数についてコンパイラが警告することはないでしょう。</p>
<!--
#### Ignoring Parts of a Value with a Nested `_`
-->
<h4 id="ネストされた_で値の一部を無視する"><a class="header" href="#ネストされた_で値の一部を無視する">ネストされた<code>_</code>で値の一部を無視する</a></h4>
<!--
We can also use `_` inside another pattern to ignore just part of a value, for
example, when we want to test for only part of a value but have no use for the
other parts in the corresponding code we want to run. Listing 18-18 shows code
responsible for managing a setting’s value. The business requirements are that
the user should not be allowed to overwrite an existing customization of a
setting but can unset the setting and can give the setting a value if it is
currently unset.
-->
<p>また、他のパターンの内部で<code>_</code>を使用して、値の一部だけを無視することもでき、例えば、
値の一部だけを確認したいけれども、走らせたい対応するコードでは他の部分を使用することがない時などです。
リスト18-18は、設定の値を管理する責任を負ったコードを示しています。業務要件は、
ユーザが既存の設定の変更を上書きすることはできないべきだけれども、設定を解除し、
現在設定がされていなければ設定に値を与えられるというものです。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) =&gt; {
        // 既存の値の変更を上書きできません
        println!(&quot;Can't overwrite an existing customized value&quot;);
    }
    _ =&gt; {
        setting_value = new_setting_value;
    }
}

// 設定は{:?}です
println!(&quot;setting is {:?}&quot;, setting_value);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-18: Using an underscore within patterns that
match `Some` variants when we don’t need to use the value inside the
`Some`</span>
-->
<p><span class="caption">リスト18-18: <code>Some</code>内の値を使用する必要がない時に<code>Some</code>列挙子と合致するパターンでアンダースコアを使用する</span></p>
<!--
This code will print `Can't overwrite an existing customized value` and then
`setting is Some(5)`. In the first match arm, we don’t need to match on or use
the values inside either `Some` variant, but we do need to test for the case
when `setting_value` and `new_setting_value` are the `Some` variant. In that
case, we print why we’re not changing `setting_value`, and it doesn’t get
changed.
-->
<p>このコードは、<code>Can't overwrite an existing customized value</code>、そして<code>setting is Some(5)</code>と出力するでしょう。
最初のマッチアームで、どちらの<code>Some</code>列挙子内部の値にも合致させたり、使用する必要はありませんが、
<code>setting_value</code>と<code>new_setting_value</code>が<code>Some</code>列挙子の場合を確かに確認する必要があります。
その場合、何故<code>setting_value</code>を変更しないかを出力し、変更しません。</p>
<!--
In all other cases (if either `setting_value` or `new_setting_value` are
`None`) expressed by the `_` pattern in the second arm, we want to allow
`new_setting_value` to become `setting_value`.
-->
<p>2番目のアームの<code>_</code>パターンで表現される他のあらゆる場合(<code>setting_value</code>と<code>new_setting_value</code>どちらかが<code>None</code>なら)には、
<code>new_setting_value</code>に<code>setting_value</code>になってほしいです。</p>
<!--
We can also use underscores in multiple places within one pattern to ignore
particular values. Listing 18-19 shows an example of ignoring the second and
fourth values in a tuple of five items.
-->
<p>また、1つのパターンの複数箇所でアンダースコアを使用して特定の値を無視することもできます。
リスト18-19は、5要素のタプルで2番目と4番目の値を無視する例です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) =&gt; {
        // 何らかの数値: {}, {}, {}
        println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
    },
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-19: Ignoring multiple parts of a tuple</span>
-->
<p><span class="caption">リスト18-19: タプルの複数の部分を無視する</span></p>
<!--
This code will print `Some numbers: 2, 8, 32`, and the values 4 and 16 will be
ignored.
-->
<p>このコードは、<code>Some numbers: 2, 8, 32</code>と出力し、値4と16は無視されます。</p>
<!--
#### Ignoring an Unused Variable by Starting Its Name with `_`
-->
<h4 id="名前を_で始めて未使用の変数を無視する"><a class="header" href="#名前を_で始めて未使用の変数を無視する">名前を<code>_</code>で始めて未使用の変数を無視する</a></h4>
<!--
If you create a variable but don’t use it anywhere, Rust will usually issue a
warning because that could be a bug. But sometimes it’s useful to create a
variable you won’t use yet, such as when you’re prototyping or just starting a
project. In this situation, you can tell Rust not to warn you about the unused
variable by starting the name of the variable with an underscore. In Listing
18-20, we create two unused variables, but when we run this code, we should
only get a warning about one of them.
-->
<p>変数を作っているのにどこでも使用していなければ、バグかもしれないのでコンパイラは通常、警告を発します。
しかし時として、まだ使用しない変数を作るのが有用なこともあります。プロトタイプを開発していたり、
プロジェクトを始めた直後だったりなどです。このような場面では、変数名をアンダースコアで始めることで、
コンパイラに未使用変数について警告しないよう指示することができます。リスト18-20で2つの未使用変数を生成していますが、
このコードを実行すると、そのうちの1つにしか警告が出ないはずです。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-20: Starting a variable name with an
underscore to avoid getting unused variable warnings</span>
-->
<p><span class="caption">リスト18-20: アンダースコアで変数名を始めて未使用変数警告が出るのを回避する</span></p>
<!--
Here we get a warning about not using the variable `y`, but we don’t get a
warning about not using the variable preceded by the underscore.
-->
<p>ここで、変数<code>y</code>を使用していないことに対して警告が出ていますが、アンダースコアが接頭辞になっている変数には、
使用していないという警告が出ていません。</p>
<!--
Note that there is a subtle difference between using only `_` and using a name
that starts with an underscore. The syntax `_x` still binds the value to the
variable, whereas `_` doesn’t bind at all. To show a case where this
distinction matters, Listing 18-21 will provide us with an error.
-->
<p><code>_</code>だけを使うのとアンダースコアで始まる名前を使うことには微妙な違いがあることに注意してください。
<code>_x</code>記法はそれでも、値を変数に束縛する一方で、<code>_</code>は全く束縛しません。この差異が問題になる場合を示すために、
リスト18-21はエラーを提示するでしょう。</p>
<pre><code class="language-rust ignore">// こんにちは！
let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_s) = s {
    // 文字列が見つかりました
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
</code></pre>
<!--
<span class="caption">Listing 18-21: An unused variable starting with an
underscore still binds the value, which might take ownership of the value</span>
-->
<p><span class="caption">リスト18-21: それでも、アンダースコアで始まる未使用の変数は値を束縛し、値の所有権を奪う可能性がある</span></p>
<!--
We’ll receive an error because the `s` value will still be moved into `_s`,
which prevents us from using `s` again. However, using the underscore by itself
doesn’t ever bind to the value. Listing 18-22 will compile without any errors
because `s` doesn’t get moved into `_`.
-->
<p>それでも<code>s</code>値は<code>_s</code>にムーブされ、再度<code>s</code>を使用できなくするので、エラーを受け取るでしょう。ですが、
アンダースコアを単独で使用すれば、値を束縛することは全くありません。
<code>s</code>が<code>_</code>にムーブされないので、リスト18-22はエラーなくコンパイルできます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-22: Using an underscore does not bind the
value</span>
-->
<p><span class="caption">リスト18-22: アンダースコアを使用すると、値を束縛しない</span></p>
<!--
This code works just fine because we never bind `s` to anything; it isn’t moved.
-->
<p>このコードは、<code>s</code>を何にも束縛しないので、ただ単に上手く動きます。つまり、ムーブされないのです。</p>
<!--
#### Ignoring Remaining Parts of a Value with `..`
-->
<h4 id="で値の残りの部分を無視する"><a class="header" href="#で値の残りの部分を無視する"><code>..</code>で値の残りの部分を無視する</a></h4>
<!--
With values that have many parts, we can use the `..` syntax to use only a few
parts and ignore the rest, avoiding the need to list underscores for each
ignored value. The `..` pattern ignores any parts of a value that we haven’t
explicitly matched in the rest of the pattern. In Listing 18-23, we have a
`Point` struct that holds a coordinate in three-dimensional space. In the
`match` expression, we want to operate only on the `x` coordinate and ignore
the values in the `y` and `z` fields.
-->
<p>多くの部分がある値では、<code>..</code>記法を使用していくつかの部分だけを使用して残りを無視し、
無視する値それぞれにアンダースコアを列挙する必要性を回避できます。<code>..</code>パターンは、
パターンの残りで明示的にマッチさせていない値のどんな部分も無視します。リスト18-23では、
3次元空間で座標を保持する<code>Point</code>構造体があります。<code>match</code>式で<code>x</code>座標のみ処理し、
<code>y</code>と<code>z</code>フィールドの値は無視したいです。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-23: Ignoring all fields of a `Point` except
for `x` by using `..`</span>
-->
<p><span class="caption">リスト18-23: <code>..</code>で<code>x</code>以外の<code>Point</code>のフィールド全てを無視する</span></p>
<!--
We list the `x` value and then just include the `..` pattern. This is quicker
than having to list `y: _` and `z: _`, particularly when we’re working with
structs that have lots of fields in situations where only one or two fields are
relevant.
-->
<p><code>x</code>値を列挙し、それから<code>..</code>パターンを含んでいるだけです。これは、<code>y: _</code>や<code>z: _</code>と列挙しなければいけないのに比べて、
手っ取り早いです。特に1つや2つのフィールドのみが関連する場面で多くのフィールドがある構造体に取り掛かっている時には。</p>
<!--
The syntax `..` will expand to as many values as it needs to be. Listing 18-24
shows how to use `..` with a tuple.
-->
<p><code>..</code>記法は、必要な数だけ値に展開されます。リスト18-24は、タプルで<code>..</code>を使用する方法を表示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {}, {}&quot;, first, last);
        },
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-24: Matching only the first and last values in
a tuple and ignoring all other values</span>
-->
<p><span class="caption">リスト18-24: タプルの最初と最後の値にだけ合致し、他の値を無視する</span></p>
<!--
In this code, the first and last value are matched with `first` and `last`. The
`..` will match and ignore everything in the middle.
-->
<p>このコードにおいて、最初と最後の値は<code>first</code>と<code>last</code>に合致します。<code>..</code>は、
途中のもの全部に合致し、無視します。</p>
<!--
However, using `..` must be unambiguous. If it is unclear which values are
intended for matching and which should be ignored, Rust will give us an error.
Listing 18-25 shows an example of using `..` ambiguously, so it will not
compile.
-->
<p>しかしながら、<code>..</code>を使うのは明確でなければなりません。どの値がマッチしてどの値が無視されるべきかが不明瞭なら、
コンパイラはエラーを出します。リスト18-25は、<code>..</code>を曖昧に使用する例なので、コンパイルできません。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre>
<!--
<span class="caption">Listing 18-25: An attempt to use `..` in an ambiguous
way</span>
-->
<p><span class="caption">リスト18-25: <code>..</code>を曖昧に使用しようとする試み</span></p>
<!--
When we compile this example, we get this error:
-->
<p>この例をコンパイルすると、こんなエラーが出ます:</p>
<pre><code class="language-text">error: `..` can only be used once per tuple or tuple struct pattern
(エラー: `..`は、タプルやタプル構造体パターン1つにつき、1回しか使用できません)
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |                      ^^
</code></pre>
<!--
It’s impossible for Rust to determine how many values in the tuple to ignore
before matching a value with `second` and then how many further values to
ignore thereafter. This code could mean that we want to ignore `2`, bind
`second` to `4`, and then ignore `8`, `16`, and `32`; or that we want to ignore
`2` and `4`, bind `second` to `8`, and then ignore `16` and `32`; and so forth.
The variable name `second` doesn’t mean anything special to Rust, so we get a
compiler error because using `..` in two places like this is ambiguous.
-->
<p>コンパイラが、<code>second</code>の値に合致する前にタプルの幾つの値を無視し、それからそれによってさらに幾つの値を無視するかを決めることは不可能です。
このコードは、<code>2</code>を無視し、<code>second</code>に<code>4</code>を束縛し、それから<code>8</code>、<code>16</code>、<code>32</code>を無視したり、
<code>2</code>と<code>4</code>を無視して<code>second</code>に<code>8</code>を束縛し、それから<code>16</code>と<code>32</code>を無視するなどを意味することもあるでしょう。
変数名の<code>second</code>は、コンパイラにとってなんの特別な意味もなく、このように2箇所で<code>..</code>を使うのは曖昧なので、
コンパイルエラーになります。</p>
<!--
### Creating References in Patterns with `ref` and `ref mut`
-->
<h3 id="refとref-mutでパターンに参照を生成する"><a class="header" href="#refとref-mutでパターンに参照を生成する"><code>ref</code>と<code>ref mut</code>でパターンに参照を生成する</a></h3>
<!--
Let’s look at using `ref` to make references so ownership of the values isn’t
moved to variables in the pattern. Usually, when you match against a pattern,
the variables introduced by the pattern are bound to a value. Rust’s ownership
rules mean the value will be moved into the `match` or wherever you’re using
the pattern. Listing 18-26 shows an example of a `match` that has a pattern
with a variable and then usage of the entire value in the `println!` statement
later, after the `match`. This code will fail to compile because ownership of
part of the `robot_name` value is transferred to the `name` variable in the
pattern of the first `match` arm.
-->
<p><code>ref</code>を使用して値の所有権がパターンの変数にムーブされないように、参照を生成することに目を向けましょう。
通常、パターンにマッチさせると、パターンで導入された変数は値に束縛されます。Rustの所有権規則は、
その値が<code>match</code>などパターンを使用しているあらゆる場所にムーブされることを意味します。
リスト18-26は、変数があるパターンとそれから<code>match</code>の後に値全体を<code>println!</code>文で後ほど使用する<code>match</code>の例を示しています。
このコードはコンパイルに失敗します。<code>robot_name</code>値の一部の所有権が、
最初の<code>match</code>アームのパターンの<code>name</code>変数に移るからです。</p>
<pre><code class="language-rust ignore">let robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    // 名前が見つかりました: {}
    Some(name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

// robot_nameは: {:?}
println!(&quot;robot_name is: {:?}&quot;, robot_name);
</code></pre>
<!--
<span class="caption">Listing 18-26: Creating a variable in a `match` arm
pattern takes ownership of the value</span>
-->
<p><span class="caption">リスト18-26: <code>match</code>アームパターンで変数を生成すると、値の所有権が奪われる</span></p>
<!--
Because ownership of part of `robot_name` has been moved to `name`, we can no
longer use `robot_name` in the `println!` after the `match` because
`robot_name` no longer has ownership.
-->
<p><code>robot_name</code>の一部の所有権が<code>name</code>にムーブされたので、<code>robot_name</code>に最早所有権がないために、
<code>match</code>の後に<code>println!</code>で最早<code>robot_name</code>を使用することは叶いません。</p>
<!--
To fix this code, we want to make the `Some(name)` pattern *borrow* that part
of `robot_name` rather than taking ownership. You’ve already seen that, outside
of patterns, the way to borrow a value is to create a reference using `&`, so
you might think the solution is changing `Some(name)` to `Some(&name)`.
-->
<p>このコードを修正するために、<code>Some(name)</code>パターンに所有権を奪わせるのではなく、
<code>robot_name</code>のその部分を借用させたいです。パターンの外なら、値を借用する手段は、
<code>&amp;</code>で参照を生成することだと既にご認識でしょうから、解決策は<code>Some(name)</code>を<code>Some(&amp;name)</code>に変えることだとお考えかもしれませんね。</p>
<!--
However, as you saw in the “Destructuring to Break Apart Values” section, the
syntax `&` in patterns does not *create* a reference but *matches* an existing
reference in the value. Because `&` already has that meaning in patterns, we
can’t use `&` to create a reference in a pattern.
-->
<p>しかしながら、「分配して値を分解する」節で見かけたように、パターンにおける<code>&amp;</code>記法は参照を<em>生成</em>せず、
値の既存の参照に<em>マッチ</em>します。パターンにおいて<code>&amp;</code>には既にその意味があるので、
<code>&amp;</code>を使用してパターンで参照を生成することはできません。</p>
<!--
Instead, to create a reference in a pattern, we use the `ref` keyword before
the new variable, as shown in Listing 18-27.
-->
<p>その代わりに、パターンで参照を生成するには、リスト18-27のように、新しい変数の前に<code>ref</code>キーワードを使用します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    Some(ref name) =&gt; println!(&quot;Found a name: {}&quot;, name),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-27: Creating a reference so a pattern variable
does not take ownership of a value</span>
-->
<p><span class="caption">リスト18-27: パターンの変数が値の所有権を奪わないように参照を生成する</span></p>
<!--
This example will compile because the value in the `Some` variant in
`robot_name` is not moved into the `match`; the `match` only took a reference
to the data in `robot_name` rather than moving it.
-->
<p><code>robot_name</code>の<code>Some</code>列挙子の値が<code>match</code>にムーブされないので、この例はコンパイルできます;
<code>match</code>はムーブするのではなく、<code>robot_name</code>のデータへの参照を取っただけなのです。</p>
<!--
To create a mutable reference so we’re able to mutate a value matched in a
pattern, we use `ref mut` instead of `&mut`. The reason is, again, that in
patterns, the latter is for matching existing mutable references, not creating
new ones. Listing 18-28 shows an example of a pattern creating a mutable
reference.
-->
<p>パターンで合致した値を可変化できるように可変参照を生成するには、<code>&amp;mut</code>の代わりに<code>ref mut</code>を使用します。
理由は今度も、パターンにおいて、前者は既存の可変参照にマッチするためにあり、新しい参照を生成しないからです。
リスト18-28は、可変参照を生成するパターンの例です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut robot_name = Some(String::from(&quot;Bors&quot;));

match robot_name {
    // 別の名前
    Some(ref mut name) =&gt; *name = String::from(&quot;Another name&quot;),
    None =&gt; (),
}

println!(&quot;robot_name is: {:?}&quot;, robot_name);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-28: Creating a mutable reference to a value as
part of a pattern using `ref mut`</span>
-->
<p><span class="caption">リスト18-28: <code>ref mut</code>を使用して、パターンの一部として値への可変参照を生成する</span></p>
<!--
This example will compile and print `robot_name is: Some("Another name")`.
Because `name` is a mutable reference, we need to dereference within the match
arm code using the `*` operator to mutate the value.
-->
<p>この例はコンパイルが通り、<code>robot_name is: Some(&quot;Another name&quot;)</code>と出力するでしょう。
<code>name</code>は可変参照なので、値を可変化するためにマッチアーム内で<code>*</code>演算子を使用して参照外しする必要があります。</p>
<!--
### Extra Conditionals with Match Guards
-->
<h3 id="マッチガードで追加の条件式"><a class="header" href="#マッチガードで追加の条件式">マッチガードで追加の条件式</a></h3>
<!--
A *match guard* is an additional `if` condition specified after the pattern in
a `match` arm that must also match, along with the pattern matching, for that
arm to be chosen. Match guards are useful for expressing more complex ideas
than a pattern alone allows.
-->
<p><em>マッチガード</em>は、<code>match</code>アームのパターンの後に指定されるパターンマッチングとともに、
そのアームが選択されるのにマッチしなければならない追加の<code>if</code>条件です。マッチガードは、
1つのパターン単独でできるよりも複雑な考えを表現するのに役に立ちます。</p>
<!--
The condition can use variables created in the pattern. Listing 18-29 shows a
`match` where the first arm has the pattern `Some(x)` and also has a match
guard of `if x < 5`.
-->
<p>この条件は、パターンで生成された変数を使用できます。リスト18-29は、
最初のアームにパターン<code>Some(x)</code>と<code>if x &lt; 5</code>というマッチガードもある<code>match</code>を示しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num = Some(4);

match num {
    // 5未満です: {}
    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-29: Adding a match guard to a pattern</span>
-->
<p><span class="caption">リスト18-29: パターンにマッチガードを追記する</span></p>
<!--
This example will print `less than five: 4`. When `num` is compared to the
pattern in the first arm, it matches, because `Some(4)` matches `Some(x)`. Then
the match guard checks whether the value in `x` is less than `5`, and because
it is, the first arm is selected.
-->
<p>この例は、<code>less than five: 4</code>と出力します。<code>num</code>が最初のアームのパターンと比較されると、
<code>Some(4)</code>は<code>Some(x)</code>に一致するので、マッチします。そして、マッチガードが<code>x</code>の値が<code>5</code>未満か確認し、
そうなっているので、最初のアームが選択されます。</p>
<!--
If `num` had been `Some(10)` instead, the match guard in the first arm would
have been false because 10 is not less than 5. Rust would then go to the second
arm, which would match because the second arm doesn’t have a match guard and
therefore matches any `Some` variant.
-->
<p>代わりに<code>num</code>が<code>Some(10)</code>だったなら、最初のアームのマッチガードは偽になったでしょう。
10は5未満ではないからです。Rustはそうしたら2番目のアームに移動し、マッチするでしょう。
2番目のアームにはマッチガードがなく、それ故にあらゆる<code>Some</code>列挙子に一致するからです。</p>
<!--
There is no way to express the `if x < 5` condition within a pattern, so the
match guard gives us the ability to express this logic.
-->
<p>パターン内で<code>if x &lt; 5</code>という条件を表現する方法はありませんので、マッチガードにより、
この論理を表現する能力が得られるのです。</p>
<!--
In Listing 18-11, we mentioned that we could use match guards to solve our
pattern-shadowing problem. Recall that a new variable was created inside the
pattern in the `match` expression instead of using the variable outside the
`match`. That new variable meant we couldn’t test against the value of the
outer variable. Listing 18-30 shows how we can use a match guard to fix this
problem.
-->
<p>リスト18-11において、マッチガードを使用すれば、パターンがシャドーイングする問題を解決できると述べました。
<code>match</code>の外側の変数を使用するのではなく、<code>match</code>式のパターン内部では新しい変数が作られることを思い出してください。
その新しい変数は、外側の変数の値と比較することができないことを意味しました。リスト18-30は、
マッチガードを使ってこの問題を修正する方法を表示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {:?}&quot;, n),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<!--
<span class="caption">Listing 18-30: Using a match guard to test for equality
with an outer variable</span>
-->
<p><span class="caption">リスト18-30: マッチガードを使用して外側の変数と等しいか確認する</span></p>
<!--
This code will now print `Default case, x = Some(5)`. The pattern in the second
match arm doesn’t introduce a new variable `y` that would shadow the outer `y`,
meaning we can use the outer `y` in the match guard. Instead of specifying the
pattern as `Some(y)`, which would have shadowed the outer `y`, we specify
`Some(n)`. This creates a new variable `n` that doesn’t shadow anything because
there is no `n` variable outside the `match`.
-->
<p>このコードは今度は、<code>Default case, x = Some(5)</code>と出力するでしょう。2番目のマッチアームのパターンは、
外側の<code>y</code>を覆い隠してしまう新しい変数<code>y</code>を導入せず、マッチガード内で外側の<code>y</code>を使用できることを意味します。
外側の<code>y</code>を覆い隠してしまう<code>Some(y)</code>としてパターンを指定するのではなく、<code>Some(n)</code>を指定しています。
これにより、何も覆い隠さない新しい変数<code>n</code>が生成されます。<code>match</code>の外側には<code>n</code>変数は存在しないからです。</p>
<!--
The match guard `if n == y` is not a pattern and therefore doesn’t introduce
new variables. This `y` *is* the outer `y` rather than a new shadowed `y`, and
we can look for a value that has the same value as the outer `y` by comparing
`n` to `y`.
-->
<p>マッチガードの<code>if n == y</code>はパターンではなく、故に新しい変数を導入しません。この<code>y</code>は、
新しいシャドーイングされた<code>y</code>ではなく、外側の<code>y</code><em>であり</em>、<code>n</code>と<code>y</code>を比較することで、
外側の<code>y</code>と同じ値を探すことができます。</p>
<!--
You can also use the *or* operator `|` in a match guard to specify multiple
patterns; the match guard condition will apply to all the patterns. Listing
18-31 shows the precedence of combining a match guard with a pattern that uses
`|`. The important part of this example is that the `if y` match guard applies
to `4`, `5`, *and* `6`, even though it might look like `if y` only applies to
`6`.
-->
<p>また、マッチガードで<em>or</em>演算子の<code>|</code>を使用して複数のパターンを指定することもできます;
マッチガードの条件は全てのパターンに適用されます。リスト18-31は、
<code>|</code>を使用するパターンとマッチガードを組み合わせる優先度を示しています。この例で重要な部分は、
<code>if y</code>は<code>6</code>にしか適用されないように見えるのに、<code>if y</code>マッチガードが<code>4</code>、<code>5</code>、<em>そして</em><code>6</code>に適用されることです。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 4;
let y = false;

match x {
    // はい
    4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
    // いいえ
    _ =&gt; println!(&quot;no&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-31: Combining multiple patterns with a match
guard</span>
-->
<p><span class="caption">リスト18-31: 複数のパターンとマッチガードを組み合わせる</span></p>
<!--
The match condition states that the arm only matches if the value of `x` is
equal to `4`, `5`, or `6` *and* if `y` is `true`. When this code runs, the
pattern of the first arm matches because `x` is `4`, but the match guard `if y`
is false, so the first arm is not chosen. The code moves on to the second arm,
which does match, and this program prints `no`. The reason is that the `if`
condition applies to the whole pattern `4 | 5 | 6`, not only to the last value
`6`. In other words, the precedence of a match guard in relation to a pattern
behaves like this:
-->
<p>マッチの条件は、<code>x</code>の値が<code>4</code>、<code>5</code>、<code>6</code>に等しく<em>かつ</em><code>y</code>が<code>true</code>の場合だけにアームがマッチすると宣言しています。
このコードが走ると、最初のアームのパターンは<code>x</code>が<code>4</code>なので、合致しますが、マッチガード<code>if y</code>は偽なので、
最初のアームは選ばれません。コードは2番目のアームに移動して、これがマッチし、このプログラムは<code>no</code>と出力します。
理由は、<code>if</code>条件が最後の値の<code>6</code>だけでなく、パターン全体<code>4 | 5 | 6</code>に適用されるからです。
言い換えると、パターンと関わるマッチガードの優先度は、以下のように振る舞います:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<!--
rather than this:
-->
<p>以下のようにではありません:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<!--
After running the code, the precedence behavior is evident: if the match guard
were applied only to the final value in the list of values specified using the
`|` operator, the arm would have matched and the program would have printed
`yes`.
-->
<p>コードを実行後には、優先度の動作は明らかになります: マッチガードが<code>|</code>演算子で指定される値のリストの最後の値にしか適用されないなら、
アームはマッチし、プログラムは<code>yes</code>と出力したでしょう。</p>
<!--
### `@` Bindings
-->
<h3 id="束縛"><a class="header" href="#束縛"><code>@</code>束縛</a></h3>
<!--
The *at* operator (`@`) lets us create a variable that holds a value at the
same time we’re testing that value to see whether it matches a pattern. Listing
18-32 shows an example where we want to test that a `Message::Hello` `id` field
is within the range `3..=7`. But we also want to bind the value to the variable
`id_variable` so we can use it in the code associated with the arm. We could
name this variable `id`, the same as the field, but for this example we’ll use
a different name.
-->
<p><em>at</em>演算子(<code>@</code>)により、値を保持する変数を生成するのと同時にその値がパターンに一致するかを調べることができます。
リスト18-32は、<code>Message::Hello</code>の<code>id</code>フィールドが範囲<code>3..=7</code>にあるかを確かめたいという例です。
しかし、アームに紐づいたコードで使用できるように変数<code>id_variable</code>に値を束縛もしたいです。この変数をフィールドと同じ、
<code>id</code>と名付けることもできますが、この例では異なる名前にします。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id_variable @ 3..=7 } =&gt; {
        // 範囲内のidが見つかりました: {}
        println!(&quot;Found an id in range: {}&quot;, id_variable)
    },
    Message::Hello { id: 10..=12 } =&gt; {
        // 別の範囲内のidが見つかりました
        println!(&quot;Found an id in another range&quot;)
    },
    Message::Hello { id } =&gt; {
        // それ以外のidが見つかりました
        println!(&quot;Found some other id: {}&quot;, id)
    },
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 18-32: Using `@` to bind to a value in a pattern
while also testing it</span>
-->
<p><span class="caption"><code>@</code>を使用してテストしつつ、パターンの値に束縛する</span></p>
<!--
This example will print `Found an id in range: 5`. By specifying `id_variable
@` before the range `3..=7`, we’re capturing whatever value matched the range
while also testing that the value matched the range pattern.
-->
<p>この例は、<code>Found an id in range: 5</code>と出力します。範囲<code>3..=7</code>の前に<code>id_variable @</code>と指定することで、
値が範囲パターンに一致することを確認しつつ、範囲にマッチしたどんな値も捕捉しています。</p>
<!--
In the second arm, where we only have a range specified in the pattern, the code
associated with the arm doesn’t have a variable that contains the actual value
of the `id` field. The `id` field’s value could have been 10, 11, or 12, but
the code that goes with that pattern doesn’t know which it is. The pattern code
isn’t able to use the value from the `id` field, because we haven’t saved the
`id` value in a variable.
-->
<p>パターンで範囲しか指定していない2番目のアームでは、アームに紐づいたコードに<code>id</code>フィールドの実際の値を含む変数はありません。
<code>id</code>フィールドの値は10、11、12だった可能性があるでしょうが、そのパターンに来るコードは、
どれなのかわかりません。パターンのコードは<code>id</code>フィールドの値を使用することは叶いません。
<code>id</code>の値を変数に保存していないからです。</p>
<!--
In the last arm, where we’ve specified a variable without a range, we do have
the value available to use in the arm’s code in a variable named `id`. The
reason is that we’ve used the struct field shorthand syntax. But we haven’t
applied any test to the value in the `id` field in this arm, as we did with the
first two arms: any value would match this pattern.
-->
<p>範囲なしに変数を指定している最後のアームでは、確かにアームのコードで使用可能な値が<code>id</code>という変数にあります。
理由は、構造体フィールド省略記法を使ったからです。しかし、このアームで<code>id</code>フィールドの値に対して、
最初の2つのアームのようには、確認を行っていません: どんな値でも、このパターンに一致するでしょう。</p>
<!--
Using `@` lets us test a value and save it in a variable within one pattern.
-->
<p><code>@</code>を使用することで、値を検査しつつ、1つのパターン内で変数に保存させてくれるのです。</p>
<!--
## Summary
-->
<h2 id="まとめ-17"><a class="header" href="#まとめ-17">まとめ</a></h2>
<!--
Rust’s patterns are very useful in that they help distinguish between different
kinds of data. When used in `match` expressions, Rust ensures your patterns
cover every possible value, or your program won’t compile. Patterns in `let`
statements and function parameters make those constructs more useful, enabling
the destructuring of values into smaller parts at the same time as assigning to
variables. We can create simple or complex patterns to suit our needs.
-->
<p>Rustのパターンは、異なる種類のデータを区別するのに役立つという点でとても有用です。<code>match</code>式で使用されると、
コンパイラはパターンが全ての可能性を網羅しているか保証し、そうでなければプログラムはコンパイルできません。
<code>let</code>文や関数の引数のパターンは、その構文をより有用にし、値を分配して小さな部品にすると同時に変数に代入できるようにしてくれます。
単純だったり複雑だったりするパターンを生成してニーズに合わせることができます。</p>
<!--
Next, for the penultimate chapter of the book, we’ll look at some advanced
aspects of a variety of Rust’s features.
-->
<p>次の本書の末尾から2番目の章では、Rustの多彩な機能の高度な視点に目を向けます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Advanced Features
-->
<h1 id="高度な機能"><a class="header" href="#高度な機能">高度な機能</a></h1>
<!--
By now, you’ve learned the most commonly used parts of the Rust programming
language. Before we do one more project in Chapter 20, we’ll look at a few
aspects of the language you might run into every once in a while. You can use
this chapter as a reference for when you encounter any unknowns when using
Rust. The features you’ll learn to use in this chapter are useful in very
specific situations. Although you might not reach for them often, we want to
make sure you have a grasp of all the features Rust has to offer.
-->
<p>今までに、Rustプログラミング言語の最もよく使われる部分を学んできました。第20章でもう1つ別のプロジェクトを行う前に、
時折遭遇する言語の側面をいくつか見ましょう。この章は、Rustを使用する際に知らないことに遭遇した時に参考にすることができます。
この章で使用することを学ぶ機能は、かなり限定的な場面でしか役に立ちません。あまり頻繁には手を伸ばすことがない可能性はありますが、
Rustが提供しなければならない機能全ての概要を確かに把握してもらいたいのです。</p>
<!--
In this chapter, we’ll cover:
-->
<p>この章で講義するのは:</p>
<!--
* Unsafe Rust: how to opt out of some of Rust’s guarantees and take
  responsibility for manually upholding those guarantees
* Advanced traits: associated types, default type parameters, fully qualified
  syntax, supertraits, and the newtype pattern in relation to traits
* Advanced types: more about the newtype pattern, type aliases, the never type,
  and dynamically sized types
* Advanced functions and closures: function pointers and returning closures
* Macros: ways to define code that defines more code at compile time
-->
<ul>
<li>Unsafe Rust: Rustの保証の一部を抜けてその保証を手動で保持する責任を負う方法</li>
<li>高度なトレイト: 関連型、デフォルト型引数、フルパス記法、スーパートレイト、トレイトに関連するニュータイプパターン</li>
<li>高度な型: ニュータイプパターンについてもっと、型エイリアス、never型、動的サイズ決定型</li>
<li>高度な関数とクロージャ: 関数ポインタとクロージャの返却</li>
<li>マクロ: コンパイル時に、より多くのコードを定義するコードを定義する方法</li>
</ul>
<!--
It’s a panoply of Rust features with something for everyone! Let’s dive in!
-->
<p>皆さんのための何かがあるRustの機能の盛大な儀式です！さあ、飛び込みましょう！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Unsafe Rust
-->
<h2 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h2>
<!--
All the code we’ve discussed so far has had Rust’s memory safety guarantees
enforced at compile time. However, Rust has a second language hidden inside it
that doesn’t enforce these memory safety guarantees: it’s called *unsafe Rust*
and works just like regular Rust, but gives us extra superpowers.
-->
<p>ここまでに議論してきたコードは全て、Rustのメモリ安全保証がコンパイル時に強制されていました。しかしながら、
Rustには、これらのメモリ安全保証を強制しない第2の言語が中に隠されています: それは<em>unsafe Rust</em>と呼ばれ、
普通のRustのように動きますが、おまけの強大な力を与えてくれます。</p>
<!--
Unsafe Rust exists because, by nature, static analysis is conservative. When
the compiler tries to determine whether or not code upholds the guarantees,
it’s better for it to reject some valid programs rather than accept some
invalid programs. Although the code might be okay, as far as Rust is able to
tell, it’s not! In these cases, you can use unsafe code to tell the compiler,
“Trust me, I know what I’m doing.” The downside is that you use it at our own
risk: if you use unsafe code incorrectly, problems due to memory unsafety, such
as null pointer dereferencing, can occur.
-->
<p>静的解析は原理的に保守的なので、unsafe Rustが存在します。コードが保証を保持しているかコンパイラが決定しようとする際、
なんらかの不正なプログラムを受け入れるよりも合法なプログラムを拒否したほうがいいのです。コードは大丈夫かもしれないけれど、
コンパイラにわかる範囲ではダメなのです！このような場合、unsafeコードを使用してコンパイラに「信じて！何をしているかわかってるよ」と教えられます。
欠点は、自らのリスクで使用することです: unsafeコードを誤って使用したら、
nullポインタ参照外しなどのメモリ非安全に起因する問題が起こることもあるのです。</p>
<!--
Another reason Rust has an unsafe alter ego is that the underlying computer
hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you
couldn’t do certain tasks. Rust needs to allow you to do low-level systems
programming, such as directly interacting with the operating system or even
writing your own operating system. Working with low-level systems programming
is one of the goals of the language. Let’s explore what we can do with unsafe
Rust and how to do it.
-->
<p>Rustにunsafeな分身がある別の理由は、根本にあるコンピュータのハードウェアが本質的にunsafeだからです。
Rustがunsafeな処理を行わせてくれなかったら、特定の仕事を行えないでしょう。Rustは、低レベルなシステムプログラミングを許可する必要があります。
直接OSと相互作用したり、独自のOSを書くことさえもそうです。低レベルなシステムプログラミングに取り組むことは、
言語の目標の1つなのです。unsafe Rustでできることとその方法を探究しましょう。</p>
<!--
### Unsafe Superpowers
-->
<h3 id="unsafeの強大な力superpower"><a class="header" href="#unsafeの強大な力superpower">unsafeの強大な力(superpower)</a></h3>
<!--
To switch to unsafe Rust, use the `unsafe` keyword and then start a new block
that holds the unsafe code. You can take four actions in unsafe Rust, called
*unsafe superpowers*, that you can’t in safe Rust. Those superpowers include
the ability to:
-->
<p>unsafe Rustに切り替えるには、<code>unsafe</code>キーワードを使用し、それからunsafeコードを保持する新しいブロックを開始してください。
safe Rustでは行えない4つの行動をunsafe Rustでは行え、これは<em>unsafe superpowers</em>と呼ばれます。
そのsuperpowerには、以下の能力が含まれています:</p>
<!--
* Dereference a raw pointer
* Call an unsafe function or method
* Access or modify a mutable static variable
* Implement an unsafe trait
-->
<ul>
<li>生ポインタを参照外しすること</li>
<li>unsafeな関数やメソッドを呼ぶこと</li>
<li>可変で静的な変数にアクセスしたり変更すること</li>
<li>unsafeなトレイトを実装すること</li>
</ul>
<!--
It’s important to understand that `unsafe` doesn’t turn off the borrow checker
or disable any other of Rust’s safety checks: if you use a reference in unsafe
code, it will still be checked. The `unsafe` keyword only gives you access to
these four features that are then not checked by the compiler for memory
safety. You'll still get some degree of safety inside of an unsafe block.
-->
<p><code>unsafe</code>は、借用チェッカーや他のRustの安全性チェックを無効にしないことを理解するのは重要なことです:
unsafeコードで参照を使用しても、チェックはされます。<code>unsafe</code>キーワードにより、これら4つの機能にアクセスできるようになり、
その場合、コンパイラによってこれらのメモリ安全性は確認されないのです。unsafeブロック内でも、ある程度の安全性は得られます。</p>
<!--
In addition, `unsafe` does not mean the code inside the block is necessarily
dangerous or that it will definitely have memory safety problems: the intent is
that as the programmer, you’ll ensure the code inside an `unsafe` block will
access memory in a valid way.
-->
<p>また、unsafeは、そのブロックが必ずしも危険だったり、絶対メモリ安全上の問題を抱えていることを意味するものではありません:
その意図は、プログラマとして<code>unsafe</code>ブロック内のコードがメモリに合法的にアクセスすることを保証することです。</p>
<!--
People are fallible, and mistakes will happen, but by requiring these four
unsafe operations to be inside blocks annotated with `unsafe` you’ll know that
any errors related to memory safety must be within an `unsafe` block. Keep
`unsafe` blocks small; you’ll be thankful later when you investigate memory
bugs.
-->
<p>人間は失敗をするもので、間違いも起きますが、これら4つのunsafeな処理を<code>unsafe</code>で注釈されたブロックに入れる必要があることで、
メモリ安全性に関するどんなエラーも<code>unsafe</code>ブロック内にあるに違いないと知ります。<code>unsafe</code>ブロックは小さくしてください;
メモリのバグを調査するときに感謝することになるでしょう。</p>
<!--
To isolate unsafe code as much as possible, it’s best to enclose unsafe code
within a safe abstraction and provide a safe API, which we’ll discuss later in
the chapter when we examine unsafe functions and methods. Parts of the standard
library are implemented as safe abstractions over unsafe code that has been
audited. Wrapping unsafe code in a safe abstraction prevents uses of `unsafe`
from leaking out into all the places that you or your users might want to use
the functionality implemented with `unsafe` code, because using a safe
abstraction is safe.
-->
<p>unsafeなコードをできるだけ分離するために、unsafeなコードを安全な抽象の中に閉じ込め、安全なAPIを提供するのが最善です。
これについては、後ほどunsafeな関数とメソッドを調査する際に議論します。標準ライブラリの一部は、
検査されたunsafeコードの安全な抽象として実装されています。安全な抽象にunsafeなコードを包むことで、
<code>unsafe</code>が、あなたやあなたのユーザが<code>unsafe</code>コードで実装された機能を使いたがる可能性のある箇所全部に漏れ出ることを防ぎます。
安全な抽象を使用することは、安全だからです。</p>
<!--
Let’s look at each of the four unsafe superpowers in turn. We’ll also look at
some abstractions that provide a safe interface to unsafe code.
-->
<p>4つのunsafeなsuperpowerを順に見ていきましょう。unsafeなコードへの安全なインターフェイスを提供する一部の抽象化にも目を向けます。</p>
<!--
### Dereferencing a Raw Pointer
-->
<h3 id="生ポインタを参照外しする"><a class="header" href="#生ポインタを参照外しする">生ポインタを参照外しする</a></h3>
<!--
In Chapter 4, in the “Dangling References” section, we mentioned that the
compiler ensures references are always valid. Unsafe Rust has two new types
called *raw pointers* that are similar to references. As with references, raw
pointers can be immutable or mutable and are written as `*const T` and `*mut
T`, respectively. The asterisk isn’t the dereference operator; it’s part of the
type name. In the context of raw pointers, *immutable* means that the pointer
can’t be directly assigned to after being dereferenced.
-->
<p>第4章の「ダングリング参照」節で、コンパイラは、参照が常に有効であることを保証することに触れました。
unsafe Rustには参照に類似した<em>生ポインタ</em>と呼ばれる2つの新しい型があります。参照同様、
生ポインタも不変や可変になり得て、それぞれ<code>*const T</code>と<code>*mut T</code>と表記されます。このアスタリスクは、参照外し演算子ではありません;
型名の一部です。生ポインタの文脈では、<em>不変</em>は、参照外し後に直接ポインタに代入できないことを意味します。</p>
<!--
Different from references and smart pointers, raw pointers:
-->
<p>参照やスマートポインタと異なり、生ポインタは:</p>
<!--
* Are allowed to ignore the borrowing rules by having both immutable and
mutable pointers or multiple mutable pointers to the same location
* Aren’t guaranteed to point to valid memory
* Are allowed to be null
* Don’t implement any automatic cleanup
-->
<ul>
<li>同じ場所への不変と可変なポインタや複数の可変なポインタが存在することで借用規則を無視できる</li>
<li>有効なメモリを指しているとは保証されない</li>
<li>nullの可能性がある</li>
<li>自動的な片付けは実装されていない</li>
</ul>
<!--
By opting out of having Rust enforce these guarantees, you can give up
the guaranteed safety in exchange for greater performance or the ability to
interface with another language or hardware where Rust’s guarantees don’t apply.
-->
<p>これらの保証をコンパイラに強制させることから抜けることで、保証された安全性を諦めてパフォーマンスを向上させたり、
Rustの保証が適用されない他の言語やハードウェアとのインターフェイスの能力を得ることができます。</p>
<!--
Listing 19-1 shows how to create an immutable and a mutable raw pointer from
references.
-->
<p>リスト19-1は、参照から不変と可変な生ポインタを生成する方法を示しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-1: Creating raw pointers from references</span>
-->
<p><span class="caption">リスト19-1: 参照から生ポインタを生成する</span></p>
<!--
Notice that we don’t include the `unsafe` keyword in this code. We can create
raw pointers in safe code; we just can’t dereference raw pointers outside an
unsafe block, as you’ll see in a bit.
-->
<p>このコードには<code>unsafe</code>キーワードを含めていないことに注意してください。safeコードで生ポインタを生成できます;
もうすぐわかるように、unsafeブロックの外では、生ポインタを参照外しできないだけなのです。</p>
<!--
We’ve created raw pointers by using `as` to cast an immutable and a mutable
reference into their corresponding raw pointer types. Because we created them
directly from references guaranteed to be valid, we know these particular raw
pointers are valid, but we can’t make that assumption about just any raw
pointer.
-->
<p><code>as</code>を使って不変と可変な参照を対応する生ポインタの型にキャストして生ポインタを生成しました。
有効であることが保証される参照から直接生ポインタを生成したので、これらの特定の生ポインタは有効であることがわかりますが、
その前提をあらゆる生ポインタに敷くことはできません。</p>
<!--
Next, we’ll create a raw pointer whose validity we can’t be so certain of.
Listing 19-2 shows how to create a raw pointer to an arbitrary location in
memory. Trying to use arbitrary memory is undefined: there might be data at
that address or there might not, the compiler might optimize the code so there
is no memory access, or the program might error with a segmentation fault.
Usually, there is no good reason to write code like this, but it is possible.
-->
<p>次に、有効であることが確信できない生ポインタを生成します。リスト19-2は、メモリの任意の箇所を指す生ポインタの生成法を示しています。
任意のメモリを使用しようとすることは未定義です: そのアドレスにデータがある可能性もあるし、ない可能性もあり、
コンパイラがコードを最適化してメモリアクセスがなくなる可能性もあるし、プログラムがセグメンテーションフォールトでエラーになる可能性もあります。
通常、このようなコードを書くいい理由はありませんが、可能ではあります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let address = 0x012345usize;
let r = address as *const i32;
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-2: Creating a raw pointer to an arbitrary
memory address</span>
-->
<p><span class="caption">リスト19-2: 任意のメモリアドレスへの生ポインタを生成する</span></p>
<!--
Recall that we can create raw pointers in safe code, but we can’t *dereference*
raw pointers and read the data being pointed to. In Listing 19-3, we use the
dereference operator `*` on a raw pointer that requires an `unsafe` block.
-->
<p>safeコードで生ポインタを生成できるけれども、生ポインタを<em>参照外し</em>して指しているデータを読むことはできないことを思い出してください。
リスト19-3では、<code>unsafe</code>ブロックが必要になる参照外し演算子の<code>*</code>を生ポインタに使っています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

unsafe {
    println!(&quot;r1 is: {}&quot;, *r1);
    println!(&quot;r2 is: {}&quot;, *r2);
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-3: Dereferencing raw pointers within an
`unsafe` block</span>
-->
<p><span class="caption">リスト19-3: <code>unsafe</code>ブロック内で生ポインタを参照外しする</span></p>
<!--
Creating a pointer does no harm; it’s only when we try to access the value that
it points at that we might end up dealing with an invalid value.
-->
<p>ポインタの生成は害を及ぼしません; 問題が起こり得るのはポインタが指している値にアクセスしようとするときのみで、この際に無効な値を扱うことになる可能性があります。</p>
<!--
Note also that in Listing 19-1 and 19-3, we created `*const i32` and `*mut i32`
raw pointers that both pointed to the same memory location, where `num` is
stored. If we instead tried to create an immutable and a mutable reference to
`num`, the code would not have compiled because Rust’s ownership rules don’t
allow a mutable reference at the same time as any immutable references. With
raw pointers, we can create a mutable pointer and an immutable pointer to the
same location and change data through the mutable pointer, potentially creating
a data race. Be careful!
-->
<p>また、リスト19-1とリスト19-3では、
<code>num</code>が格納されている同じメモリ上の場所を両方とも指す<code>*const i32</code>と<code>*mut i32</code>の生ポインタを生成したことに注目してください。
代わりに<code>num</code>への不変と可変な参照を生成しようとしたら、コードはコンパイルできなかったでしょう。
Rustの所有権規則により、不変参照と可変参照を同時に存在させられないからです。生ポインタなら、
同じ場所への可変なポインタと不変なポインタを生成でき、可変なポインタを通してデータを変更し、データ競合を引き起こす可能性があります。
気を付けてください！</p>
<!--
With all of these dangers, why would you ever use raw pointers? One major use
case is when interfacing with C code, as you’ll see in the next section,
“Calling an Unsafe Function or Method.” Another case is when building up safe
abstractions that the borrow checker doesn’t understand. We’ll introduce unsafe
functions and then look at an example of a safe abstraction that uses unsafe
code.
-->
<p>これらの危険がありながら、一体何故生ポインタを使うのでしょうか？主なユースケースの1つは、次の節「unsafeな関数やメソッドを呼ぶ」で見るように、
Cコードとのインターフェイスです。別のユースケースは、借用チェッカーには理解できない安全な抽象を構成する時です。
unsafeな関数を導入し、それからunsafeコードを使用する安全な抽象の例に目を向けます。</p>
<!--
### Calling an Unsafe Function or Method
-->
<h3 id="unsafeな関数やメソッドを呼ぶ"><a class="header" href="#unsafeな関数やメソッドを呼ぶ">unsafeな関数やメソッドを呼ぶ</a></h3>
<!--
The second type of operation that requires an unsafe block is calls to unsafe
functions. Unsafe functions and methods look exactly like regular functions and
methods, but they have an extra `unsafe` before the rest of the definition. The
`unsafe` keyword in this context indicates the function has requirements we
need to uphold when we call this function, because Rust can’t guarantee we’ve
met these requirements. By calling an unsafe function within an `unsafe` block,
we’re saying that we’ve read this function’s documentation and take
responsibility for upholding the function’s contracts.
-->
<p>unsafeブロックが必要になる2番目の処理は、unsafe関数の呼び出しです。unsafeな関数やメソッドも見た目は、
普通の関数やメソッドと全く同じですが、残りの定義の前に追加の<code>unsafe</code>があります。この文脈での<code>unsafe</code>キーワードは、
この関数を呼ぶ際に保持しておく必要のある要求が関数にあることを示唆します。コンパイラには、
この要求を満たしているか保証できないからです。<code>unsafe</code>ブロックでunsafeな関数を呼び出すことで、
この関数のドキュメンテーションを読み、関数の契約を守っているという責任を取ると宣言します。</p>
<!--
Here is an unsafe function named `dangerous` that doesn’t do anything in its
body:
-->
<p>こちらは、本体で何もしない<code>dangerous</code>というunsafeな関数です:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn dangerous() {}

unsafe {
    dangerous();
}
<span class="boring">}
</span></code></pre></pre>
<!--
We must call the `dangerous` function within a separate `unsafe` block. If we
try to call `dangerous` without the `unsafe` block, we’ll get an error:
-->
<p>個別の<code>unsafe</code>ブロックで<code>dangerous</code>関数を呼ばなければなりません。<code>unsafe</code>ブロックなしで<code>dangerous</code>を呼ぼうとすれば、
エラーになるでしょう:</p>
<pre><code class="language-text">error[E0133]: call to unsafe function requires unsafe function or block
(エラー: unsafe関数の呼び出しには、unsafeな関数かブロックが必要です)
 --&gt;
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
</code></pre>
<!--
By inserting the `unsafe` block around our call to `dangerous`, we’re asserting
to Rust that we’ve read the function’s documentation, we understand how to use
it properly, and we’ve verified that we’re fulfilling the contract of the
function.
-->
<p><code>dangerous</code>への呼び出しの周りに<code>unsafe</code>ブロックを挿入することで、コンパイラに関数のドキュメンテーションを読み、
適切に使用する方法を理解したことをアサートし、関数の契約を満たしていると実証しました。</p>
<!--
Bodies of unsafe functions are effectively `unsafe` blocks, so to perform other
unsafe operations within an unsafe function, we don’t need to add another
`unsafe` block.
-->
<p>unsafe関数の本体は、実効的に<code>unsafe</code>ブロックになるので、unsafe関数内でunsafeな別の処理を行うのに、
別の<code>unsafe</code>ブロックは必要ないのです。</p>
<!--
#### Creating a Safe Abstraction over Unsafe Code
-->
<h4 id="unsafeコードに安全な抽象を行う"><a class="header" href="#unsafeコードに安全な抽象を行う">unsafeコードに安全な抽象を行う</a></h4>
<!--
Just because a function contains unsafe code doesn’t mean we need to mark the
entire function as unsafe. In fact, wrapping unsafe code in a safe function is
a common abstraction. As an example, let’s study a function from the standard
library, `split_at_mut`, that requires some unsafe code and explore how we
might implement it. This safe method is defined on mutable slices: it takes one
slice and makes it two by splitting the slice at the index given as an
argument. Listing 19-4 shows how to use `split_at_mut`.
-->
<p>関数がunsafeなコードを含んでいるだけで関数全体をunsafeでマークする必要があることにはなりません。
事実、安全な関数でunsafeなコードをラップすることは一般的な抽象化です。例として、
なんらかのunsafeコードが必要になる標準ライブラリの関数<code>split_at_mut</code>を学び、その実装方法を探究しましょう。
この安全なメソッドは、可変なスライスに定義されています: スライスを1つ取り、引数で与えられた添え字でスライスを分割して2つにします。
リスト19-4は、<code>split_at_mut</code>の使用法を示しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &amp;mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &amp;mut [1, 2, 3]);
assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-4: Using the safe `split_at_mut`
function</span>
-->
<p><span class="caption">リスト19-4: 安全な<code>split_at_mut</code>関数を使用する</span></p>
<!--
We can’t implement this function using only safe Rust. An attempt might look
something like Listing 19-5, which won’t compile. For simplicity, we’ll
implement `split_at_mut` as a function rather than a method and only for slices
of `i32` values rather than for a generic type `T`.
-->
<p>この関数をsafe Rustだけを使用して実装することはできません。試みは、リスト19-5のようになる可能性がありますが、コンパイルできません。
簡単のため、<code>split_at_mut</code>をメソッドではなく関数として実装し、ジェネリックな型<code>T</code>ではなく、<code>i32</code>のスライス用に実装します。</p>
<pre><code class="language-rust ignore">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid],
     &amp;mut slice[mid..])
}
</code></pre>
<!--
<span class="caption">Listing 19-5: An attempted implementation of
`split_at_mut` using only safe Rust</span>
-->
<p><span class="caption">リスト19-5: safe Rustだけを使用した<code>split_at_mut</code>の未遂の実装</span></p>
<!--
This function first gets the total length of the slice. Then it asserts that
the index given as a parameter is within the slice by checking whether it’s
less than or equal to the length. The assertion means that if we pass an index
that is greater than the index to split the slice at, the function will panic
before it attempts to use that index.
-->
<p>この関数はまず、スライスの全体の長さを得ます。それから引数で与えられた添え字が長さ以下であるかを確認してスライス内にあることをアサートします。
このアサートは、スライスを分割する添え字よりも大きい添え字を渡したら、その添え字を使用しようとする前に関数がパニックすることを意味します。</p>
<!--
Then we return two mutable slices in a tuple: one from the start of the
original slice to the `mid` index and another from `mid` to the end of the
slice.
-->
<p>そして、2つの可変なスライスをタプルで返します: 1つは元のスライスの最初から<code>mid</code>添え字まで、
もう一方は、<code>mid</code>からスライスの終わりまでです。</p>
<!--
When we try to compile the code in Listing 19-5, we’ll get an error.
-->
<p>リスト19-5のコードのコンパイルを試みると、エラーになるでしょう。</p>
<pre><code class="language-text">error[E0499]: cannot borrow `*slice` as mutable more than once at a time
(エラー: 一度に2回以上、`*slice`を可変で借用できません)
 --&gt;
  |
6 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
</code></pre>
<!--
Rust’s borrow checker can’t understand that we’re borrowing different parts of
the slice; it only knows that we’re borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay because the two
slices aren’t overlapping, but Rust isn’t smart enough to know this. When we
know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.
-->
<p>Rustの借用チェッカーには、スライスの異なる部分を借用していることが理解できないのです; 
同じスライスから2回借用していることだけ知っています。2つのスライスが被らないので、
スライスの異なる部分を借用することは、根本的に大丈夫なのですが、コンパイラはこれを知れるほど賢くありません。
プログラマにはコードが大丈夫とわかるのに、コンパイラにはわからないのなら、unsafeコードに手を伸ばすタイミングです。</p>
<!--
Listing 19-6 shows how to use an `unsafe` block, a raw pointer, and some calls
to unsafe functions to make the implementation of `split_at_mut` work.
-->
<p>リスト19-6は<code>unsafe</code>ブロック、生ポインタ、unsafe関数への呼び出しをして<code>split_at_mut</code>の実装が動くようにする方法を示しています。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-6: Using unsafe code in the implementation of
the `split_at_mut` function</span>
-->
<p><span class="caption">リスト19-6: <code>split_at_mut</code>関数の実装でunsafeコードを使用する</span></p>
<!--
Recall from “The Slice Type” section in Chapter 4 that slices are a pointer to
some data and the length of the slice. We use the `len` method to get the
length of a slice and the `as_mut_ptr` method to access the raw pointer of a
slice. In this case, because we have a mutable slice to `i32` values,
`as_mut_ptr` returns a raw pointer with the type `*mut i32`, which we’ve stored
in the variable `ptr`.
-->
<p>第4章の「スライス型」節から、スライスはなんらかのデータへのポインタとスライスの長さであることを思い出してください。
<code>len</code>メソッドを使用してスライスの長さを得て、<code>as_mut_ptr</code>メソッドを使用してスライスの生ポインタにアクセスしています。
この場合、<code>i32</code>値の可変スライスがあるので、<code>as_mut_ptr</code>は型<code>*mut i32</code>の生ポインタを返し、これを変数<code>ptr</code>に格納しました。</p>
<!--
We keep the assertion that the `mid` index is within the slice. Then we get to
the unsafe code: the `slice::from_raw_parts_mut` function takes a raw pointer
and a length, and it creates a slice. We use this function to create a slice
that starts from `ptr` and is `mid` items long. Then we call the `offset`
method on `ptr` with `mid` as an argument to get a raw pointer that starts at
`mid`, and we create a slice using that pointer and the remaining number of
items after `mid` as the length.
-->
<p><code>mid</code>添え字がスライス内にあるかというアサートを残しています。そして、unsafeコードに到達します:
<code>slice::from_raw_parts_mut</code>関数は、生ポインタと長さを取り、スライスを生成します。この関数を使って、
<code>ptr</code>から始まり、<code>mid</code>の長さのスライスを生成しています。それから<code>ptr</code>に<code>mid</code>を引数として<code>offset</code>メソッドを呼び出し、
<code>mid</code>で始まる生ポインタを得て、そのポインタと<code>mid</code>の後の残りの要素数を長さとして使用してスライスを生成しています。</p>
<!--
The function `slice::from_raw_parts_mut` is unsafe because it takes a raw
pointer and must trust that this pointer is valid. The `offset` method on raw
pointers is also unsafe, because it must trust that the offset location is also
a valid pointer. Therefore, we had to put an `unsafe` block around our calls to
`slice::from_raw_parts_mut` and `offset` so we could call them. By looking at
the code and by adding the assertion that `mid` must be less than or equal to
`len`, we can tell that all the raw pointers used within the `unsafe` block
will be valid pointers to data within the slice. This is an acceptable and
appropriate use of `unsafe`.
-->
<p>関数<code>slice::from_raw_parts_mut</code>は、unsafeです。何故なら、生ポインタを取り、このポインタが有効であることを信用しなければならないからです。
生ポインタの<code>offset</code>メソッドもunsafeです。オフセット位置もまた有効なポインタであることを信用しなければならないからです。
故に、<code>slice::from_raw_parts_mut</code>と<code>offset</code>を呼べるように、その呼び出しの周りに<code>unsafe</code>ブロックを置かなければならなかったのです。
コードを眺めて<code>mid</code>が<code>len</code>以下でなければならないとするアサートを追加することで、
<code>unsafe</code>ブロック内で使用されている生ポインタが全てスライス内のデータへの有効なポインタであることがわかります。
これは、受け入れられ、適切な<code>unsafe</code>の使用法です。</p>
<!--
Note that we don’t need to mark the resulting `split_at_mut` function as
`unsafe`, and we can call this function from safe Rust. We’ve created a safe
abstraction to the unsafe code with an implementation of the function that uses
`unsafe` code in a safe way, because it creates only valid pointers from the
data this function has access to.
-->
<p>できあがった<code>split_at_mut</code>関数を<code>unsafe</code>でマークする必要はなく、この関数をsafe Rustから呼び出せることに注意してください。
<code>unsafe</code>コードを安全に使用する関数の実装で、unsafeコードへの安全な抽象化を行いました。
この関数がアクセスするデータからの有効なポインタだけを生成するからです。</p>
<!--
In contrast, the use of `slice::from_raw_parts_mut` in Listing 19-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice 10,000 items long:
-->
<p>対照的に、リスト19-7の<code>slice::from_raw_parts_mut</code>の使用は、スライスが使用されるとクラッシュする可能性が高いでしょう。
このコードは任意のメモリアドレスを取り、10,000要素の長さのスライスを生成します:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice;

let address = 0x012345usize;
let r = address as *mut i32;

let slice = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-7: Creating a slice from an arbitrary memory
location</span>
-->
<p><span class="caption">リスト19-7: 任意のメモリアドレスからスライスを生成する</span></p>
<!--
We don’t own the memory at this arbitrary location, and there is no guarantee
that the slice this code creates contains valid `i32` values. Attempting to use
`slice` as though it’s a valid slice results in undefined behavior.
-->
<p>この任意の場所のメモリは所有していなく、このコードが生成するスライスに有効な<code>i32</code>値が含まれる保証もありません。
<code>slice</code>を有効なスライスであるかのように使用しようとすると、未定義動作に陥ります。</p>
<!--
#### Using `extern` Functions to Call External Code
-->
<h4 id="extern関数を使用して外部のコードを呼び出す"><a class="header" href="#extern関数を使用して外部のコードを呼び出す"><code>extern</code>関数を使用して、外部のコードを呼び出す</a></h4>
<!--
Sometimes, your Rust code might need to interact with code written in another
language. For this, Rust has a keyword, `extern`, that facilitates the creation
and use of a *Foreign Function Interface (FFI)*. An FFI is a way for a
programming language to define functions and enable a different (foreign)
programming language to call those functions.
-->
<p>時として、自分のRustコードが他の言語で書かれたコードと相互作用する必要が出てくる可能性があります。このために、
Rustには<code>extern</code>というキーワードがあり、これは、
<em>FFI</em>(Foreign Function Interface: 外部関数インターフェイス)の生成と使用を容易にします。
FFIは、あるプログラミング言語に関数を定義させ、異なる(外部の)プログラミング言語にそれらの関数を呼び出すことを可能にする方法です</p>
<!--
Listing 19-8 demonstrates how to set up an integration with the `abs` function
from the C standard library. Functions declared within `extern` blocks are
always unsafe to call from Rust code. The reason is that other languages don’t
enforce Rust’s rules and guarantees, and Rust can’t check them, so
responsibility falls on the programmer to ensure safety.
-->
<p>リスト19-8は、Cの標準ライブラリから<code>abs</code>関数を統合するセットアップ方法をデモしています。
<code>extern</code>ブロック内で宣言された関数は、常にRustコードから呼ぶにはunsafeになります。理由は、
他の言語では、Rustの規則や保証が強制されず、コンパイラもチェックできないので、
安全性を保証する責任はプログラマに降りかかるのです。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        // -3の絶対値は、Cによると{}
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-8: Declaring and calling an `extern` function
defined in another language</span>
-->
<p><span class="caption">リスト19-8: 他の言語で定義された<code>extern</code>関数を宣言し、呼び出す</span></p>
<!--
Within the `extern "C"` block, we list the names and signatures of external
functions from another language we want to call. The `"C"` part defines which
*application binary interface (ABI)* the external function uses: the ABI
defines how to call the function at the assembly level. The `"C"` ABI is the
most common and follows the C programming language’s ABI.
-->
<p><code>extern &quot;C&quot;</code>ブロック内で他の言語から呼び出した関数の名前とシグニチャを列挙します。<code>&quot;C&quot;</code>の部分は、
外部関数がどの<em>ABI</em>(application binary interface: アプリケーション・バイナリ・インターフェイス)を使用しているか定義します:
ABIは関数の呼び出し方法をアセンブリレベルで定義します。<code>&quot;C&quot;</code>ABIは最も一般的でCプログラミング言語のABIに従っています。</p>
<!--
> #### Calling Rust Functions from Other Languages
>
> We can also use `extern` to create an interface that allows other languages
> to call Rust functions. Instead of an `extern` block, we add the `extern`
> keyword and specify the ABI to use just before the `fn` keyword. We also need
> to add a `#[no_mangle]` annotation to tell the Rust compiler not to mangle
> the name of this function. *Mangling* is when a compiler changes the name
> we’ve given a function to a different name that contains more information for
> other parts of the compilation process to consume but is less human readable.
> Every programming language compiler mangles names slightly differently, so
> for a Rust function to be nameable by other languages, we must disable the
> Rust compiler’s name mangling.
>
> In the following example, we make the `call_from_c` function accessible from
> C code, after it’s compiled to a shared library and linked from C:
>
> ```rust
> #[no_mangle]
> pub extern "C" fn call_from_c() {
>     println!("Just called a Rust function from C!");
> }
> ```
>
> This usage of `extern` does not require `unsafe`.
-->
<blockquote>
<h4 id="他の言語からrustの関数を呼び出す"><a class="header" href="#他の言語からrustの関数を呼び出す">他の言語からRustの関数を呼び出す</a></h4>
<p>また、<code>extern</code>を使用して他の言語にRustの関数を呼ばせるインターフェイスを生成することもできます。
<code>extern</code>ブロックの代わりに、<code>extern</code>キーワードを追加し、<code>fn</code>キーワードの直前に使用するABIを指定します。
さらに、<code>#[no_mangle]</code>注釈を追加してRustコンパイラに関数名をマングルしないように指示する必要もあります。
<em>マングル</em>とは、コンパイラが関数に与えた名前を他のコンパイル過程の情報をより多く含むけれども、人間に読みにくい異なる名前にすることです。
全ての言語のコンパイラは、少々異なる方法でマングルを行うので、Rustの関数が他の言語で名前付けできるように、
Rustコンパイラの名前マングルをオフにしなければならないのです。</p>
<p>以下の例では、共有ライブラリにコンパイルし、Cからリンクした後に<code>call_from_c</code>関数をCコードからアクセスできるようにしています:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    // CからRust関数を呼び出したばかり！
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>この<code>extern</code>の使用法では、<code>unsafe</code>は必要ありません。</p>
</blockquote>
<!--
### Accessing or Modifying a Mutable Static Variable
-->
<h3 id="可変で静的な変数にアクセスしたり変更する"><a class="header" href="#可変で静的な変数にアクセスしたり変更する">可変で静的な変数にアクセスしたり、変更する</a></h3>
<!--
Until now, we’ve not talked about *global variables*, which Rust does support
but can be problematic with Rust’s ownership rules. If two threads are
accessing the same mutable global variable, it can cause a data race.
-->
<p>今までずっと、<em>グローバル変数</em>について語りませんでした。グローバル変数をRustは確かにサポートしていますが、
Rustの所有権規則で問題になることもあります。2つのスレッドが同じ可変なグローバル変数にアクセスしていたら、
データ競合を起こすこともあります。</p>
<!--
In Rust, global variables are called *static* variables. Listing 19-9 shows an
example declaration and use of a static variable with a string slice as a
value.
-->
<p>Rustでは、グローバル変数は、<em>static</em>(静的)変数と呼ばれます。リスト19-9は、
値として文字列スライスのある静的変数の宣言例と使用を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
	// 名前は: {}
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-9: Defining and using an immutable static
variable</span>
-->
<p><span class="caption">リスト19-9: 不変で静的な変数を定義し、使用する</span></p>
<!--
Static variables are similar to constants, which we discussed in the
“Differences Between Variables and Constants” section in Chapter 3. The names
of static variables are in `SCREAMING_SNAKE_CASE` by convention, and we *must*
annotate the variable’s type, which is `&'static str` in this example. Static
variables can only store references with the `'static` lifetime, which means
the Rust compiler can figure out the lifetime; we don’t need to annotate it
explicitly. Accessing an immutable static variable is safe.
-->
<p>静的変数は、定数に似ています。定数については、第3章の「変数と定数の違い」節で議論しました。
静的変数の名前は慣習で<code>SCREAMING_SNAKE_CASE</code>(<code>直訳</code>: 叫ぶスネークケース)になり、変数の型を注釈し<em>なければなりません</em>。
この例では<code>&amp;'static str</code>です。静的変数は、<code>'static</code>ライフタイムの参照のみ格納でき、
これは、Rustコンパイラがライフタイムを推量できることを意味します; 明示的に注釈する必要はありません。
不変で静的な変数にアクセスすることは安全です。</p>
<!--
Constants and immutable static variables might seem similar, but a subtle
difference is that values in a static variable have a fixed address in memory.
Using the value will always access the same data. Constants, on the other hand,
are allowed to duplicate their data whenever they’re used.
-->
<p>定数と不変で静的な変数は、類似して見える可能性がありますが、微妙な差異は、
静的変数の値は固定されたメモリアドレスになることです。値を使用すると、常に同じデータにアクセスします。
一方、定数は使用される度にデータを複製させることができます。</p>
<!--
Another difference between constants and static variables is that static
variables can be mutable. Accessing and modifying mutable static variables is
*unsafe*. Listing 19-10 shows how to declare, access, and modify a mutable
static variable named `COUNTER`.
-->
<p>定数と静的変数の別の違いは、静的変数は可変にもなることです。可変で静的な変数にアクセスし変更することは、unsafeです。
リスト19-10は、<code>COUNTER</code>という可変で静的な変数を宣言し、アクセスし、変更する方法を表示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-10: Reading from or writing to a mutable
static variable is unsafe</span>
-->
<p><span class="caption">リスト19-10: 可変で静的な変数を読んだり、書き込むのはunsafeである</span></p>
<!--
As with regular variables, we specify mutability using the `mut` keyword. Any
code that reads or writes from `COUNTER` must be within an `unsafe` block. This
code compiles and prints `COUNTER: 3` as we would expect because it’s single
threaded. Having multiple threads access `COUNTER` would likely result in data
races.
-->
<p>普通の変数同様、<code>mut</code>キーワードを使用して可変性を指定します。<code>COUNTER</code>を読み書きするコードはどれも、<code>unsafe</code>ブロックになければなりません。
シングルスレッドなので、このコードは想定通り、コンパイルでき、<code>COUNTER: 3</code>と出力します。
複数のスレッドに<code>COUNTER</code>にアクセスさせると、データ競合になる可能性が高いでしょう。</p>
<!--
With mutable data that is globally accessible, it’s difficult to ensure there
are no data races, which is why Rust considers mutable static variables to be
unsafe. Where possible, it’s preferable to use the concurrency techniques and
thread-safe smart pointers we discussed in Chapter 16 so the compiler checks
that data accessed from different threads is done safely.
-->
<p>グローバルにアクセス可能な可変なデータがあると、データ競合がないことを保証するのは難しくなり、そのため、
Rustは可変で静的な変数をunsafeと考えるのです。可能なら、コンパイラが、データが異なるスレッドからアクセスされることが安全に行われているかを確認するように、
第16章で議論した並行性テクニックとスレッド安全なスマートポインタを使用するのが望ましいです。</p>
<!--
### Implementing an Unsafe Trait
-->
<h3 id="unsafeなトレイトを実装する"><a class="header" href="#unsafeなトレイトを実装する">unsafeなトレイトを実装する</a></h3>
<!--
The final action that works only with `unsafe` is implementing an unsafe trait.
A trait is unsafe when at least one of its methods has some invariant that the
compiler can’t verify. We can declare that a trait is `unsafe` by adding the
`unsafe` keyword before `trait` and marking the implementation of the trait as
`unsafe` too, as shown in Listing 19-11.
-->
<p><code>unsafe</code>でのみ動く最後の行動は、unsafeなトレイトを実装することです。少なくとも、1つのメソッドにコンパイラが確かめられないなんらかの不変条件があると、
トレイトはunsafeになります。<code>trait</code>の前に<code>unsafe</code>キーワードを追加し、トレイトの実装も<code>unsafe</code>でマークすることで、
トレイトが<code>unsafe</code>であると宣言できます。リスト19-11のようにですね。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe trait Foo {
    // methods go here
    // メソッドがここに来る
}

unsafe impl Foo for i32 {
    // method implementations go here
    // メソッドの実装がここに来る
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-11: Defining and implementing an unsafe
trait</span>
-->
<p><span class="caption">リスト19-11: unsafeなトレイトを定義して実装する</span></p>
<!--
By using `unsafe impl`, we’re promising that we’ll uphold the invariants that
the compiler can’t verify.
-->
<p><code>unsafe impl</code>を使用することで、コンパイラが確かめられない不変条件を守ることを約束しています。</p>
<!--
As an example, recall the `Sync` and `Send` marker traits we discussed in the
“Extensible Concurrency with the `Sync` and `Send` Traits” section in Chapter
16: the compiler implements these traits automatically if our types are
composed entirely of `Send` and `Sync` types. If we implement a type that
contains a type that is not `Send` or `Sync`, such as raw pointers, and we want
to mark that type as `Send` or `Sync`, we must use `unsafe`. Rust can’t verify
that our type upholds the guarantees that it can be safely sent across threads
or accessed from multiple threads; therefore, we need to do those checks
manually and indicate as such with `unsafe`.
-->
<p>例として、第16章の「<code>Sync</code>と<code>Send</code>トレイトで拡張可能な並行性」節で議論した<code>Sync</code>と<code>Send</code>マーカートレイトを思い出してください:
型が完全に<code>Send</code>と<code>Sync</code>型だけで構成されていたら、コンパイラはこれらのトレイトを自動的に実装します。
生ポインタなどの<code>Send</code>や<code>Sync</code>でない型を含む型を実装し、その型を<code>Send</code>や<code>Sync</code>でマークしたいなら、
<code>unsafe</code>を使用しなければなりません。コンパイラは、型がスレッド間を安全に送信できたり、
複数のスレッドから安全にアクセスできるという保証を保持しているか確かめられません; 故に、そのチェックを手動で行い、
<code>unsafe</code>でそのように示唆する必要があります。</p>
<!--
### When to Use Unsafe Code
-->
<h3 id="いつunsafeコードを使用するべきか"><a class="header" href="#いつunsafeコードを使用するべきか">いつunsafeコードを使用するべきか</a></h3>
<!--
Using `unsafe` to take one of the four actions (superpowers) just discussed
isn’t wrong or even frowned upon. But it is trickier to get `unsafe` code
correct because the compiler can’t help uphold memory safety. When you have a
reason to use `unsafe` code, you can do so, and having the explicit `unsafe`
annotation makes it easier to track down the source of problems if they occur.
-->
<p><code>unsafe</code>を使って議論したばかりの4つの行動(強大な力)のうちの1つを行うのは間違っていたり、認められさえもしないものではありません。
ですが、<code>unsafe</code>コードを正しくするのは、より巧妙なことでしょう。コンパイラがメモリ安全性を保持する手助けをできないからです。
<code>unsafe</code>コードを使用する理由があるなら、そうすることができ、明示的に<code>unsafe</code>注釈をすることで問題が起きたら、
その原因を追求するのが容易になります。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Advanced Traits
-->
<h2 id="高度なトレイト"><a class="header" href="#高度なトレイト">高度なトレイト</a></h2>
<!--
We first covered traits in the “Traits: Defining Shared Behavior” section of
Chapter 10, but as with lifetimes, we didn’t discuss the more advanced details.
Now that you know more about Rust, we can get into the nitty-gritty.
-->
<p>最初にトレイトについて講義したのは、第10章の「トレイト: 共通の振る舞いを定義する」節でしたが、
ライフタイム同様、より高度な詳細は議論しませんでした。今や、Rustに詳しくなったので、核心に迫れるでしょう。</p>
<!--
### Specifying Placeholder Types in Trait Definitions with Associated Types
-->
<h3 id="関連型でトレイト定義においてプレースホルダーの型を指定する"><a class="header" href="#関連型でトレイト定義においてプレースホルダーの型を指定する">関連型でトレイト定義においてプレースホルダーの型を指定する</a></h3>
<!--
*Associated types* connect a type placeholder with a trait such that the trait
method definitions can use these placeholder types in their signatures. The
implementor of a trait will specify the concrete type to be used in this type’s
place for the particular implementation. That way, we can define a trait that
uses some types without needing to know exactly what those types are until the
trait is implemented.
-->
<p><em>関連型</em>は、トレイトのメソッド定義がシグニチャでプレースホルダーの型を使用できるように、トレイトと型のプレースホルダーを結び付けます。
トレイトを実装するものがこの特定の実装で型の位置に使用される具体的な型を指定します。そうすることで、
なんらかの型を使用するトレイトをトレイトを実装するまでその型が一体なんであるかを知る必要なく定義できます。</p>
<!--
3行目、the rest of the bookとあるが、これ以降の章という意味での残りではなく、ここまでに見かけてきた章のことと思われるため
-->
<!--
We’ve described most of the advanced features in this chapter as being rarely
needed. Associated types are somewhere in the middle: they’re used more rarely
than features explained in the rest of the book but more commonly than many of
the other features discussed in this chapter.
-->
<p>この章のほとんどの高度な機能は、稀にしか必要にならないと解説しました。関連型はその中間にあります:
本の他の部分で説明される機能よりは使用されるのが稀ですが、この章で議論される他の多くの機能よりは頻繁に使用されます。</p>
<!--
One example of a trait with an associated type is the `Iterator` trait that the
standard library provides. The associated type is named `Item` and stands in
for the type of the values the type implementing the `Iterator` trait is
iterating over. In “The `Iterator` Trait and the `next` Method” section of
Chapter 13, we mentioned that the definition of the `Iterator` trait is as
shown in Listing 19-20.
-->
<p>関連型があるトレイトの一例は、標準ライブラリが提供する<code>Iterator</code>トレイトです。その関連型は<code>Item</code>と名付けられ、
<code>Iterator</code>トレイトを実装している型が走査している値の型の代役を務めます。第13章の「<code>Iterator</code>トレイトと<code>next</code>メソッド」節で、
<code>Iterator</code>トレイトの定義は、リスト19-20に示したようなものであることに触れました。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-20: The definition of the `Iterator` trait
that has an associated type `Item`</span>
-->
<p><span class="caption">リスト19-20: 関連型<code>Item</code>がある<code>Iterator</code>トレイトの定義</span></p>
<!--
The type `Item` is a placeholder type, and the `next` method’s definition shows
that it will return values of type `Option<Self::Item>`. Implementors of the
`Iterator` trait will specify the concrete type for `Item`, and the `next`
method will return an `Option` containing a value of that concrete type.
-->
<p>型<code>Item</code>はプレースホルダー型で<code>next</code>メソッドの定義は、型<code>Option&lt;Self::Item&gt;</code>の値を返すことを示しています。
<code>Iterator</code>トレイトを実装するものは、<code>Item</code>の具体的な型を指定し、<code>next</code>メソッドは、
その具体的な型の値を含む<code>Option</code>を返します。</p>
<!--
ジェネリクスはこうという話をしているのに、似ていると言っているのがどうも引っかかる
1行目終わり、the latter allowsと思われるが、直っていない
-->
<!--
Associated types might seem like a similar concept to generics, in that the
latter allow us to define a function without specifying what types it can
handle. So why use associated types?
-->
<p>関連型は、ジェネリクスにより扱う型を指定せずに関数を定義できるという点でジェネリクスに似た概念のように思える可能性があります。
では、何故関連型を使用するのでしょうか？</p>
<!--
Let’s examine the difference between the two concepts with an example from
Chapter 13 that implements the `Iterator` trait on the `Counter` struct. In
Listing 13-21, we specified that the `Item` type was `u32`:
-->
<p>2つの概念の違いを第13章から<code>Counter</code>構造体に<code>Iterator</code>トレイトを実装する例で調査しましょう。
リスト13-21で、<code>Item</code>型は<code>u32</code>だと指定しました:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
</code></pre>
<!--
This syntax seems comparable to that of generics. So why not just define the
`Iterator` trait with generics, as shown in Listing 19-21?
-->
<p>この記法は、ジェネリクスと比較可能に思えます。では、何故単純にリスト19-21のように、
<code>Iterator</code>トレイトをジェネリクスで定義しないのでしょうか？</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-21: A hypothetical definition of the
`Iterator` trait using generics</span>
-->
<p><span class="caption">リスト19-21: ジェネリクスを使用した架空の<code>Iterator</code>トレイトの定義</span></p>
<!--
The difference is that when using generics, as in Listing 19-21, we must
annotate the types in each implementation; because we can also implement
`Iterator<String> for Counter` or any other type, we could have multiple
implementations of `Iterator` for `Counter`. In other words, when a trait has a
generic parameter, it can be implemented for a type multiple times, changing
the concrete types of the generic type parameters each time. When we use the
`next` method on `Counter`, we would have to provide type annotations to
indicate which implementation of `Iterator` we want to use.
-->
<p>差異は、リスト19-21のようにジェネリクスを使用すると、各実装で型を注釈しなければならないことです;
<code>Iterator&lt;String&gt; for Counter</code>や他のどんな型にも実装することができるので、
<code>Counter</code>の<code>Iterator</code>の実装が複数できるでしょう。換言すれば、トレイトにジェネリックな引数があると、
毎回ジェネリックな型引数の具体的な型を変更してある型に対して複数回実装できるということです。
<code>Counter</code>に対して<code>next</code>メソッドを使用する際に、どの<code>Iterator</code>の実装を使用したいか型注釈をつけなければならないでしょう。</p>
<!--
With associated types, we don’t need to annotate types because we can’t
implement a trait on a type multiple times. In Listing 19-20 with the
definition that uses associated types, we can only choose what the type of
`Item` will be once, because there can only be one `impl Iterator for Counter`.
We don’t have to specify that we want an iterator of `u32` values everywhere
that we call `next` on `Counter`.
-->
<p>関連型なら、同じ型に対してトレイトを複数回実装できないので、型を注釈する必要はありません。
関連型を使用する定義があるリスト19-20では、<code>Item</code>の型は1回しか選択できませんでした。
1つしか<code>impl Iterator for Counter</code>がないからです。<code>Counter</code>に<code>next</code>を呼び出す度に、
<code>u32</code>値のイテレータが欲しいと指定しなくてもよいわけです。</p>
<!--
### Default Generic Type Parameters and Operator Overloading
-->
<h3 id="デフォルトのジェネリック型引数と演算子オーバーロード"><a class="header" href="#デフォルトのジェネリック型引数と演算子オーバーロード">デフォルトのジェネリック型引数と演算子オーバーロード</a></h3>
<!--
When we use generic type parameters, we can specify a default concrete type for
the generic type. This eliminates the need for implementors of the trait to
specify a concrete type if the default type works. The syntax for specifying a
default type for a generic type is `<PlaceholderType=ConcreteType>` when
declaring the generic type.
-->
<p>ジェネリックな型引数を使用する際、ジェネリックな型に対して既定の具体的な型を指定できます。これにより、
既定の型が動くのなら、トレイトを実装する側が具体的な型を指定する必要を排除します。ジェネリックな型に既定の型を指定する記法は、
ジェネリックな型を宣言する際に<code>&lt;PlaceholderType=ConcreteType&gt;</code>です。</p>
<!--
A great example of a situation where this technique is useful is with operator
overloading. *Operator overloading* is customizing the behavior of an operator
(such as `+`) in particular situations.
-->
<p>このテクニックが有用になる場面の好例が、演算子オーバーロードです。<em>演算子オーバーロード</em>とは、
特定の状況で演算子(<code>+</code>など)の振る舞いをカスタマイズすることです。</p>
<!--
Rust doesn’t allow you to create your own operators or overload arbitrary
operators. But you can overload the operations and corresponding traits listed
in `std::ops` by implementing the traits associated with the operator. For
example, in Listing 19-22 we overload the `+` operator to add two `Point`
instances together. We do this by implementing the `Add` trait on a `Point`
struct:
-->
<p>Rustでは、独自の演算子を作ったり、任意の演算子をオーバーロードすることはできません。しかし、
演算子に紐づいたトレイトを実装することで<code>std::ops</code>に列挙された処理と対応するトレイトをオーバーロードできます。
例えば、リスト19-22で<code>+</code>演算子をオーバーロードして2つの<code>Point</code>インスタンスを足し合わせています。
<code>Point</code>構造体に<code>Add</code>トレイトを実装することでこれを行なっています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-22: Implementing the `Add` trait to overload
the `+` operator for `Point` instances</span>
-->
<p><span class="caption">リスト19-22: <code>Add</code>トレイトを実装して<code>Point</code>インスタンス用に<code>+</code>演算子をオーバーロードする</span></p>
<!--
The `add` method adds the `x` values of two `Point` instances and the `y`
values of two `Point` instances to create a new `Point`. The `Add` trait has an
associated type named `Output` that determines the type returned from the `add`
method.
-->
<p><code>add</code>メソッドは2つの<code>Point</code>インスタンスの<code>x</code>値と2つの<code>Point</code>インスタンスの<code>y</code>値を足します。
<code>Add</code>トレイトには、<code>add</code>メソッドから返却される型を決定する<code>Output</code>という関連型があります。</p>
<!--
The default generic type in this code is within the `Add` trait. Here is its
definition:
-->
<p>このコードの既定のジェネリック型は、<code>Add</code>トレイト内にあります。こちらがその定義です:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Add&lt;RHS=Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code should look generally familiar: a trait with one method and an
associated type. The new part is `RHS=Self`: this syntax is called *default
type parameters*. The `RHS` generic type parameter (short for “right hand
side”) defines the type of the `rhs` parameter in the `add` method. If we don’t
specify a concrete type for `RHS` when we implement the `Add` trait, the type
of `RHS` will default to `Self`, which will be the type we’re implementing
`Add` on.
-->
<p>このコードは一般的に馴染みがあるはずです: 1つのメソッドと関連型が1つあるトレイトです。
新しい部分は、<code>RHS=Self</code>です: この記法は、<em>デフォルト型引数</em>と呼ばれます。
RHSというジェネリックな型引数(&quot;right hand side&quot;: 右辺の省略形)が、<code>add</code>メソッドの<code>rhs</code>引数の型を定義しています。
<code>Add</code>トレイトを実装する際に<code>RHS</code>の具体的な型を指定しなければ、<code>RHS</code>の型は標準で<code>Self</code>になり、
これは<code>Add</code>を実装している型になります。</p>
<!--
When we implemented `Add` for `Point`, we used the default for `RHS` because we
wanted to add two `Point` instances. Let’s look at an example of implementing
the `Add` trait where we want to customize the `RHS` type rather than using the
default.
-->
<p><code>Point</code>に<code>Add</code>を実装する際、2つの<code>Point</code>インスタンスを足したかったので、<code>RHS</code>の規定を使用しました。
既定を使用するのではなく、<code>RHS</code>の型をカスタマイズしたくなる<code>Add</code>トレイトの実装例に目を向けましょう。</p>
<!--
We have two structs `Millimeters` and `Meters`, holding values in different
units. We want to add values in millimeters to values in meters and have the
implementation of `Add` do the conversion correctly. We can implement `Add` for
`Millimeters` with `Meters` as the `RHS`, as shown in Listing 19-23.
-->
<p>異なる単位で値を保持する構造体、<code>Millimeters</code>と<code>Meters</code>(それぞれ<code>ミリメートル</code>と<code>メートル</code>)が2つあります。
ミリメートルの値をメートルの値に足し、<code>Add</code>の実装に変換を正しくしてほしいです。
<code>Add</code>を<code>RHS</code>に<code>Meters</code>のある<code>Millimeters</code>に実装することができます。リスト19-23のように:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-23: Implementing the `Add` trait on
`Millimeters` to add `Millimeters` to `Meters`</span>
-->
<p><span class="caption">リスト19-23: <code>Millimeters</code>に<code>Add</code>トレイトを実装して、<code>Meters</code>に<code>Millimeters</code>を足す</span></p>
<!--
To add `Millimeters` and `Meters`, we specify `impl Add<Meters>` to set the
value of the `RHS` type parameter instead of using the default of `Self`.
-->
<p><code>Millimeters</code>を<code>Meters</code>に足すため、<code>Self</code>という既定を使う代わりに<code>impl Add&lt;Meters&gt;</code>を指定して、
<code>RHS</code>型引数の値をセットしています。</p>
<!--
You'll use default type parameters in two main ways:
-->
<p>主に2通りの方法でデフォルト型引数を使用します:</p>
<!--
* To extend a type without breaking existing code
* To allow customization in specific cases most users won’t need
-->
<ul>
<li>既存のコードを破壊せずに型を拡張する</li>
<li>ほとんどのユーザは必要としない特定の場合でカスタマイズを可能にする</li>
</ul>
<!--
The standard library’s `Add` trait is an example of the second purpose:
usually, you’ll add two like types, but the `Add` trait provides the ability to
customize beyond that. Using a default type parameter in the `Add` trait
definition means you don’t have to specify the extra parameter most of the
time. In other words, a bit of implementation boilerplate isn’t needed, making
it easier to use the trait.
-->
<p>標準ライブラリの<code>Add</code>トレイトは、2番目の目的の例です: 通常、2つの似た型を足しますが、
<code>Add</code>トレイトはそれ以上にカスタマイズする能力を提供します。<code>Add</code>トレイト定義でデフォルト型引数を使用することは、
ほとんどの場合、追加の引数を指定しなくてもよいことを意味します。つまり、トレイトを使いやすくして、
ちょっとだけ実装の定型コードが必要なくなるのです。</p>
<!--
The first purpose is similar to the second but in reverse: if you want to add a
type parameter to an existing trait, you can give it a default to allow
extension of the functionality of the trait without breaking the existing
implementation code.
-->
<p>最初の目的は2番目に似ていますが、逆です: 既存のトレイトに型引数を追加したいなら、既定を与えて、
既存の実装コードを破壊せずにトレイトの機能を拡張できるのです。</p>
<!--
### Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name
-->
<h3 id="明確化のためのフルパス記法-同じ名前のメソッドを呼ぶ"><a class="header" href="#明確化のためのフルパス記法-同じ名前のメソッドを呼ぶ">明確化のためのフルパス記法: 同じ名前のメソッドを呼ぶ</a></h3>
<!--
Nothing in Rust prevents a trait from having a method with the same name as
another trait’s method, nor does Rust prevent you from implementing both traits
on one type. It’s also possible to implement a method directly on the type with
the same name as methods from traits.
-->
<p>Rustにおいて、別のトレイトのメソッドと同じ名前のメソッドがトレイトにあったり、両方のトレイトを1つの型に実装することを妨げるものは何もありません。
トレイトのメソッドと同じ名前のメソッドを直接型に実装することも可能です。</p>
<!--
When calling methods with the same name, you'll need to tell Rust which one you
want to use. Consider the code in Listing 19-24 where we’ve defined two traits,
`Pilot` and `Wizard`, that both have a method called `fly`. We then implement
both traits on a type `Human` that already has a method named `fly` implemented
on it. Each `fly` method does something different.
-->
<p>同じ名前のメソッドを呼ぶ際、コンパイラにどれを使用したいのか教える必要があるでしょう。両方とも<code>fly</code>というメソッドがある2つのトレイト、
<code>Pilot</code>と<code>Wizard</code>(<code>訳注</code>: パイロットと魔法使い)を定義したリスト19-24のコードを考えてください。
それから両方のトレイトを既に<code>fly</code>というメソッドが実装されている型<code>Human</code>(<code>訳注</code>: 人間)に実装します。
各<code>fly</code>メソッドは異なることをします。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        // キャプテンのお言葉
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        // 上がれ！
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        // *激しく腕を振る*
        println!(&quot;*waving arms furiously*&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-24: Two traits are defined to have a `fly`
method and are implemented on the `Human` type, and a `fly` method is
implemented on `Human` directly</span>
-->
<p><span class="caption">リスト19-24: 2つのトレイトに<code>fly</code>があるように定義され、<code>Human</code>に実装されつつ、
<code>fly</code>メソッドは<code>Human</code>に直接にも実装されている</span></p>
<!--
When we call `fly` on an instance of `Human`, the compiler defaults to calling
the method that is directly implemented on the type, as shown in Listing 19-25.
-->
<p><code>Human</code>のインスタンスに対して<code>fly</code>を呼び出すと、コンパイラは型に直接実装されたメソッドを標準で呼び出します。
リスト19-25のようにですね:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-25: Calling `fly` on an instance of
`Human`</span>
-->
<p><span class="caption">リスト19-25: <code>Human</code>のインスタンスに対して<code>fly</code>を呼び出す</span></p>
<!--
Running this code will print `*waving arms furiously*`, showing that Rust
called the `fly` method implemented on `Human` directly.
-->
<p>このコードを実行すると、<code>*waving arms furiously*</code>と出力され、コンパイラが<code>Human</code>に直接実装された<code>fly</code>メソッドを呼んでいることを示しています。</p>
<!--
To call the `fly` methods from either the `Pilot` trait or the `Wizard` trait,
we need to use more explicit syntax to specify which `fly` method we mean.
Listing 19-26 demonstrates this syntax.
-->
<p><code>Pilot</code>トレイトか、<code>Wizard</code>トレイトの<code>fly</code>メソッドを呼ぶためには、
より明示的な記法を使用して、どの<code>fly</code>メソッドを意図しているか指定する必要があります。
リスト19-26は、この記法をデモしています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-26: Specifying which trait’s `fly` method we
want to call</span>
-->
<p><span class="caption">リスト19-26: どのトレイトの<code>fly</code>メソッドを呼び出したいか指定する</span></p>
<!--
Specifying the trait name before the method name clarifies to Rust which
implementation of `fly` we want to call. We could also write
`Human::fly(&person)`, which is equivalent to the `person.fly()` that we used
in Listing 19-26, but this is a bit longer to write if we don’t need to
disambiguate.
-->
<p>メソッド名の前にトレイト名を指定すると、コンパイラにどの<code>fly</code>の実装を呼び出したいか明確化できます。
また、<code>Human::fly(&amp;person)</code>と書くこともでき、リスト19-26で使用した<code>person.fly()</code>と等価ですが、
こちらの方は明確化する必要がないなら、ちょっと記述量が増えます。</p>
<!--
Running this code prints the following:
-->
<p>このコードを実行すると、こんな出力がされます:</p>
<pre><code class="language-text">This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<!--
Because the `fly` method takes a `self` parameter, if we had two *types* that
both implement one *trait*, Rust could figure out which implementation of a
trait to use based on the type of `self`.
-->
<p><code>fly</code>メソッドは<code>self</code>引数を取るので、1つの<em>トレイト</em>を両方実装する<em>型</em>が2つあれば、
コンパイラには、<code>self</code>の型に基づいてどのトレイトの実装を使うべきかわかるでしょう。</p>
<!--
However, associated functions that are part of traits don’t have a `self`
parameter. When two types in the same scope implement that trait, Rust can’t
figure out which type you mean unless you use *fully qualified syntax*. For
example, the `Animal` trait in Listing 19-27 has the associated function
`baby_name`, the implementation of `Animal` for the struct `Dog`, and the
associated function `baby_name` defined on `Dog` directly.
-->
<p>しかしながら、トレイトの一部になる関連関数には<code>self</code>引数がありません。同じスコープの2つの型がそのトレイトを実装する場合、
<em>フルパス記法</em>(fully qualified syntax)を使用しない限り、どの型を意図しているかコンパイラは推論できません。例えば、
リスト19-27の<code>Animal</code>トレイトには、関連関数<code>baby_name</code>、構造体<code>Dog</code>の<code>Animal</code>の実装、
<code>Dog</code>に直接定義された関連関数<code>baby_name</code>があります。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        // スポット(Wikipediaによると、飼い主の事故死後もその人の帰りを待つ忠犬の名前の模様)
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        // 子犬
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    // 赤ちゃん犬は{}と呼ばれる
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-27: A trait with an associated function and a
type with an associated function of the same name that also implements the
trait</span>
-->
<p><span class="caption">リスト19-27: 関連関数のあるトレイトとそのトレイトも実装し、同じ名前の関連関数がある型</span></p>
<!--
This code is for an animal shelter that wants to name all puppies Spot, which
is implemented in the `baby_name` associated function that is defined on `Dog`.
The `Dog` type also implements the trait `Animal`, which describes
characteristics that all animals have. Baby dogs are called puppies, and that
is expressed in the implementation of the `Animal` trait on `Dog` in the
`baby_name` function associated with the `Animal` trait.
-->
<p>このコードは、全ての子犬をスポットと名付けたいアニマル・シェルター(<code>訳注</code>: 身寄りのないペットを保護する保健所みたいなところ)用で、
<code>Dog</code>に定義された<code>baby_name</code>関連関数で実装されています。<code>Dog</code>型は、トレイト<code>Animal</code>も実装し、
このトレイトは全ての動物が持つ特徴を記述します。赤ちゃん犬は子犬と呼ばれ、
それが<code>Dog</code>の<code>Animal</code>トレイトの実装の<code>Animal</code>トレイトと紐づいた<code>base_name</code>関数で表現されています。</p>
<!--
In `main`, we call the `Dog::baby_name` function, which calls the associated
function defined on `Dog` directly. This code prints the following:
-->
<p><code>main</code>で、<code>Dog::baby_name</code>関数を呼び出し、直接<code>Dog</code>に定義された関連関数を呼び出しています。
このコードは以下のような出力をします:</p>
<pre><code class="language-text">A baby dog is called a Spot
</code></pre>
<!--
This output isn’t what we wanted. We want to call the `baby_name` function that
is part of the `Animal` trait that we implemented on `Dog` so the code prints
`A baby dog is called a puppy`. The technique of specifying the trait name that
we used in Listing 19-26 doesn’t help here; if we change `main` to the code in
Listing 19-28, we’ll get a compilation error.
-->
<p>この出力は、欲しかったものではありません。<code>Dog</code>に実装した<code>Animal</code>トレイトの一部の<code>baby_name</code>関数を呼び出したいので、
コードは<code>A baby dog is called a puppy</code>と出力します。リスト19-26で使用したトレイト名を指定するテクニックは、
ここでは役に立ちません; <code>main</code>をリスト19-28のようなコードに変更したら、コンパイルエラーになるでしょう。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
}
</code></pre>
<!--
<span class="caption">Listing 19-28: Attempting to call the `baby_name`
function from the `Animal` trait, but Rust doesn’t know which implementation to
use</span>
-->
<p><span class="caption">リスト19-28: <code>Animal</code>トレイトの<code>baby_name</code>関数を呼び出そうとするも、コンパイラにはどの実装を使うべきかわからない</span></p>
<!--
Because `Animal::baby_name` is an associated function rather than a method, and
thus doesn’t have a `self` parameter, Rust can’t figure out which
implementation of `Animal::baby_name` we want. We’ll get this compiler error:
-->
<p><code>Animal::baby_name</code>はメソッドではなく関連関数であり、故に<code>self</code>引数がないので、どの<code>Animal::baby_name</code>が欲しいのか、
コンパイラには推論できません。こんなコンパイルエラーが出るでしょう:</p>
<pre><code class="language-text">error[E0283]: type annotations required: cannot resolve `_: Animal`
(エラー: 型注釈が必要です: `_: Animal`を解決できません)
  --&gt; src/main.rs:20:43
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^
   |
   = note: required by `Animal::baby_name`
   (注釈: `Animal::baby_name`に必要です)
</code></pre>
<!--
To disambiguate and tell Rust that we want to use the implementation of
`Animal` for `Dog`, we need to use fully qualified syntax. Listing 19-29
demonstrates how to use fully qualified syntax.
-->
<p><code>Dog</code>に対して<code>Animal</code>実装を使用したいと明確化し、コンパイラに指示するには、フルパス記法を使う必要があります。
リスト19-29は、フルパス記法を使用する方法をデモしています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;puppy&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-29: Using fully qualified syntax to specify
that we want to call the `baby_name` function from the `Animal` trait as
implemented on `Dog`</span>
-->
<p><span class="caption">リスト19-29: フルパス記法を使って<code>Dog</code>に実装されているように、
<code>Animal</code>トレイトからの<code>baby_name</code>関数を呼び出したいと指定する</span></p>
<!--
We’re providing Rust with a type annotation within the angle brackets, which
indicates we want to call the `baby_name` method from the `Animal` trait as
implemented on `Dog` by saying that we want to treat the `Dog` type as an
`Animal` for this function call. This code will now print what we want:
-->
<p>コンパイラに山カッコ内で型注釈を提供し、これは、この関数呼び出しでは<code>Dog</code>型を<code>Animal</code>として扱いたいと宣言することで、
<code>Dog</code>に実装されたように、<code>Animal</code>トレイトの<code>baby_name</code>メソッドを呼び出したいと示唆しています。
もうこのコードは、望み通りの出力をします:</p>
<pre><code class="language-text">A baby dog is called a puppy
</code></pre>
<!--
In general, fully qualified syntax is defined as follows:
-->
<p>一般的に、フルパス記法は、以下のように定義されています:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<!--
For associated functions, there would not be a `receiver`: there would only be
the list of other arguments. You could use fully qualified syntax everywhere
that you call functions or methods. However, you’re allowed to omit any part of
this syntax that Rust can figure out from other information in the program. You
only need to use this more verbose syntax in cases where there are multiple
implementations that use the same name and Rust needs help to identify which
implementation you want to call.
-->
<p>関連関数では、<code>receiver</code>がないでしょう: 他の引数のリストがあるだけでしょう。関数やメソッドを呼び出す箇所全部で、
フルパス記法を使用することもできるでしょうが、プログラムの他の情報からコンパイラが推論できるこの記法のどの部分も省略することが許容されています。
同じ名前を使用する実装が複数あり、どの実装を呼び出したいかコンパイラが特定するのに助けが必要な場合だけにこのより冗長な記法を使用する必要があるのです。</p>
<!--
### Using Supertraits to Require One Trait’s Functionality Within Another Trait
-->
<h3 id="スーパートレイトを使用して別のトレイト内であるトレイトの機能を必要とする"><a class="header" href="#スーパートレイトを使用して別のトレイト内であるトレイトの機能を必要とする">スーパートレイトを使用して別のトレイト内で、あるトレイトの機能を必要とする</a></h3>
<!--
Sometimes, you might need one trait to use another trait’s functionality. In
this case, you need to rely on the dependent trait's also being implemented.
The trait you rely on is a *supertrait* of the trait you’re implementing.
-->
<p>時として、あるトレイトに別のトレイトの機能を使用させる必要がある可能性があります。この場合、
依存するトレイトも実装されることを信用する必要があります。信用するトレイトは、実装しているトレイトの<em>スーパートレイト</em>です。</p>
<!--
For example, let’s say we want to make an `OutlinePrint` trait with an
`outline_print` method that will print a value framed in asterisks. That is,
given a `Point` struct that implements `Display` to result in `(x, y)`, when we
call `outline_print` on a `Point` instance that has `1` for `x` and `3` for
`y`, it should print the following:
-->
<p>例えば、アスタリスクをフレームにする値を出力する<code>outline_print</code>メソッドがある<code>OutlinePrint</code>トレイトを作りたくなったとしましょう。
つまり、<code>Display</code>を実装し、<code>(x, y)</code>という結果になる<code>Point</code>構造体が与えられて、
<code>x</code>が<code>1</code>、<code>y</code>が<code>3</code>の<code>Point</code>インスタンスに対して<code>outline_print</code>を呼び出すと、以下のような出力をするはずです:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<!--
In the implementation of `outline_print`, we want to use the `Display` trait’s
functionality. Therefore, we need to specify that the `OutlinePrint` trait will
work only for types that also implement `Display` and provide the functionality
that `OutlinePrint` needs. We can do that in the trait definition by specifying
`OutlinePrint: Display`. This technique is similar to adding a trait bound to
the trait. Listing 19-30 shows an implementation of the `OutlinePrint` trait.
-->
<p><code>outline_print</code>の実装では、<code>Display</code>トレイトの機能を使用したいです。故に、<code>Display</code>も実装する型に対してだけ<code>OutlinePrint</code>が動くと指定し、
<code>OutlinePrint</code>が必要とする機能を提供する必要があるわけです。トレイト定義で<code>OutlinePrint: Display</code>と指定することで、
そうすることができます。このテクニックは、トレイトにトレイト境界を追加することに似ています。
リスト19-30は、<code>OutlinePrint</code>トレイトの実装を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-30: Implementing the `OutlinePrint` trait that
requires the functionality from `Display`</span>
-->
<p><span class="caption">リスト19-30: <code>Display</code>からの機能を必要とする<code>OutlinePrint</code>トレイトを実装する</span></p>
<!--
Because we’ve specified that `OutlinePrint` requires the `Display` trait, we
can use the `to_string` function that is automatically implemented for any type
that implements `Display`. If we tried to use `to_string` without adding a
colon and specifying `Display` trait after the trait name, we’d get an
error saying that no method named `to_string` was found for the type `&Self` in
the current scope.
-->
<p><code>OutlinePrint</code>は<code>Display</code>トレイトを必要とすると指定したので、<code>Display</code>を実装するどんな型にも自動的に実装される<code>to_string</code>関数を使えます。
トレイト名の後にコロンと<code>Display</code>トレイトを追加せずに<code>to_string</code>を使おうとしたら、
現在のスコープで型<code>&amp;Self</code>に<code>to_string</code>というメソッドは存在しないというエラーが出るでしょう。</p>
<!--
Let’s see what happens when we try to implement `OutlinePrint` on a type that
doesn’t implement `Display`, such as the `Point` struct:
-->
<p><code>Display</code>を実装しない型、<code>Point</code>構造体などに<code>OutlinePrint</code>を実装しようとしたら、何が起きるか確認しましょう:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait OutlinePrint {}
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">}
</span></code></pre></pre>
<!--
We get an error saying that `Display` is required but not implemented:
-->
<p><code>Display</code>が必要だけれども、実装されていないというエラーが出ます:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;
try using `:?` instead if you are using a format string
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
</code></pre>
<!--
To fix this, we implement `Display` on `Point` and satisfy the constraint that
`OutlinePrint` requires, like so:
-->
<p>これを修正するために、<code>Point</code>に<code>Display</code>を実装し、<code>OutlinePrint</code>が必要とする制限を満たします。
こんな感じで:</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
Then implementing the `OutlinePrint` trait on `Point` will compile
successfully, and we can call `outline_print` on a `Point` instance to display
it within an outline of asterisks.
-->
<p>そうすれば、<code>Point</code>に<code>OutlinePrint</code>トレイトを実装してもコンパイルは成功し、
<code>Point</code>インスタンスに対して<code>outline_print</code>を呼び出し、アスタリスクのふちの中に表示することができます。</p>
<!--
### Using the Newtype Pattern to Implement External Traits on External Types
-->
<h3 id="ニュータイプパターンを使用して外部の型に外部のトレイトを実装する"><a class="header" href="#ニュータイプパターンを使用して外部の型に外部のトレイトを実装する">ニュータイプパターンを使用して外部の型に外部のトレイトを実装する</a></h3>
<!--
In Chapter 10 in the “Implementing a Trait on a Type” section, we mentioned the
orphan rule that states we’re allowed to implement a trait on a type as long as
either the trait or the type are local to our crate. It’s possible to get
around this restriction using the *newtype pattern*, which involves creating a
new type in a tuple struct. (We covered tuple structs in the “Using Tuple
Structs without Named Fields to Create Different Types” section of Chapter 5.)
The tuple struct will have one field and be a thin wrapper around the type we
want to implement a trait for. Then the wrapper type is local to our crate, and
we can implement the trait on the wrapper. *Newtype* is a term that originates
from the Haskell programming language. There is no runtime performance penalty
for using this pattern, and the wrapper type is elided at compile time.
-->
<p>第10章の「型にトレイトを実装する」節で、トレイトか型がクレートにローカルな限り、型にトレイトを実装できると述べるオーファンルールについて触れました。
<em>ニュータイプパターン</em>を使用してこの制限を回避することができ、タプル構造体に新しい型を作成することになります。
(タプル構造体については、第5章の「異なる型を生成する名前付きフィールドのないタプル構造体を使用する」節で講義しました。)
タプル構造体は1つのフィールドを持ち、トレイトを実装したい型の薄いラッパになるでしょう。そして、
ラッパの型はクレートにローカルなので、トレイトをラッパに実装できます。<em>ニュータイプ</em>という用語は、
Haskellプログラミング言語に端を発しています。このパターンを使用するのに実行時のパフォーマンスを犠牲にすることはなく、
ラッパ型はコンパイル時に省かれます。</p>
<!--
As an example, let’s say we want to implement `Display` on `Vec<T>`, which the
orphan rule prevents us from doing directly because the `Display` trait and the
`Vec<T>` type are defined outside our crate. We can make a `Wrapper` struct
that holds an instance of `Vec<T>`; then we can implement `Display` on
`Wrapper` and use the `Vec<T>` value, as shown in Listing 19-31.
-->
<p>例として、<code>Vec&lt;T&gt;</code>に<code>Display</code>を実装したいとしましょう。<code>Display</code>トレイトも<code>Vec&lt;T&gt;</code>型もクレートの外で定義されているので、
直接それを行うことはオーファンルールにより妨げられます。<code>Vec&lt;T&gt;</code>のインスタンスを保持する<code>Wrapper</code>構造体を作成できます;
そして、<code>Wrapper</code>に<code>Display</code>を実装し、<code>Vec&lt;T&gt;</code>値を使用できます。リスト19-31のように。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-31: Creating a `Wrapper` type around
`Vec<String>` to implement `Display`</span>
-->
<p><span class="caption">リスト19-31: <code>Vec&lt;String&gt;</code>の周りに<code>Wrapper</code>を作成して<code>Display</code>を実装する</span></p>
<!--
The implementation of `Display` uses `self.0` to access the inner `Vec<T>`,
because `Wrapper` is a tuple struct and `Vec<T>` is the item at index 0 in the
tuple. Then we can use the functionality of the `Display` type on `Wrapper`.
-->
<p><code>Display</code>の実装は、<code>self.0</code>で中身の<code>Vec&lt;T&gt;</code>にアクセスしています。<code>Wrapper</code>はタプル構造体で、
<code>Vec&lt;T&gt;</code>がタプルの添え字0の要素だからです。それから、<code>Wrapper</code>に対して<code>Display</code>型の機能を使用できます。</p>
<!--
The downside of using this technique is that `Wrapper` is a new type, so it
doesn’t have the methods of the value it’s holding. We would have to implement
all the methods of `Vec<T>` directly on `Wrapper` such that the methods
delegate to `self.0`, which would allow us to treat `Wrapper` exactly like a
`Vec<T>`. If we wanted the new type to have every method the inner type has,
implementing the `Deref` trait (discussed in Chapter 15 in the “Treating Smart
Pointers like Regular References with the `Deref` Trait” section) on the
`Wrapper` to return the inner type would be a solution. If we don’t want the
`Wrapper` type to have all the methods of the inner type—for example, to
restrict the `Wrapper` type’s behavior—we would have to implement just the
methods we do want manually.
-->
<p>このテクニックを使用する欠点は、<code>Wrapper</code>が新しい型なので、保持している値のメソッドがないことです。
<code>self.0</code>に委譲して、<code>Wrapper</code>を<code>Vec&lt;T&gt;</code>と全く同様に扱えるように、<code>Wrapper</code>に直接<code>Vec&lt;T&gt;</code>の全てのメソッドを実装しなければならないでしょう。
内部の型が持つ全てのメソッドを新しい型に持たせたいなら、
<code>Deref</code>トレイト(第15章の「<code>Deref</code>トレイトでスマートポインタを普通の参照のように扱う」節で議論しました)を<code>Wrapper</code>に実装して、
内部の型を返すことは解決策の1つでしょう。内部の型のメソッド全部を<code>Wrapper</code>型に持たせたくない(例えば、<code>Wrapper</code>型の機能を制限するなど)なら、
本当に欲しいメソッドだけを手動で実装しなければならないでしょう。</p>
<!--
Now you know how the newtype pattern is used in relation to traits; it’s also a
useful pattern even when traits are not involved. Let’s switch focus and look
at some advanced ways to interact with Rust’s type system.
-->
<p>もう、トレイトに関してニュータイプパターンが使用される方法を知りました; トレイトが関連しなくても、
有用なパターンでもあります。焦点を変更して、Rustの型システムと相互作用する一部の高度な方法を見ましょう。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Advanced Types
-->
<h2 id="高度な型"><a class="header" href="#高度な型">高度な型</a></h2>
<!--
The Rust type system has some features that we’ve mentioned in this book but
haven’t yet discussed. We’ll start by discussing newtypes in general as we
examine why newtypes are useful as types. Then we’ll move on to type aliases, a
feature similar to newtypes but with slightly different semantics. We’ll also
discuss the `!` type and dynamically sized types.
-->
<p>Rustの型システムには、この本で触れたけれども、まだ議論していない機能があります。ニュータイプが何故型として有用なのかを調査するため、
一般化してニュータイプを議論することから始めます。そして、型エイリアスに移ります。ニュータイプに類似しているけれども、
多少異なる意味を持つ機能です。また、<code>!</code>型と動的サイズ決定型も議論します。</p>
<!--
> Note: The next section assumes you’ve read the earlier section “The Newtype
> Pattern to Implement External Traits on External Types.”
-->
<blockquote>
<p>注釈: 次の節は、前節「外部の型に外部のトレイトを実装するニュータイプパターン」を読了済みであることを前提にしています。</p>
</blockquote>
<!--
### Using the Newtype Pattern for Type Safety and Abstraction
-->
<h3 id="型安全性と抽象化を求めてニュータイプパターンを使用する"><a class="header" href="#型安全性と抽象化を求めてニュータイプパターンを使用する">型安全性と抽象化を求めてニュータイプパターンを使用する</a></h3>
<!--
The newtype pattern is useful for tasks beyond those we’ve discussed so far,
including statically enforcing that values are never confused and indicating
the units of a value. You saw an example of using newtypes to indicate units in
Listing 19-23: recall that the `Millimeters` and `Meters` structs wrapped `u32`
values in a newtype. If we wrote a function with a parameter of type
`Millimeters`, we couldn’t compile a program that accidentally tried to call
that function with a value of type `Meters` or a plain `u32`.
-->
<p>ここまでに議論した以上の作業についてもニュータイプパターンは有用で、静的に絶対に値を混同しないことを強制したり、
値の単位を示すことを含みます。ニュータイプを使用して単位を示す例をリスト19-23で見かけました:
<code>Millimeters</code>と<code>Meters</code>構造体は、<code>u32</code>値をニュータイプにラップしていたことを思い出してください。
型<code>Millimeters</code>を引数にする関数を書いたら、誤ってその関数を型<code>Meters</code>や普通の<code>u32</code>で呼び出そうとするプログラムはコンパイルできないでしょう。</p>
<!--
Another use of the newtype pattern is in abstracting away some implementation
details of a type: the new type can expose a public API that is different from
the API of the private inner type if we used the new type directly to restrict
the available functionality, for example.
-->
<p>型の実装の詳細を抽象化する際にニュータイプパターンを使用するでしょう: 例えば、新しい型を直接使用して、
利用可能な機能を制限したら、非公開の内部の型のAPIとは異なる公開APIを新しい型は露出できます。</p>
<!--
Newtypes can also hide internal implementation. For example, we could provide a
`People` type to wrap a `HashMap<i32, String>` that stores a person’s ID
associated with their name. Code using `People` would only interact with the
public API we provide, such as a method to add a name string to the `People`
collection; that code wouldn’t need to know that we assign an `i32` ID to names
internally. The newtype pattern is a lightweight way to achieve encapsulation
to hide implementation details, which we discussed in the “Encapsulation that
Hides Implementation Details” section of Chapter 17.
-->
<p>ニュータイプはまた、内部の実装を<ruby>隠匿<rp>(</rp><rt>いんとく</rt><rp>)</rp></ruby>することもできます。例を挙げれば、<code>People</code>型を提供して、
人のIDと名前を紐づけて格納する<code>HashMap&lt;i32, String&gt;</code>をラップすることができるでしょう。
<code>People</code>を使用するコードは、名前の文字列を<code>People</code>コレクションに追加するメソッドなど、
提供している公開APIとだけ相互作用するでしょう; そのコードは、内部で<code>i32</code>IDを名前に代入していることを知る必要はないでしょう。
ニュータイプパターンは、カプセル化を実現して実装の詳細を隠匿する軽い方法であり、
実装の詳細を隠匿することは、第17章の「カプセル化は実装詳細を隠蔽する」節で議論しましたね。</p>
<!--
### Creating Type Synonyms with Type Aliases
-->
<h3 id="型エイリアスで型同義語を生成する"><a class="header" href="#型エイリアスで型同義語を生成する">型エイリアスで型同義語を生成する</a></h3>
<!--
Along with the newtype pattern, Rust provides the ability to declare a *type
alias* to give an existing type another name. For this we use the `type`
keyword. For example, we can create the alias `Kilometers` to `i32` like so:
-->
<p>ニュータイプパターンに付随して、Rustでは、既存の型に別の名前を与える<em>型エイリアス</em>(type alias: 型別名)を宣言する能力が提供されています。
このために、<code>type</code>キーワードを使用します。例えば、以下のように<code>i32</code>に対して<code>Kilometers</code>というエイリアスを作れます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Kilometers = i32;
<span class="boring">}
</span></code></pre></pre>
<!--
Now, the alias `Kilometers` is a *synonym* for `i32`; unlike the `Millimeters`
and `Meters` types we created in Listing 19-23, `Kilometers` is not a separate,
new type. Values that have the type `Kilometers` will be treated the same as
values of type `i32`:
-->
<p>これで、別名の<code>Kilometers</code>は<code>i32</code>と<em>同義語</em>になりました; リスト19-23で生成した<code>Millimeters</code>と<code>Meters</code>とは異なり、
<code>Kilometers</code>は個別の新しい型ではありません。型<code>Kilometers</code>の値は、型<code>i32</code>の値と同等に扱われます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<!--
Because `Kilometers` and `i32` are the same type, we can add values of both
types and we can pass `Kilometers` values to functions that take `i32`
parameters. However, using this method, we don’t get the type checking benefits
that we get from the newtype pattern discussed earlier.
-->
<p><code>Kilometers</code>と<code>i32</code>が同じ型なので、両方の型の値を足し合わせたり、<code>Kilometers</code>の値を<code>i32</code>引数を取る関数に渡せたりします。
ですが、この方策を使用すると、先ほど議論したニュータイプパターンで得られる型チェックの利便性は得られません。</p>
<!--
The main use case for type synonyms is to reduce repetition. For example, we
might have a lengthy type like this:
-->
<p>型同義語の主なユースケースは、繰り返しを減らすことです。例えば、こんな感じの長い型があるかもしれません:</p>
<pre><code class="language-rust ignore">Box&lt;Fn() + Send + 'static&gt;
</code></pre>
<!--
Writing this lengthy type in function signatures and as type annotations all
over the code can be tiresome and error prone. Imagine having a project full of
code like that in Listing 19-32.
-->
<p>この長ったらしい型を関数シグニチャや型注釈としてコードのあちこちで記述するのは、面倒で間違いも起きやすいです。
リスト19-32のそのようなコードで溢れかえったプロジェクトがあることを想像してください。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f: Box&lt;Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Box&lt;Fn() + Send + 'static&gt;) {
    // --snip--
}

fn returns_long_type() -&gt; Box&lt;Fn() + Send + 'static&gt; {
    // --snip--
<span class="boring">    Box::new(|| ())
</span>}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-32: Using a long type in many places</span>
-->
<p><span class="caption">リスト19-32: 長い型を多くの場所で使用する</span></p>
<!--
A type alias makes this code more manageable by reducing the repetition. In
Listing 19-33, we’ve introduced an alias named `Thunk` for the verbose type and
can replace all uses of the type with the shorter alias `Thunk`.
-->
<p>型エイリアスは、繰り返しを減らすことでこのコードをより管理しやすくしてくれます。リスト19-33で、
冗長な型に<code>Thunk</code>(<code>注釈</code>: 塊)を導入し、その型の使用全部をより短い別名の<code>Thunk</code>で置き換えることができます。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Thunk = Box&lt;Fn() + Send + 'static&gt;;

let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -&gt; Thunk {
    // --snip--
<span class="boring">    Box::new(|| ())
</span>}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-33: Introducing a type alias `Thunk` to reduce
repetition</span>
-->
<p><span class="caption">リスト19-33: 型エイリアスの<code>Thunk</code>を導入して繰り返しを減らす</span></p>
<!--
This code is much easier to read and write! Choosing a meaningful name for a
type alias can help communicate your intent as well (*thunk* is a word for code
to be evaluated at a later time, so it’s an appropriate name for a closure that
gets stored).
-->
<p>このコードの方が遥かに読み書きしやすいです！型エイリアスに意味のある名前を選択すると、
意図を伝えるのにも役に立つことがあります(<em>thunk</em>は後ほど評価されるコードのための単語なので、
格納されるクロージャーには適切な名前です)。</p>
<!--
Type aliases are also commonly used with the `Result<T, E>` type for reducing
repetition. Consider the `std::io` module in the standard library. I/O
operations often return a `Result<T, E>` to handle situations when operations
fail to work. This library has a `std::io::Error` struct that represents all
possible I/O errors. Many of the functions in `std::io` will be returning
`Result<T, E>` where the `E` is `std::io::Error`, such as these functions in
the `Write` trait:
-->
<p>型エイリアスは、繰り返しを減らすために<code>Result&lt;T, E&gt;</code>型ともよく使用されます。標準ライブラリの<code>std::io</code>モジュールを考えてください。
I/O処理はしばしば、<code>Result&lt;T, E&gt;</code>を返して処理がうまく動かなかった時を扱います。このライブラリには、
全ての可能性のあるI/Oエラーを表す<code>std::io::Error</code>構造体があります。<code>std::io</code>の関数の多くは、
<code>Write</code>トレイトの以下の関数のように<code>E</code>が<code>std::io::Error</code>の<code>Result&lt;T, E&gt;</code>を返すでしょう:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Error;
use std::fmt;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<!--
The `Result<..., Error>` is repeated a lot. As such, `std::io` has this type of
alias declaration:
-->
<p><code>Result&lt;..., Error&gt;</code>が何度も繰り返されてます。そんな状態なので、<code>std::io</code>にはこんな類のエイリアス宣言があります:</p>
<pre><code class="language-rust ignore">type Result&lt;T&gt; = Result&lt;T, std::io::Error&gt;;
</code></pre>
<!--
Because this declaration is in the `std::io` module, we can use the fully
qualified alias `std::io::Result<T>`-that is, a `Result<T, E>` with the `E`
filled in as `std::io::Error`. The `Write` trait function signatures end up
looking like this:
-->
<p>この宣言は<code>std::io</code>モジュール内にあるので、フルパスエイリアスの<code>std::io::Result&lt;T&gt;</code>を使用できます。
つまり、<code>E</code>が<code>std::io::Error</code>で埋められた<code>Result&lt;T, E&gt;</code>です。その結果、<code>Write</code>トレイトの関数シグニチャは、
以下のような見た目になります:</p>
<pre><code class="language-rust ignore">pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<!--
The type alias helps in two ways: it makes code easier to write *and* it gives
us a consistent interface across all of `std::io`. Because it’s an alias, it’s
just another `Result<T, E>`, which means we can use any methods that work on
`Result<T, E>` with it, as well as special syntax like the `?` operator.
-->
<p>型エイリアスは、2通りの方法で役に立っています: コードを書きやすくすること<em>と</em><code>std::io</code>を通して首尾一貫したインターフェイスを与えてくれることです。
別名なので、ただの<code>Result&lt;T, E&gt;</code>であり、要するに<code>Result&lt;T, E&gt;</code>に対して動くメソッドはなんでも使えるし、
<code>?</code>演算子のような特殊な記法も使えます。</p>
<!--
### The Never Type that Never Returns
-->
<h3 id="never型は絶対に返らない"><a class="header" href="#never型は絶対に返らない">never型は絶対に返らない</a></h3>
<!--
to stand inで「代役を務める」という意味だが、ここではあえて直訳にした
-->
<!--
Rust has a special type named `!` that’s known in type theory lingo as the
*empty type* because it has no values. We prefer to call it the *never type*
because it stands in the place of the return type when a function will never
return. Here is an example:
-->
<p>Rustには、<code>!</code>という名前の特別な型があります。それは型理論の専門用語では <em>Empty型</em> と呼ばれ値なしを表します。私たちは、
関数が値を返すことが決して (never) ない時に戻り値の型を記す場所に使われるので、<em>never type</em>(<code>訳注</code>: 日本語にはできないので、never型と呼ぶしかないか)と呼ぶのが好きです。
こちらが例です:</p>
<pre><code class="language-rust ignore">fn bar() -&gt; ! {
    // --snip--
}
</code></pre>
<!--
This code is read as “the function `bar` returns never.” Functions that return
never are called *diverging functions*. We can’t create values of the type `!`
so `bar` can never possibly return.
-->
<p>このコードは、「関数<code>bar</code>はneverを返す」と解読します。neverを返す関数は、<em>発散する関数</em>(diverging function)と呼ばれます。
型<code>!</code>の値は生成できないので、<code>bar</code>からリターンする（呼び出し元に制御を戻す）ことは決してできません。</p>
<!--
But what use is a type you can never create values for? Recall the code from
Listing 2-5; we’ve reproduced part of it here in Listing 19-34.
-->
<p>ですが、値を絶対に生成できない型をどう使用するのでしょうか？リスト2-5のコードを思い出してください;
リスト19-34に一部を再掲します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let guess = &quot;3&quot;;
</span><span class="boring">loop {
</span>let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
<span class="boring">break;
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-34: A `match` with an arm that ends in
`continue`</span>
-->
<p><span class="caption">リスト19-34: <code>continue</code>になるアームがある<code>match</code></span></p>
<!--
At the time, we skipped over some details in this code. In Chapter 6 in “The
`match` Control Flow Operator” section, we discussed that `match` arms must all
return the same type. So, for example, the following code doesn’t work:
-->
<p>この時点では、このコードの詳細の一部を飛ばしました。第6章の「<code>match</code>制御フロー演算子」節で、
<code>match</code>アームは全て同じ型を返さなければならないと議論しました。従って、例えば以下のコードは動きません:</p>
<pre><code class="language-rust ignore">let guess = match guess.trim().parse() {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;hello&quot;,
}
</code></pre>
<!--
The type of `guess` in this code would have to be an integer *and* a string,
and Rust requires that `guess` have only one type. So what does `continue`
return? How were we allowed to return a `u32` from one arm and have another arm
that ends with `continue` in Listing 19-34?
-->
<p>このコードの<code>guess</code>は整数<em>かつ</em>文字列にならなければならないでしょうが、Rustでは、<code>guess</code>は1つの型にしかならないことを要求されます。
では、<code>continue</code>は何を返すのでしょうか？どうやってリスト19-34で1つのアームからは<code>u32</code>を返し、別のアームでは、
<code>continue</code>で終わっていたのでしょうか？</p>
<!--
As you might have guessed, `continue` has a `!` value. That is, when Rust
computes the type of `guess`, it looks at both match arms, the former with a
value of `u32` and the latter with a `!` value. Because `!` can never have a
value, Rust decides that the type of `guess` is `u32`.
-->
<p>もうお気付きかもしれませんが、<code>continue</code>は<code>!</code>値です。つまり、コンパイラが<code>guess</code>の型を計算する時、
両方のmatchアームを見て、前者は<code>u32</code>の値、後者は<code>!</code>値となります。<code>!</code>は絶対に値を持ち得ないので、
コンパイラは、<code>guess</code>の型は<code>u32</code>と決定するのです。</p>
<!--
The formal way of describing this behavior is that expressions of type `!` can
be coerced into any other type. We’re allowed to end this `match` arm with
`continue` because `continue` doesn’t return a value; instead, it moves control
back to the top of the loop, so in the `Err` case, we never assign a value to
`guess`.
-->
<p>この振る舞いを解説する公式の方法は、型<code>!</code>の式は、他のどんな型にも型強制され得るということです。
この<code>match</code>アームを<code>continue</code>で終えることができます。何故なら、<code>continue</code>は値を返さないからです;
その代わりに制御をループの冒頭に戻すので、<code>Err</code>の場合、<code>guess</code>には絶対に値を代入しないのです。</p>
<!--
The never type is useful with the `panic!` macro as well. Remember the `unwrap`
function that we call on `Option<T>` values to produce a value or panic? Here
is its definition:
-->
<p>never型は、<code>panic!</code>マクロとも有用です。<code>Option&lt;T&gt;</code>値に対して呼び出して、値かパニックを生成した<code>unwrap</code>関数を覚えていますか？
こちらがその定義です:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<!--
In this code, the same thing happens as in the `match` in Listing 19-34: Rust
sees that `val` has the type `T` and `panic!` has the type `!`, so the result
of the overall `match` expression is `T`. This code works because `panic!`
doesn't produce a value; it ends the program. In the `None` case, we won’t be
returning a value from `unwrap`, so this code is valid.
-->
<p>このコードにおいて、リスト19-34の<code>match</code>と同じことが起きています: コンパイラは、<code>val</code>の型は<code>T</code>で、
<code>panic!</code>の型は<code>!</code>なので、<code>match</code>式全体の結果は<code>T</code>と確認します。<code>panic!</code>は値を生成しないので、
このコードは動きます。つまり、プログラムを終了するのです。<code>None</code>の場合、<code>unwrap</code>から値は返さないので、
このコードは合法なのです。</p>
<!--
One final expression that has the type `!` is a `loop`:
-->
<p>型が<code>!</code>の最後の式は、<code>loop</code>です:</p>
<pre><code class="language-rust ignore">// 永遠に
print!(&quot;forever &quot;);

loop {
    // さらに永遠に
    print!(&quot;and ever &quot;);
}
</code></pre>
<!--
Here, the loop never ends, so `!` is the value of the expression. However, this
wouldn’t be true if we included a `break`, because the loop would terminate
when it got to the `break`.
-->
<p>ここで、ループは終わりませんので、<code>!</code>が式の値です。ところが、<code>break</code>を含んでいたら、これは真実にはならないでしょう。
<code>break</code>に到達した際にループが終了してしまうからです。</p>
<!--
### Dynamically Sized Types and the `Sized` Trait
-->
<h3 id="動的サイズ決定型とsizedトレイト"><a class="header" href="#動的サイズ決定型とsizedトレイト">動的サイズ決定型と<code>Sized</code>トレイト</a></h3>
<!--
Due to Rust’s need to know certain details, such as how much space to allocate
for a value of a particular type, there is a corner of its type system that can
be confusing: the concept of *dynamically sized types*. Sometimes referred to
as *DSTs* or *unsized types*, these types let us write code using values whose
size we can know only at runtime.
-->
<p>コンパイラが特定の型の値1つにどれくらいのスペースのメモリを確保するのかなどの特定の詳細を知る必要があるために、
Rustの型システムには混乱を招きやすい細かな仕様があります: <em>動的サイズ決定型</em>の概念です。時として<em>DST</em>や<em>サイズなし型</em>とも称され、
これらの型により、実行時にしかサイズを知ることのできない値を使用するコードを書かせてくれます。</p>
<!--
Let’s dig into the details of a dynamically sized type called `str`, which
we’ve been using throughout the book. That’s right, not `&str`, but `str` on
its own, is a DST. We can’t know how long the string is until runtime, meaning
we can’t create a variable of type `str`, nor can we take an argument of type
`str`. Consider the following code, which does not work:
-->
<p><code>str</code>と呼ばれる動的サイズ決定型の詳細を深掘りしましょう。本を通して使用してきましたね。
そうです。<code>&amp;str</code>ではなく、<code>str</code>は単独でDSTなのです。実行時までは文字列の長さを知ることができず、
これは、型<code>str</code>の変数を生成したり、型<code>str</code>を引数に取ることはできないことを意味します。
動かない以下のコードを考えてください:</p>
<pre><code class="language-rust ignore">// こんにちは
let s1: str = &quot;Hello there!&quot;;
// 調子はどう？
let s2: str = &quot;How's it going?&quot;;
</code></pre>
<!--
Rust needs to know how much memory to allocate for any value of a particular
type, and all values of a type must use the same amount of memory. If Rust
allowed us to write this code, these two `str` values would need to take up the
same amount of space. But they have different lengths: `s1` needs 12 bytes of
storage and `s2` needs 15. This is why it’s not possible to create a variable
holding a dynamically sized type.
-->
<p>コンパイラは、特定の型のどんな値に対しても確保するメモリ量を知る必要があり、ある型の値は全て同じ量のメモリを使用しなければなりません。
Rustでこのコードを書くことが許容されたら、これら2つの<code>str</code>値は、同じ量のスペースを消費する必要があったでしょう。
ですが、長さが異なります: <code>s1</code>は、12バイトのストレージが必要で、<code>s2</code>は15バイトです。このため、
動的サイズ決定型を保持する変数を生成することはできないのです。</p>
<!--
So what do we do? In this case, you already know the answer: we make the types
of `s1` and `s2` a `&str` rather than a `str`. Recall that in the “String
Slices” section of Chapter 4, we said the slice data structure stores the
starting position and the length of the slice.
-->
<p>では、どうすればいいのでしょうか？この場合、もう答えはご存知です: <code>s1</code>と<code>s2</code>の型を<code>str</code>ではなく、
<code>&amp;str</code>にすればいいのです。第4章の「文字列スライス」節でスライスデータ構造は、
開始地点とスライスの長さを格納していると述べたことを思い出してください。</p>
<!--
So although a `&T` is a single value that stores the memory address of where
the `T` is located, a `&str` is *two* values: the address of the `str` and its
length. As such, we can know the size of a `&str` value at compile time: it’s
twice the length of a `usize`. That is, we always know the size of a `&str`, no
matter how long the string it refers to is. In general, this is the way in
which dynamically sized types are used in Rust: they have an extra bit of
metadata that stores the size of the dynamic information. The golden rule of
dynamically sized types is that we must always put values of dynamically sized
types behind a pointer of some kind.
-->
<p>従って、<code>&amp;T</code>は、<code>T</code>がどこにあるかのメモリアドレスを格納する単独の値だけれども、<code>&amp;str</code>は<em>2つ</em>の値なのです:
<code>str</code>のアドレスとその長さです。そのため、コンパイル時に<code>&amp;str</code>のサイズを知ることができます:
<code>usize</code>の長さの2倍です。要するに、参照している文字列の長さによらず、常に<code>&amp;str</code>のサイズがわかります。
通常、このようにしてRustでは動的サイズ決定型が使用されます: 動的情報のサイズを格納する追加のちょっとしたメタデータがあるのです。
動的サイズ決定型の黄金規則は、常に動的サイズ決定型の値をなんらかの種類のポインタの背後に配置しなければならないということです。</p>
<!--
We can combine `str` with all kinds of pointers: for example, `Box<str>` or
`Rc<str>`. In fact, you’ve seen this before but with a different dynamically
sized type: traits. Every trait is a dynamically sized type we can refer to by
using the name of the trait. In Chapter 17 in the “Using Trait Objects that
Allow for Values of Different Types” section, we mentioned that to use traits
as trait objects, we must put them behind a pointer, such as `&Trait` or
`Box<Trait>` (`Rc<Trait>` would work too).
-->
<p><code>str</code>を全ての種類のポインタと組み合わせられます: 例を挙げれば、<code>Box&lt;str&gt;</code>や<code>Rc&lt;str&gt;</code>などです。
実際、これまでに見かけましたが、異なる動的サイズ決定型でした: トレイトです。全てのトレイトは、
トレイト名を使用して参照できる動的サイズ決定型です。第17章の「トレイトオブジェクトで異なる型の値を許容する」節で、
トレイトをトレイトオブジェクトとして使用するには、<code>&amp;Trait</code>や<code>Box&lt;Trait&gt;</code>(<code>Rc&lt;Trait&gt;</code>も動くでしょう)など、
ポインタの背後に配置しなければならないことに触れました。</p>
<!--
To work with DSTs, Rust has a particular trait called the `Sized` trait to
determine whether or not a type’s size is known at compile time. This trait is
automatically implemented for everything whose size is known at compile time.
In addition, Rust implicitly adds a bound on `Sized` to every generic function.
That is, a generic function definition like this:
-->
<p>DSTを扱うために、Rustには<code>Sized</code>トレイトと呼ばれる特定のトレイトがあり、型のサイズがコンパイル時にわかるかどうかを決定します。
このトレイトは、コンパイル時にサイズの判明する全てのものに自動的に実装されます。加えて、
コンパイラは暗黙的に全てのジェネリックな関数に<code>Sized</code>の境界を追加します。つまり、こんな感じのジェネリック関数定義は:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}
</code></pre>
<!--
is actually treated as though we had written this:
-->
<p>実際にはこう書いたかのように扱われます:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
</code></pre>
<!--
By default, generic functions will work only on types that have a known size at
compile time. However, you can use the following special syntax to relax this
restriction:
-->
<p>既定では、ジェネリック関数はコンパイル時に判明するサイズがある型に対してのみ動きます。
ですが、以下の特別な記法を用いてこの制限を緩めることができます:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
</code></pre>
<!--
A trait bound on `?Sized` is the opposite of a trait bound on `Sized`: we would
read this as “`T` may or may not be `Sized`.” This syntax is only available for
`Sized`, not any other traits.
-->
<p><code>?Sized</code>のトレイト境界は、<code>Sized</code>のトレイト境界の逆になります: これを「<code>T</code>は<code>Sized</code>かもしれないし、違うかもしれない」と解読するでしょう。
この記法は、<code>Sized</code>にのみ利用可能で、他のトレイトにはありません。</p>
<!--
Also note that we switched the type of the `t` parameter from `T` to `&T`.
Because the type might not be `Sized`, we need to use it behind some kind of
pointer. In this case, we’ve chosen a reference.
-->
<p>また、<code>t</code>引数の型を<code>T</code>から<code>&amp;T</code>に切り替えたことにも注目してください。型は<code>Sized</code>でない可能性があるので、
なんらかのポインタの背後に使用する必要があるのです。今回は、参照を選択しました。</p>
<!--
Next, we’ll talk about functions and closures!
-->
<p>次は、関数とクロージャについて語ります！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Advanced Functions and Closures
-->
<h2 id="高度な関数とクロージャ"><a class="header" href="#高度な関数とクロージャ">高度な関数とクロージャ</a></h2>
<!--
Finally, we’ll explore some advanced features related to functions and
closures, which include function pointers and returning closures.
-->
<p>最後に関数とクロージャに関連する高度な機能の一部を探究し、これには関数ポインタとクロージャの返却が含まれます。</p>
<!--
### Function Pointers
-->
<h3 id="関数ポインタ"><a class="header" href="#関数ポインタ">関数ポインタ</a></h3>
<!--
We’ve talked about how to pass closures to functions; you can also pass regular
functions to functions! This technique is useful when you want to pass a
function you’ve already defined rather than defining a new closure. Doing this
with function pointers will allow you to use functions as arguments to other
functions. Functions coerce to the type `fn` (with a lowercase f), not to be
confused with the `Fn` closure trait. The `fn` type is called a *function
pointer*. The syntax for specifying that a parameter is a function pointer is
similar to that of closures, as shown in Listing 19-35.
-->
<p>クロージャを関数に渡す方法について語りました; 普通の関数を関数に渡すこともできるのです！
新しいクロージャを定義するのではなく、既に定義した関数を渡したい時にこのテクニックは有用です。
これを関数ポインタで行うと、関数を引数として他の関数に渡して使用できます。関数は、型<code>fn</code>(小文字のfです)に型強制されます。
<code>Fn</code>クロージャトレイトと混同すべきではありません。<code>fn</code>型は、<em>関数ポインタ</em>と呼ばれます。
引数が関数ポインタであると指定する記法は、クロージャのものと似ています。リスト19-35のように。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    // 答えは{}
    println!(&quot;The answer is: {}&quot;, answer);
}
</code></pre></pre>
<!--
<span class="caption">Listing 19-35: Using the `fn` type to accept a function
pointer as an argument</span>
-->
<p><span class="caption">リスト19-35: <code>fn</code>型を使用して引数として関数ポインタを受け入れる</span></p>
<!--
This code prints `The answer is: 12`. We specify that the parameter `f` in
`do_twice` is an `fn` that takes one parameter of type `i32` and returns an
`i32`. We can then call `f` in the body of `do_twice`. In `main`, we can pass
the function name `add_one` as the first argument to `do_twice`.
-->
<p>このコードは、<code>The answer is: 12</code>と出力します。<code>do_twice</code>の引数<code>f</code>は、型<code>i32</code>の1つの引数を取り、
<code>i32</code>を返す<code>fn</code>と指定しています。それから、<code>do_twice</code>の本体で<code>f</code>を呼び出すことができます。
<code>main</code>では、関数名の<code>add_one</code>を最初の引数として<code>do_twice</code>に渡せます。</p>
<!--
Unlike closures, `fn` is a type rather than a trait, so we specify `fn` as the
parameter type directly rather than declaring a generic type parameter with one
of the `Fn` traits as a trait bound.
-->
<p>クロージャと異なり、<code>fn</code>はトレイトではなく型なので、トレイト境界として<code>Fn</code>トレイトの1つでジェネリックな型引数を宣言するのではなく、
直接<code>fn</code>を引数の型として指定します。</p>
<!--
Function pointers implement all three of the closure traits (`Fn`, `FnMut`, and
`FnOnce`), so you can always pass a function pointer as an argument for a
function that expects a closure. It’s best to write functions using a generic
type and one of the closure traits so your functions can accept either
functions or closures.
-->
<p>関数ポインタは、クロージャトレイト3つ全て(<code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>)を実装するので、常に関数ポインタを引数として、
クロージャを期待する関数に渡すことができます。関数が関数とクロージャどちらも受け入れられるように、
ジェネリックな型とクロージャトレイトの1つを使用して関数を書くのが最善です。</p>
<!--
An example of where you would want to only accept `fn` and not closures is when
interfacing with external code that doesn’t have closures: C functions can
accept functions as arguments, but C doesn’t have closures.
-->
<p>クロージャではなく<code>fn</code>だけを受け入れたくなる箇所の一例は、クロージャのない外部コードとのインターフェイスです:
C関数は引数として関数を受け入れられますが、Cにはクロージャがありません。</p>
<!--
couldだが、でしょうでは文を続けられないので、できるであろうにしている
-->
<!--
As an example of where you could use either a closure defined inline or a named
function, let’s look at a use of `map`. To use the `map` function to turn a
vector of numbers into a vector of strings, we could use a closure, like this:
-->
<p>インラインでクロージャが定義されるか、名前付きの関数を使用できるであろう箇所の例として、<code>map</code>の使用に目を向けましょう。
<code>map</code>関数を使用して数字のベクタを文字列のベクタに変換するには、このようにクロージャを使用できるでしょう:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(|i| i.to_string())
    .collect();
<span class="boring">}
</span></code></pre></pre>
<!--
Or we could name a function as the argument to `map` instead of the closure,
like this:
-->
<p>あるいは、このようにクロージャの代わりに<code>map</code>に引数として関数を名指しできるでしょう:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(ToString::to_string)
    .collect();
<span class="boring">}
</span></code></pre></pre>
<!--
Note that we must use the fully qualified syntax that we talked about earlier
in the “Advanced Traits” section because there are multiple functions available
named `to_string`. Here, we’re using the `to_string` function defined in the
`ToString` trait, which the standard library has implemented for any type that
implements `Display`.
-->
<p>先ほど「高度なトレイト」節で語ったフルパス記法を使わなければならないことに注意してください。
というのも、<code>to_string</code>という利用可能な関数は複数あるからです。ここでは、
<code>ToString</code>トレイトで定義された<code>to_string</code>関数を使用していて、このトレイトは標準ライブラリが、
<code>Display</code>を実装するあらゆる型に実装しています。</p>
<!--
Some people prefer this style, and some people prefer to use closures. They end
up compiling to the same code, so use whichever style is clearer to you.
-->
<p>このスタイルを好む方もいますし、クロージャを使うのを好む方もいます。どちらも結果的に同じコードにコンパイルされるので、
どちらでも、自分にとって明確な方を使用してください。</p>
<!--
### Returning Closures
-->
<h3 id="クロージャを返却する"><a class="header" href="#クロージャを返却する">クロージャを返却する</a></h3>
<!--
Closures are represented by traits, which means you can’t return closures
directly. In most cases where you might want to return a trait, you can instead
use the concrete type that implements the trait as the return value of the
function. But you can’t do that with closures because they don’t have a
concrete type that is returnable; you’re not allowed to use the function
pointer `fn` as a return type, for example.
-->
<p>クロージャはトレイトによって表現されます。つまり、クロージャを直接は返却できないのです。
トレイトを返却したい可能性のあるほとんどの場合、代わりにトレイトを実装する具体的な型を関数の戻り値として使用できます。
ですが、クロージャではそれはできません。返却可能な具体的な型がないからです; 例えば、
関数ポインタの<code>fn</code>を戻り値の型として使うことは許容されていません。</p>
<!--
The following code tries to return a closure directly, but it won’t compile:
-->
<p>以下のコードは、クロージャを直接返そうとしていますが、コンパイルできません:</p>
<pre><code class="language-rust ignore">fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<!--
The compiler error is as follows:
-->
<p>コンパイルエラーは以下の通りです:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::ops::Fn(i32) -&gt; i32 + 'static:
std::marker::Sized` is not satisfied
 --&gt;
  |
1 | fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^ `std::ops::Fn(i32) -&gt; i32 + 'static`
  does not have a constant size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for
  `std::ops::Fn(i32) -&gt; i32 + 'static`
  = note: the return type of a function must have a statically known size
</code></pre>
<!--
The error references the `Sized` trait again! Rust doesn’t know how much space
it will need to store the closure. We saw a solution to this problem earlier.
We can use a trait object:
-->
<p>エラーは、再度<code>Sized</code>トレイトを参照しています！コンパイラには、クロージャを格納するのに必要なスペースがどれくらいかわからないのです。
この問題の解決策は先ほど見かけました。トレイトオブジェクトを使えます:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<!--
This code will compile just fine. For more about trait objects, refer to the
“Using Trait Objects That Allow for Values of Different Types” section in
Chapter 17.
-->
<p>このコードは、問題なくコンパイルできます。トレイトオブジェクトについて詳しくは、
第17章の「トレイトオブジェクトで異なる型の値を許容する」節を参照してください。</p>
<!--
Next, let’s look at macros!
-->
<p>次は、マクロを見てみましょう！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Macros
-->
<h2 id="マクロ"><a class="header" href="#マクロ">マクロ</a></h2>
<!--
We’ve used macros like `println!` throughout this book, but we haven’t fully
explored what a macro is and how it works. The term *macro* refers to a family
of features in Rust: *declarative* macros with `macro_rules!` and three kinds
of *procedural* macros:
-->
<p>本全体を通じて<code>println!</code>のようなマクロを使用してきましたが、マクロがなんなのかや、
どう動いているのかということは完全には探究していませんでした。
Rustにおいて、<em>マクロ</em>という用語はある機能の集合のことを指します：<code>macro_rules!</code>を使った <em>宣言的 (declarative)</em> マクロと、3種類の <em>手続き的 (procedural)</em> マクロ：</p>
<!--
* Custom `#[derive]` macros that specify code added with the `derive` attribute
  used on structs and enums
* Attribute-like macros that define custom attributes usable on any item
* Function-like macros that look like function calls but operate on the tokens
  specified as their argument
-->
<ul>
<li>構造体とenumに<code>derive</code>属性を使ったときに追加されるコードを指定する、カスタムの<code>#[derive]</code>マクロ</li>
<li>任意の要素に使えるカスタムの属性を定義する、属性風のマクロ</li>
<li>関数のように見えるが、引数として指定されたトークンに対して作用する関数風のマクロ</li>
</ul>
<p>です。</p>
<!--
We’ll talk about each of these in turn, but first, let’s look at why we even
need macros when we already have functions.
-->
<p>それぞれについて一つずつ話していきますが、その前にまず、どうして関数がすでにあるのにマクロなんてものが必要なのか見てみましょう。</p>
<!--
### The Difference Between Macros and Functions
-->
<h3 id="マクロと関数の違い"><a class="header" href="#マクロと関数の違い">マクロと関数の違い</a></h3>
<!--
Fundamentally, macros are a way of writing code that writes other code, which
is known as *metaprogramming*. In Appendix C, we discuss the `derive`
attribute, which generates an implementation of various traits for you. We’ve
also used the `println!` and `vec!` macros throughout the book. All of these
macros *expand* to produce more code than the code you’ve written manually.
-->
<p>基本的に、マクロは、他のコードを記述するコードを書く術であり、これは<em>メタプログラミング</em>として知られています。
付録Cで、<code>derive</code>属性を議論し、これは、色々なトレイトの実装を生成してくれるのでした。
また、本を通して<code>println!</code>や<code>vec!</code>マクロを使用してきました。これらのマクロは全て、<em>展開</em>され、
手で書いたよりも多くのコードを生成します。</p>
<!--
Metaprogramming is useful for reducing the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have
some additional powers that functions don’t.
-->
<p>メタプログラミングは、書いて管理しなければならないコード量を減らすのに有用で、これは、関数の役目の一つでもあります。
ですが、マクロには関数にはない追加の力があります。</p>
<!--
A function signature must declare the number and type of parameters the
function has. Macros, on the other hand, can take a variable number of
parameters: we can call `println!("hello")` with one argument or
`println!("hello {}", name)` with two arguments. Also, macros are expanded
before the compiler interprets the meaning of the code, so a macro can, for
example, implement a trait on a given type. A function can’t, because it gets
called at runtime and a trait needs to be implemented at compile time.
-->
<p>関数シグニチャは、関数の引数の数と型を宣言しなければなりません。一方、マクロは可変長の引数を取れます:
<code>println!(&quot;hello&quot;)</code>のように1引数で呼んだり、<code>println!(&quot;hello {}&quot;, name)</code>のように2引数で呼んだりできるのです。
また、マクロは、コンパイラがコードの意味を解釈する前に展開されるので、例えば、
与えられた型にトレイトを実装できます。関数ではできません。何故なら、関数は実行時に呼ばれ、
トレイトはコンパイル時に実装される必要があるからです。</p>
<!--
The downside to implementing a macro instead of a function is that macro
definitions are more complex than function definitions because you’re writing
Rust code that writes Rust code. Due to this indirection, macro definitions are
generally more difficult to read, understand, and maintain than function
definitions.
-->
<p>関数ではなくマクロを実装する欠点は、Rustコードを記述するRustコードを書いているので、
関数定義よりもマクロ定義は複雑になることです。この間接性のために、マクロ定義は一般的に、
関数定義よりも、読みにくく、わかりにくく、管理しづらいです。</p>
<!--
Another important difference between macros and functions is that you must
define macros or bring them into scope *before* you call them in a file, as
opposed to functions you can define anywhere and call anywhere.
-->
<p>マクロと関数にはもう一つ、重要な違いがあります: ファイル内で呼び出す<em>前</em>にマクロは定義したりスコープに導入しなければなりませんが、
一方で関数はどこにでも定義でき、どこでも呼び出せます。</p>
<!--
### Declarative Macros with `macro_rules!` for General Metaprogramming
-->
<h3 id="一般的なメタプログラミングのためにmacro_rulesで宣言的なマクロ"><a class="header" href="#一般的なメタプログラミングのためにmacro_rulesで宣言的なマクロ">一般的なメタプログラミングのために<code>macro_rules!</code>で宣言的なマクロ</a></h3>
<!--
The most widely used form of macros in Rust is *declarative macros*. These are
also sometimes referred to as “macros by example,” “`macro_rules!` macros,” or
just plain “macros.” At their core, declarative macros allow you to write
something similar to a Rust `match` expression. As discussed in Chapter 6,
`match` expressions are control structures that take an expression, compare the
resulting value of the expression to patterns, and then run the code associated
with the matching pattern. Macros also compare a value to patterns that are
associated with particular code: in this situation, the value is the literal
Rust source code passed to the macro; the patterns are compared with the
structure of that source code; and the code associated with each pattern, when
matched, replaces the code passed to the macro. This all happens during
compilation.
-->
<p>Rustにおいて、最もよく使用される形態のマクロは、<em>宣言的マクロ</em>です。これらは時として、
<em>例によるマクロ</em>、<em><code>macro_rules!</code>マクロ</em>、あるいはただ単に<em>マクロ</em>とも称されます。
核となるのは、宣言的マクロは、Rustの<code>match</code>式に似た何かを書けるということです。第6章で議論したように、
<code>match</code>式は、式を取り、式の結果の値をパターンと比較し、それからマッチしたパターンに紐づいたコードを実行する制御構造です。
マクロも、あるコードと紐付けられたパターンと値を比較します。ここで、値とは
マクロに渡されたリテラルのRustのソースコードそのもののこと。パターンがそのソースコードの構造と比較されます。
各パターンに紐づいたコードは、それがマッチしたときに、マクロに渡されたコードを置き換えます。これは全て、コンパイル時に起きます。</p>
<!--
To define a macro, you use the `macro_rules!` construct. Let’s explore how to
use `macro_rules!` by looking at how the `vec!` macro is defined. Chapter 8
covered how we can use the `vec!` macro to create a new vector with particular
values. For example, the following macro creates a new vector containing three
integers:
-->
<p>マクロを定義するには、<code>macro_rules!</code>構文を使用します。<code>vec!</code>マクロが定義されている方法を見て、
<code>macro_rules!</code>を使用する方法を探究しましょう。<code>vec!</code>マクロを使用して特定の値で新しいベクタを生成する方法は、
第8章で講義しました。例えば、以下のマクロは、3つの整数を持つ新しいベクタを生成します:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<!--
We could also use the `vec!` macro to make a vector of two integers or a vector
of five string slices. We wouldn’t be able to use a function to do the same
because we wouldn’t know the number or type of values up front.
-->
<p>また、<code>vec!</code>マクロを使用して2整数のベクタや、5つの文字列スライスのベクタなども生成できます。
同じことを関数を使って行うことはできません。予め、値の数や型がわかっていないからです。</p>
<!--
Listing 19-28 shows a slightly simplified definition of the `vec!` macro.
-->
<p>リスト19-28で<ruby>些<rp>(</rp><rt>いささ</rt><rp>)</rp></ruby>か簡略化された<code>vec!</code>マクロの定義を見かけましょう。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 19-28: A simplified version of the `vec!` macro
definition</span>
-->
<p><span class="caption">リスト19-28: <code>vec!</code>マクロ定義の簡略化されたバージョン</span></p>
<!--
> Note: The actual definition of the `vec!` macro in the standard library
> includes code to preallocate the correct amount of memory up front. That code
> is an optimization that we don’t include here to make the example simpler.
-->
<blockquote>
<p>標準ライブラリの<code>vec!</code>マクロの実際の定義は、予め正確なメモリ量を確保するコードを含みます。
その最適化コードは、ここでは簡略化のために含みません。</p>
</blockquote>
<!--
The `#[macro_export]` annotation indicates that this macro should be made
available whenever the crate in which the macro is defined is brought into
scope. Without this annotation, the macro can’t be brought into scope.
-->
<p><code>#[macro_export]</code>注釈は、マクロを定義しているクレートがスコープに持ち込まれたなら、無条件でこのマクロが利用可能になるべきということを示しています。
この注釈がなければ、このマクロはスコープに導入されることができません。</p>
<!--
We then start the macro definition with `macro_rules!` and the name of the
macro we’re defining *without* the exclamation mark. The name, in this case
`vec`, is followed by curly brackets denoting the body of the macro definition.
-->
<p>それから、<code>macro_rules!</code>でマクロ定義と定義しているマクロの名前をビックリマーク<em>なしで</em>始めています。
名前はこの場合<code>vec</code>であり、マクロ定義の本体を意味する波括弧が続いています。</p>
<!--
The structure in the `vec!` body is similar to the structure of a `match`
expression. Here we have one arm with the pattern `( $( $x:expr ),* )`,
followed by `=>` and the block of code associated with this pattern. If the
pattern matches, the associated block of code will be emitted. Given that this
is the only pattern in this macro, there is only one valid way to match; any
other pattern will result in an error. More complex macros will have more than
one arm.
-->
<p><code>vec!</code>本体の構造は、<code>match</code>式の構造に類似しています。ここではパターン<code>( $( $x:expr ),* )</code>の1つのアーム、
<code>=&gt;</code>とこのパターンに紐づくコードのブロックが続きます。パターンが合致すれば、紐づいたコードのブロックが発されます。
これがこのマクロの唯一のパターンであることを踏まえると、合致する合法的な方法は一つしかありません;
それ以外は、全部エラーになるでしょう。より複雑なマクロには、2つ以上のアームがあるでしょう。</p>
<!--
Valid pattern syntax in macro definitions is different than the pattern syntax
covered in Chapter 18 because macro patterns are matched against Rust code
structure rather than values. Let’s walk through what the pattern pieces in
Listing 19-28 mean; for the full macro pattern syntax, see [the reference].
-->
<p>マクロ定義で合法なパターン記法は、第18章で講義したパターン記法とは異なります。というのも、
マクロのパターンは値ではなく、Rustコードの構造に対してマッチされるからです。リスト19-28のパターンの部品がどんな意味か見ていきましょう;
マクロパターン記法全ては<a href="https://doc.rust-lang.org/reference/macros.html">参考文献</a>をご覧ください。</p>
<!--
[the reference]: ../reference/macros-by-example.html
-->
<!--
First, a set of parentheses encompasses the whole pattern. A dollar sign (`$`)
is next, followed by a set of parentheses that captures values that match the
pattern within the parentheses for use in the replacement code. Within `$()` is
`$x:expr`, which matches any Rust expression and gives the expression the name
`$x`.
-->
<p>まず、1組のカッコがパターン全体を囲んでいます。次にドル記号(<code>$</code>)、そして1組のカッコが続き、
このかっこは、置き換えるコードで使用するためにかっこ内でパターンにマッチする値をキャプチャします。
<code>$()</code>の内部には、<code>$x:expr</code>があり、これは任意のRust式にマッチし、その式に<code>$x</code>という名前を与えます。</p>
<!--
The comma following `$()` indicates that a literal comma separator character
could optionally appear after the code that matches the code in `$()`. The `*`
specifies that the pattern matches zero or more of whatever precedes the `*`.
-->
<p><code>$()</code>に続くカンマは、<code>$()</code>にキャプチャされるコードにマッチするコードの後に、区別を意味するリテラルのカンマ文字が現れるという選択肢もあることを示唆しています。
<code>*</code>は、パターンが<code>*</code>の前にあるもの0個以上にマッチすることを指定しています。</p>
<!--
When we call this macro with `vec![1, 2, 3];`, the `$x` pattern matches three
times with the three expressions `1`, `2`, and `3`.
-->
<p>このマクロを<code>vec![1, 2, 3];</code>と呼び出すと、<code>$x</code>パターンは、3つの式<code>1</code>、<code>2</code>、<code>3</code>で3回マッチします。</p>
<!--
Now let’s look at the pattern in the body of the code associated with this arm:
`temp_vec.push()` within `$()*` is generated for each part that matches `$()`
in the pattern zero or more times depending on how many times the pattern
matches. The `$x` is replaced with each expression matched. When we call this
macro with `vec![1, 2, 3];`, the code generated that replaces this macro call
will be the following:
-->
<p>さて、このアームに紐づくコードの本体のパターンに目を向けましょう: <code>$()*</code>部分内部の<code>temp_vec.push()</code>コードは、
パターンがマッチした回数に応じて0回以上パターン内で<code>$()</code>にマッチする箇所ごとに生成されます。
<code>$x</code>はマッチした式それぞれに置き換えられます。このマクロを<code>vec![1, 2, 3];</code>と呼び出すと、
このマクロ呼び出しを置き換え、生成されるコードは以下のようになるでしょう:</p>
<pre><code class="language-rust ignore">{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
</code></pre>
<!--
We’ve defined a macro that can take any number of arguments of any type and can
generate code to create a vector containing the specified elements.
-->
<p>任意の型のあらゆる数の引数を取り、指定した要素を含むベクタを生成するコードを生成できるマクロを定義しました。</p>
<!--
There are some strange edge cases with `macro_rules!`. In the future, Rust will
have a second kind of declarative macro that will work in a similar fashion but
fix some of these edge cases. After that update, `macro_rules!` will be
effectively deprecated. With this in mind, as well as the fact that most Rust
programmers will *use* macros more than *write* macros, we won’t discuss
`macro_rules!` any further. To learn more about how to write macros, consult
the online documentation or other resources, such as [“The Little Book of Rust
Macros”][tlborm].
-->
<p><code>macro_rules!</code>には、いくつかの奇妙なコーナーケースがあります。
将来、Rustには別種の宣言的マクロが登場する予定です。これは、同じように働くけれども、それらのコーナーケースのうちいくらかを修正します。
そのアップデート以降、<code>macro_rules!</code>は事実上非推奨 (deprecated) となる予定です。
この事実と、ほとんどのRustプログラマーはマクロを<em>書く</em>よりも<em>使う</em>ことが多いということを考えて、<code>macro_rules!</code>についてはこれ以上語らないことにします。
もしマクロの書き方についてもっと知りたければ、オンラインのドキュメントや、<a href="https://danielkeep.github.io/tlborm/book/index.html">“The Little Book of Rust Macros”</a>のようなその他のリソースを参照してください。</p>
<!--
### Procedural Macros for Generating Code from Attributes
-->
<h3 id="属性からコードを生成する手続き的マクロ"><a class="header" href="#属性からコードを生成する手続き的マクロ">属性からコードを生成する手続き的マクロ</a></h3>
<!--
The second form of macros is *procedural macros*, which act more like functions
(and are a type of procedure). Procedural macros accept some code as an input,
operate on that code, and produce some code as an output rather than matching
against patterns and replacing the code with other code as declarative macros
do.
-->
<p>2つ目のマクロの形は、<em>手続き的マクロ</em>と呼ばれ、より関数のように働きます（そして一種の手続きです）。
宣言的マクロがパターンマッチングを行い、マッチしたコードを他のコードで置き換えていたのとは違い、
手続き的マクロは、コードを入力として受け取り、そのコードに対して作用し、出力としてコードを生成します。</p>
<!--
The three kinds of procedural macros (custom derive, attribute-like, and
function-like) all work in a similar fashion.
-->
<p>3種の手続き的マクロ (カスタムのderiveマクロ, 属性風マクロ、関数風マクロ)はみな同じような挙動をします。</p>
<!--
When creating procedural macros, the definitions must reside in their own crate
with a special crate type. This is for complex technical reasons that we hope
to eliminate in the future. Using procedural macros looks like the code in
Listing 19-29, where `some_attribute` is a placeholder for using a specific
macro.
-->
<p>手続き的マクロを作る際は、その定義はそれ専用の特殊なクレート内に置かれる必要があります。
これは複雑な技術的理由によるものであり、将来的には解消したいです。
手続き的マクロを使うとListing 19-29のコードのようになります。<code>some_attribute</code>がそのマクロを使うためのプレースホールダーです。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}
</code></pre>
<!--
<span class="caption">Listing 19-29: An example of using a procedural
macro</span>
-->
<p><span class="caption">Listing 19-29: 手続き的マクロの使用例</span></p>
<!--
The function that defines a procedural macro takes a `TokenStream` as an input
and produces a `TokenStream` as an output. The `TokenStream` type is defined by
the `proc_macro` crate that is included with Rust and represents a sequence of
tokens. This is the core of the macro: the source code that the macro is
operating on makes up the input `TokenStream`, and the code the macro produces
is the output `TokenStream`. The function also has an attribute attached to it
that specifies which kind of procedural macro we’re creating. We can have
multiple kinds of procedural macros in the same crate.
-->
<p>手続き的マクロを定義する関数は<code>TokenStream</code>を入力として受け取り、<code>TokenStream</code>を出力として生成します。
<code>TokenStream</code>型はRustに内蔵されている<code>proc_macro</code>クレートで定義されており、トークンの列を表します。
ここがマクロの一番重要なところなのですが、マクロが作用するソースコードは、入力の<code>TokenStream</code>へと変換され、マクロが生成するコードが出力の<code>TokenStream</code>なのです。
この関数には属性もつけられていますが、これはどの種類の手続き的マクロを作っているのかを指定します。
同じクレート内に複数の種類の手続き的マクロを持つことも可能です。</p>
<!--
Let’s look at the different kinds of procedural macros. We’ll start with a
custom derive macro and then explain the small dissimilarities that make the
other forms different.
-->
<p>様々な種類の手続き的マクロを見てみましょう。カスタムのderiveマクロから始めて、そのあと他の種類との小さな相違点を説明します。</p>
<!--
### How to Write a Custom `derive` Macro
-->
<h3 id="カスタムのderive-マクロの書き方"><a class="header" href="#カスタムのderive-マクロの書き方">カスタムの<code>derive</code> マクロの書き方</a></h3>
<!--
Let’s create a crate named `hello_macro` that defines a trait named
`HelloMacro` with one associated function named `hello_macro`. Rather than
making our crate users implement the `HelloMacro` trait for each of their
types, we’ll provide a procedural macro so users can annotate their type with
`#[derive(HelloMacro)]` to get a default implementation of the `hello_macro`
function. The default implementation will print `Hello, Macro! My name is
TypeName!` where `TypeName` is the name of the type on which this trait has
been defined. In other words, we’ll write a crate that enables another
programmer to write code like Listing 19-30 using our crate.
-->
<p><code>hello_macro</code>という名前のクレートを作成してみましょう。
このクレートは、<code>hello_macro</code>という関連関数が1つある<code>HelloMacro</code>というトレイトを定義します。
クレートの使用者に使用者の型に<code>HelloMacro</code>トレイトを実装することを強制するのではなく、
使用者が型を<code>#[derive(HelloMacro)]</code>で注釈して<code>hello_macro</code>関数の既定の実装を得られるように、
手続き的マクロを提供します。既定の実装は、<code>Hello, Macro! My name is TypeName!</code>(<code>訳注</code>: こんにちは、マクロ！僕の名前はTypeNameだよ！)と出力し、
ここで<code>TypeName</code>はこのトレイトが定義されている型の名前です。言い換えると、他のプログラマに我々のクレートを使用して、
リスト19-30のようなコードを書けるようにするクレートを記述します。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<!--
<span class="caption">Listing 19-30: The code a user of our crate will be able
to write when using our procedural macro</span>
-->
<p><span class="caption">リスト19-30: 我々の手続き的マクロを使用した時にクレートの使用者が書けるようになるコード</span></p>
<!--
This code will print `Hello, Macro! My name is Pancakes!` when we’re done. The
first step is to make a new library crate, like this:
-->
<p>このコードは完成したら、<code>Hello, Macro! My name is Pancakes!</code>(<code>Pancakes</code>: ホットケーキ)と出力します。最初の手順は、
新しいライブラリクレートを作成することです。このように:</p>
<pre><code class="language-console">$ cargo new hello_macro --lib
</code></pre>
<!--
Next, we’ll define the `HelloMacro` trait and its associated function:
-->
<p>次に<code>HelloMacro</code>トレイトと関連関数を定義します:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait HelloMacro {
    fn hello_macro();
}
<span class="boring">}
</span></code></pre></pre>
<!--
We have a trait and its function. At this point, our crate user could implement
the trait to achieve the desired functionality, like so:
-->
<p>トレイトと関数があります。この時点でクレートの使用者は、以下のように、
このトレイトを実装して所望の機能を達成できるでしょう。</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<!--
However, they would need to write the implementation block for each type they
wanted to use with `hello_macro`; we want to spare them from having to do this
work.
-->
<p>しかしながら、使用者は、<code>hello_macro</code>を使用したい型それぞれに実装ブロックを記述する必要があります;
この作業をしなくても済むようにしたいです。</p>
<!--
Additionally, we can’t yet provide the `hello_macro` function with default
implementation that will print the name of the type the trait is implemented
on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s
name at runtime. We need a macro to generate code at compile time.
-->
<p>さらに、まだ<code>hello_macro</code>関数にトレイトが実装されている型の名前を出力する既定の実装を提供することはできません:
Rustにはリフレクションの能力がないので、型の名前を実行時に検索することができないのです。
コンパイル時にコード生成するマクロが必要です。</p>
<blockquote>
<p>注釈: リフレクションとは、実行時に型名や関数の中身などを取得する機能のことです。
言語によって提供されていたりいなかったりしますが、実行時にメタデータがないと取得できないので、
RustやC++のようなアセンブリコードに翻訳され、パフォーマンスを要求される高級言語では、提供されないのが一般的と思われます。</p>
</blockquote>
<!--
The next step is to define the procedural macro. At the time of this writing,
procedural macros need to be in their own crate. Eventually, this restriction
might be lifted. The convention for structuring crates and macro crates is as
follows: for a crate named `foo`, a custom derive procedural macro crate is
called `foo_derive`. Let’s start a new crate called `hello_macro_derive` inside
our `hello_macro` project:
-->
<p>次の手順は、手続き的マクロを定義することです。これを執筆している時点では、手続き的マクロは、
独自のクレートに存在する必要があります。最終的には、この制限は持ち上げられる可能性があります。
クレートとマクロクレートを構成する慣習は以下の通りです: <code>foo</code>というクレートに対して、
カスタムのderive手続き的マクロクレートは<code>foo_derive</code>と呼ばれます。<code>hello_macro</code>プロジェクト内に、
<code>hello_macro_derive</code>と呼ばれる新しいクレートを開始しましょう:</p>
<pre><code class="language-console">$ cargo new hello_macro_derive --lib
</code></pre>
<!--
Our two crates are tightly related, so we create the procedural macro crate
within the directory of our `hello_macro` crate. If we change the trait
definition in `hello_macro`, we’ll have to change the implementation of the
procedural macro in `hello_macro_derive` as well. The two crates will need to
be published separately, and programmers using these crates will need to add
both as dependencies and bring them both into scope. We could instead have the
`hello_macro` crate use `hello_macro_derive` as a dependency and re-export the
procedural macro code. However, the way we’ve structured the project makes it
possible for programmers to use `hello_macro` even if they don’t want the
`derive` functionality.
-->
<p>2つのクレートは緊密に関係しているので、<code>hello_macro</code>クレートのディレクトリ内に手続き的マクロクレートを作成しています。
<code>hello_macro</code>のトレイト定義を変更したら、<code>hello_macro_derive</code>の手続き的マクロの実装も変更しなければならないでしょう。
2つのクレートは個別に公開される必要があり、これらのクレートを使用するプログラマは、
両方を依存に追加し、スコープに導入する必要があるでしょう。<code>hello_macro</code>クレートに依存として、
<code>hello_macro_derive</code>を使用させ、手続き的マクロのコードを再エクスポートすることもできるかもしれませんが、
このようなプロジェクトの構造にすることで、プログラマが<code>derive</code>機能を使用したくなくても、<code>hello_macro</code>を使用することが可能になります。</p>
<!--
We need to declare the `hello_macro_derive` crate as a procedural macro crate.
We’ll also need functionality from the `syn` and `quote` crates, as you’ll see
in a moment, so we need to add them as dependencies. Add the following to the
*Cargo.toml* file for `hello_macro_derive`:
-->
<p><code>hello_macro_derive</code>クレートを手続き的マクロクレートとして宣言する必要があります。
また、すぐにわかるように、<code>syn</code>と<code>quote</code>クレートの機能も必要になるので、依存として追加する必要があります。
以下を<code>hello_macro_derive</code>の<em>Cargo.toml</em>ファイルに追加してください:</p>
<!--
<span class="filename">Filename: hello_macro_derive/Cargo.toml</span>
-->
<p><span class="filename">ファイル名: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;1.0&quot;
quote = &quot;1.0&quot;
</code></pre>
<!--
To start defining the procedural macro, place the code in Listing 19-31 into
your *src/lib.rs* file for the `hello_macro_derive` crate. Note that this code
won’t compile until we add a definition for the `impl_hello_macro` function.
-->
<p>手続き的マクロの定義を開始するために、<code>hello_macro_derive</code>クレートの<em>src/lib.rs</em>ファイルにリスト19-31のコードを配置してください。
<code>impl_hello_macro</code>関数の定義を追加するまでこのコードはコンパイルできないことに注意してください。</p>
<!--
<span class="filename">Filename: hello_macro_derive/src/lib.rs</span>
-->
<p><span class="filename">ファイル名: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">extern crate proc_macro;

use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // 操作可能な構文木としてのRustコードの表現を構築する
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // トレイトの実装内容を構築
    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}
</code></pre>
<!--
<span class="caption">Listing 19-31: Code that most procedural macro crates
will require in order to process Rust code</span>
-->
<p><span class="caption">リスト19-31: Rustコードを処理するためにほとんどの手続き的マクロクレートに必要になるコード</span></p>
<!--
Notice that we’ve split the code into the `hello_macro_derive` function, which
is responsible for parsing the `TokenStream`, and the `impl_hello_macro`
function, which is responsible for transforming the syntax tree: this makes
writing a procedural macro more convenient. The code in the outer function
(`hello_macro_derive` in this case) will be the same for almost every
procedural macro crate you see or create. The code you specify in the body of
the inner function (`impl_hello_macro` in this case) will be different
depending on your procedural macro’s purpose.
-->
<p><code>TokenStream</code>をパースする役割を持つ<code>hello_macro_derive</code>関数と、構文木を変換する役割を持つ<code>impl_hello_macro</code>関数にコードを分割したことに注目してください：これにより手続き的マクロを書くのがより簡単になります。
外側の関数（今回だと<code>hello_macro_derive</code>）のコードは、あなたが見かけたり作ったりするであろうほとんどすべての手続き的マクロのクレートで同じです。
内側の関数（今回だと<code>impl_hello_macro</code>）の内部に書き込まれるコードは、手続き的マクロの目的によって異なってくるでしょう。</p>
<!--
We’ve introduced three new crates: `proc_macro`, [`syn`], and [`quote`]. The
`proc_macro` crate comes with Rust, so we didn’t need to add that to the
dependencies in *Cargo.toml*. The `proc_macro` crate is the compiler’s API that
allows us to read and manipulate Rust code from our code.
-->
<p>3つの新しいクレートを導入しました: <code>proc_macro</code>、<a href="https://crates.io/crates/syn"><code>syn</code></a>、<a href="https://crates.io/crates/quote"><code>quote</code></a>です。<code>proc_macro</code>クレートは、
Rustに付随してくるので、<em>Cargo.toml</em>の依存に追加する必要はありませんでした。<code>proc_macro</code>クレートはコンパイラのAPIで、私達のコードからRustのコードを読んだり操作したりすることを可能にします。</p>
<!--
The `syn` crate parses Rust code from a string into a data structure that we
can perform operations on. The `quote` crate turns `syn` data structures back
into Rust code. These crates make it much simpler to parse any sort of Rust
code we might want to handle: writing a full parser for Rust code is no simple
task.
-->
<p><code>syn</code>クレートは、文字列からRustコードを構文解析し、
処理を行えるデータ構造にします。<code>quote</code>クレートは、<code>syn</code>データ構造を取り、Rustコードに変換し直します。
これらのクレートにより、扱いたい可能性のあるあらゆる種類のRustコードを構文解析するのがはるかに単純になります:
Rustコードの完全なパーサを書くのは、単純な作業ではないのです。</p>
<!--
The `hello_macro_derive` function will be called when a user of our library
specifies `#[derive(HelloMacro)]` on a type. This is possible because we’ve
annotated the `hello_macro_derive` function here with `proc_macro_derive` and
specified the name, `HelloMacro`, which matches our trait name; this is the
convention most procedural macros follow.
-->
<p><code>hello_macro_derive</code>関数は、ライブラリの使用者が型に<code>#[derive(HelloMacro)]</code>を指定した時に呼び出されます。
それが可能な理由は、ここで<code>hello_macro_derive</code>関数を<code>proc_macro_derive</code>で注釈し、トレイト名に一致する<code>HelloMacro</code>を指定したからです;
これは、ほとんどの手続き的マクロが倣う慣習です。</p>
<!--
The `hello_macro_derive` function first converts the `input` from a
`TokenStream` to a data structure that we can then interpret and perform
operations on. This is where `syn` comes into play. The `parse` function in
`syn` takes a `TokenStream` and returns a `DeriveInput` struct representing the
parsed Rust code. Listing 19-32 shows the relevant parts of the `DeriveInput`
struct we get from parsing the `struct Pancakes;` string:
-->
<p>この関数はまず、<code>TokenStream</code>からの<code>input</code>をデータ構造に変換し、解釈したり操作したりできるようにします。
ここで<code>syn</code>が登場します。
<code>syn</code>の<code>parse</code>関数は<code>TokenStream</code>を受け取り、パースされたRustのコードを表現する<code>DeriveInput</code>構造体を返します。
Listing 19-32は<code>struct Pancakes;</code>という文字列をパースすることで得られる<code>DeriveInput</code>構造体の関係ある部分を表しています。</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
</code></pre>
<!--
<span class="caption">Listing 19-32: The `DeriveInput` instance we get when
parsing the code that has the macro’s attribute in Listing 19-30</span>
-->
<p><span class="caption">Listing 19-32: このマクロを使った属性を持つListing 19-30のコードをパースしたときに得られる<code>DeriveInput</code>インスタンス</span></p>
<!--
The fields of this struct show that the Rust code we’ve parsed is a unit struct
with the `ident` (identifier, meaning the name) of `Pancakes`. There are more
fields on this struct for describing all sorts of Rust code; check the [`syn`
documentation for `DeriveInput`][syn-docs] for more information.
-->
<p>この構造体のフィールドは、構文解析したRustコードが<code>Pancakes</code>という<code>ident</code>(識別子、つまり名前)のユニット構造体であることを示しています。
この構造体にはRustコードのあらゆる部分を記述するフィールドがもっと多くあります;
<a href="https://docs.rs/syn/1.0/syn/struct.DeriveInput.html"><code>DeriveInput</code>の<code>syn</code>ドキュメンテーション</a>で詳細を確認してください。</p>
<!--
Soon we’ll define the `impl_hello_macro` function, which is where we’ll build
the new Rust code we want to include. But before we do, note that the output
for our derive macro is also a `TokenStream`. The returned `TokenStream` is
added to the code that our crate users write, so when they compile their crate,
they’ll get the extra functionality that we provide in the modified
`TokenStream`.
-->
<p>まもなく<code>impl_hello_macro</code>関数を定義し、そこにインクルードしたい新しいRustコードを構築します。
でもその前に、私達のderiveマクロのための出力もまた<code>TokenStream</code>であることに注目してください。
返された<code>TokenStream</code>をクレートの使用者が書いたコードに追加しているので、クレートをコンパイルすると、
我々が修正した<code>TokenStream</code>で提供している追加の機能を得られます。</p>
<!--
You might have noticed that we’re calling `unwrap` to cause the
`hello_macro_derive` function to panic if the call to the `syn::parse` function
fails here. It’s necessary for our procedural macro to panic on errors because
`proc_macro_derive` functions must return `TokenStream` rather than `Result` to
conform to the procedural macro API. We’ve simplified this example by using
`unwrap`; in production code, you should provide more specific error messages
about what went wrong by using `panic!` or `expect`.
-->
<p>ここで、<code>unwrap</code>を呼び出すことで、<code>syn::parse</code>関数が失敗したときに<code>hello_macro_derive</code>関数をパニックさせていることにお気付きかもしれません。
エラー時にパニックするのは、手続き的マクロコードでは必要なことです。何故なら、
<code>proc_macro_derive</code>関数は、手続き的マクロのAPIに従うために、<code>Result</code>ではなく
<code>TokenStream</code>を返さなければならないからです。この例については、<code>unwrap</code>を使用して簡略化することを選択しました;
プロダクションコードでは、<code>panic!</code>か<code>expect</code>を使用して何が間違っていたのかより具体的なエラーメッセージを提供すべきです。</p>
<!--
Now that we have the code to turn the annotated Rust code from a `TokenStream`
into a `DeriveInput` instance, let’s generate the code that implements the
`HelloMacro` trait on the annotated type, as shown in Listing 19-33.
-->
<p>今や、<code>TokenStream</code>からの注釈されたRustコードを<code>DeriveInput</code>インスタンスに変換するコードができたので、
Listing 19-33のように、注釈された型に<code>HelloMacro</code>トレイトを実装するコードを生成しましょう:</p>
<!--
<span class="filename">Filename: hello_macro_derive/src/lib.rs</span>
-->
<p><span class="filename">ファイル名: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">extern crate proc_macro;
</span><span class="boring">
</span><span class="boring">use proc_macro::TokenStream;
</span><span class="boring">use quote::quote;
</span><span class="boring">use syn;
</span><span class="boring">
</span><span class="boring">#[proc_macro_derive(HelloMacro)]
</span><span class="boring">pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
</span><span class="boring">    // Construct a representation of Rust code as a syntax tree
</span><span class="boring">    // that we can manipulate
</span><span class="boring">    let ast = syn::parse(input).unwrap();
</span><span class="boring">
</span><span class="boring">    // Build the trait implementation
</span><span class="boring">    impl_hello_macro(&amp;ast)
</span><span class="boring">}
</span><span class="boring">
</span>fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}!&quot;, stringify!(#name));
            }
        }
    };
    gen.into()
}
</code></pre>
<!--
<span class="caption">Listing 19-33: Implementing the `HelloMacro` trait using
the parsed Rust code</span>
-->
<p><span class="caption">Listing 19-33: パースされたRustコードを用いて<code>HelloMacro</code>トレイトを実装する</span></p>
<!--
We get an `Ident` struct instance containing the name (identifier) of the
annotated type using `ast.ident`. The struct in Listing 19-32 shows that when
we run the `impl_hello_macro` function on the code in Listing 19-30, the
`ident` we get will have the `ident` field with a value of `"Pancakes"`. Thus,
the `name` variable in Listing 19-33 will contain an `Ident` struct instance
that, when printed, will be the string `"Pancakes"`, the name of the struct in
Listing 19-30.
-->
<p><code>ast.ident</code>を使って、注釈された型の名前(識別子)を含む<code>Ident</code>構造体インスタンスを得ています。
Listing 19-32の構造体を見ると、<code>impl_hello_macro</code>関数をListing 19-30のコードに実行したときに私達の得る<code>ident</code>は、フィールド<code>ident</code>の値として<code>&quot;Pancakes&quot;</code>を持つだろうとわかります。
従って、Listing 19-33における変数<code>name</code>は構造体<code>Ident</code>のインスタンスをもちます。このインスタンスは、printされた時は文字列<code>&quot;Pancakes&quot;</code>、即ちListing 19-30の構造体の名前となります。</p>
<!--
The `quote!` macro lets us define the Rust code that we want to return. The
compiler expects something different to the direct result of the `quote!`
macro’s execution, so we need to convert it to a `TokenStream`. We do this by
calling the `into` method, which consumes this intermediate representation and
returns a value of the required `TokenStream` type.
-->
<p><code>quote!</code>マクロを使うことで、私達が返したいRustコードを定義することができます。
ただ、コンパイラが期待しているものは<code>quote!</code>マクロの実行結果とはちょっと違うものです。なので、<code>TokenStream</code>に変換してやる必要があります。
マクロの出力する直接表現を受け取り、必要とされている<code>TokenStream</code>型の値を返す<code>into</code>メソッドを呼ぶことでこれを行います。</p>
<!--
The `quote!` macro also provides some very cool templating mechanics: we can
enter `#name`, and `quote!` will replace it with the value in the variable
`name`. You can even do some repetition similar to the way regular macros work.
Check out [the `quote` crate’s docs][quote-docs] for a thorough introduction.
-->
<p>このマクロはまた、非常にかっこいいテンプレート機構も提供してくれます; <code>#name</code>と書くと、<code>quote!</code>は
それを<code>name</code>という変数の値と置き換えます。普通のマクロが動作するのと似た繰り返しさえ行えます。
本格的に入門したいなら、<a href="https://docs.rs/quote"><code>quote</code>クレートのdoc</a>をご確認ください。</p>
<!--
We want our procedural macro to generate an implementation of our `HelloMacro`
trait for the type the user annotated, which we can get by using `#name`. The
trait implementation has one function, `hello_macro`, whose body contains the
functionality we want to provide: printing `Hello, Macro! My name is` and then
the name of the annotated type.
-->
<p>手続き的マクロには使用者が注釈した型に対して<code>HelloMacro</code>トレイトの実装を生成してほしいですが、
これは<code>#name</code>を使用することで得られます。トレイトの実装には1つの関数<code>hello_macro</code>があり、
この本体に提供したい機能が含まれています: <code>Hello, Macro! My name is</code>、そして、注釈した型の名前を出力する機能です。</p>
<!--
The `stringify!` macro used here is built into Rust. It takes a Rust
expression, such as `1 + 2`, and at compile time turns the expression into a
string literal, such as `"1 + 2"`. This is different than `format!` or
`println!`, macros which evaluate the expression and then turn the result into
a `String`. There is a possibility that the `#name` input might be an
expression to print literally, so we use `stringify!`. Using `stringify!` also
saves an allocation by converting `#name` to a string literal at compile time.
-->
<p>ここで使用した<code>stringify!</code>マクロは、言語に組み込まれています。<code>1 + 2</code>などのようなRustの式を取り、
コンパイル時に<code>&quot;1 + 2&quot;</code>のような文字列リテラルにその式を変換します。
これは、<code>format!</code>や<code>println!</code>のような、式を評価し、そしてその結果を<code>String</code>に変換するマクロとは異なります。
<code>#name</code>入力が文字通り出力されるべき式という可能性もあるので、<code>stringify!</code>を使用しています。
<code>stringify!</code>を使用すると、コンパイル時に<code>#name</code>を文字列リテラルに変換することで、メモリ確保しなくても済みます。</p>
<!--
At this point, `cargo build` should complete successfully in both `hello_macro`
and `hello_macro_derive`. Let’s hook up these crates to the code in Listing
19-30 to see the procedural macro in action! Create a new binary project in
your *projects* directory using `cargo new pancakes`. We need to add
`hello_macro` and `hello_macro_derive` as dependencies in the `pancakes`
crate’s *Cargo.toml*. If you’re publishing your versions of `hello_macro` and
`hello_macro_derive` to [crates.io](https://crates.io/), they would be regular
dependencies; if not, you can specify them as `path` dependencies as follows:
-->
<p>この時点で、<code>cargo build</code>は<code>hello_macro</code>と<code>hello_macro_derive</code>の両方で成功するはずです。
これらのクレートをリスト19-30のコードにフックして、手続き的マクロが動くところを確認しましょう！
<code>cargo new pancakes</code>であなたの<em>プロジェクトの</em>ディレクトリ（訳注：これまでに作った2つのクレート内ではないということ）に新しいバイナリプロジェクトを作成してください。
<code>hello_macro</code>と<code>hello_macro_derive</code>を依存として<code>pancakes</code>クレートの<em>Cargo.toml</em>に追加する必要があります。
自分のバージョンの<code>hello_macro</code>と<code>hello_macro_derive</code>を<a href="https://crates.io/">crates.io</a> に公開しているなら、
普通の依存になるでしょう; そうでなければ、以下のように<code>path</code>依存として指定すればよいです:</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<!--
Put the code in Listing 19-30 into *src/main.rs*, and run `cargo run`: it
should print `Hello, Macro! My name is Pancakes!` The implementation of the
`HelloMacro` trait from the procedural macro was included without the
`pancakes` crate needing to implement it; the `#[derive(HelloMacro)]` added the
trait implementation.
-->
<p>リスト19-30のコードを<em>src/main.rs</em>に配置し、<code>cargo run</code>を実行してください: <code>Hello, Macro! My name is Pancakes</code>と出力するはずです。
手続き的マクロの<code>HelloMacro</code>トレイトの実装は、<code>pancakes</code>クレートが実装する必要なく、包含されました;
<code>#[derive(HelloMacro)]</code>がトレイトの実装を追加したのです。</p>
<!--
Next, let’s explore how the other kinds of procedural macros differ from custom
derive macros.
-->
<p>続いて、他の種類の手続き的マクロがカスタムのderiveマクロとどのように異なっているか見てみましょう。</p>
<!--
### Attribute-like macros
-->
<h3 id="属性風マクロ"><a class="header" href="#属性風マクロ">属性風マクロ</a></h3>
<!--
Attribute-like macros are similar to custom derive macros, but instead of
generating code for the `derive` attribute, they allow you to create new
attributes. They’re also more flexible: `derive` only works for structs and
enums; attributes can be applied to other items as well, such as functions.
Here’s an example of using an attribute-like macro: say you have an attribute
named `route` that annotates functions when using a web application framework:
-->
<p>属性風マクロはカスタムのderiveマクロと似ていますが、<code>derive</code>属性のためのコードを生成するのではなく、新しい属性を作ることができます。
また、属性風マクロはよりフレキシブルでもあります：<code>derive</code>は構造体とenumにしか使えませんでしたが、属性は関数のような他の要素に対しても使えるのです。
属性風マクロを使った例を以下に示しています：webアプリケーションフレームワークを使っているときに、<code>route</code>という関数につける属性名があるとします：</p>
<pre><code class="language-rust ignore">#[route(GET, &quot;/&quot;)]
fn index() {
</code></pre>
<!--
This `#[route]` attribute would be defined by the framework as a procedural
macro. The signature of the macro definition function would look like this:
-->
<p>この<code>#[route]</code>属性はそのフレームワークによって手続き的マクロとして定義されたものなのでしょう。
マクロを定義する関数のシグネチャは以下のようになっているでしょう：</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
</code></pre>
<!--
Here, we have two parameters of type `TokenStream`. The first is for the
contents of the attribute: the `GET, "/"` part. The second is the body of the
item the attribute is attached to: in this case, `fn index() {}` and the rest
of the function’s body.
-->
<p>ここで、2つ<code>TokenStream</code>型の引数がありますね。
1つ目は属性の中身：<code>GET, &quot;/&quot;</code>に対応しており、2つ目は属性が付けられた要素の中身に対応しています。今回だと<code>fn index() {}</code>と関数の本体の残りですね。</p>
<!--
Other than that, attribute-like macros work the same way as custom derive
macros: you create a crate with the `proc-macro` crate type and implement a
function that generates the code you want!
-->
<p>それ以外において、属性風マクロはカスタムのderiveマクロと同じ動きをします：
クレートタイプとして<code>proc-macro</code>を使ってクレートを作り、あなたのほしいコードを生成してくれる関数を実装すればよいです！</p>
<!--
### Function-like macros
-->
<h3 id="関数風マクロ"><a class="header" href="#関数風マクロ">関数風マクロ</a></h3>
<!--
Function-like macros define macros that look like function calls. Similarly to
`macro_rules!` macros, they’re more flexible than functions; for example, they
can take an unknown number of arguments. However, `macro_rules!` macros can be
defined only using the match-like syntax we discussed in the section
[“Declarative Macros with `macro_rules!` for General Metaprogramming”][decl]
earlier. Function-like macros take a `TokenStream` parameter and their
definition manipulates that `TokenStream` using Rust code as the other two
types of procedural macros do. An example of a function-like macro is an `sql!`
macro that might be called like so:

[decl]: #declarative-macros-with-macro_rules-for-general-metaprogramming
-->
<p>関数風マクロは、関数呼び出しのように見えるマクロを定義します。
これらは、<code>macro_rules!</code>マクロのように、関数よりフレキシブルです。
たとえば、これらは任意の数の引数を取ることができます。
しかし、<a href="ch19-06-macros.html#%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E3%83%A1%E3%82%BF%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E3%81%9F%E3%82%81%E3%81%ABmacro_rules%E3%81%A7%E5%AE%A3%E8%A8%80%E7%9A%84%E3%81%AA%E3%83%9E%E3%82%AF%E3%83%AD">一般的なメタプログラミングのために<code>macro_rules!</code>で宣言的なマクロ</a>で話したように、<code>macro_rules!</code>マクロはmatch風の構文を使ってのみ定義できたのでした。
関数風マクロは引数として<code>TokenStream</code>をとり、その<code>TokenStream</code>を定義に従って操作します。操作には、他の2つの手続き的マクロと同じように、Rustコードが使われます。
例えば、<code>sql!</code>マクロという関数風マクロで、以下のように呼び出されるものを考えてみましょう：</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);
</code></pre>
<!--
This macro would parse the SQL statement inside it and check that it’s
syntactically correct, which is much more complex processing than a
`macro_rules!` macro can do. The `sql!` macro would be defined like this:
-->
<p>このマクロは、中に入れられたSQL文をパースし、それが構文的に正しいことを確かめます。これは<code>macro_rules!</code>マクロが可能とするよりも遥かに複雑な処理です。
<code>sql!</code>マクロは以下のように定義することができるでしょう：</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre>
<!--
This definition is similar to the custom derive macro’s signature: we receive
the tokens that are inside the parentheses and return the code we wanted to
generate.
-->
<p>この定義はカスタムのderiveマクロのシグネチャと似ています：カッコの中のトークンを受け取り、生成したいコードを返すのです。</p>
<!--
## Summary
-->
<h2 id="まとめ-18"><a class="header" href="#まとめ-18">まとめ</a></h2>
<!--
Whew! Now you have some Rust features in your toolbox that you won’t use often,
but you’ll know they’re available in very particular circumstances. We’ve
introduced several complex topics so that when you encounter them in error
message suggestions or in other peoples’ code, you’ll be able to recognize
these concepts and syntax. Use this chapter as a reference to guide you to
solutions.
-->
<p>ふう！
あなたがいま手にしたRustの機能はあまり頻繁に使うものではありませんが、非常に特殊な状況ではその存在を思い出すことになるでしょう。
たくさんの難しいトピックを紹介しましたが、これは、もしあなたがエラー時の推奨メッセージや他の人のコードでそれらに遭遇した時、その概念と文法を理解できるようになっていてほしいからです。
この章を、解決策にたどり着くためのリファレンスとして活用してください。</p>
<!--
Next, we’ll put everything we’ve discussed throughout the book into practice
and do one more project!
-->
<p>次は、この本で話してきたすべてのことを実際に使って、もう一つプロジェクトをやってみましょう！</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Final Project: Building a Multithreaded Web Server
-->
<h1 id="最後のプロジェクト-マルチスレッドのwebサーバを構築する"><a class="header" href="#最後のプロジェクト-マルチスレッドのwebサーバを構築する">最後のプロジェクト: マルチスレッドのWebサーバを構築する</a></h1>
<!--
It’s been a long journey, but we’ve reached the end of the book. In this
chapter, we’ll build one more project together to demonstrate some of the
concepts we covered in the final chapters, as well as recap some earlier
lessons.
-->
<p>長い旅でしたが、本の末端に到達しました。この章では、共にもう一つプロジェクトを構築して最後の方の章で講義した概念の一部をデモしつつ、
それより前の方で学習した内容を思い出してもらいます。</p>
<!--
For our final project, we’ll make a web server that says “hello” and looks like
Figure 20-1 in a web browser.
-->
<p>最後のプロジェクトでは、<code>hello</code>と話すWebサーバを作り、Webブラウザでは、図20-1のような見た目になります。</p>
<p><img src="img/trpl20-01.png" alt="hello from rust" /></p>
<!--
<span class="caption">Figure 20-1: Our final shared project</span>
-->
<p><span class="caption">図20-1: 最後の共有されたプロジェクト</span></p>
<!--
Here is the plan to build the web server:
-->
<p>こちらがWebサーバを構築するプランです:</p>
<!--
1. Learn a bit about TCP and HTTP.
2. Listen for TCP connections on a socket.
3. Parse a small number of HTTP requests.
4. Create a proper HTTP response.
5. Improve the throughput of our server with a thread pool.
-->
<ol>
<li>TCPとHTTPについて少し学ぶ。</li>
<li>ソケットでTCP接続をリッスンする。</li>
<li>少量のHTTPリクエストを構文解析する。</li>
<li>適切なHTTPレスポンスを生成する。</li>
<li>スレッドプールでサーバのスループットを強化する。</li>
</ol>
<!--
But before we get started, we should mention one detail: the method we’ll use
won’t be the best way to build a web server with Rust. A number of
production-ready crates are available on *https://crates.io/* that provide more
complete web server and thread pool implementations than we’ll build.
-->
<p>ですが、取り掛かる前に、ある小さな事実に触れなければなりません:
わたしたちがこれから行うやり方は、RustでWebサーバを構築する最善の方法ではないだろうということです。
これから構築するよりもより完全なWebサーバとスレッドプールの実装を提供する製品利用可能な多くのクレートが、
<em>https://crates.io/</em> で利用可能なのです。</p>
<!--
However, our intention in this chapter is to help you learn, not to take the
easy route. Because Rust is a systems programming language, we can choose the
level of abstraction we want to work with and can go to a lower level than is
possible or practical in other languages. We’ll write the basic HTTP server and
thread pool manually so you can learn the general ideas and techniques behind
the crates you might use in the future.
-->
<p>しかしながら、この章での意図は、学習を手助けすることであり、簡単なやり方を選ぶことではありません。
Rustはシステムプログラミング言語なので、取りかかる抽象度を選ぶことができ、
他の言語で可能だったり実践的だったりするよりも低レベルまで行くことができます。一般的な考えと将来使う可能性のあるクレートの背後にある技術を学べるように、
手動で基本的なHTTPサーバとスレッドプールを書きます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Building a Single-Threaded Web Server
-->
<h2 id="シングルスレッドのwebサーバを構築する"><a class="header" href="#シングルスレッドのwebサーバを構築する">シングルスレッドのWebサーバを構築する</a></h2>
<!--
We’ll start by getting a single-threaded web server working. Before we begin,
let’s look at a quick overview of the protocols involved in building web
servers. The details of these protocols are beyond the scope of this book, but
a brief overview will give you the information you need.
-->
<p>シングルスレッドのWebサーバを動かすところから始めます。始める前に、Webサーバ構築に関係するプロトコルをさっと一覧しましょう。
これらのプロトコルの詳細は、この本の範疇を超えていますが、さっと眺めることで必要な情報が得られるでしょう。</p>
<!--
The two main protocols involved in web servers are the *Hypertext Transfer
Protocol* *(HTTP)* and the *Transmission Control Protocol* *(TCP)*. Both
protocols are *request-response* protocols, meaning a *client* initiates
requests and a *server* listens to the requests and provides a response to the
client. The contents of those requests and responses are defined by the
protocols.
-->
<p>主に2つのプロトコルがWebサーバに関係し、<em>Hypertext Transfer Protocol</em> <em>(HTTP)</em>(<code>注釈</code>: ハイパーテキスト転送プロトコル)と、
<em>Transmission Control Protocol</em> <em>(TCP)</em>(<code>注釈</code>: 伝送制御プロトコル)です。
両者のプロトコルは、<em>リクエスト・レスポンス</em>プロトコルであり、つまり、<em>クライアント</em>がリクエスト(要求)を初期化し、
<em>サーバ</em>はリクエストをリッスンし、クライアントにレスポンス(応答)を提供するということです。
それらのリクエストとレスポンスの中身は、プロトコルで規定されています。</p>
<!--
TCP is the lower-level protocol that describes the details of how information
gets from one server to another but doesn’t specify what that information is.
HTTP builds on top of TCP by defining the contents of the requests and
responses. It’s technically possible to use HTTP with other protocols, but in
the vast majority of cases, HTTP sends its data over TCP. We’ll work with the
raw bytes of TCP and HTTP requests and responses.
-->
<p>TCPは、情報がとあるサーバから別のサーバへどう到達するかの詳細を記述するものの、その情報がなんなのかは指定しない、
より低レベルのプロトコルです。HTTPはリクエストとレスポンスの中身を定義することでTCPの上に成り立っています。
技術的にはHTTPを他のプロトコルとともに使用することができますが、大抵の場合、HTTPはTCPの上にデータを送信します。
TCPとHTTPのリクエストとレスポンスの生のバイトを取り扱います。</p>
<!--
### Listening to the TCP Connection
-->
<h3 id="tcp接続をリッスンする"><a class="header" href="#tcp接続をリッスンする">TCP接続をリッスンする</a></h3>
<!--
Our web server needs to listen to a TCP connection, so that’s the first part
we’ll work on. The standard library offers a `std::net` module that lets us do
this. Let’s make a new project in the usual fashion:
-->
<p>WebサーバはTCP接続をリッスンするので、そこが最初に取り掛かる部分になります。標準ライブラリは、
<code>std::net</code>というこれを行うモジュールを用意しています。通常通り、新しいプロジェクトを作りましょう:</p>
<pre><code class="language-text">$ cargo new hello --bin
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<!--
Now enter the code in Listing 20-1 in *src/main.rs* to start. This code will
listen at the address `127.0.0.1:7878` for incoming TCP streams. When it gets
an incoming stream, it will print `Connection established!`.
-->
<p>さて、リスト20-1のコードを<em>src/main.rs</em>に入力して始めてください。このコードは、
TCPストリームを受信するため<code>127.0.0.1:7878</code>というアドレスをリッスンします。
入力ストリームを得ると、<code>Connection established!</code>と出力します。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        // 接続が確立しました
        println!(&quot;Connection established!&quot;);
    }
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-1: Listening for incoming streams and printing
a message when we receive a stream</span>
-->
<p><span class="caption">リスト20-1: 入力ストリームをリッスンし、ストリームを受け付けた時にメッセージを出力する</span></p>
<!--
Using `TcpListener`, we can listen for TCP connections at the address
`127.0.0.1:7878`. In the address, the section before the colon is an IP address
representing your computer (this is the same on every computer and doesn’t
represent the authors’ computer specifically), and `7878` is the port. We’ve
chosen this port for two reasons: HTTP is normally accepted on this port, and
7878 is “rust” typed on a telephone.
-->
<p><code>TcpListener</code>により、アドレス<code>127.0.0.1:7878</code>でTCP接続をリッスンできます。アドレス内で、
コロンの前の区域は、自分のコンピュータを表すIPアドレスで(これはどんなコンピュータでも同じで、
特に著者のコンピュータを表すわけではありません)、<code>7878</code>はポートです。このポートを選択した理由は2つあります:
HTTPは通常このポートで受け付けられることと、7878は電話で“rust”と入力されるからです。</p>
<!--
The `bind` function in this scenario works like the `new` function in that it
will return a new `TcpListener` instance. The reason the function is called
`bind` is that in networking, connecting to a port to listen to is known as
“binding to a port.”
-->
<p>この筋書きでの<code>bind</code>関数は、新しい<code>TcpListener</code>インスタンスを返すという点で<code>new</code>関数のような働きをします。
この関数が<code>bind</code>と呼ばれている理由は、ネットワークにおいて、リッスンすべきポートに接続することは、
「ポートに束縛する」(binding to a port)こととして知られているからです。</p>
<!--
The `bind` function returns a `Result<T, E>`, which indicates that binding
might fail. For example, connecting to port 80 requires administrator
privileges (nonadministrators can listen only on ports higher than 1024), so if
we tried to connect to port 80 without being an administrator, binding wouldn’t
work. As another example, binding wouldn’t work if we ran two instances of our
program and so had two programs listening to the same port. Because we’re
writing a basic server just for learning purposes, we won’t worry about
handling these kinds of errors; instead, we use `unwrap` to stop the program if
errors happen.
-->
<p><code>bind</code>関数は<code>Result&lt;T, E&gt;</code>を返し、束縛が失敗することもあることを示しています。例えば、
ポート80に接続するには管理者権限が必要なので(管理者以外はポート1024以上しかリッスンできません)管理者にならずにポート80に接続を試みたら、
束縛はうまくいかないでしょう。また、別の例として自分のプログラムを2つ同時に立ち上げて2つのプログラムが同じポートをリッスンしたら、
束縛は機能しないでしょう。学習目的のためだけに基本的なサーバを記述しているので、この種のエラーを扱う心配はしません;
その代わり、<code>unwrap</code>を使用してエラーが発生したら、プログラムを停止します。</p>
<!--
The `incoming` method on `TcpListener` returns an iterator that gives us a
sequence of streams (more specifically, streams of type `TcpStream`). A single
*stream* represents an open connection between the client and the server. A
*connection* is the name for the full request and response process in which a
client connects to the server, the server generates a response, and the server
closes the connection. As such, `TcpStream` will read from itself to see what
the client sent and then allow us to write our response to the stream. Overall,
this `for` loop will process each connection in turn and produce a series of
streams for us to handle.
-->
<p><code>TcpListener</code>の<code>incoming</code>メソッドは、一連のストリームを与えるイテレータを返します(具体的には、型<code>TcpStream</code>のストリーム)。
単独の<em>ストリーム</em>がクライアント・サーバ間の開かれた接続を表します。<em>接続</em>(connection)は、
クライアントがサーバに接続し、サーバがレスポンスを生成し、サーバが接続を閉じるというリクエストとレスポンス全体の過程の名前です。
そのため、<code>TcpStream</code>は自身を読み取って、クライアントが送信したことを確認し、それからレスポンスをストリームに記述させてくれます。
総括すると、この<code>for</code>ループは各接続を順番に処理し、我々が扱えるように一連のストリームを生成します。</p>
<!--
For now, our handling of the stream consists of calling `unwrap` to terminate
our program if the stream has any errors; if there aren’t any errors, the
program prints a message. We’ll add more functionality for the success case in
the next listing. The reason we might receive errors from the `incoming` method
when a client connects to the server is that we’re not actually iterating over
connections. Instead, we’re iterating over *connection attempts*. The
connection might not be successful for a number of reasons, many of them
operating system specific. For example, many operating systems have a limit to
the number of simultaneous open connections they can support; new connection
attempts beyond that number will produce an error until some of the open
connections are closed.
-->
<p>とりあえず、ストリームの扱いは、<code>unwrap</code>を呼び出してストリームにエラーがあった場合にプログラムを停止することから構成されています;
エラーがなければ、プログラムはメッセージを出力します。次のリストで成功した時にさらに多くの機能を追加します。
クライアントがサーバに接続する際に<code>incoming</code>メソッドからエラーを受け取る可能性がある理由は、
実際には接続を走査していないからです。代わりに<em>接続の試行</em>を走査しています。接続は多くの理由で失敗する可能性があり、
そのうちの多くは、OS特有です。例を挙げれば、多くのOSには、サポートできる同時に開いた接続数に上限があります;
開かれた接続の一部が閉じられるまでその数字を超えた接続の試行はエラーになります。</p>
<!--
Let’s try running this code! Invoke `cargo run` in the terminal and then load
*127.0.0.1:7878* in a web browser. The browser should show an error message
like “Connection reset,” because the server isn’t currently sending back any
data. But when you look at your terminal, you should see several messages that
were printed when the browser connected to the server!
-->
<p>このコードを試しに実行してみましょう！端末で<code>cargo run</code>を呼び出し、それからWebブラウザで<em>127.0.0.1:7878</em>をロードしてください。
ブラウザは、「接続がリセットされました」などのエラーメッセージを表示するはずです。サーバが現状、何もデータを返してこないからです。
ですが、端末に目を向ければ、ブラウザがサーバに接続した際にいくつかメッセージが出力されるのを目の当たりにするはずです。</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<!--
Sometimes, you’ll see multiple messages printed for one browser request; the
reason might be that the browser is making a request for the page as well as a
request for other resources, like the *favicon.ico* icon that appears in the
browser tab.
-->
<p>時々、1回のブラウザリクエストで複数のメッセージが出力されるのを目の当たりにするでしょう;
その理由は、ブラウザがページだけでなく、
ブラウザのタブに出現する<em>favicon.ico</em>アイコンなどの他のリソースにもリクエストを行なっているということかもしれません。</p>
<!--
It could also be that the browser is trying to connect to the server multiple
times because the server isn’t responding with any data. When `stream` goes out
of scope and is dropped at the end of the loop, the connection is closed as
part of the `drop` implementation. Browsers sometimes deal with closed
connections by retrying, because the problem might be temporary. The important
factor is that we’ve successfully gotten a handle to a TCP connection!
-->
<p>サーバが何もデータを送り返してこないので、ブラウザがサーバに何度も接続を試みているということである可能性もあるでしょう。
<code>stream</code>がスコープを抜け、ループの最後でドロップされると、接続は<code>drop</code>実装の一部として閉じられます。
ブラウザは、再試行することで閉じられた接続を扱うことがあります。問題が一時的なものである可能性があるからです。
重要な要素は、TCP接続へのハンドルを得ることに成功したということです！</p>
<!--
Remember to stop the program by pressing <span class="keystroke">ctrl-c</span>
when you’re done running a particular version of the code. Then restart `cargo
run` after you’ve made each set of code changes to make sure you’re running the
newest code.
-->
<p>特定のバージョンのコードを走らせ終わった時に<span class="keystroke">ctrl-c</span>を押して、
プログラムを止めることを忘れないでください。そして、一連のコード変更を行った後に<code>cargo run</code>を再起動し、
最新のコードを実行していることを確かめてください。</p>
<!--
### Reading the Request
-->
<h3 id="リクエストを読み取る"><a class="header" href="#リクエストを読み取る">リクエストを読み取る</a></h3>
<!--
Let’s implement the functionality to read the request from the browser! To
separate the concerns of first getting a connection and then taking some action
with the connection, we’ll start a new function for processing connections. In
this new `handle_connection` function, we’ll read data from the TCP stream and
print it so we can see the data being sent from the browser. Change the code to
look like Listing 20-2.
-->
<p>ブラウザからリクエストを読み取る機能を実装しましょう！まず接続を得、それから接続に対して何らかの行動を行う責任を分離するために、
接続を処理する新しい関数を開始します。この新しい<code>handle_connection</code>関数において、TCPストリームからデータを読み取り、
ブラウザからデータが送られていることを確認できるように端末に出力します。コードをリスト20-2のように変更してください。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpStream;
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&amp;mut buffer).unwrap();

    println!(&quot;Request: {}&quot;, String::from_utf8_lossy(&amp;buffer[..]));
}
</code></pre></pre>
<!--
<span class="caption">Listing 20-2: Reading from the `TcpStream` and printing
the data</span>
-->
<p><span class="caption">リスト20-2: <code>TcpStream</code>から読み取り、データを出力する</span></p>
<!--
We bring `std::io::prelude` into scope to get access to certain traits that let
us read from and write to the stream. In the `for` loop in the `main` function,
instead of printing a message that says we made a connection, we now call the
new `handle_connection` function and pass the `stream` to it.
-->
<p><code>std::io::prelude</code>をスコープに導入して、ストリームから読み書きさせてくれる特定のトレイトにアクセスできるようにしています。
<code>main</code>関数内の<code>for</code>ループで、接続を確立したというメッセージを出力する代わりに、今では、
新しい<code>handle_connection</code>関数を呼び出し、<code>stream</code>を渡しています。</p>
<!--
In the `handle_connection` function, we’ve made the `stream` parameter mutable.
The reason is that the `TcpStream` instance keeps track of what data it returns
to us internally. It might read more data than we asked for and save that data
for the next time we ask for data. It therefore needs to be `mut` because its
internal state might change; usually, we think of “reading” as not needing
mutation, but in this case we need the `mut` keyword.
-->
<p><code>handle_connection</code>関数において、<code>stream</code>引数を可変にしました。理由は、
<code>TcpStream</code>インスタンスが内部で返すデータを追いかけているからです。要求した以上のデータを読み取り、
次回データを要求した時のためにそのデータを保存する可能性があります。故に、内部の状態が変化する可能性があるので、
<code>mut</code>にする必要があるのです; 普通、「読み取り」に可変化は必要ないと考えてしまいますが、この場合、<code>mut</code>キーワードが必要です。</p>
<!--
Next, we need to actually read from the stream. We do this in two steps: first,
we declare a `buffer` on the stack to hold the data that is read in. We’ve made
the buffer 1024 bytes in size, which is big enough to hold the data of a basic
request and sufficient for our purposes in this chapter. If we wanted to handle
requests of an arbitrary size, buffer management would need to be more
complicated; we’ll keep it simple for now. We pass the buffer to `stream.read`,
which will read bytes from the `TcpStream` and put them in the buffer.
-->
<p>次に、実際にストリームから読み取る必要があります。これを2つの手順で行います: まず、
スタックに読み取ったデータを保持する<code>buffer</code>を宣言します。バッファーのサイズは1024バイトにしました。
これは、基本的なリクエストには十分な大きさでこの章の目的には必要十分です。任意のサイズのリクエストを扱いたければ、
バッファーの管理はもっと複雑にする必要があります; 今は、単純に保っておきます。このバッファーを<code>stream.read</code>に渡し、
これが<code>TcpStream</code>からバイトを読み取ってバッファーに置きます。</p>
<!--
Second, we convert the bytes in the buffer to a string and print that string.
The `String::from_utf8_lossy` function takes a `&[u8]` and produces a `String`
from it. The “lossy” part of the name indicates the behavior of this function
when it sees an invalid UTF-8 sequence: it will replace the invalid sequence
with `�`, the `U+FFFD REPLACEMENT CHARACTER`. You might see replacement
characters for characters in the buffer that aren’t filled by request data.
-->
<p>2番目にバッファーのバイトを文字列に変換し、その文字列を出力します。<code>String::from_utf8_lossy</code>関数は、
<code>&amp;[u8]</code>を取り、<code>String</code>を生成します。名前の“lossy”の箇所は、無効なUTF-8シーケンスを目の当たりにした際のこの関数の振る舞いを示唆しています:
無効なシーケンスを<code>�</code>、<code>U+FFFD REPLACEMENT CHARACTER</code>で置き換えます。
リクエストデータによって埋められなかったバッファーの部分(<code>訳注</code> バッファーとして1024バイトの領域を用意しているが、リクエストデータは1024バイト存在しないことがほとんどなので変数 <code>buffer</code> の後ろ部分が埋められないまま放置されることを意図していると思われる) は、置換文字が表示される場合があります。</p>
<!--
Let’s try this code! Start the program and make a request in a web browser
again. Note that we’ll still get an error page in the browser, but our
program’s output in the terminal will now look similar to this:
-->
<p>このコードを試しましょう！プログラムを開始してWebブラウザで再度リクエストを送ってください。ブラウザではそれでも、
エラーページが得られるでしょうが、端末のプログラムの出力はこんな感じになっていることに注目してください:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42 secs
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
</code></pre>
<!--
Depending on your browser, you might get slightly different output. Now that
we’re printing the request data, we can see why we get multiple connections
from one browser request by looking at the path after `Request: GET`. If the
repeated connections are all requesting */*, we know the browser is trying to
fetch */* repeatedly because it’s not getting a response from our program.
-->
<p>ブラウザによって、少し異なる出力になる可能性があります。今やリクエストデータを出力しているので、
<code>Request: GET</code>の後のパスを見ることで1回のブラウザリクエストから複数の接続が得られる理由が確認できます。
繰り返される接続が全て <em>/</em> を要求しているなら、ブラウザは、我々のプログラムからレスポンスが得られないので、
繰り返し <em>/</em> をフェッチしようとしていることがわかります。</p>
<!--
Let’s break down this request data to understand what the browser is asking of
our program.
-->
<p>このリクエストデータを噛み砕いて、ブラウザが我々のプログラムに何を要求しているかを理解しましょう。</p>
<!--
### A Closer Look at an HTTP Request
-->
<h3 id="httpリクエストを詳しく見る"><a class="header" href="#httpリクエストを詳しく見る">HTTPリクエストを詳しく見る</a></h3>
<!--
HTTP is a text-based protocol, and a request takes this format:
-->
<p>HTTPはテキストベースのプロトコルで、1つの要求はこのようなフォーマットに則っています:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<!--
The first line is the *request line* that holds information about what the
client is requesting. The first part of the request line indicates the *method*
being used, such as `GET` or `POST`, which describes how the client is making
this request. Our client used a `GET` request.
-->
<p>1行目は、クライアントが要求しているものがなんなのかについての情報を保持するリクエスト行です。
リクエスト行の最初の部分は使用されている<code>GET</code>や<code>POST</code>などの<em>メソッド</em>を示し、これは、どのようにクライアントがこの要求を行なっているかを記述します。
クライアントは<code>GET</code>リクエストを使用しました。</p>
<!--
The next part of the request line is */*, which indicates the *Uniform Resource
Identifier* *(URI)* the client is requesting: a URI is almost, but not quite,
the same as a *Uniform Resource Locator* *(URL)*. The difference between URIs
and URLs isn’t important for our purposes in this chapter, but the HTTP spec
uses the term URI, so we can just mentally substitute URL for URI here.
-->
<p>リクエスト行の次の部分は <em>/</em> で、これはクライアントが要求している<em>Uniform Resource Identifier</em> <em>(URI)</em>(<code>注釈</code>: 統一資源識別子)を示します:
URIはほぼ<em>Uniform Resource Locator</em> <em>(URL)</em>(<code>注釈</code>: 統一資源位置指定子)と同じですが、完全に同じではありません。
URIとURLの違いは、この章の目的には重要ではありませんが、HTTPの規格はURIという用語を使用しているので、
ここでは脳内でURIをURLと読み替えられます。</p>
<!--
The last part is the HTTP version the client uses, and then the request line
ends in a *CRLF sequence*. (CRLF stands for *carriage return* and *line feed*,
which are terms from the typewriter days!) The CRLF sequence can also be
written as `\r\n`, where `\r` is a carriage return and `\n` is a line feed. The
CRLF sequence separates the request line from the rest of the request data.
Note that when the CRLF is printed, we see a new line start rather than `\r\n`.
-->
<p>最後の部分は、クライアントが使用しているHTTPのバージョンで、それからリクエスト行は<em>CRLF</em>で終了します。
(CRLFは<em>carriage return</em>と<em>line feed</em>(無理に日本語でいえば、キャリッジ(紙を固定するシリンダー)が戻ることと行を(コンピュータに)与えること)を表していて、
これはタイプライター時代からの用語です！)CRLFは<code>\r\n</code>とも表記され、<code>\r</code>がキャリッジ・リターンで<code>\n</code>がライン・フィードです。
CRLFにより、リクエスト行がリクエストデータの残りと区別されています。CRLFを出力すると、
<code>\r\n</code>ではなく、新しい行が開始されることに注意してください。</p>
<!--
Looking at the request line data we received from running our program so far,
we see that `GET` is the method, */* is the request URI, and `HTTP/1.1` is the
version.
-->
<p>ここまでプログラムを実行して受け取ったリクエスト行のデータをみると、<code>GET</code>がメソッド、<em>/</em> が要求URI、
<code>HTTP/1.1</code>がバージョンであることが確認できます。</p>
<!--
After the request line, the remaining lines starting from `Host:` onward are
headers. `GET` requests have no body.
-->
<p>リクエスト行の後に、<code>Host:</code>以下から始まる残りの行は、ヘッダです。<code>GET</code>リクエストには、本体（<code>訳注</code>:<code>message-body</code>のこと）がありません。</p>
<!--
Try making a request from a different browser or asking for a different
address, such as *127.0.0.1:7878/test*, to see how the request data changes.
-->
<p>試しに他のブラウザからリクエストを送ったり、<em>127.0.0.1:7878/test</em>などの異なるアドレスを要求してみて、どうリクエストデータが変わるか確認してください。</p>
<!--
Now that we know what the browser is asking for, let’s send back some data!
-->
<p>さて、ブラウザが要求しているものがわかったので、何かデータを返しましょう！</p>
<!--
### Writing a Response
-->
<h3 id="レスポンスを記述する"><a class="header" href="#レスポンスを記述する">レスポンスを記述する</a></h3>
<!--
Now we’ll implement sending data in response to a client request. Responses
have the following format:
-->
<p>さて、クライアントのリクエストに対する返答としてデータの送信を実装します。レスポンスは、以下のようなフォーマットです:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<!--
The first line is a *status line* that contains the HTTP version used in the
response, a numeric status code that summarizes the result of the request, and
a reason phrase that provides a text description of the status code. After the
CRLF sequence are any headers, another CRLF sequence, and the body of the
response.
-->
<p>最初の行は、レスポンスで使用されるHTTPバージョン、リクエストの結果を要約する数値ステータス・コード、そしてステータス・コードのテキスト記述を提供する理由句を含む <em>ステータス行</em> です。
CRLFシーケンスの後には、任意のヘッダ、別のCRLFシーケンス、そしてレスポンスの本体が続きます。</p>
<!--
Here is an example response that uses HTTP version 1.1, has a status code of
200, an OK reason phrase, no headers, and no body:
-->
<p>こちらがHTTPバージョン1.1を使用し、ステータスコードが200で、OKフレーズ、ヘッダと本体なしの例のレスポンスです:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<!--
The status code 200 is the standard success response. The text is a tiny
successful HTTP response. Let’s write this to the stream as our response to a
successful request! From the `handle_connection` function, remove the
`println!` that was printing the request data and replace it with the code in
Listing 20-3.
-->
<p>ステータスコード200は、一般的な成功のレスポンスです。テキストは、<ruby>矮小<rp>(</rp><rt>わいしょう</rt><rp>)</rp></ruby>な成功のHTTPレスポンスです。
これを成功したリクエストへの返答としてストリームに書き込みましょう！<code>handle_connection</code>関数から、
リクエストデータを出力していた<code>println!</code>を除去し、リスト20-3のコードと置き換えてください。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span>fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];

    stream.read(&amp;mut buffer).unwrap();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-3: Writing a tiny successful HTTP response to
the stream</span>
-->
<p><span class="caption">リスト20-3: ストリームに矮小な成功のHTTPレスポンスを書き込む</span></p>
<!--
The first new line defines the `response` variable that holds the success
message’s data. Then we call `as_bytes` on our `response` to convert the string
data to bytes. The `write` method on `stream` takes a `&[u8]` and sends those
bytes directly down the connection.
-->
<p>新しい最初の行に成功したメッセージのデータを保持する<code>response</code>変数を定義しています。そして、
<code>response</code>に対して<code>as_bytes</code>を呼び出し、文字列データをバイトに変換します。<code>stream</code>の<code>write</code>メソッドは、
<code>&amp;[u8]</code>を取り、接続に直接そのバイトを送信します。</p>
<!--
Because the `write` operation could fail, we use `unwrap` on any error result
as before. Again, in a real application you would add error handling here.
Finally, `flush` will wait and prevent the program from continuing until all
the bytes are written to the connection; `TcpStream` contains an internal
buffer to minimize calls to the underlying operating system.
-->
<p><code>write</code>処理は失敗することもあるので、以前のようにエラーの結果には<code>unwrap</code>を使用します。
今回も、実際のアプリでは、エラー処理をここに追加するでしょう。最後に<code>flush</code>は待機し、
バイトが全て接続に書き込まれるまでプログラムが継続するのを防ぎます; <code>TcpStream</code>は内部にバッファーを保持して、
元となるOSへの呼び出しを最小化します。</p>
<!--
With these changes, let’s run our code and make a request. We’re no longer
printing any data to the terminal, so we won’t see any output other than the
output from Cargo. When you load *127.0.0.1:7878* in a web browser, you should
get a blank page instead of an error. You’ve just hand-coded an HTTP request
and response!
-->
<p>これらの変更とともに、コードを実行し、リクエストをしましょう。最早、端末にどんなデータも出力していないので、
Cargoからの出力以外には何も出力はありません。Webブラウザで<em>127.0.0.1:7878</em>をロードすると、
エラーではなく空のページが得られるはずです。HTTPリクエストとレスポンスを手で実装したばかりなのです！</p>
<!--
### Returning Real HTML
-->
<h3 id="本物のhtmlを返す"><a class="header" href="#本物のhtmlを返す">本物のHTMLを返す</a></h3>
<!--
Let’s implement the functionality for returning more than a blank page. Create
a new file, *hello.html*, in the root of your project directory, not in the
*src* directory. You can input any HTML you want; Listing 20-4 shows one
possibility.
-->
<p>空のページ以上のものを返す機能を実装しましょう。新しいファイル<em>hello.html</em>を<em>src</em>ディレクトリではなく、
プロジェクトのルートディレクトリに作成してください。お好きなようにHTMLを書いてください;
リスト20-4は、一つの可能性を示しています。</p>
<!--
<span class="filename">Filename: hello.html</span>
-->
<p><span class="filename">ファイル名: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
&lt;!--
やあ！
--&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
&lt;!--
Rustからやあ
--&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!--
<span class="caption">Listing 20-4: A sample HTML file to return in a
response</span>
-->
<p><span class="caption">リスト20-4: レスポンスで返すサンプルのHTMLファイル</span></p>
<!--
This is a minimal HTML5 document with a heading and some text. To return this
from the server when a request is received, we’ll modify `handle_connection` as
shown in Listing 20-5 to read the HTML file, add it to the response as a body,
and send it.
-->
<p>これは、ヘッドとテキストのある最低限のHTML5ドキュメントです。リクエストを受け付けた際にこれをサーバから返すには、
リスト20-5のように<code>handle_connection</code>を変更してHTMLファイルを読み込み、本体としてレスポンスに追加して送ります。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span>use std::fs::File;
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let mut file = File::open(&quot;hello.html&quot;).unwrap();

    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-5: Sending the contents of *hello.html* as the
body of the response</span>
-->
<p><span class="caption">リスト20-5: レスポンスの本体として<em>hello.html</em>の中身を送る</span></p>
<!--
We’ve added a line at the top to bring the standard library’s `File` into
scope. The code for opening a file and reading the contents should look
familiar; we used it in Chapter 12 when we read the contents of a file for our
I/O project in Listing 12-4.
-->
<p>先頭に行を追加して標準ライブラリの<code>File</code>をスコープに導入しました。ファイルを開き、中身を読み込むコードは、
馴染みがあるはずです; リスト12-4でI/Oプロジェクト用にファイルの中身を読み込んだ時に第12章で使用しましたね。</p>
<!--
Next, we use `format!` to add the file’s contents as the body of the success
response.
-->
<p>次に<code>format!</code>でファイルの中身を成功したレスポンスの本体として追記しています。</p>
<!--
Run this code with `cargo run` and load *127.0.0.1:7878* in your browser; you
should see your HTML rendered!
-->
<p>このコードを<code>cargo run</code>で走らせ、<em>127.0.0.1:7878</em>をブラウザでロードしてください;
HTMLが描画されるのが確認できるはずです！</p>
<!--
Currently, we’re ignoring the request data in `buffer` and just sending back
the contents of the HTML file unconditionally. That means if you try requesting
*127.0.0.1:7878/something-else* in your browser, you’ll still get back this
same HTML response. Our server is very limited and is not what most web servers
do. We want to customize our responses depending on the request and only send
back the HTML file for a well-formed request to */*.
-->
<p>現時点では、<code>buffer</code>内のリクエストデータは無視し、無条件でHTMLファイルの中身を送り返しているだけです。
これはつまり、ブラウザで<em>127.0.0.1:7878/something-else</em>をリクエストしても、
この同じHTMLレスポンスが得られるということです。我々のサーバはかなり限定的で、多くのWebサーバとは異なっています。
リクエストに基づいてレスポンスをカスタマイズし、<em>/</em> への合法なリクエストに対してのみHTMLファイルを送り返したいです。</p>
<!--
### Validating the Request and Selectively Responding
-->
<h3 id="リクエストにバリデーションをかけ選択的にレスポンスを返す"><a class="header" href="#リクエストにバリデーションをかけ選択的にレスポンスを返す">リクエストにバリデーションをかけ、選択的にレスポンスを返す</a></h3>
<!--
Right now, our web server will return the HTML in the file no matter what the
client requested. Let’s add functionality to check that the browser is
requesting */* before returning the HTML file and return an error if the
browser requests anything else. For this we need to modify `handle_connection`,
as shown in Listing 20-6. This new code checks the content of the request
received against what we know a request for */* looks like and adds `if` and
`else` blocks to treat requests differently.
-->
<p>現状、このWebサーバはクライアントが何を要求しても、このファイルのHTMLを返します。HTMLファイルを返却する前にブラウザが <em>/</em> をリクエストしているか確認し、
ブラウザが他のものを要求していたらエラーを返す機能を追加しましょう。このために、
<code>handle_connection</code>をリスト20-6のように変更する必要があります。この新しいコードは、
<em>/</em> への要求がどんな見た目になるのか我々が知っていることに対して受け取ったリクエストの中身を検査し、<code>if</code>と<code>else</code>ブロックを追加して、
リクエストを異なる形で扱います。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::fs::File;
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if buffer.starts_with(get) {
        let mut file = File::open(&quot;hello.html&quot;).unwrap();

        let mut contents = String::new();
        file.read_to_string(&amp;mut contents).unwrap();

        let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // 何か他の要求
        // some other request
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-6: Matching the request and handling requests
to */* differently than other requests</span>
-->
<p><span class="caption">リスト20-6: リクエストをマッチさせ、<em>/</em> へのリクエストを他のリクエストとは異なる形で扱う</span></p>
<!--
First, we hardcode the data corresponding to the */* request into the `get`
variable. Because we’re reading raw bytes into the buffer, we transform `get`
into a byte string by adding the `b""` byte string syntax at the start of the
content data. Then we check whether `buffer` starts with the bytes in `get`. If
it does, it means we’ve received a well-formed request to */*, which is the
success case we’ll handle in the `if` block that returns the contents of our
HTML file.
-->
<p>まず、<em>/</em> リクエストに対応するデータを<code>get</code>変数にハードコードしています。生のバイトをバッファーに読み込んでいるので、
<code>b&quot;&quot;</code>バイト文字列記法を中身のデータの先頭に追記することで、<code>get</code>をバイト文字列に変換しています。
そして、<code>buffer</code>が<code>get</code>のバイトから始まっているか確認します。もしそうなら、<em>/</em> への合法なリクエストを受け取ったことを意味し、
これが、HTMLファイルの中身を返す<code>if</code>ブロックで扱う成功した場合になります。</p>
<!--
If `buffer` does *not* start with the bytes in `get`, it means we’ve received
some other request. We’ll add code to the `else` block in a moment to respond
to all other requests.
-->
<p><code>buffer</code>が<code>get</code>のバイトで始まら<em>ない</em>のなら、何か他のリクエストを受け取ったことになります。
この後すぐ、<code>else</code>ブロックに他のリクエストに対応するコードを追加します。</p>
<!--
Run this code now and request *127.0.0.1:7878*; you should get the HTML in
*hello.html*. If you make any other request, such as
*127.0.0.1:7878/something-else*, you’ll get a connection error like you
saw when running the code in Listing 20-1 and Listing 20-2.
-->
<p>さあ、このコードを走らせて<em>127.0.0.1:7878</em>を要求してください; <em>hello.html</em>のHTMLが得られるはずです。
<em>127.0.0.1:7878/something-else</em>などの他のリクエストを行うと、リスト20-1や20-2のコードを走らせた時に見かけた接続エラーになるでしょう。</p>
<!--
Now let’s add the code in Listing 20-7 to the `else` block to return a response
with the status code 404, which signals that the content for the request was
not found. We’ll also return some HTML for a page to render in the browser
indicating the response to the end user.
-->
<p>では、<code>else</code>ブロックにリスト20-7のコードを追記して、ステータスコード404のレスポンスを返しましょう。
これは、リクエストの中身が見つからなかったことを通知します。エンドユーザへのレスポンスを示し、ページをブラウザに描画するよう、
何かHTMLも返します。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::fs::File;
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">if true {
</span>// --snip--

} else {
    let status_line = &quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;;
    let mut file = File::open(&quot;404.html&quot;).unwrap();
    let mut contents = String::new();

    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-7: Responding with status code 404 and an
error page if anything other than */* was requested</span>
-->
<p><span class="caption">リスト20-7: <em>/</em> 以外の何かが要求されたら、ステータスコード404とエラーページで応答する</span></p>
<!--
Here, our response has a status line with status code 404 and the reason
phrase `NOT FOUND`. We’re still not returning headers, and the body of the
response will be the HTML in the file *404.html*. You’ll need to create a
*404.html* file next to *hello.html* for the error page; again feel free to use
any HTML you want or use the example HTML in Listing 20-8.
-->
<p>ここでは、レスポンスにはステータスコード404と理由フレーズ<code>NOT FOUND</code>のステータス行があります。
それでもヘッダは返さず、レスポンスの本体は、ファイル<em>404.html</em>のHTMLになります。エラーページのために、
<em>hello.html</em>の隣に<em>404.html</em>ファイルを作成する必要があります; 今回も、ご自由にお好きなHTMLにしたり、
リスト20-8の例のHTMLを使用したりしてください。</p>
<!--
<span class="filename">Filename: 404.html</span>
-->
<p><span class="filename">ファイル名: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
&lt;!--
ああ！
--&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
&lt;!--
すいません。要求しているものが理解できません
--&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<!--
<span class="caption">Listing 20-8: Sample content for the page to send back
with any 404 response</span>
-->
<p><span class="caption">リスト20-8: あらゆる404レスポンスでページが送り返す中身のサンプル</span></p>
<!--
With these changes, run your server again. Requesting *127.0.0.1:7878*
should return the contents of *hello.html*, and any other request, like
*127.0.0.1:7878/foo*, should return the error HTML from *404.html*.
-->
<p>これらの変更とともに、もう一度サーバを実行してください。<em>127.0.0.1:7878</em>を要求すると、
<em>hello.html</em>の中身が返り、<em>127.0.0.1:7878/foo</em>などの他のリクエストには<em>404.html</em>からのエラーHTMLが返るはずです。</p>
<!--
### A Touch of Refactoring
-->
<h3 id="リファクタリングの触り"><a class="header" href="#リファクタリングの触り">リファクタリングの触り</a></h3>
<!--
At the moment the `if` and `else` blocks have a lot of repetition: they’re both
reading files and writing the contents of the files to the stream. The only
differences are the status line and the filename. Let’s make the code more
concise by pulling out those differences into separate `if` and `else` lines
that will assign the values of the status line and the filename to variables;
we can then use those variables unconditionally in the code to read the file
and write the response. Listing 20-9 shows the resulting code after replacing
the large `if` and `else` blocks.
-->
<p>現在、<code>if</code>と<code>else</code>ブロックには多くの繰り返しがあります: どちらもファイルを読み、ファイルの中身をストリームに書き込んでいます。
唯一の違いは、ステータス行とファイル名だけです。それらの差異を、ステータス行とファイル名の値を変数に代入する個別の<code>if</code>と<code>else</code>行に引っ張り出して、
コードをより簡潔にしましょう; そうしたら、それらの変数を無条件にコードで使用し、ファイルを読んでレスポンスを書き込めます。
リスト20-9は、大きな<code>if</code>と<code>else</code>ブロックを置き換えた後の結果のコードを示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::fs::File;
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
<span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span>    // --snip--

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let mut file = File::open(filename).unwrap();
    let mut contents = String::new();

    file.read_to_string(&amp;mut contents).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-9: Refactoring the `if` and `else` blocks to
contain only the code that differs between the two cases</span>
-->
<p><span class="caption">リスト20-9: 2つの場合で異なるコードだけを含むように、<code>if</code>と<code>else</code>ブロックをリファクタリングする</span></p>
<!--
Now the `if` and `else` blocks only return the appropriate values for the
status line and filename in a tuple; we then use destructuring to assign these
two values to `status_line` and `filename` using a pattern in the `let`
statement, as discussed in Chapter 18.
-->
<p>これで、<code>if</code>と<code>else</code>ブロックは、タプルにステータス行とファイル名の適切な値を返すだけになりました; 
それから、分配を使用してこれら2つの値を第18章で議論したように、<code>let</code>文のパターンで<code>status_line</code>と<code>filename</code>に代入しています。</p>
<!--
The previously duplicated code is now outside the `if` and `else` blocks and
uses the `status_line` and `filename` variables. This makes it easier to see
the difference between the two cases, and it means we have only one place to
update the code if we want to change how the file reading and response writing
work. The behavior of the code in Listing 20-9 will be the same as that in
Listing 20-8.
-->
<p>前は重複していたコードは、今では<code>if</code>と<code>else</code>ブロックの外に出て、<code>status_line</code>と<code>filename</code>変数を使用しています。
これにより、2つの場合の違いがわかりやすくなり、ファイル読み取りとレスポンス記述の動作法を変更したくなった際に、
1箇所だけコードを更新すればいいようになったことを意味します。リスト20-9のコードの振る舞いは、
リスト20-8と同じです。</p>
<!--
Awesome! We now have a simple web server in approximately 40 lines of Rust code
that responds to one request with a page of content and responds to all other
requests with a 404 response.
-->
<p>素晴らしい！もう、およそ40行のRustコードで、あるリクエストには中身のあるページで応答し、
他のあらゆるリクエストには404レスポンスで応答する単純なWebサーバができました。</p>
<!--
Currently, our server runs in a single thread, meaning it can only serve one
request at a time. Let’s examine how that can be a problem by simulating some
slow requests. Then we'll fix it so our server can handle multiple requests at
once.
-->
<p>現状、このサーバは、シングルスレッドで実行されます。つまり、1回に1つのリクエストしか捌けないということです。
何か遅いリクエストをシミュレーションすることで、それが問題になる可能性を調査しましょう。
それから1度にサーバが複数のリクエストを扱えるように修正します。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Turning Our Single-Threaded Server into a Multithreaded Server
-->
<h2 id="シングルスレッドサーバをマルチスレッド化する"><a class="header" href="#シングルスレッドサーバをマルチスレッド化する">シングルスレッドサーバをマルチスレッド化する</a></h2>
<!--
Right now, the server will process each request in turn, meaning it won’t
process a second connection until the first is finished processing. If the
server received more and more requests, this serial execution would be less and
less optimal. If the server receives a request that takes a long time to
process, subsequent requests will have to wait until the long request is
finished, even if the new requests can be processed quickly. We’ll need to fix
this, but first, we’ll look at the problem in action.
-->
<p>現状、サーバはリクエストを順番に処理します。つまり、最初の接続が処理し終わるまで、2番目の接続は処理しないということです。
サーバが受け付けるリクエストの量が増えるほど、この連続的な実行は、最適ではなくなるでしょう。
サーバが処理するのに長い時間がかかるリクエストを受け付けたら、新しいリクエストは迅速に処理できても、
続くリクエストは長いリクエストが完了するまで待たなければならなくなるでしょう。これを修正する必要がありますが、
まずは、実際に問題が起こっているところを見ます。</p>
<!--
### Simulating a Slow Request in the Current Server Implementation
-->
<h3 id="現在のサーバの実装で遅いリクエストをシミュレーションする"><a class="header" href="#現在のサーバの実装で遅いリクエストをシミュレーションする">現在のサーバの実装で遅いリクエストをシミュレーションする</a></h3>
<!--
We’ll look at how a slow-processing request can affect other requests made to
our current server implementation. Listing 20-10 implements handling a request
to */sleep* with a simulated slow response that will cause the server to sleep
for 5 seconds before responding.
-->
<p>処理が遅いリクエストが現在のサーバ実装に対して行われる他のリクエストにどう影響するかに目を向けます。
リスト20-10は、応答する前に5秒サーバをスリープさせる遅いレスポンスをシミュレーションした <em>/sleep</em>へのリクエストを扱う実装です。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::time::Duration;
<span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::fs::File;
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
<span class="boring">    let mut buffer = [0; 1024];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span>    // --snip--

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-10: Simulating a slow request by recognizing
*/sleep* and sleeping for 5 seconds</span>
-->
<p><span class="caption">リスト20-10: <em>/sleep</em>を認識して5秒間スリープすることで遅いリクエストをシミュレーションする</span></p>
<!--
This code is a bit messy, but it’s good enough for simulation purposes. We
created a second request `sleep`, whose data our server recognizes. We added an
`else if` after the `if` block to check for the request to */sleep*. When that
request is received, the server will sleep for 5 seconds before rendering the
successful HTML page.
-->
<p>このコードはちょっと汚いですが、シミュレーション目的には十分です。2番目のリクエスト<code>sleep</code>を作成し、
そのデータをサーバは認識します。<code>if</code>ブロックの後に<code>else if</code>を追加し、<em>/sleep</em>へのリクエストを確認しています。
そのリクエストが受け付けられると、サーバは成功のHTMLページを描画する前に5秒間スリープします。</p>
<!--
You can see how primitive our server is: real libraries would handle the
recognition of multiple requests in a much less verbose way!
-->
<p>我々のサーバがどれだけ基礎的か見て取れます: 本物のライブラリは、もっと冗長でない方法で複数のリクエストの認識を扱うでしょう！</p>
<!--
Start the server using `cargo run`. Then open two browser windows: one for
*http://localhost:7878/* and the other for *http://localhost:7878/sleep*. If
you enter the */* URI a few times, as before, you’ll see it respond quickly.
But if you enter */sleep*, and then load */*, you’ll see that */* waits until
`sleep` has slept for its full 5 seconds before loading.
-->
<p><code>cargo run</code>でサーバを開始してください。それから2つブラウザのウインドウを開いてください: 1つは、
<em>http://localhost:7878/</em> 用、そしてもう1つは<em>http://localhost:7878/sleep</em> 用です。
以前のように <em>/</em> URIを数回入力したら、素早く応答するでしょう。しかし、<em>/sleep</em>を入力し、それから <em>/</em> をロードしたら、
<code>sleep</code>がロードする前にきっかり5秒スリープし終わるまで、<em>/</em> は待機するのを目撃するでしょう。</p>
<!--
There are multiple ways we could change how our web server works to avoid
having more requests back up behind a slow request; the one we’ll implement is
a thread pool.
-->
<p>より多くのリクエストが遅いリクエストの背後に回ってしまうのを回避するようWebサーバが動く方法を変える方法は複数あります;
これから実装するのは、スレッドプールです。</p>
<!--
### Improving Throughput with a Thread Pool
-->
<h3 id="スレッドプールでスループットを向上させる"><a class="header" href="#スレッドプールでスループットを向上させる">スレッドプールでスループットを向上させる</a></h3>
<!--
A *thread pool* is a group of spawned threads that are waiting and ready to
handle a task. When the program receives a new task, it assigns one of the
threads in the pool to the task, and that thread will process the task. The
remaining threads in the pool are available to handle any other tasks that come
in while the first thread is processing. When the first thread is done
processing its task, it’s returned to the pool of idle threads, ready to handle
a new task. A thread pool allows you to process connections concurrently,
increasing the throughput of your server.
-->
<p><em>スレッドプール</em>は、待機し、タスクを処理する準備のできた一塊りの大量に生成されたスレッドです。
プログラムが新しいタスクを受け取ったら、プールのスレッドのどれかをタスクにあてがい、
そのスレッドがそのタスクを処理します。
プールの残りのスレッドは、最初のスレッドが処理中にやってくる他のあらゆるタスクを扱うために利用可能です。
最初のスレッドがタスクの処理を完了したら、アイドル状態のスレッドプールに戻り、新しいタスクを処理する準備ができます。
スレッドプールにより、並行で接続を処理でき、サーバのスループットを向上させます。</p>
<!--
We’ll limit the number of threads in the pool to a small number to protect us
from Denial of Service (DoS) attacks; if we had our program create a new thread
for each request as it came in, someone making 10 million requests to our
server could create havoc by using up all our server’s resources and grinding
the processing of requests to a halt.
-->
<p>プール内のスレッド数は、小さい数字に制限し、DoS(Denial of Service; サービスの拒否)攻撃から保護します; リクエストが来た度に新しいスレッドをプログラムに生成させたら、
1000万リクエストをサーバに行う誰かが、サーバのリソースを使い尽くし、リクエストの処理を停止に追い込むことで、
大混乱を招くことができてしまうでしょう。</p>
<!--
Rather than spawning unlimited threads, we’ll have a fixed number of threads
waiting in the pool. As requests come in, they’ll be sent to the pool for
processing. The pool will maintain a queue of incoming requests. Each of the
threads in the pool will pop off a request from this queue, handle the request,
and then ask the queue for another request. With this design, we can process
`N` requests concurrently, where `N` is the number of threads. If each thread
is responding to a long-running request, subsequent requests can still back up
in the queue, but we’ve increased the number of long-running requests we can
handle before reaching that point.
-->
<p>無制限にスレッドを大量生産するのではなく、プールに固定された数のスレッドを待機させます。リクエストが来る度に、
処理するためにプールに送られます。プールは、やって来るリクエストのキューを管理します。
プールの各スレッドがこのキューからリクエストを取り出し、リクエストを処理し、そして、別のリクエストをキューに要求します。
この設計により、<code>N</code>リクエストを並行して処理でき、ここで<code>N</code>はスレッド数です。各スレッドが実行に時間のかかるリクエストに応答していたら、
続くリクエストはそれでも、キュー内で待機させられてしまうこともありますが、その地点に到達する前に扱える時間のかかるリクエスト数を増加させました。</p>
<!--
This technique is just one of many ways to improve the throughput of a web
server. Other options you might explore are the fork/join model and the
single-threaded async I/O model. If you’re interested in this topic, you can
read more about other solutions and try to implement them in Rust; with a
low-level language like Rust, all of these options are possible.
-->
<p>このテクニックは、Webサーバのスループットを向上させる多くの方法の1つに過ぎません。探究する可能性のある他の選択肢は、
fork/joinモデルと、シングルスレッドの非同期I/Oモデルです。この話題にご興味があれば、他の解決策についてもっと読み、
Rustで実装を試みることができます; Rustのような低レベル言語であれば、これらの選択肢全部が可能なのです。</p>
<!--
Before we begin implementing a thread pool, let’s talk about what using the
pool should look like. When you’re trying to design code, writing the client
interface first can help guide your design. Write the API of the code so it’s
structured in the way you want to call it; then implement the functionality
within that structure rather than implementing the functionality and then
designing the public API.
-->
<p>スレッドプールを実装し始める前に、プールを使うのはどんな感じになるはずなのかについて語りましょう。コードの設計を試みる際、
クライアントのインターフェイスをまず書くことは、設計を導く手助けになることがあります。呼び出したいように構成されるよう、
コードのAPIを記述してください; そして、機能を実装してから公開APIの設計をするのではなく、その構造内で機能を実装してください。</p>
<!--
Similar to how we used test-driven development in the project in Chapter 12,
we’ll use compiler-driven development here. We’ll write the code that calls the
functions we want, and then we’ll look at errors from the compiler to determine
what we should change next to get the code to work.
-->
<p>第12章のプロジェクトでTDDを使用したように、ここではCompiler Driven Development(コンパイラ駆動開発)を使用します。
欲しい関数を呼び出すコードを書き、それからコンパイラの出すエラーを見てコードが動くように次に何を変更すべきかを決定します。</p>
<!--
#### Code Structure If We Could Spawn a Thread for Each Request
-->
<h4 id="各リクエストに対してスレッドを立ち上げられる場合のコードの構造"><a class="header" href="#各リクエストに対してスレッドを立ち上げられる場合のコードの構造">各リクエストに対してスレッドを立ち上げられる場合のコードの構造</a></h4>
<!--
First, let’s explore how our code might look if it did create a new thread for
every connection. As mentioned earlier, this isn’t our final plan due to the
problems with potentially spawning an unlimited number of threads, but it is a
starting point. Listing 20-11 shows the changes to make to `main` to spawn a
new thread to handle each stream within the `for` loop.
-->
<p>まず、全接続に対して新しいスレッドを確かに生成した場合にコードがどんな見た目になるかを探究しましょう。
先ほど述べたように、無制限にスレッドを大量生産する可能性があるという問題のため、これは最終的な計画ではありませんが、
開始点です。リスト20-11は、新しいスレッドを立ち上げて<code>for</code>ループ内で各ストリームを扱うために<code>main</code>に行う変更を示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::thread;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">fn handle_connection(mut stream: TcpStream) {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-11: Spawning a new thread for each
stream</span>
-->
<p><span class="caption">リスト20-11: 各ストリームに対して新しいスレッドを立ち上げる</span></p>
<!--
As you learned in Chapter 16, `thread::spawn` will create a new thread and then
run the code in the closure in the new thread. If you run this code and load
*/sleep* in your browser, then */* in two more browser tabs, you’ll indeed see
that the requests to */* don’t have to wait for */sleep* to finish. But as we
mentioned, this will eventually overwhelm the system because you'd making
new threads without any limit.
-->
<p>第16章で学んだように、<code>thread::spawn</code>は新しいスレッドを生成し、それからクロージャ内のコードを新しいスレッドで実行します。
このコードを実行してブラウザで <em>/sleep</em>をロードし、それからもう2つのブラウザのタブで <em>/</em> をロードしたら、
確かに <em>/</em> へのリクエストは、<em>/sleep</em>が完了するのを待機しなくても済むことがわかるでしょう。
ですが、前述したように、無制限にスレッドを生成することになるので、これは最終的にシステムを参らせてしまうでしょう。</p>
<!--
#### Creating a Similar Interface for a Finite Number of Threads
-->
<h4 id="有限数のスレッド用に似たインターフェイスを作成する"><a class="header" href="#有限数のスレッド用に似たインターフェイスを作成する">有限数のスレッド用に似たインターフェイスを作成する</a></h4>
<!--
We want our thread pool to work in a similar, familiar way so switching from
threads to a thread pool doesn’t require large changes to the code that uses
our API. Listing 20-12 shows the hypothetical interface for a `ThreadPool`
struct we want to use instead of `thread::spawn`.
-->
<p>スレッドからスレッドプールへの変更にAPIを使用するコードへの大きな変更が必要ないように、
スレッドプールには似た、馴染み深い方法で動作してほしいです。リスト20-12は、
<code>thread::spawn</code>の代わりに使用したい<code>ThreadPool</code>構造体の架空のインターフェイスを表示しています。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use std::thread;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">struct ThreadPool;
</span><span class="boring">impl ThreadPool {
</span><span class="boring">   fn new(size: u32) -&gt; ThreadPool { ThreadPool }
</span><span class="boring">   fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">       where F: FnOnce() + Send + 'static {}
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">fn handle_connection(mut stream: TcpStream) {}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-12: Our ideal `ThreadPool` interface</span>
-->
<p><span class="caption">リスト20-12: <code>ThreadPool</code>の理想的なインターフェイス</span></p>
<!--
We use `ThreadPool::new` to create a new thread pool with a configurable number
of threads, in this case four. Then, in the `for` loop, `pool.execute` has a
similar interface as `thread::spawn` in that it takes a closure the pool should
run for each stream. We need to implement `pool.execute` so it takes the
closure and gives it to a thread in the pool to run. This code won’t yet
compile, but we’ll try so the compiler can guide us in how to fix it.
-->
<p><code>ThreadPool::new</code>を使用して設定可能なスレッド数で新しいスレッドプールを作成し、今回の場合は4です。
それから<code>for</code>ループ内で、<code>pool.execute</code>は、プールが各ストリームに対して実行すべきクロージャを受け取るという点で、
<code>thread::spawn</code>と似たインターフェイスです。<code>pool.execute</code>を実装する必要があるので、
これはクロージャを取り、実行するためにプール内のスレッドに与えます。このコードはまだコンパイルできませんが、
コンパイラがどう修正したらいいかガイドできるように試してみます。</p>
<!--
#### Building the `ThreadPool` Struct Using Compiler Driven Development
-->
<h4 id="コンパイラ駆動開発でthreadpool構造体を構築する"><a class="header" href="#コンパイラ駆動開発でthreadpool構造体を構築する">コンパイラ駆動開発で<code>ThreadPool</code>構造体を構築する</a></h4>
<!--
Make the changes in Listing 20-12 to *src/main.rs*, and then let’s use the
compiler errors from `cargo check` to drive our development. Here is the first
error we get:
-->
<p>リスト20-12の変更を<em>src/main.rs</em>に行い、それから開発を駆動するために<code>cargo check</code>からのコンパイラエラーを活用しましょう。
こちらが得られる最初のエラーです:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve. Use of undeclared type or module `ThreadPool`
(エラー: 解決に失敗しました。未定義の型またはモジュール`ThreadPool`を使用しています)
  --&gt; src\main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ Use of undeclared type or module
   `ThreadPool`

error: aborting due to previous error
</code></pre>
<!--
Great! This error tells us we need a `ThreadPool` type or module, so we’ll
build one now. Our `ThreadPool` implementation will be independent of the kind
of work our web server is doing. So, let’s switch the `hello` crate from a
binary crate to a library crate to hold our `ThreadPool` implementation. After
we change to a library crate, we could also use the separate thread pool
library for any work we want to do using a thread pool, not just for serving
web requests.
-->
<p>よろしい!このエラーは<code>ThreadPool</code>型かモジュールが必要なことを教えてくれているので、今構築します。
<code>ThreadPool</code>の実装は、Webサーバが行う仕事の種類とは独立しています。従って、<code>hello</code>クレートをバイナリクレートからライブラリクレートに切り替え、
<code>ThreadPool</code>の実装を保持させましょう。ライブラリクレートに変更後、
個別のスレッドプールライブラリをWebリクエストを提供するためだけではなく、スレッドプールでしたいあらゆる作業にも使用できます。</p>
<!--
Create a *src/lib.rs* that contains the following, which is the simplest
definition of a `ThreadPool` struct that we can have for now:
-->
<p>以下を含む<em>src/lib.rs</em>を生成してください。これは、現状存在できる最も単純な<code>ThreadPool</code>の定義です:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ThreadPool;
<span class="boring">}
</span></code></pre></pre>
<!--
Then create a new directory, *src/bin*, and move the binary crate rooted in
*src/main.rs* into *src/bin/main.rs*. Doing so will make the library crate the
primary crate in the *hello* directory; we can still run the binary in
*src/bin/main.rs* using `cargo run`. After moving the *main.rs* file, edit it
to bring the library crate in and bring `ThreadPool` into scope by adding the
following code to the top of *src/bin/main.rs*:
-->
<p>それから新しいディレクトリ、<em>src/bin</em>を作成し、<em>src/main.rs</em>に根付くバイナリクレートを<em>src/bin/main.rs</em>に移動してください。
そうすると、ライブラリクレートが<em>hello</em>ディレクトリ内で主要クレートになります; それでも、
<code>cargo run</code>で<em>src/bin/main.rs</em>のバイナリを実行することはできます。<em>main.rs</em>ファイルを移動後、
編集してライブラリクレートを持ち込み、以下のコードを<em>src/bin/main.rs</em>の先頭に追記して<code>ThreadPool</code>をスコープに導入してください:</p>
<!--
<span class="filename">Filename: src/bin/main.rs</span>
-->
<p><span class="filename">ファイル名: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;
</code></pre>
<!--
This code still won’t work, but let’s check it again to get the next error that
we need to address:
-->
<p>このコードはまだ動きませんが、再度それを確認して扱う必要のある次のエラーを手に入れましょう:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for type
`hello::ThreadPool` in the current scope
(エラー: 現在のスコープで型`hello::ThreadPool`の関数または関連アイテムに`new`というものが見つかりません)
 --&gt; src/bin/main.rs:13:16
   |
13 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ function or associated item not found in
   `hello::ThreadPool`
</code></pre>
<!--
This error indicates that next we need to create an associated function named
`new` for `ThreadPool`. We also know that `new` needs to have one parameter
that can accept `4` as an argument and should return a `ThreadPool` instance.
Let’s implement the simplest `new` function that will have those
characteristics:
-->
<p>このエラーは、次に、<code>ThreadPool</code>に対して<code>new</code>という関連関数を作成する必要があることを示唆しています。
また、<code>new</code>には<code>4</code>を引数として受け入れる引数1つがあり、<code>ThreadPool</code>インスタンスを返すべきということも知っています。
それらの特徴を持つ最も単純な<code>new</code>関数を実装しましょう:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
We chose `usize` as the type of the `size` parameter, because we know that a
negative number of threads doesn’t make any sense. We also know we’ll use this
4 as the number of elements in a collection of threads, which is what the
`usize` type is for, as discussed in the “Integer Types” section of Chapter 3.
-->
<p><code>size</code>引数の型として、<code>usize</code>を選択しました。何故なら、マイナスのスレッド数は、何も筋が通らないことを知っているからです。
また、この4をスレッドのコレクションの要素数として使用し、第3章の「整数型」節で議論したように、これは<code>usize</code>のあるべき姿であることも知っています。</p>
<!--
Let’s check the code again:
-->
<p>コードを再度確認しましょう:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`
(警告: 未使用の変数: `size`)
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: #[warn(unused_variables)] on by default
  = note: to avoid this warning, consider using `_size` instead

error[E0599]: no method named `execute` found for type `hello::ThreadPool` in the current scope
  --&gt; src/bin/main.rs:18:14
   |
18 |         pool.execute(|| {
   |              ^^^^^^^
</code></pre>
<!--
Now we get a warning and an error. Ignoring the warning for a moment, the error
occurs because we don’t have an `execute` method on `ThreadPool`. Recall from
the “Creating a Similar Interface for a Finite Number of Threads” section that
we decided our thread pool should have an interface similar to `thread::spawn`.
In addition, we’ll implement the `execute` function so it takes the closure
it’s given and gives it to an idle thread in the pool to run.
-->
<p>今度は、警告とエラーが出ました。一時的に警告は無視して、<code>ThreadPool</code>に<code>execute</code>メソッドがないためにエラーが発生しました。
「有限数のスレッド用に似たインターフェイスを作成する」節で我々のスレッドプールは、
<code>thread::spawn</code>と似たインターフェイスにするべきと決定したことを思い出してください。
さらに、<code>execute</code>関数を実装するので、与えられたクロージャを取り、実行するようにプールの待機中のスレッドに渡します。</p>
<!--
We’ll define the `execute` method on `ThreadPool` to take a closure as a
parameter. Recall from the “Storing Closures Using Generic Parameters and the
`Fn` Traits” section in Chapter 13 that we can take closures as parameters with
three different traits: `Fn`, `FnMut`, and `FnOnce`. We need to decide which
kind of closure to use here. We know we’ll end up doing something similar to
the standard library `thread::spawn` implementation, so we can look at what
bounds the signature of `thread::spawn` has on its parameter. The documentation
shows us the following:
-->
<p><code>ThreadPool</code>に<code>execute</code>メソッドをクロージャを引数として受け取るように定義します。
第13章の「ジェネリック引数と<code>Fn</code>トレイトを使用してクロージャを保存する」節から、
3つの異なるトレイトでクロージャを引数として取ることができることを思い出してください: <code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>です。
ここでは、どの種類のクロージャを使用するか決定する必要があります。最終的には、
標準ライブラリの<code>thread::spawn</code>実装に似たことをすることがわかっているので、
<code>thread::spawn</code>のシグニチャで引数にどんな境界があるか見ることができます。ドキュメンテーションは、以下のものを示しています:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<!--
The `F` type parameter is the one we’re concerned with here; the `T` type
parameter is related to the return value, and we’re not concerned with that. We
can see that `spawn` uses `FnOnce` as the trait bound on `F`. This is probably
what we want as well, because we’ll eventually pass the argument we get in
`execute` to `spawn`. We can be further confident that `FnOnce` is the trait we
want to use because the thread for running a request will only execute that
request’s closure one time, which matches the `Once` in `FnOnce`.
-->
<p><code>F</code>型引数がここで関心のあるものです; <code>T</code>型引数は戻り値と関係があり、関心はありません。<code>spawn</code>は、
<code>F</code>のトレイト境界として<code>FnOnce</code>を使用していることが確認できます。これはおそらく、我々が欲しているものでもあるでしょう。
というのも、最終的には<code>execute</code>で得た引数を<code>spawn</code>に渡すからです。さらに<code>FnOnce</code>は使用したいトレイトであると自信を持つことができます。
リクエストを実行するスレッドは、そのリクエストのクロージャを1回だけ実行し、これは<code>FnOnce</code>の<code>Once</code>に合致するからです。</p>
<!--
The `F` type parameter also has the trait bound `Send` and the lifetime bound
`'static`, which are useful in our situation: we need `Send` to transfer the
closure from one thread to another and `'static` because we don’t know how long
the thread will take to execute. Let’s create an `execute` method on
`ThreadPool` that will take a generic parameter of type `F` with these bounds:
-->
<p><code>F</code>型引数にはまた、トレイト境界の<code>Send</code>とライフタイム境界の<code>'static</code>もあり、この状況では有用です:
あるスレッドから別のスレッドにクロージャを移動するのに<code>Send</code>が必要で、スレッドの実行にどれくらいかかるかわからないので、
<code>'static</code>も必要です。<code>ThreadPool</code>にこれらの境界のジェネリックな型<code>F</code>の引数を取る<code>execute</code>メソッドを生成しましょう:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct ThreadPool;
</span>impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {

    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
We still use the `()` after `FnOnce` because this `FnOnce` represents a closure
that takes no parameters and doesn’t return a value. Just like function
definitions, the return type can be omitted from the signature, but even if we
have no parameters, we still need the parentheses.
-->
<p>それでも、<code>FnOnce</code>の後に<code>()</code>を使用しています。この<code>FnOnce</code>は引数を取らず、値も返さないクロージャを表すからです。
関数定義同様に、戻り値の型はシグニチャから省略できますが、引数がなくても、カッコは必要です。</p>
<!--
Again, this is the simplest implementation of the `execute` method: it does
nothing, but we’re trying only to make our code compile. Let’s check it again:
-->
<p>またもや、これが<code>execute</code>メソッドの最も単純な実装です: 何もしませんが、
コードがコンパイルできるようにしようとしているだけです。再確認しましょう:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: #[warn(unused_variables)] on by default
  = note: to avoid this warning, consider using `_size` instead

warning: unused variable: `f`
 --&gt; src/lib.rs:8:30
  |
8 |     pub fn execute&lt;F&gt;(&amp;self, f: F)
  |                              ^
  |
  = note: to avoid this warning, consider using `_f` instead
</code></pre>
<!--
We’re receiving only warnings now, which means it compiles! But note that if
you try `cargo run` and make a request in the browser, you’ll see the errors in
the browser that we saw at the beginning of the chapter. Our library isn’t
actually calling the closure passed to `execute` yet!
-->
<p>これで警告を受け取るだけになり、コンパイルできるようになりました！しかし、<code>cargo run</code>を試して、
ブラウザでリクエストを行うと、章の冒頭で見かけたエラーがブラウザに現れることに注意してください。
ライブラリは、まだ実際に<code>execute</code>に渡されたクロージャを呼び出していないのです！</p>
<!--
> Note: A saying you might hear about languages with strict compilers, such as
> Haskell and Rust, is “if the code compiles, it works.” But this saying is not
> universally true. Our project compiles, but it does absolutely nothing! If we
> were building a real, complete project, this would be a good time to start
> writing unit tests to check that the code compiles *and* has the behavior we
> want.
-->
<blockquote>
<p>注釈: HaskellやRustなどの厳密なコンパイラがある言語についての格言として「コードがコンパイルできたら、
動作する」というものをお聴きになったことがある可能性があります。ですが、この格言は普遍的に当てはまるものではありません。
このプロジェクトはコンパイルできますが、全く何もしません！本物の完璧なプロジェクトを構築しようとしているのなら、
ここが単体テストを書き始めて、コードがコンパイルでき、<em>かつ</em>欲しい振る舞いを保持していることを確認するのに良い機会でしょう。</p>
</blockquote>
<!--
#### Validating the Number of Threads in `new`
-->
<h4 id="newでスレッド数を検査する"><a class="header" href="#newでスレッド数を検査する"><code>new</code>でスレッド数を検査する</a></h4>
<!--
We’ll continue to get warnings because we aren’t doing anything with the
parameters to `new` and `execute`. Let’s implement the bodies of these
functions with the behavior we want. To start, let’s think about `new`. Earlier
we chose an unsigned type for the `size` parameter, because a pool with a
negative number of threads makes no sense. However, a pool with zero threads
also makes no sense, yet zero is a perfectly valid `usize`. We’ll add code to
check that `size` is greater than zero before we return a `ThreadPool` instance
and have the program panic if it receives a zero by using the `assert!` macro,
as shown in Listing 20-13.
-->
<p><code>new</code>と<code>execute</code>の引数で何もしていないので、警告が出続けます。欲しい振る舞いでこれらの関数の本体を実装しましょう。
まずはじめに、<code>new</code>を考えましょう。先刻、<code>size</code>引数に非負整数型を選択しました。負のスレッド数のプールは、
全く道理が通らないからです。しかしながら、0スレッドのプールも全く意味がわかりませんが、0も完全に合法な<code>usize</code>です。
<code>ThreadPool</code>インスタンスを返す前に<code>size</code>が0よりも大きいことを確認するコードを追加し、リスト20-13に示したように、
<code>assert!</code>マクロを使用することで0を受け取った時にプログラムをパニックさせます。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct ThreadPool;
</span>impl ThreadPool {
    /// 新しいThreadPoolを生成する。
    ///
    /// sizeがプールのスレッド数です。
    ///
    /// # パニック
    ///
    /// sizeが0なら、`new`関数はパニックします。
    ///
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-13: Implementing `ThreadPool::new` to panic if
`size` is zero</span>
-->
<p><span class="caption">リスト20-13: <code>ThreadPool::new</code>を実装して<code>size</code>が0ならパニックする</span></p>
<!--
2行目後半、calls outを声高に叫ぶとした。叫ぶだけでは何か物足りない気がするので
-->
<!--
We’ve added some documentation for our `ThreadPool` with doc comments. Note
that we followed good documentation practices by adding a section that calls
out the situations in which our function can panic, as discussed in Chapter 14.
Try running `cargo doc --open` and clicking the `ThreadPool` struct to see what
the generated docs for `new` look like!
-->
<p>doc commentで<code>ThreadPool</code>にドキュメンテーションを追加しました。第14章で議論したように、
関数がパニックすることもある場面を声高に叫ぶセクションを追加することで、
いいドキュメンテーションの実践に<ruby>倣<rp>(</rp><rt>なら</rt><rp>)</rp></ruby>っていることに注意してください。
試しに<code>cargo doc --open</code>を実行し、<code>ThreadPool</code>構造体をクリックして、<code>new</code>の生成されるドキュメンテーションがどんな見た目か確かめてください！</p>
<!--
Instead of adding the `assert!` macro as we’ve done here, we could make `new`
return a `Result` like we did with `Config::new` in the I/O project in Listing
12-9. But we’ve decided in this case that trying to create a thread pool
without any threads should be an unrecoverable error. If you’re feeling
ambitious, try to write a version of `new` with the following signature to
compare both versions:
-->
<p>ここでしたように<code>assert!</code>マクロを追加する代わりに、リスト12-9のI/Oプロジェクトの<code>Config::new</code>のように、
<code>new</code>に<code>Result</code>を返させることもできるでしょう。しかし、今回の場合、スレッドなしでスレッドプールを作成しようとするのは、
回復不能なエラーであるべきと決定しました。野心を感じるのなら、以下のシグニチャの<code>new</code>も書いてみて、両者を比較してみてください:</p>
<pre><code class="language-rust ignore">pub fn new(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {
</code></pre>
<!--
#### Creating Space to Store the Threads
-->
<h4 id="スレッドを格納するスペースを生成する"><a class="header" href="#スレッドを格納するスペースを生成する">スレッドを格納するスペースを生成する</a></h4>
<!--
Now that we have a way to know we have a valid number of threads to store in
the pool, we can create those threads and store them in the `ThreadPool` struct
before returning it. But how do we “store” a thread? Let’s take another look at
the `thread::spawn` signature:
-->
<p>今や、プールに格納する合法なスレッド数を知る方法ができたので、<code>ThreadPool</code>構造体を返す前にスレッドを作成して格納できます。
ですが、どのようにスレッドを「格納」するのでしょうか？もう一度、<code>thread::spawn</code>シグニチャを眺めてみましょう:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<!--
The `spawn` function returns a `JoinHandle<T>`, where `T` is the type that the
closure returns. Let’s try using `JoinHandle` too and see what happens. In our
case, the closures we’re passing to the thread pool will handle the connection
and not return anything, so `T` will be the unit type `()`.
-->
<p><code>spawn</code>関数は、<code>JoinHandle&lt;T&gt;</code>を返し、ここで<code>T</code>は、クロージャが返す型です。試しに同じように<code>JoinHandle</code>を使ってみて、
どうなるか見てみましょう。我々の場合、スレッドプールに渡すクロージャは接続を扱い、何も返さないので、
<code>T</code>はユニット型<code>()</code>になるでしょう。</p>
<!--
The code in Listing 20-14 will compile but doesn’t create any threads yet.
We’ve changed the definition of `ThreadPool` to hold a vector of
`thread::JoinHandle<()>` instances, initialized the vector with a capacity of
`size`, set up a `for` loop that will run some code to create the threads, and
returned a `ThreadPool` instance containing them.
-->
<p>リスト20-14のコードはコンパイルできますが、まだスレッドは何も生成しません。<code>ThreadPool</code>の定義を変更して、
<code>thread::JoinHandle&lt;()&gt;</code>インスタンスのベクタを保持し、<code>size</code>キャパシティのベクタを初期化し、
スレッドを生成する何らかのコードを実行する<code>for</code>ループを設定し、それらを含む<code>ThreadPool</code>インスタンスを返します。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // スレッドを生成してベクタに格納する
            // create some threads and store them in the vector
        }

        ThreadPool {
            threads
        }
    }

    // --snip--
}
</code></pre>
<!--
<span class="caption">Listing 20-14: Creating a vector for `ThreadPool` to hold
the threads</span>
-->
<p><span class="caption">リスト20-14: <code>ThreadPool</code>にスレッドを保持するベクタを生成する</span></p>
<!--
We’ve brought `std::thread` into scope in the library crate, because we’re
using `thread::JoinHandle` as the type of the items in the vector in
`ThreadPool`.
-->
<p>ライブラリクレート内で<code>std::thread</code>をスコープに導入しました。<code>ThreadPool</code>のベクタの要素の型として、
<code>thread::JoinHandle</code>を使用しているからです。</p>
<!--
Once a valid size is received, our `ThreadPool` creates a new vector that can
hold `size` items. We haven’t used the `with_capacity` function in this book
yet, which performs the same task as `Vec::new` but with an important
difference: it preallocates space in the vector. Because we know we need to
store `size` elements in the vector, doing this allocation up front is slightly
more efficient than using `Vec::new`, which resizes itself as elements are
inserted.
-->
<p>一旦、合法なサイズを受け取ったら、<code>ThreadPool</code>は<code>size</code>個の要素を保持できる新しいベクタを生成します。
この本ではまだ、<code>with_capacity</code>関数を使用したことがありませんが、これは<code>Vec::new</code>と同じ作業をしつつ、
重要な違いがあります: ベクタに予めスペースを確保しておくのです。ベクタに<code>size</code>個の要素を格納する必要があることはわかっているので、
このメモリ確保を前もってしておくと、<code>Vec::new</code>よりも少しだけ効率的になります。<code>Vec::new</code>は、
要素が挿入されるにつれて、自身のサイズを変更します。</p>
<!--
When you run `cargo check` again, you’ll get a few more warnings, but it should
succeed.
-->
<p>再び<code>cargo check</code>を実行すると、もういくつか警告が出るものの、成功するはずです。</p>
<!--
#### A `Worker` Struct Responsible for Sending Code from the `ThreadPool` to a Thread
-->
<h4 id="threadpoolからスレッドにコードを送信する責任を負うworker構造体"><a class="header" href="#threadpoolからスレッドにコードを送信する責任を負うworker構造体"><code>ThreadPool</code>からスレッドにコードを送信する責任を負う<code>Worker</code>構造体</a></h4>
<!--
We left a comment in the `for` loop in Listing 20-14 regarding the creation of
threads. Here, we’ll look at how we actually create threads. The standard
library provides `thread::spawn` as a way to create threads, and
`thread::spawn` expects to get some code the thread should run as soon as the
thread is created. However, in our case, we want to create the threads and have
them *wait* for code that we’ll send later. The standard library’s
implementation of threads doesn’t include any way to do that; we have to
implement it manually.
-->
<p>リスト20-14の<code>for</code>ループにスレッドの生成に関するコメントを残しました。ここでは、実際にスレッドを生成する方法に目を向けます。
標準ライブラリはスレッドを生成する手段として<code>thread::spawn</code>を提供し、<code>thread::spawn</code>は、
生成されるとすぐにスレッドが実行すべき何らかのコードを得ることを予期します。ところが、我々の場合、
スレッドを生成して、後ほど送信するコードを<em>待機</em>してほしいです。標準ライブラリのスレッドの実装は、
それをするいかなる方法も含んでいません; それを手動で実装しなければなりません。</p>
<!--
We’ll implement this behavior by introducing a new data structure between the
`ThreadPool` and the threads that will manage this new behavior. We’ll call
this data structure `Worker`, which is a common term in pooling
implementations. Think of people working in the kitchen at a restaurant: the
workers wait until orders come in from customers, and then they’re responsible
for taking those orders and filling them.
-->
<p>この新しい振る舞いを管理するスレッドと<code>ThreadPool</code>間に新しいデータ構造を導入することでこの振る舞いを実装します。
このデータ構造を<code>Worker</code>と呼び、プール実装では一般的な用語です。レストランのキッチンで働く人々を思い浮かべてください:
労働者は、お客さんからオーダーが来るまで待機し、それからそれらのオーダーを取り、満たすことに責任を負います。</p>
<!--
Instead of storing a vector of `JoinHandle<()>` instances in the thread pool,
we’ll store instances of the `Worker` struct. Each `Worker` will store a single
`JoinHandle<()>` instance. Then we’ll implement a method on `Worker` that will
take a closure of code to run and send it to the already running thread for
execution. We’ll also give each worker an `id` so we can distinguish between
the different workers in the pool when logging or debugging.
-->
<p>スレッドプールに<code>JoinHandle&lt;()&gt;</code>インスタンスのベクタを格納する代わりに、<code>Worker</code>構造体のインスタンスを格納します。
各<code>Worker</code>が単独の<code>JoinHandle&lt;()&gt;</code>インスタンスを格納します。そして、<code>Worker</code>に実行するコードのクロージャを取り、
既に走っているスレッドに実行してもらうために送信するメソッドを実装します。ログを取ったり、デバッグする際にプールの異なるワーカーを区別できるように、
各ワーカーに<code>id</code>も付与します。</p>
<!--
Let’s make the following changes to what happens when we create a `ThreadPool`.
We’ll implement the code that sends the closure to the thread after we have
`Worker` set up in this way:
-->
<p><code>ThreadPool</code>を生成する際に発生することに以下の変更を加えましょう。このように<code>Worker</code>をセットアップした後に、
スレッドにクロージャを送信するコードを実装します:</p>
<!--
1. Define a `Worker` struct that holds an `id` and a `JoinHandle<()>`.
2. Change `ThreadPool` to hold a vector of `Worker` instances.
3. Define a `Worker::new` function that takes an `id` number and returns a
`Worker` instance that holds the `id` and a thread spawned with an empty
closure.
4. In `ThreadPool::new`, use the `for` loop counter to generate an `id`, create
a new `Worker` with that `id`, and store the worker in the vector.
-->
<ol>
<li><code>id</code>と<code>JoinHandle&lt;()&gt;</code>を保持する<code>Worker</code>構造体を定義する。</li>
<li><code>ThreadPool</code>を変更し、<code>Worker</code>インスタンスのベクタを保持する。</li>
<li><code>id</code>番号を取り、<code>id</code>と空のクロージャで大量生産されるスレッドを保持する<code>Worker</code>インスタンスを返す<code>Worker::new</code>関数を定義する。</li>
<li><code>ThreadPool::new</code>で<code>for</code>ループカウンタを使用して<code>id</code>を生成し、その<code>id</code>で新しい<code>Worker</code>を生成し、ベクタにワーカーを格納する。</li>
</ol>
<!--
If you’re up for a challenge, try implementing these changes on your own before
looking at the code in Listing 20-15.
-->
<p>挑戦に積極的ならば、リスト20-15のコードを見る前にご自身でこれらの変更を実装してみてください。</p>
<!--
Ready? Here is Listing 20-15 with one way to make the preceding modifications.
-->
<p>いいですか？こちらが先ほどの変更を行う1つの方法を行ったリスト20-15です。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers
        }
    }
    // --snip--
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker {
            id,
            thread,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-15: Modifying `ThreadPool` to hold `Worker`
instances instead of holding threads directly</span>
-->
<p><span class="caption">リスト20-15: <code>ThreadPool</code>を変更してスレッドを直接保持するのではなく、<code>Worker</code>インスタンスを保持する</span></p>
<!--
We’ve changed the name of the field on `ThreadPool` from `threads` to `workers`
because it’s now holding `Worker` instances instead of `JoinHandle<()>`
instances. We use the counter in the `for` loop as an argument to
`Worker::new`, and we store each new `Worker` in the vector named `workers`.
-->
<p><code>ThreadPool</code>のフィールド名を<code>threads</code>から<code>workers</code>に変更しました。<code>JoinHandle&lt;()&gt;</code>インスタンスではなく、
<code>Worker</code>インスタンスを保持するようになったからです。<code>for</code>ループのカウンタを<code>Worker::new</code>への引数として使用し、
それぞれの新しい<code>Worker</code>を<code>workers</code>というベクタに格納します。</p>
<!--
External code (like our server in *src/bin/main.rs*) doesn’t need to know the
implementation details regarding using a `Worker` struct within `ThreadPool`,
so we make the `Worker` struct and its `new` function private. The
`Worker::new` function uses the `id` we give it and stores a `JoinHandle<()>`
instance that is created by spawning a new thread using an empty closure.
-->
<p>外部のコード(<em>src/bin/main.rs</em>のサーバなど)は、<code>ThreadPool</code>内で<code>Worker</code>構造体を使用していることに関する実装の詳細を知る必要はないので、
<code>Worker</code>構造体とその<code>new</code>関数は非公開にしています。<code>Worker::new</code>関数は与えた<code>id</code>を使用し、
空のクロージャを使って新しいスレッドを立ち上げることで生成される<code>JoinHandle&lt;()&gt;</code>インスタンスを格納します。</p>
<!--
This code will compile and will store the number of `Worker` instances we
specified as an argument to `ThreadPool::new`. But we’re *still* not processing
the closure that we get in `execute`. Let’s look at how to do that next.
-->
<p>このコードはコンパイルでき、<code>ThreadPool::new</code>への引数として指定した数の<code>Worker</code>インスタンスを格納します。
ですが<em>それでも</em>、<code>execute</code>で得るクロージャを処理してはいません。次は、それをする方法に目を向けましょう。</p>
<!--
#### Sending Requests to Threads via Channels
-->
<h4 id="チャンネル経由でスレッドにリクエストを送信する"><a class="header" href="#チャンネル経由でスレッドにリクエストを送信する">チャンネル経由でスレッドにリクエストを送信する</a></h4>
<!--
Now we’ll tackle the problem that the closures given to `thread::spawn` do
absolutely nothing. Currently, we get the closure we want to execute in the
`execute` method. But we need to give `thread::spawn` a closure to run when we
create each `Worker` during the creation of the `ThreadPool`.
-->
<p>さて、<code>thread::spawn</code>に与えられたクロージャが全く何もしないという問題に取り組みましょう。現在、
<code>execute</code>メソッドで実行したいクロージャを得ています。ですが、<code>ThreadPool</code>の生成中、<code>Worker</code>それぞれを生成する際に、
実行するクロージャを<code>thread::spawn</code>に与える必要があります。</p>
<!--
We want the `Worker` structs that we just created to fetch code to run from a
queue held in the `ThreadPool` and send that code to its thread to run.
-->
<p>作ったばかりの<code>Worker</code>構造体に<code>ThreadPool</code>が保持するキューから実行するコードをフェッチして、
そのコードをスレッドが実行できるように送信してほしいです。</p>
<!--
In Chapter 16, you learned about *channels*—a simple way to communicate between
two threads—that would be perfect for this use case. We’ll use a channel to
function as the queue of jobs, and `execute` will send a job from the
`ThreadPool` to the `Worker` instances, which will send the job to its thread.
Here is the plan:
-->
<p>第16章でこのユースケースにぴったりであろう<em>チャンネル</em>(2スレッド間コミュニケーションをとる単純な方法)について学びました。
チャンネルをキューの仕事として機能させ、<code>execute</code>は<code>ThreadPool</code>から<code>Worker</code>インスタンスに仕事を送り、
これが仕事をスレッドに送信します。こちらが計画です:</p>
<!--
1. The `ThreadPool` will create a channel and hold on to the sending side of
the channel.
2. Each `Worker` will hold on to the receiving side of the channel.
3. We’ll create a new `Job` struct that will hold the closures we want to send
down the channel.
4. The `execute` method will send the job it wants to execute down the sending
side of the channel.
5. In its thread, the `Worker` will loop over its receiving side of the channel
and execute the closures of any jobs it receives.
-->
<ol>
<li><code>ThreadPool</code>はチャンネルを生成し、チャンネルの送信側に就く。</li>
<li><code>Worker</code>それぞれは、チャンネルの受信側に就く。</li>
<li>チャンネルに送信したいクロージャを保持する新しい<code>Job</code>構造体を生成する。</li>
<li><code>execute</code>メソッドは、実行したい仕事をチャンネルの送信側に送信する。</li>
<li>スレッド内で、<code>Worker</code>はチャンネルの受信側をループし、受け取ったあらゆる仕事のクロージャを実行する。</li>
</ol>
<!--
Let’s start by creating a channel in `ThreadPool::new` and holding the sending
side in the `ThreadPool` instance, as shown in Listing 20-16. The `Job` struct
doesn’t hold anything for now but will be the type of item we’re sending down
the channel.
-->
<p><code>ThreadPool::new</code>内でチャンネルを生成し、<code>ThreadPool</code>インスタンスに送信側を保持することから始めましょう。リスト20-16のようにですね。
今の所、<code>Job</code>構造体は何も保持しませんが、チャンネルに送信する種類の要素になります。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span>// --snip--
use std::sync::mpsc;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // --snip--
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-16: Modifying `ThreadPool` to store the
sending end of a channel that sends `Job` instances</span>
-->
<p><span class="caption">リスト20-18: <code>ThreadPool</code>を変更して<code>Job</code>インスタンスを送信するチャンネルの送信側を格納する</span></p>
<!--
In `ThreadPool::new`, we create our new channel and have the pool hold the
sending end. This will successfully compile, still with warnings.
-->
<p><code>ThreadPool::new</code>内で新しいチャンネルを生成し、プールに送信側を保持させています。これはコンパイルに成功しますが、
まだ警告があります。</p>
<!--
Let’s try passing a receiving end of the channel into each worker as the thread
pool creates them. We know we want to use the receiving end in the
thread that the workers spawn, so we’ll reference the `receiver` parameter in
the closure. The code in Listing 20-17 won’t quite compile yet.
-->
<p>スレッドプールがワーカーを生成する際に各ワーカーにチャンネルの受信側を試しに渡してみましょう。
受信側はワーカーが大量生産するスレッド内で使用したいことがわかっているので、クロージャ内で<code>receiver</code>引数を参照します。
リスト20-17のコードはまだ完璧にはコンパイルできません。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-17: Passing the receiving end of the channel
to the workers</span>
-->
<p><span class="caption">リスト20-17: チャンネルの受信側をワーカーに渡す</span></p>
<!--
We’ve made some small and straightforward changes: we pass the receiving end of
the channel into `Worker::new`, and then we use it inside the closure.
-->
<p>多少些細で単純な変更を行いました: チャンネルの受信側を<code>Worker::new</code>に渡し、それからクロージャの内側で使用しています。</p>
<!--
When we try to check this code, we get this error:
-->
<p>このコードのチェックを試みると、このようなエラーが出ます:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:27:42
   |
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here in
   previous iteration of loop
   |
   = note: move occurs because `receiver` has type
   `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
</code></pre>
<!--
The code is trying to pass `receiver` to multiple `Worker` instances. This
won’t work, as you’ll recall from Chapter 16: the channel implementation that
Rust provides is multiple *producer*, single *consumer*. This means we can’t
just clone the consuming end of the channel to fix this code. Even if we could,
that is not the technique we would want to use; instead, we want to distribute
the jobs across threads by sharing the single `receiver` among all the workers.
-->
<p>このコードは、<code>receiver</code>を複数の<code>Worker</code>インスタンスに渡そうとしています。第16章を思い出すように、これは動作しません:
Rustが提供するチャンネル実装は、複数の<em>生成者</em>、単独の<em>消費者</em>です。要するに、
チャンネルの消費側をクローンするだけでこのコードを修正することはできません。たとえできたとしても、
使用したいテクニックではありません; 代わりに、全ワーカー間で単独の<code>receiver</code>を共有することで、
スレッド間に仕事を分配したいです。</p>
<!--
Additionally, taking a job off the channel queue involves mutating the
`receiver`, so the threads need a safe way to share and modify `receiver`;
otherwise, we might get race conditions (as covered in Chapter 16).
-->
<p>さらに、チャンネルキューから仕事を取り出すことは、<code>receiver</code>を可変化することに関連するので、
スレッドには、<code>receiver</code>を共有して変更する安全な方法が必要です; さもなくば、
競合状態に陥る可能性があります(第16章で講義しました)。</p>
<!--
Recall the thread-safe smart pointers discussed in Chapter 16: to share
ownership across multiple threads and allow the threads to mutate the value, we
need to use `Arc<Mutex<T>>`. The `Arc` type will let multiple workers own the
receiver, and `Mutex` will ensure that only one worker gets a job from the
receiver at a time. Listing 20-18 shows the changes we need to make.
-->
<p>第16章で議論したスレッド安全なスマートポインタを思い出してください: 複数のスレッドで所有権を共有しつつ、
スレッドに値を可変化させるためには、<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>を使用する必要があります。<code>Arc</code>型は、
複数のワーカーに受信者を所有させ、<code>Mutex</code>により、1度に受信者から1つの仕事をたった1つのワーカーが受け取ることを保証します。
リスト20-18は、行う必要のある変更を示しています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::sync::mpsc;
</span>use std::sync::Arc;
use std::sync::Mutex;
// --snip--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    // --snip--
}

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">           receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread,
</span><span class="boring">        }
</span>    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-18: Sharing the receiving end of the channel
among the workers using `Arc` and `Mutex`</span>
-->
<p><span class="caption">リスト20-18: <code>Arc</code>と<code>Mutex</code>を使用してワーカー間でチャンネルの受信側を共有する</span></p>
<!--
In `ThreadPool::new`, we put the receiving end of the channel in an `Arc` and a
`Mutex`. For each new worker, we clone the `Arc` to bump the reference count so
the workers can share ownership of the receiving end.
-->
<p><code>ThreadPool::new</code>で、チャンネルの受信側を<code>Arc</code>と<code>Mutex</code>に置いています。新しいワーカーそれぞれに対して、
<code>Arc</code>をクローンして参照カウントを跳ね上げているので、ワーカーは受信側の所有権を共有することができます。</p>
<!--
With these changes, the code compiles! We’re getting there!
-->
<p>これらの変更でコードはコンパイルできます！ゴールはもうすぐそこです！</p>
<!--
#### Implementing the `execute` Method
-->
<h4 id="executeメソッドを実装する"><a class="header" href="#executeメソッドを実装する"><code>execute</code>メソッドを実装する</a></h4>
<!--
Let’s finally implement the `execute` method on `ThreadPool`. We’ll also change
`Job` from a struct to a type alias for a trait object that holds the type of
closure that `execute` receives. As discussed in the “Creating Type Synonyms
with Type Aliases” section of Chapter 19, type aliases allow us to make long
types shorter. Look at Listing 20-19.
-->
<p>最後に<code>ThreadPool</code>に<code>execute</code>メソッドを実装しましょう。
<code>Job</code>も構造体から<code>execute</code>が受け取るクロージャの型を保持するトレイトオブジェクトの型エイリアスに変更します。
第19章の「型エイリアスで型同義語を生成する」節で議論したように、型エイリアスにより長い型を短くできます。
リスト20-19をご覧ください。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// --snip--
<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">use std::sync::mpsc;
</span><span class="boring">struct Worker {}
</span>
type Job = Box&lt;FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
<span class="boring">}
</span></code></pre></pre>
<!--
<span class="caption">Listing 20-19: Creating a `Job` type alias for a `Box`
that holds each closure and then sending the job down the channel</span>
-->
<p><span class="caption">リスト20-19: 各クロージャを保持する<code>Box</code>に対して<code>Job</code>型エイリアスを生成し、それからチャンネルに仕事を送信する</span></p>
<!--
After creating a new `Job` instance using the closure we get in `execute`, we
send that job down the sending end of the channel. We’re calling `unwrap` on
`send` for the case that sending fails. This might happen if, for example, we
stop all our threads from executing, meaning the receiving end has stopped
receiving new messages. At the moment, we can’t stop our threads from
executing: our threads continue executing as long as the pool exists. The
reason we use `unwrap` is that we know the failure case won’t happen, but the
compiler doesn’t know that.
-->
<p><code>execute</code>で得たクロージャを使用して新しい<code>Job</code>インスタンスを生成した後、その仕事をチャンネルの送信側に送信しています。
送信が失敗した時のために<code>send</code>に対して<code>unwrap</code>を呼び出しています。これは例えば、全スレッドの実行を停止させるなど、
受信側が新しいメッセージを受け取るのをやめてしまったときなどに起こる可能性があります。現時点では、
スレッドの実行を止めることはできません: スレッドは、プールが存在する限り実行し続けます。
<code>unwrap</code>を使用している理由は、失敗する場合が起こらないとわかっているからですが、コンパイラにはわかりません。</p>
<!--
But we’re not quite done yet! In the worker, our closure being passed to
`thread::spawn` still only *references* the receiving end of the channel.
Instead, we need the closure to loop forever, asking the receiving end of the
channel for a job and running the job when it gets one. Let’s make the change
shown in Listing 20-20 to `Worker::new`.
-->
<p>ですが、まだやり終えたわけではありませんよ！ワーカー内で<code>thread::spawn</code>に渡されているクロージャは、
それでもチャンネルの受信側を<em>参照</em>しているだけです。その代わりに、クロージャには永遠にループし、
チャンネルの受信側に仕事を要求し、仕事を得たらその仕事を実行してもらう必要があります。
リスト20-20に示した変更を<code>Worker::new</code>に行いましょう。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                // ワーカー{}は仕事を得ました; 実行します
                println!(&quot;Worker {} got a job; executing.&quot;, id);

                (*job)();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-20: Receiving and executing the jobs in the
worker’s thread</span>
-->
<p><span class="caption">リスト20-20: ワーカーのスレッドで仕事を受け取り、実行する</span></p>
<!--
Here, we first call `lock` on the `receiver` to acquire the mutex, and then we
call `unwrap` to panic on any errors. Acquiring a lock might fail if the mutex
is in a *poisoned* state, which can happen if some other thread panicked while
holding the lock rather than releasing the lock. In this situation, calling
`unwrap` to have this thread panic is the correct action to take. Feel free to
change this `unwrap` to an `expect` with an error message that is meaningful to
you.
-->
<p>ここで、まず<code>receiver</code>に対して<code>lock</code>を呼び出してミューテックスを獲得し、それから<code>unwrap</code>を呼び出して、
エラーの際にはパニックします。ロックの獲得は、ミューテックスが<em>毒された</em>状態なら失敗する可能性があり、
これは、他のどれかのスレッドがロックを保持している間に、解放するのではなく、パニックした場合に起き得ます。
この場面では、<code>unwrap</code>を呼び出してこのスレッドをパニックさせるのは、取るべき正当な行動です。
この<code>unwrap</code>をあなたにとって意味のあるエラーメッセージを伴う<code>expect</code>に変更することは、ご自由に行なってください。</p>
<!--
If we get the lock on the mutex, we call `recv` to receive a `Job` from the
channel. A final `unwrap` moves past any errors here as well, which might occur
if the thread holding the sending side of the channel has shut down, similar to
how the `send` method returns `Err` if the receiving side shuts down.
-->
<p>ミューテックスのロックを獲得できたら、<code>recv</code>を呼び出してチャンネルから<code>Job</code>を受け取ります。
最後の<code>unwrap</code>もここであらゆるエラーを超えていき、これはチャンネルの送信側を保持するスレッドが閉じた場合に発生する可能性があり、
受信側が閉じた場合に<code>send</code>メソッドが<code>Err</code>を返すのと似ています。</p>
<!--
The call to `recv` blocks, so if there is no job yet, the current thread will
wait until a job becomes available. The `Mutex<T>` ensures that only one
`Worker` thread at a time is trying to request a job.
-->
<p><code>recv</code>の呼び出しはブロックするので、まだ仕事がなければ、現在のスレッドは、仕事が利用可能になるまで待機します。
<code>Mutex&lt;T&gt;</code>により、ただ1つの<code>Worker</code>スレッドのみが一度に仕事の要求を試みることを保証します。</p>
<!--
Theoretically, this code should compile. Unfortunately, the Rust compiler isn’t
perfect yet, and we get this error:
-->
<p>理論的には、このコードはコンパイルできるはずです。残念ながら、Rustコンパイラはまだ完全ではなく、
このようなエラーが出ます:</p>
<pre><code class="language-text">error[E0161]: cannot move a value of type std::ops::FnOnce() +
std::marker::Send: the size of std::ops::FnOnce() + std::marker::Send cannot be
statically determined
(エラー: std::ops::FnOnce() + std::marker::Sendの値をムーブできません:
std::ops::FnOnce() + std::marker::Sendのサイズを静的に決定できません)
  --&gt; src/lib.rs:63:17
   |
63 |                 (*job)();
   |                 ^^^^^^
</code></pre>
<!--
This error is fairly cryptic because the problem is fairly cryptic. To call a
`FnOnce` closure that is stored in a `Box<T>` (which is what our `Job` type
alias is), the closure needs to move itself *out* of the `Box<T>` because the
closure takes ownership of `self` when we call it. In general, Rust doesn’t
allow us to move a value out of a `Box<T>` because Rust doesn’t know how big
the value inside the `Box<T>` will be: recall in Chapter 15 that we used
`Box<T>` precisely because we had something of an unknown size that we wanted
to store in a `Box<T>` to get a value of a known size.
-->
<p>問題が非常に謎めいているので、エラーも非常に謎めいています。<code>Box&lt;T&gt;</code>に格納された<code>FnOnce</code>クロージャを呼び出すためには(<code>Job</code>型エイリアスがそう)、
呼び出す際にクロージャが<code>self</code>の所有権を奪うので、
クロージャは自身を<code>Box&lt;T&gt;</code><em>から</em>ムーブする必要があります。一般的に、Rustは<code>Box&lt;T&gt;</code>から値をムーブすることを許可しません。
コンパイラには、<code>Box&lt;T&gt;</code>の内側の値がどれほどの大きさなのか見当がつかないからです: 
第15章で<code>Box&lt;T&gt;</code>に格納して既知のサイズの値を得たい未知のサイズの何かがあるために<code>Box&lt;T&gt;</code>を正確に使用したことを思い出してください。</p>
<!--
As you saw in Listing 17-15, we can write methods that use the syntax `self:
Box<Self>`, which allows the method to take ownership of a `Self` value stored
in a `Box<T>`. That’s exactly what we want to do here, but unfortunately Rust
won’t let us: the part of Rust that implements behavior when a closure is
called isn’t implemented using `self: Box<Self>`. So Rust doesn’t yet
understand that it could use `self: Box<Self>` in this situation to take
ownership of the closure and move the closure out of the `Box<T>`.
-->
<p>リスト17-15で見かけたように、記法<code>self: Box&lt;Self&gt;</code>を使用するメソッドを書くことができ、
これにより、メソッドは<code>Box&lt;T&gt;</code>に格納された<code>Self</code>値の所有権を奪うことができます。
それがまさしくここで行いたいことですが、残念ながらコンパイラはさせてくれません:
クロージャが呼び出された際に振る舞いを実装するRustの一部は、<code>self: Box&lt;Self&gt;</code>を使用して実装されていないのです。
故に、コンパイラはまだこの場面において<code>self: Box&lt;Self&gt;</code>を使用してクロージャの所有権を奪い、
クロージャを<code>Box&lt;T&gt;</code>からムーブできることを理解していないのです。</p>
<!--
Rust is still a work in progress with places where the compiler could be
improved, but in the future, the code in Listing 20-20 should work just fine.
People just like you are working to fix this and other issues! After you’ve
finished this book, we would love for you to join in.
-->
<p>Rustはまだコンパイラの改善途上にあり、リスト20-20のコードは、
将来的にうまく動くようになるべきです。まさしくあなたのような方がこれや他の問題を修正しています！この本を完了したら、
是非ともあなたにも参加していただきたいです。</p>
<!--
But for now, let’s work around this problem using a handy trick. We can tell
Rust explicitly that in this case we can take ownership of the value inside the
`Box<T>` using `self: Box<Self>`; then, once we have ownership of the closure,
we can call it. This involves defining a new trait `FnBox` with the method
`call_box` that will use `self: Box<Self>` in its signature, defining `FnBox`
for any type that implements `FnOnce()`, changing our type alias to use the new
trait, and changing `Worker` to use the `call_box` method. These changes are
shown in Listing 20-21.
-->
<p>ですがとりあえず、手頃なトリックを使ってこの問題を回避しましょう。この場合、<code>self: Box&lt;Self&gt;</code>で、
<code>Box&lt;T&gt;</code>の内部の値の所有権を奪うことができることをコンパイラに明示的に教えてあげます;
そして、一旦クロージャの所有権を得たら、呼び出せます。これには、
シグニチャに<code>self: Box&lt;Self&gt;</code>を使用する<code>call_box</code>というメソッドのある新しいトレイト<code>FnBox</code>を定義すること、
<code>FnOnce()</code>を実装する任意の型に対して<code>FnBox</code>を定義すること、型エイリアスを新しいトレイトを使用するように変更すること、
<code>Worker</code>を<code>call_box</code>メソッドを使用するように変更することが関連します。これらの変更は、
リスト20-21に表示されています。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-21: Adding a new trait `FnBox` to work around
the current limitations of `Box<FnOnce()>`</span>
-->
<p><span class="caption">リスト20-21: 新しいトレイト<code>FnBox</code>を追加して<code>Box&lt;FnOnce()&gt;</code>の現在の制限を回避する</span></p>
<!--
First, we create a new trait named `FnBox`. This trait has the one method
`call_box`, which is similar to the `call` methods on the other `Fn*` traits
except that it takes `self: Box<Self>` to take ownership of `self` and move the
value out of the `Box<T>`.
-->
<p>まず、<code>FnBox</code>という新しいトレイトを作成します。このトレイトには<code>call_box</code>という1つのメソッドがあり、
これは、<code>self: Box&lt;Self&gt;</code>を取って<code>self</code>の所有権を奪い、<code>Box&lt;T&gt;</code>から値をムーブする点を除いて、
他の<code>Fn*</code>トレイトの<code>call</code>メソッドと類似しています。</p>
<!--
Next, we implement the `FnBox` trait for any type `F` that implements the
`FnOnce()` trait. Effectively, this means that any `FnOnce()` closures can use
our `call_box` method. The implementation of `call_box` uses `(*self)()` to
move the closure out of the `Box<T>` and call the closure.
-->
<p>次に、<code>FnOnce()</code>トレイトを実装する任意の型<code>F</code>に対して<code>FnBox</code>トレイトを実装します。実質的にこれは、
あらゆる<code>FnOnce()</code>クロージャが<code>call_box</code>メソッドを使用できることを意味します。<code>call_box</code>の実装は、
<code>(*self)()</code>を使用して<code>Box&lt;T&gt;</code>からクロージャをムーブし、クロージャを呼び出します。</p>
<!--
We now need our `Job` type alias to be a `Box` of anything that implements our
new trait `FnBox`. This will allow us to use `call_box` in `Worker` when we get
a `Job` value instead of invoking the closure directly. Implementing the
`FnBox` trait for any `FnOnce()` closure means we don’t have to change anything
about the actual values we’re sending down the channel. Now Rust is able to
recognize that what we want to do is fine.
-->
<p>これで<code>Job</code>型エイリアスには、新しいトレイトの<code>FnBox</code>を実装する何かの<code>Box</code>である必要が出てきました。
これにより、クロージャを直接呼び出す代わりに<code>Job</code>値を得た時に<code>Worker</code>の<code>call_box</code>を使えます。
任意の<code>FnOnce()</code>クロージャに対して<code>FnBox</code>トレイトを実装することは、チャンネルに送信する実際の値は何も変えなくてもいいことを意味します。
もうコンパイラは、我々が行おうとしていることが平気なことであると認識できます。</p>
<!--
This trick is very sneaky and complicated. Don’t worry if it doesn’t make
perfect sense; someday, it will be completely unnecessary.
-->
<p>このトリックは非常にこそこそしていて複雑です。完璧に筋が通らなくても心配しないでください;
いつの日か、完全に不要になるでしょう。</p>
<!--
With the implementation of this trick, our thread pool is in a working state!
Give it a `cargo run`, and make some requests:
-->
<p>このトリックの実装で、スレッドプールは動く状態になります！<code>cargo run</code>を実行し、
リクエストを行なってください:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never used: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `id`
  --&gt; src/lib.rs:61:5
   |
61 |     id: usize,
   |     ^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `thread`
  --&gt; src/lib.rs:62:5
   |
62 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.99 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<!--
Success! We now have a thread pool that executes connections asynchronously.
There are never more than four threads created, so our system won’t get
overloaded if the server receives a lot of requests. If we make a request to
*/sleep*, the server will be able to serve other requests by having another
thread run them.
-->
<p>成功！もう非同期に接続を実行するスレッドプールができました。絶対に4つ以上のスレッドが生成されないので、
サーバが多くのリクエストを受け取っても、システムは過負荷にならないでしょう。<em>/sleep</em>にリクエストを行なっても、
サーバは他のスレッドに実行させることで他のリクエストを提供できるでしょう。</p>
<!--
After learning about the `while let` loop in Chapter 18, you might be wondering
why we didn’t write the worker thread code as shown in Listing 20-22.
-->
<p>第18章で<code>while let</code>ループを学んだ後で、なぜリスト20-22に示したようにワーカースレッドのコードを記述しなかったのか、
不思議に思っている可能性があります。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-22: An alternative implementation of
`Worker::new` using `while let`</span>
-->
<p><span class="caption">リスト20-22: <code>while let</code>を使用したもう1つの<code>Worker::new</code>の実装</span></p>
<!--
This code compiles and runs but doesn’t result in the desired threading
behavior: a slow request will still cause other requests to wait to be
processed. The reason is somewhat subtle: the `Mutex` struct has no public
`unlock` method because the ownership of the lock is based on the lifetime of
the `MutexGuard<T>` within the `LockResult<MutexGuard<T>>` that the `lock`
method returns. At compile time, the borrow checker can then enforce the rule
that a resource guarded by a `Mutex` cannot be accessed unless we hold the
lock. But this implementation can also result in the lock being held longer
than intended if we don’t think carefully about the lifetime of the
`MutexGuard<T>`. Because the values in the `while` expression remain in scope
for the duration of the block, the lock remains held for the duration of the
call to `job.call_box()`, meaning other workers cannot receive jobs.
-->
<p>このコードはコンパイルでき、動きますが、望み通りのスレッドの振る舞いにはなりません:
遅いリクエストがそれでも、他のリクエストが処理されるのを待機させてしまうのです。理由はどこか捉えがたいものです:
<code>Mutex</code>構造体には公開の<code>unlock</code>メソッドがありません。ロックの所有権が、
<code>lock</code>メソッドが返す<code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code>内の<code>MutexGuard&lt;T&gt;</code>のライフタイムに基づくからです。
コンパイル時には、ロックを保持していない限り、借用チェッカーはそうしたら、<code>Mutex</code>に保護されるリソースにはアクセスできないという規則を強制できます。
しかし、この実装は、<code>MutexGuard&lt;T&gt;</code>のライフタイムについて熟考しなければ、
意図したよりもロックが長い間保持される結果になり得ます。<code>while</code>式の値がブロックの間中スコープに残り続けるので、
ロックは<code>job.call_box</code>の呼び出し中保持されたままになり、つまり、他のワーカーが仕事を受け取れなくなるのです。</p>
<!--
By using `loop` instead and acquiring the lock and a job within the block
rather than outside it, the `MutexGuard` returned from the `lock` method is
dropped as soon as the `let job` statement ends. This ensures that the lock is
held during the call to `recv`, but it is released before the call to
`job.call_box()`, allowing multiple requests to be serviced concurrently.
-->
<p>代わりに<code>loop</code>を使用し、ロックと仕事をブロックの外ではなく、内側で獲得することで、
<code>lock</code>メソッドが返す<code>MutexGuard</code>は<code>let job</code>文が終わると同時にドロップされます。
これにより、複数のリクエストを並行で提供し、ロックは<code>recv</code>の呼び出しの間は保持されるけれども、
<code>job.call_box</code>の呼び出しの前には解放されることを保証します。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Graceful Shutdown and Cleanup
-->
<h2 id="正常なシャットダウンと片付け"><a class="header" href="#正常なシャットダウンと片付け">正常なシャットダウンと片付け</a></h2>
<!--
The code in Listing 20-21 is responding to requests asynchronously through the
use of a thread pool, as we intended. We get some warnings about the `workers`,
`id`, and `thread` fields that we’re not using in a direct way that reminds us
we’re not cleaning up anything. When we use the less elegant <span
class="keystroke">ctrl-c</span> method to halt the main thread, all other
threads are stopped immediately as well, even if they’re in the middle of
serving a request.
-->
<p>リスト20-21のコードは、意図した通り、スレッドプールの使用を通してリクエストに非同期に応答できます。
直接使用していない<code>workers</code>、<code>id</code>、<code>thread</code>フィールドについて警告が出ます。この警告は、現在のコードは何も片付けていないことを思い出させてくれます。
優美さに欠ける<span class="keystroke">ctrl-c</span>を使用してメインスレッドを停止させる方法を使用すると、
リクエストの処理中であっても、他のスレッドも停止します。</p>
<!--
Now we’ll implement the `Drop` trait to call `join` on each of the threads in
the pool so they can finish the requests they’re working on before closing.
Then we’ll implement a way to tell the threads they should stop accepting new
requests and shut down. To see this code in action, we’ll modify our server to
accept only two requests before gracefully shutting down its thread pool.
-->
<p>では、閉じる前に取り掛かっているリクエストを完了できるように、プールの各スレッドに対して<code>join</code>を呼び出す<code>Drop</code>トレイトを実装します。
そして、スレッドに新しいリクエストの受付を停止し、終了するように教える方法を実装します。
このコードが動いているのを確かめるために、サーバを変更して正常にスレッドプールを終了する前に2つしかリクエストを受け付けないようにします。</p>
<!--
### Implementing the `Drop` Trait on `ThreadPool`
-->
<h3 id="threadpoolにdropトレイトを実装する"><a class="header" href="#threadpoolにdropトレイトを実装する"><code>ThreadPool</code>に<code>Drop</code>トレイトを実装する</a></h3>
<!--
Let’s start with implementing `Drop` on our thread pool. When the pool is
dropped, our threads should all join to make sure they finish their work.
Listing 20-23 shows a first attempt at a `Drop` implementation; this code won’t
quite work yet.
-->
<p>スレッドプールに<code>Drop</code>を実装するところから始めましょう。プールがドロップされると、
スレッドは全てjoinして、作業を完了するのを確かめるべきです。リスト20-23は、<code>Drop</code>実装の最初の試みを表示しています;
このコードはまだ完全には動きません。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            // ワーカー{}を終了します
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-23: Joining each thread when the thread pool
goes out of scope</span>
-->
<p><span class="caption">リスト20-23: スレッドプールがスコープを抜けた時にスレッドをjoinさせる</span></p>
<!--
First, we loop through each of the thread pool `workers`. We use `&mut` for
this because `self` is a mutable reference, and we also need to be able to
mutate `worker`. For each worker, we print a message saying that this
particular worker is shutting down, and then we call `join` on that worker’s
thread. If the call to `join` fails, we use `unwrap` to make Rust panic and go
into an ungraceful shutdown.
-->
<p>まず、スレッドプール<code>workers</code>それぞれを走査します。<code>self</code>は可変参照であり、<code>worker</code>を可変化できる必要もあるので、
これには<code>&amp;mut</code>を使用しています。ワーカーそれぞれに対して、特定のワーカーを終了する旨のメッセージを出力し、
それから<code>join</code>をワーカースレッドに対して呼び出しています。<code>join</code>の呼び出しが失敗したら、
<code>unwrap</code>を使用してRustをパニックさせ、正常でないシャットダウンに移行します。</p>
<!--
Here is the error we get when we compile this code:
-->
<p>こちらが、このコードをコンパイルする際に出るエラーです:</p>
<pre><code class="language-text">error[E0507]: cannot move out of borrowed content
  --&gt; src/lib.rs:65:13
   |
65 |             worker.thread.join().unwrap();
   |             ^^^^^^ cannot move out of borrowed content
</code></pre>
<!--
The error tells us we can’t call `join` because we only have a mutable borrow
of each `worker` and `join` takes ownership of its argument. To solve this
issue, we need to move the thread out of the `Worker` instance that owns
`thread` so `join` can consume the thread. We did this in Listing 17-15: if
`Worker` holds an `Option<thread::JoinHandle<()>` instead, we can call the
`take` method on the `Option` to move the value out of the `Some` variant and
leave a `None` variant in its place. In other words, a `Worker` that is running
will have a `Some` variant in `thread`, and when we want to clean up a
`Worker` we’ll replace `Some` with `None` so the worker doesn’t have a
thread to run.
-->
<p>各<code>worker</code>の可変参照しかなく、<code>join</code>は引数の所有権を奪うためにこのエラーは<code>join</code>を呼び出せないと教えてくれています。
この問題を解決するには、<code>join</code>がスレッドを消費できるように、<code>thread</code>を所有する<code>Worker</code>インスタンスからスレッドをムーブする必要があります。
これをリスト17-15では行いました: <code>Worker</code>が代わりに<code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code>を保持していれば、
<code>Option</code>に対して<code>take</code>メソッドを呼び出し、<code>Some</code>列挙子から値をムーブし、その場所に<code>None</code>列挙子を残すことができます。
言い換えれば、実行中の<code>Worker</code>には<code>thread</code>に<code>Some</code>列挙子があり、<code>Worker</code>を片付けたい時には、
ワーカーが実行するスレッドがないように<code>Some</code>を<code>None</code>で置き換えるのです。</p>
<!--
So we know we want to update the definition of `Worker` like this:
-->
<p>従って、<code>Worker</code>の定義を以下のように更新したいことがわかります:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span>struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<!--
Now let’s lean on the compiler to find the other places that need to change.
Checking this code, we get two errors:
-->
<p>さて、コンパイラを頼りにして他に変更する必要がある箇所を探しましょう。このコードをチェックすると、
2つのエラーが出ます:</p>
<pre><code class="language-text">error[E0599]: no method named `join` found for type
`std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope
  --&gt; src/lib.rs:65:27
   |
65 |             worker.thread.join().unwrap();
   |                           ^^^^

error[E0308]: mismatched types
  --&gt; src/lib.rs:89:13
   |
89 |             thread,
   |             ^^^^^^
   |             |
   |             expected enum `std::option::Option`, found struct
   `std::thread::JoinHandle`
   |             help: try using a variant of the expected type: `Some(thread)`
   |
   = note: expected type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`
              found type `std::thread::JoinHandle&lt;_&gt;`
</code></pre>
<!--
Let’s address the second error, which points to the code at the end of
`Worker::new`; we need to wrap the `thread` value in `Some` when we create a
new `Worker`. Make the following changes to fix this error:
-->
<p>2番目のエラーを扱いましょう。これは、<code>Worker::new</code>の最後のコードを指しています; 新しい<code>Worker</code>を作成する際に、
<code>Some</code>に<code>thread</code>の値を包む必要があります。このエラーを修正するために以下の変更を行なってください:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<!--
The first error is in our `Drop` implementation. We mentioned earlier that we
intended to call `take` on the `Option` value to move `thread` out of `worker`.
The following changes will do so:
-->
<p>最初のエラーは<code>Drop</code>実装内にあります。先ほど、<code>Option</code>値に対して<code>take</code>を呼び出し、
<code>thread</code>を<code>worker</code>からムーブする意図があることに触れました。以下の変更がそれを行います:</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<!--
As discussed in Chapter 17, the `take` method on `Option` takes the `Some`
variant out and leaves `None` in its place. We’re using `if let` to destructure
the `Some` and get the thread; then we call `join` on the thread. If a worker’s
thread is already `None`, we know that worker has already had its thread
cleaned up, so nothing happens in that case.
-->
<p>第17章で議論したように、<code>Option</code>の<code>take</code>メソッドは、<code>Some</code>列挙子を取り出し、その箇所に<code>None</code>を残します。
<code>if let</code>を使用して<code>Some</code>を分配し、スレッドを得ています; そして、スレッドに対して<code>join</code>を呼び出します。
ワーカーのスレッドが既に<code>None</code>なら、ワーカーはスレッドを既に片付け済みであることがわかるので、
その場合には何も起きません。</p>
<!--
### Signaling to the Threads to Stop Listening for Jobs
-->
<h3 id="スレッドに仕事をリッスンするのを止めるよう通知する"><a class="header" href="#スレッドに仕事をリッスンするのを止めるよう通知する">スレッドに仕事をリッスンするのを止めるよう通知する</a></h3>
<!--
With all the changes we’ve made, our code compiles without any warnings. But
the bad news is this code doesn’t function the way we want it to yet. The key
is the logic in the closures run by the threads of the `Worker` instances: at
the moment, we call `join`, but that won’t shut down the threads because they
`loop` forever looking for jobs. If we try to drop our `ThreadPool` with our
current implementation of `drop`, the main thread will block forever waiting
for the first thread to finish.
-->
<p>これらの変更によって、コードは警告なしでコンパイルできます。ですが悪い知らせは、このコードが期待したようにはまだ機能しないことです。
鍵は、<code>Worker</code>インスタンスのスレッドで実行されるクロージャのロジックです: 現時点で<code>join</code>を呼び出していますが、
仕事を求めて永遠に<code>loop</code>するので、スレッドを終了しません。現在の<code>drop</code>の実装で<code>ThreadPool</code>をドロップしようとしたら、
最初のスレッドが完了するのを待機してメインスレッドは永遠にブロックされるでしょう。</p>
<!--
To fix this problem, we’ll modify the threads so they listen for either a `Job`
to run or a signal that they should stop listening and exit the infinite loop.
Instead of `Job` instances, our channel will send one of these two enum
variants.
-->
<p>この問題を修正するには、スレッドが、実行すべき<code>Job</code>か、リッスンをやめて無限ループを抜ける通知をリッスンするように、
変更します。<code>Job</code>インスタンスの代わりに、チャンネルはこれら2つのenum列挙子の一方を送信します。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Job;
</span>enum Message {
    NewJob(Job),
    Terminate,
}
<span class="boring">}
</span></code></pre></pre>
<!--
This `Message` enum will either be a `NewJob` variant that holds the `Job` the
thread should run, or it will be a `Terminate` variant that will cause the
thread to exit its loop and stop.
-->
<p>この<code>Message</code> enumはスレッドが実行すべき<code>Job</code>を保持する<code>NewJob</code>列挙子か、スレッドをループから抜けさせ、
停止させる<code>Terminate</code>列挙子のどちらかになります。</p>
<!--
We need to adjust the channel to use values of type `Message` rather than type
`Job`, as shown in Listing 20-24.
-->
<p>チャンネルを調整し、型<code>Job</code>ではなく、型<code>Message</code>を使用するようにする必要があります。リスト20-24のようにですね。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

// --snip--

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        // ワーカー{}は停止するよう指示された
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-24: Sending and receiving `Message` values and
exiting the loop if a `Worker` receives `Message::Terminate`</span>
-->
<p><span class="caption">リスト20-24: <code>Message</code>値を送受信し、<code>Worker</code>が<code>Message::Terminate</code>を受け取ったら、ループを抜ける</span></p>
<!--
To incorporate the `Message` enum, we need to change `Job` to `Message` in two
places: the definition of `ThreadPool` and the signature of `Worker::new`. The
`execute` method of `ThreadPool` needs to send jobs wrapped in the
`Message::NewJob` variant. Then, in `Worker::new` where a `Message` is received
from the channel, the job will be processed if the `NewJob` variant is
received, and the thread will break out of the loop if the `Terminate` variant
is received.
-->
<p><code>Message</code> enumを具体化するために、2箇所で<code>Job</code>を<code>Message</code>に変更する必要があります:
<code>ThreadPool</code>の定義と<code>Worker::new</code>のシグニチャです。<code>ThreadPool</code>の<code>execute</code>メソッドは、
仕事を<code>Message::NewJob</code>列挙子に包んで送信する必要があります。それから、
<code>Message</code>がチャンネルから受け取られる<code>Worker::new</code>で、<code>NewJob</code>列挙子が受け取られたら、
仕事が処理され、<code>Terminate</code>列挙子が受け取られたら、スレッドはループを抜けます。</p>
<!--
With these changes, the code will compile and continue to function in the same
way as it did after Listing 20-21. But we’ll get a warning because we aren’t
creating any messages of the `Terminate` variety. Let’s fix this warning by
changing our `Drop` implementation to look like Listing 20-25.
-->
<p>これらの変更と共に、コードはコンパイルでき、リスト20-21の後と同じように機能し続けます。ですが、
<code>Terminate</code>のメッセージを何も生成していないので、警告が出るでしょう。
<code>Drop</code>実装をリスト20-25のような見た目に変更してこの警告を修正しましょう。</p>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        // 全ワーカーを閉じます
        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            // ワーカー{}を閉じます
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<!--
<span class="caption">Listing 20-25: Sending `Message::Terminate` to the
workers before calling `join` on each worker thread</span>
-->
<p><span class="caption">リスト20-25: 各ワーカースレッドに対して<code>join</code>を呼び出す前にワーカーに<code>Message::Terminate</code>を送信する</span></p>
<!--
We’re now iterating over the workers twice: once to send one `Terminate`
message for each worker and once to call `join` on each worker’s thread. If we
tried to send a message and `join` immediately in the same loop, we couldn’t
guarantee that the worker in the current iteration would be the one to get the
message from the channel.
-->
<p>今では、ワーカーを2回走査しています: 各ワーカーに<code>Terminate</code>メッセージを送信するために1回と、
各ワーカースレッドに<code>join</code>を呼び出すために1回です。メッセージ送信と<code>join</code>を同じループで即座に行おうとすると、
現在の繰り返しのワーカーがチャンネルからメッセージを受け取っているものであるか保証できなくなってしまいます。</p>
<!--
To better understand why we need two separate loops, imagine a scenario with
two workers. If we used a single loop to iterate through each worker, on the
first iteration a terminate message would be sent down the channel and `join`
called on the first worker’s thread. If that first worker was busy processing a
request at that moment, the second worker would pick up the terminate message
from the channel and shut down. We would be left waiting on the first worker to
shut down, but it never would because the second thread picked up the terminate
message. Deadlock!
-->
<p>2つの個別のループが必要な理由をよりよく理解するために、2つのワーカーがある筋書きを想像してください。
単独のループで各ワーカーを走査すると、最初の繰り返しでチャンネルに停止メッセージが送信され、
<code>join</code>が最初のワーカースレッドで呼び出されます。その最初のワーカーが現在、リクエストの処理で忙しければ、
2番目のワーカーがチャンネルから停止メッセージを受け取り、閉じます。最初のワーカーの終了待ちをしたままですが、
2番目のスレッドが停止メッセージを拾ってしまったので、終了することは絶対にありません。デッドロックです！</p>
<!--
To prevent this scenario, we first put all of our `Terminate` messages on the
channel in one loop; then we join on all the threads in another loop. Each
worker will stop receiving requests on the channel once it gets a terminate
message. So, we can be sure that if we send the same number of terminate
messages as there are workers, each worker will receive a terminate message
before `join` is called on its thread.
-->
<p>この筋書きを回避するために、1つのループでまず、チャンネルに対して全ての<code>Terminate</code>メッセージを送信します;
そして、別のループで全スレッドのjoinを待ちます。一旦停止メッセージを受け取ったら、各ワーカーはチャンネルからのリクエストの受付をやめます。
故に、存在するワーカーと同じ数だけ停止メッセージを送れば、<code>join</code>がスレッドに対して呼び出される前に、
停止メッセージを各ワーカーが受け取ると確信できるわけです。</p>
<!--
To see this code in action, let’s modify `main` to accept only two requests
before gracefully shutting down the server, as shown in Listing 20-26.
-->
<p>このコードが動いているところを確認するために、<code>main</code>を変更してサーバを正常に閉じる前に2つしかリクエストを受け付けないようにしましょう。
リスト20-26のようにですね。</p>
<!--
<span class="filename">Filename: src/bin/main.rs</span>
-->
<p><span class="filename">ファイル名: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
</code></pre>
<!--
<span class="caption">Listing 20-26: Shut down the server after serving two
requests by exiting the loop</span>
-->
<p><span class="caption">リスト20-26: ループを抜けることで、2つのリクエストを処理した後にサーバを閉じる</span></p>
<!--
You wouldn’t want a real-world web server to shut down after serving only two
requests. This code just demonstrates that the graceful shutdown and cleanup is
in working order.
-->
<p>現実世界のWebサーバには、たった2つリクエストを受け付けた後にシャットダウンしてほしくはないでしょう。
このコードは、単に正常なシャットダウンとクリーンアップが正しく機能することを示すだけです。</p>
<!--
The `take` method is defined in the `Iterator` trait and limits the iteration
to the first two items at most. The `ThreadPool` will go out of scope at the
end of `main`, and the `drop` implementation will run.
-->
<p><code>take</code>メソッドは、<code>Iterator</code>トレイトで定義されていて、最大でも繰り返しを最初の2つの要素だけに制限します。
<code>ThreadPool</code>は<code>main</code>の末端でスコープを抜け、<code>drop</code>実装が実行されます。</p>
<!--
Start the server with `cargo run`, and make three requests. The third request
should error, and in your terminal you should see output similar to this:
-->
<p><code>cargo run</code>でサーバを開始し、3つリクエストを行なってください。3番目のリクエストはエラーになるはずで、
端末にはこのような出力が目撃できるはずです:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 3 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 1 was told to terminate.
Worker 2 was told to terminate.
Worker 0 was told to terminate.
Worker 3 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<!--
You might see a different ordering of workers and messages printed. We can see
how this code works from the messages: workers 0 and 3 got the first two
requests, and then on the third request, the server stopped accepting
connections. When the `ThreadPool` goes out of scope at the end of `main`, its
`Drop` implementation kicks in, and the pool tells all workers to terminate.
The workers each print a message when they see the terminate message, and then
the thread pool calls `join` to shut down each worker thread.
-->
<p>ワーカーとメッセージの順番は異なる可能性があります。どうやってこのコードが動くのかメッセージからわかります:
ワーカー0と3が最初の2つのリクエストを受け付け、そして3番目のリクエストではサーバは接続の受け入れをやめます。
<code>main</code>の最後で<code>ThreadPool</code>がスコープを抜ける際、<code>Drop</code>実装が割り込み、プールが全ワーカーに停止するよう指示します。
ワーカーはそれぞれ、停止メッセージを確認した時にメッセージを出力し、それからスレッドプールは各ワーカースレッドを閉じる<code>join</code>を呼び出します。</p>
<!--
Notice one interesting aspect of this particular execution: the `ThreadPool`
sent the terminate messages down the channel, and before any worker received
the messages, we tried to join worker 0. Worker 0 had not yet received the
terminate message, so the main thread blocked waiting for worker 0 to finish.
In the meantime, each of the workers received the termination messages. When
worker 0 finished, the main thread waited for the rest of the workers to
finish. At that point, they had all received the termination message and were
able to shut down.
-->
<p>この特定の実行のある面白い側面に注目してください: <code>ThreadPool</code>はチャンネルに停止メッセージを送信しますが、
どのワーカーがそのメッセージを受け取るよりも前に、ワーカー0のjoinを試みています。ワーカー0はまだ停止メッセージを受け取っていなかったので、
メインスレッドはワーカー0が完了するまで待機してブロックされます。その間に、各ワーカーは停止メッセージを受け取ります。
ワーカー0が完了したら、メインスレッドは残りのワーカーが完了するのを待機します。その時点で全ワーカーは停止メッセージを受け取った後で、
閉じることができたのです。</p>
<!--
Congrats! We’ve now completed our project; we have a basic web server that uses
a thread pool to respond asynchronously. We’re able to perform a graceful
shutdown of the server, which cleans up all the threads in the pool.
-->
<p>おめでとうございます！プロジェクトを完成させました; スレッドプールを使用して非同期に応答する基本的なWebサーバができました。
サーバの正常なシャットダウンを行うことができ、プールの全スレッドを片付けます。</p>
<!--
Here’s the full code for reference:
-->
<p>参考までに、こちらが全コードです:</p>
<!--
<span class="filename">Filename: src/bin/main.rs</span>
-->
<p><span class="filename">ファイル名: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">extern crate hello;
use hello::ThreadPool;

use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::fs::File;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    // 閉じます
    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 1024];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

     let mut file = File::open(filename).unwrap();
     let mut contents = String::new();

     file.read_to_string(&amp;mut contents).unwrap();

     let response = format!(&quot;{}{}&quot;, status_line, contents);

     stream.write(response.as_bytes()).unwrap();
     stream.flush().unwrap();
}
</code></pre>
<!--
<span class="filename">Filename: src/lib.rs</span>
-->
<p><span class="filename">ファイル名: src/lib.rs</span></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

enum Message {
    NewJob(Job),
    Terminate,
}

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;FnBox + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
We could do more here! If you want to continue enhancing this project, here are
some ideas:
-->
<p>ここでできることはまだあるでしょう！よりこのプロジェクトを改善したいのなら、こちらがアイディアの一部です:</p>
<!--
* Add more documentation to `ThreadPool` and its public methods.
* Add tests of the library’s functionality.
* Change calls to `unwrap` to more robust error handling.
* Use `ThreadPool` to perform some task other than serving web requests.
* Find a thread pool crate on *https://crates.io/* and implement a similar web
server using the crate instead. Then compare its API and robustness to the
thread pool we implemented.
-->
<ul>
<li><code>ThreadPool</code>とその公開メソッドにもっとドキュメンテーションを追加する。</li>
<li>ライブラリの機能のテストを追加する。</li>
<li><code>unwrap</code>の呼び出しをもっと頑健なエラー処理に変更する。</li>
<li><code>ThreadPool</code>を使用してWebリクエスト以外のなんらかの作業を行う。</li>
<li><em>https://crates.io</em> でスレッドプールのクレートを探して、そのクレートを代わりに使用して似たWebサーバを実装する。
そして、APIと頑健性を我々が実装したものと比較する。</li>
</ul>
<!--
## Summary
-->
<h2 id="まとめ-19"><a class="header" href="#まとめ-19">まとめ</a></h2>
<!--
Well done! You’ve made it to the end of the book! We want to thank you for
joining us on this tour of Rust. You’re now ready to implement your own Rust
projects and help with other peoples’ projects. Keep in mind that there is a
welcoming community of other Rustaceans who would love to help you with any
challenges you encounter on your Rust journey.
-->
<p>よくやりました！本の最後に到達しました！Rustのツアーに参加していただき、感謝の辞を述べたいです。
もう、ご自身のRustプロジェクトや他の方のプロジェクトのお手伝いをする準備ができています。
あなたがこれからのRustの旅で遭遇する、あらゆる困難の手助けを是非とも行いたいRustaceanたちの温かいコミュニティがあることを心に留めておいてくださいね。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
# Appendix
-->
<h1 id="付録"><a class="header" href="#付録">付録</a></h1>
<!--
The following sections contain reference material you may find useful in your
Rust journey.
-->
<p>以下の節は、Rustの旅で役に立つと思えるかもしれない参考資料を含んでいます。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Appendix A: Keywords
-->
<h2 id="付録a-キーワード"><a class="header" href="#付録a-キーワード">付録A: キーワード</a></h2>
<!--
The following list contains keywords that are reserved for current or future
use by the Rust language. As such, they cannot be used as identifiers (except
as raw identifiers as we’ll discuss in the “[Raw
Identifiers][raw-identifiers]” section), including names of
functions, variables, parameters, struct fields, modules, crates, constants,
macros, static values, attributes, types, traits, or lifetimes.
-->
<p>以下のリストは、現在、あるいは将来Rust言語により使用されるために予約されているキーワードです。
そのため、識別子として使用することはできません。識別子には、関数名、変数名、引数名、構造体のフィールド名、モジュール名、クレート名、定数名、マクロ名、静的な値の名前、属性名、型名、トレイト名、ライフタイム名などがあります。
ただし、<a href="appendix-01-keywords.html#raw-identifiers">生識別子</a>のところで議論する生識別子は例外です。</p>
<!--
### Keywords Currently in Use
-->
<h3 id="現在使用されているキーワード"><a class="header" href="#現在使用されているキーワード">現在使用されているキーワード</a></h3>
<!--
The following keywords currently have the functionality described.
-->
<p>以下のキーワードは、解説された通りの機能が現状あります。</p>
<!--
* `as` - perform primitive casting, disambiguate the specific trait containing
  an item, or rename items in `use` and `extern crate` statements
* `async` -  return a `Future` instead of blocking the current thread
* `await` - suspend execution until the result of a `Future` is ready
* `break` - exit a loop immediately
* `const` - define constant items or constant raw pointers
* `continue` - continue to the next loop iteration
* `crate` - link an external crate or a macro variable representing the crate in
  which the macro is defined
* `dyn` - dynamic dispatch to a trait object
* `else` - fallback for `if` and `if let` control flow constructs
* `enum` - define an enumeration
* `extern` - link an external crate, function, or variable
* `false` - Boolean false literal
* `fn` - define a function or the function pointer type
* `for` - loop over items from an iterator, implement a trait, or specify a
  higher-ranked lifetime
* `if` - branch based on the result of a conditional expression
* `impl` - implement inherent or trait functionality
* `in` - part of `for` loop syntax
* `let` - bind a variable
* `loop` - loop unconditionally
* `match` - match a value to patterns
* `mod` - define a module
* `move` - make a closure take ownership of all its captures
* `mut` - denote mutability in references, raw pointers, or pattern bindings
* `pub` - denote public visibility in struct fields, `impl` blocks, or modules
* `ref` - bind by reference
* `return` - return from function
* `Self` - a type alias for the type we are defining or implementing
* `self` - method subject or current module
* `static` - global variable or lifetime lasting the entire program execution
* `struct` - define a structure
* `super` - parent module of the current module
* `trait` - define a trait
* `true` - Boolean true literal
* `type` - define a type alias or associated type
* `union` - define a [union] and is only a keyword when used in a union declaration
* `unsafe` - denote unsafe code, functions, traits, or implementations
* `use` - bring symbols into scope
* `where` - denote clauses that constrain a type
* `while` - loop conditionally based on the result of an expression

[union]: ../reference/items/unions.html
-->
<!--
higher-ranked lifetimeについては議論の余地ありか
-->
<ul>
<li><code>as</code> - 基礎的なキャストの実行、要素を含む特定のトレイトの明確化、<code>use</code>や<code>extern crate</code>文の要素名を変更する</li>
<li><code>async</code> - 現在のスレッドをブロックする代わりに<code>Future</code>を返す</li>
<li><code>await</code> - <code>Future</code>の結果が準備できるまで実行を停止する</li>
<li><code>break</code> - 即座にループを抜ける</li>
<li><code>const</code> - 定数要素か定数の生ポインタを定義する</li>
<li><code>continue</code> - 次のループの繰り返しに継続する</li>
<li><code>crate</code> - 外部のクレートかマクロが定義されているクレートを表すマクロ変数をリンクする</li>
<li><code>else</code> - <code>if</code>と<code>if let</code>制御フロー構文の規定</li>
<li><code>enum</code> - 列挙型を定義する</li>
<li><code>extern</code> - 外部のクレート、関数、変数をリンクする</li>
<li><code>false</code> - bool型のfalseリテラル</li>
<li><code>fn</code> - 関数か関数ポインタ型を定義する</li>
<li><code>for</code> - イテレータの要素を繰り返す、トレイトの実装、高階ライフタイムの指定</li>
<li><code>if</code> - 条件式の結果によって条件分岐</li>
<li><code>impl</code> - 固有の機能やトレイトの機能を実装する</li>
<li><code>in</code> - <code>for</code>ループ記法の一部</li>
<li><code>let</code> - 変数を束縛する</li>
<li><code>loop</code> - 無条件にループする</li>
<li><code>match</code> - 値をパターンとマッチさせる</li>
<li><code>mod</code> - モジュールを定義する</li>
<li><code>move</code> - クロージャにキャプチャした変数全ての所有権を奪わせる</li>
<li><code>mut</code> - 参照、生ポインタ、パターン束縛で可変性に言及する</li>
<li><code>pub</code> - 構造体フィールド、<code>impl</code>ブロック、モジュールで公開性について言及する</li>
<li><code>ref</code> - 参照で束縛する</li>
<li><code>return</code> - 関数から帰る</li>
<li><code>Self</code> - 定義しようとしている・実装(implement)しようとしている型の型エイリアス</li>
<li><code>self</code> - メソッドの主題、または現在のモジュール</li>
<li><code>static</code> - グローバル変数、またはプログラム全体に渡るライフタイム</li>
<li><code>struct</code> - 構造体を定義する</li>
<li><code>super</code> - 現在のモジュールの親モジュール</li>
<li><code>trait</code> - トレイトを定義する</li>
<li><code>true</code> - bool型のtrueリテラル</li>
<li><code>type</code> - 型エイリアスか関連型を定義する</li>
<li><code>unsafe</code> - unsafeなコード、関数、トレイト、実装に言及する</li>
<li><code>use</code> - スコープにシンボルを持ち込む</li>
<li><code>where</code> - 型を制限する節に言及する</li>
<li><code>while</code> - 式の結果に基づいて条件的にループする</li>
</ul>
<!--
### Keywords Reserved for Future Use
-->
<h3 id="将来的な使用のために予約されているキーワード"><a class="header" href="#将来的な使用のために予約されているキーワード">将来的な使用のために予約されているキーワード</a></h3>
<!--
The following keywords do not have any functionality but are reserved by Rust
for potential future use.
-->
<p>以下のキーワードには機能が何もないものの、将来的に使用される可能性があるので、Rustにより予約されています。</p>
<!--
* `abstract`
* `become`
* `box`
* `do`
* `final`
* `macro`
* `override`
* `priv`
* `try`
* `typeof`
* `unsized`
* `virtual`
* `yield`
-->
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<!--
### Raw Identifiers
-->
<h3 id="生識別子"><a class="header" href="#生識別子">生識別子</a></h3>
<!--
*Raw identifiers* are the syntax that lets you use keywords where they wouldn’t
normally be allowed. You use a raw identifier by prefixing a keyword with `r#`.
-->
<p><em>生識別子</em> とは、普段は使うことが許されないキーワードを使わせてくれる構文です。
生識別子はキーワードの前に<code>r#</code>を置いて使うことができます。</p>
<!--
For example, `match` is a keyword. If you try to compile the following function
that uses `match` as its name:
-->
<p>たとえば、<code>match</code>はキーワードです。
次の、名前が<code>match</code>である関数をコンパイルしようとすると：</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
// 訳注: 引数名は、&quot;a needle in a haystack&quot; すなわち「干し草の中の針」という、
// 「見つかりそうにない捜し物」を意味する成句からもじった命名。
// 検索をする関数でよく使われる。
</code></pre>
<!--
you’ll get this error:
-->
<p>次のエラーを得ます：</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<!--
The error shows that you can’t use the keyword `match` as the function
identifier. To use `match` as a function name, you need to use the raw
identifier syntax, like this:
-->
<p>このエラーは<code>match</code>というキーワードを関数の識別子としては使えないと示しています。
<code>match</code>を関数名として使うには、次のように、生識別子構文を使う必要があります。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<!--
This code will compile without any errors. Note the `r#` prefix on the function
name in its definition as well as where the function is called in `main`.
-->
<p>このコードはなんのエラーもなくコンパイルできます。
<code>r#</code>は、定義のときも、<code>main</code>内で呼ばれたときにも、関数名の前につけられていることに注意してください。</p>
<!--
Raw identifiers allow you to use any word you choose as an identifier, even if
that word happens to be a reserved keyword. In addition, raw identifiers allow
you to use libraries written in a different Rust edition than your crate uses.
For example, `try` isn’t a keyword in the 2015 edition but is in the 2018
edition. If you depend on a library that’s written using the 2015 edition and
has a `try` function, you’ll need to use the raw identifier syntax, `r#try` in
this case, to call that function from your 2018 edition code. See [Appendix
E][appendix-e] for more information on editions.
-->
<p>生識別子を使えば、仮にそれが予約されたキーワードであろうとも、任意の単語を識別子として使えるようになります。
更に、あなたのクレートが使っているRustのeditionとは異なるeditionで書かれたライブラリを呼び出すこともできるようになります。
たとえば、<code>try</code>は2015 editionではキーワードではありませんでしたが、2018 editionではキーワードです。
もし、2015 editionで書かれており、<code>try</code>関数を持っているライブラリに依存している場合、あなたの2018 editionのコードからその関数を呼び出すためには、生識別子構文を使う必要がでてくるでしょう。今回なら<code>r#try</code>ですね。
editionに関して、より詳しくは<a href="appendix-05-editions.html">付録 E</a>を見てください。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Appendix B: Operators and Symbols
-->
<h2 id="付録b-演算子と記号"><a class="header" href="#付録b-演算子と記号">付録B: 演算子と記号</a></h2>
<!--
This appendix contains a glossary of Rust’s syntax, including operators and
other symbols that appear by themselves or in the context of paths, generics,
trait bounds, macros, attributes, comments, tuples, and brackets.
-->
<p>この付録は、演算子や、単独で現れたり、パス、ジェネリクス、トレイト境界、マクロ、属性、コメント、タプル、
かっこの文脈で現れる他の記号を含むRustの記法の用語集を含んでいます。</p>
<!--
### Operators
-->
<h3 id="演算子"><a class="header" href="#演算子">演算子</a></h3>
<!--
Table B-1 contains the operators in Rust, an example of how the operator would
appear in context, a short explanation, and whether that operator is
overloadable. If an operator is overloadable, the relevant trait to use to
overload that operator is listed.
-->
<p>表B-1は、Rustの演算子、演算子が文脈で現れる例、短い説明、その演算子がオーバーロード可能かどうかを含んでいます。
演算子がオーバーロード可能ならば、オーバーロードするのに使用する関係のあるトレイトも列挙されています。</p>
<!--
<span class="caption">Table B-1: Operators</span>
-->
<p><span class="caption">表B-1: 演算子</span></p>
<!--
| Operator | Example | Explanation | Overloadable? |
|----------|---------|-------------|---------------|
| `!` | `ident!(...)`, `ident!{...}`, `ident![...]` | Macro expansion | |
| `!` | `!expr` | Bitwise or logical complement | `Not` |
| `!=` | `var != expr` | Nonequality comparison | `PartialEq` |
| `%` | `expr % expr` | Arithmetic remainder | `Rem` |
| `%=` | `var %= expr` | Arithmetic remainder and assignment | `RemAssign` |
| `&` | `&expr`, `&mut expr` | Borrow | |
| `&` | `&type`, `&mut type`, `&'a type`, `&'a mut type` | Borrowed pointer type | |
| `&` | `expr & expr` | Bitwise AND | `BitAnd` |
| `&=` | `var &= expr` | Bitwise AND and assignment | `BitAndAssign` |
| `&&` | `expr && expr` | Logical AND | |
| `*` | `expr * expr` | Arithmetic multiplication | `Mul` |
| `*=` | `var *= expr` | Arithmetic multiplication and assignment | `MulAssign` |
| `*` | `*expr` | Dereference | |
| `*` | `*const type`, `*mut type` | Raw pointer | |
| `+` | `trait + trait`, `'a + trait` | Compound type constraint | |
| `+` | `expr + expr` | Arithmetic addition | `Add` |
| `+=` | `var += expr` | Arithmetic addition and assignment | `AddAssign` |
| `,` | `expr, expr` | Argument and element separator | |
| `-` | `- expr` | Arithmetic negation | `Neg` |
| `-` | `expr - expr` | Arithmetic subtraction | `Sub` |
| `-=` | `var -= expr` | Arithmetic subtraction and assignment | `SubAssign` |
| `->` | `fn(...) -> type`, <code>\|...\| -> type</code> | Function and closure return type | |
| `.` | `expr.ident` | Member access | |
| `..` | `..`, `expr..`, `..expr`, `expr..expr` | Right-exclusive range literal | |
| `..` | `..expr` | Struct literal update syntax | |
| `..` | `variant(x, ..)`, `struct_type { x, .. }` | “And the rest” pattern binding | |
| `...` | `expr...expr` | In a pattern: inclusive range pattern | |
| `/` | `expr / expr` | Arithmetic division | `Div` |
| `/=` | `var /= expr` | Arithmetic division and assignment | `DivAssign` |
| `:` | `pat: type`, `ident: type` | Constraints | |
| `:` | `ident: expr` | Struct field initializer | |
| `:` | `'a: loop {...}` | Loop label | |
| `;` | `expr;` | Statement and item terminator | |
| `;` | `[...; len]` | Part of fixed-size array syntax | |
| `<<` | `expr << expr` | Left-shift | `Shl` |
| `<<=` | `var <<= expr` | Left-shift and assignment | `ShlAssign` |
| `<` | `expr < expr` | Less than comparison | `PartialOrd` |
| `<=` | `expr <= expr` | Less than or equal to comparison | `PartialOrd` |
| `=` | `var = expr`, `ident = type` | Assignment/equivalence | |
| `==` | `expr == expr` | Equality comparison | `PartialEq` |
| `=>` | `pat => expr` | Part of match arm syntax | |
| `>` | `expr > expr` | Greater than comparison | `PartialOrd` |
| `>=` | `expr >= expr` | Greater than or equal to comparison | `PartialOrd` |
| `>>` | `expr >> expr` | Right-shift | `Shr` |
| `>>=` | `var >>= expr` | Right-shift and assignment | `ShrAssign` |
| `@` | `ident @ pat` | Pattern binding | |
| `^` | `expr ^ expr` | Bitwise exclusive OR | `BitXor` |
| `^=` | `var ^= expr` | Bitwise exclusive OR and assignment | `BitXorAssign` |
| <code>\|</code> | <code>pat \| pat</code> | Pattern alternatives | |
| <code>\|</code> | <code>expr \| expr</code> | Bitwise OR | `BitOr` |
| <code>\|=</code> | <code>var \|= expr</code> | Bitwise OR and assignment | `BitOrAssign` |
| <code>\|\|</code> | <code>expr \|\| expr</code> | Logical OR | |
| `?` | `expr?` | Error propagation | |
-->
<table><thead><tr><th>演算子</th><th>例</th><th>説明</th><th>オーバーロードできる？</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>マクロ展開</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>ビット反転、または論理反転</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>var != expr</code></td><td>非等価比較</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>余り演算</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>余り演算後に代入</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>借用</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>借用されたポインタ型</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>ビットAND</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>ビットAND後に代入</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>論理AND</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>掛け算</td><td><code>Mul</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>参照外し</td><td></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>生ポインタ</td><td></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>掛け算後に代入</td><td><code>MulAssign</code></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>型制限の複合化</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>足し算</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>足し算後に代入</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>引数と要素の区別</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>算術否定</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>引き算</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>引き算後に代入</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>関数とクロージャの戻り値型</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>メンバーアクセス</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>未満範囲リテラル</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>構造体リテラル更新記法</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>「残り全部」パターン束縛</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>パターンで: 以下範囲パターン</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>割り算</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>割り算後に代入</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>型制約</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>構造体フィールド初期化子</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>ループラベル</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>文、要素終端子</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>固定長配列記法の一部</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>左シフト</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>左シフト後に代入</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>未満比較</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>以下比較</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>代入/等価</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>等価比較</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>matchアーム記法の一部</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>より大きい比較</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>以上比較</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>右シフト</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>右シフト後に代入</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>パターン束縛</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>ビットXOR</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>ビットXOR後に代入</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>パターンOR</td><td></td></tr>
<tr><td><code>|</code></td><td><code>|…| expr</code></td><td>クロージャ</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>ビットOR</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>ビットOR後に代入</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>論理OR</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>エラー委譲</td><td></td></tr>
</tbody></table>
<!--
### Non-operator Symbols
-->
<h3 id="演算子以外のシンボル"><a class="header" href="#演算子以外のシンボル">演算子以外のシンボル</a></h3>
<!--
The following list contains all non-letters that don’t function as operators;
that is, they don’t behave like a function or method call.
-->
<p>以下のリストは、演算子として機能しない記号全部を含んでいます; つまり、関数やメソッド呼び出しのようには、
振る舞わないということです。</p>
<!--
Table B-2 shows symbols that appear on their own and are valid in a variety of
locations.
-->
<p>表B-2は、単独で出現し、いろんな箇所で合法になる記号を示しています。</p>
<!--
<span class="caption">Table B-2: Stand-Alone Syntax</span>
-->
<p><span class="caption">表B-2: スタンドアローン記法</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `'ident` | Named lifetime or loop label |
| `...u8`, `...i32`, `...f64`, `...usize`, etc. | Numeric literal of specific type |
| `"..."` | String literal |
| `r"..."`, `r#"..."#`, `r##"..."##`, etc. | Raw string literal, escape characters not processed |
| `b"..."` | Byte string literal; constructs a `[u8]` instead of a string |
| `br"..."`, `br#"..."#`, `br##"..."##`, etc. | Raw byte string literal, combination of raw and byte string literal |
| `'...'` | Character literal |
| `b'...'` | ASCII byte literal |
| <code>\|...\| expr</code> | Closure |
| `!` | Always empty bottom type for diverging functions |
| `_` | “Ignored” pattern binding; also used to make integer literals readable |
-->
<table><thead><tr><th>シンボル</th><th>説明</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>名前付きのライフタイム、あるいはループラベル</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>など</td><td>特定の型の数値リテラル</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>文字列リテラル</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>など</td><td>生文字列リテラル、エスケープ文字は処理されません</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td>バイト文字列リテラル、文字列の代わりに<code>[u8]</code>を構築します</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>など</td><td>生バイト文字列リテラル、生文字列とバイト文字列の組み合わせ</td></tr>
<tr><td><code>'...'</code></td><td>文字リテラル</td></tr>
<tr><td><code>b'...'</code></td><td>ASCIIバイトリテラル</td></tr>
<tr><td><code>|...| expr</code></td><td>クロージャ</td></tr>
<tr><td><code>!</code></td><td>常に発散関数の空のボトム型</td></tr>
<tr><td><code>_</code></td><td>「無視」パターン束縛: 整数リテラルを見やすくするのにも使われる</td></tr>
</tbody></table>
<!--
Table B-3 shows symbols that appear in the context of a path through the module
hierarchy to an item.
-->
<p>表B-3は、要素へのモジュール階層を通したパスの文脈で出現する記号を示しています。</p>
<!--
<span class="caption">Table B-3: Path-Related Syntax</span>
-->
<p><span class="caption">表B-3: パス関連記法</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `ident::ident` | Namespace path |
| `::path` | Path relative to the crate root (i.e., an explicitly absolute path) |
| `self::path` | Path relative to the current module (i.e., an explicitly relative path).
| `super::path` | Path relative to the parent of the current module |
| `type::ident`, `<type as trait>::ident` | Associated constants, functions, and types |
| `<type>::...` | Associated item for a type that cannot be directly named (e.g., `<&T>::...`, `<[T]>::...`, etc.) |
| `trait::method(...)` | Disambiguating a method call by naming the trait that defines it |
| `type::method(...)` | Disambiguating a method call by naming the type for which it’s defined |
| `<type as trait>::method(...)` | Disambiguating a method call by naming the trait and type |
-->
<table><thead><tr><th>シンボル</th><th>説明</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>名前空間パス</td></tr>
<tr><td><code>::path</code></td><td>クレートルートに相対的なパス(すなわち、明示的な絶対パス)</td></tr>
<tr><td><code>self::path</code></td><td>現在のモジュールに相対的なパス(すなわち、明示的な相対パス)</td></tr>
<tr><td><code>super::path</code></td><td>現在のモジュールの親モジュールに相対的なパス</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>関連定数、関数、型</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>直接名前付けできない型の関連要素(例, <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>など)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>定義したトレイトを名指ししてメソッド呼び出しを明確化する</td></tr>
<tr><td><code>type::method(...)</code></td><td>定義されている型を名指ししてメソッド呼び出しを明確化する</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>トレイト<em>と</em>型を名指ししてメソッド呼び出しを明確化する</td></tr>
</tbody></table>
<!--
Table B-4 shows symbols that appear in the context of using generic type
parameters.
-->
<p>表B-4は、ジェネリックな型引数の文脈で出現する記号を示しています。</p>
<!--
<span class="caption">Table B-4: Generics</span>
-->
<p><span class="caption">表B-4: ジェネリクス</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `path<...>` | Specifies parameters to generic type in a type (e.g., `Vec<u8>`) |
| `path::<...>`, `method::<...>` | Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., `"42".parse::<i32>()`) |
| `fn ident<...> ...` | Define generic function |
| `struct ident<...> ...` | Define generic structure |
| `enum ident<...> ...` | Define generic enumeration |
| `impl<...> ...` | Define generic implementation |
| `for<...> type` | Higher-ranked lifetime bounds |
| `type<ident=type>` | A generic type where one or more associated types have specific assignments (e.g., `Iterator<Item=T>`) |
-->
<table><thead><tr><th>シンボル</th><th>説明</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>型の内部のジェネリック型への引数を指定する(例、<code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>式中のジェネリックな型、関数、メソッドへの引数を指定する。しばしばターボ・フィッシュ(turbofish)と称される。(例、<code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>ジェネリックな関数を定義する</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>ジェネリックな構造体を定義する</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>ジェネリックな列挙型を定義する</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>ジェネリックな実装を定義する</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>高階ライフタイム境界</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>1つ以上の関連型に代入されたジェネリックな型(例、<code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
<!--
Table B-5 shows symbols that appear in the context of constraining generic type
parameters with trait bounds.
-->
<p>表B-5は、ジェネリック型引数をトレイト境界で制約する文脈で出現する記号を示しています。</p>
<!--
<span class="caption">Table B-5: Trait Bound Constraints</span>
-->
<p><span class="caption">表B-5: トレイト境界制約</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `T: U` | Generic parameter `T` constrained to types that implement `U` |
| `T: 'a` | Generic type `T` must outlive lifetime `'a` (meaning the type cannot transitively contain any references with lifetimes shorter than `'a`) |
| `T : 'static` | Generic type `T` contains no borrowed references other than `'static` ones |
| `'b: 'a` | Generic lifetime `'b` must outlive lifetime `'a` |
| `T: ?Sized` | Allow generic type parameter to be a dynamically sized type |
| `'a + trait`, `trait + trait` | Compound type constraint |
-->
<table><thead><tr><th>シンボル</th><th>説明</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td><code>U</code>を実装する型に制約されるジェネリック引数<code>T</code></td></tr>
<tr><td><code>T: 'a</code></td><td>ライフタイム<code>'a</code>よりも長生きしなければならないジェネリック型<code>T</code>(型がライフタイムより長生きするとは、<code>'a</code>よりも短いライフタイムの参照を何も遷移的に含められないことを意味する)</td></tr>
<tr><td><code>T : 'static</code></td><td>ジェネリック型<code>T</code>が<code>'static</code>なもの以外の借用された参照を何も含まない</td></tr>
<tr><td><code>'b: 'a</code></td><td>ジェネリックなライフタイム<code>'b</code>がライフタイム<code>'a</code>より長生きしなければならない</td></tr>
<tr><td><code>T: ?Sized</code></td><td>ジェネリック型引数が動的サイズ決定型であることを許容する</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>複合型制約</td></tr>
</tbody></table>
<!--
Table B-6 shows symbols that appear in the context of calling or defining
macros and specifying attributes on an item.
-->
<p>表B-6は、マクロの呼び出しや定義、要素に属性を指定する文脈で出現する記号を示しています。</p>
<!--
<span class="caption">Table B-6: Macros and Attributes</span>
-->
<p><span class="caption">表B-6: マクロと属性</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `#[meta]` | Outer attribute |
| `#![meta]` | Inner attribute |
| `$ident` | Macro substitution |
| `$ident:kind` | Macro capture |
| `$(…)…` | Macro repetition |
-->
<table><thead><tr><th>シンボル</th><th>説明</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>外部属性</td></tr>
<tr><td><code>#![meta]</code></td><td>内部属性</td></tr>
<tr><td><code>$ident</code></td><td>マクロ代用</td></tr>
<tr><td><code>$ident:kind</code></td><td>マクロキャプチャ</td></tr>
<tr><td><code>$(…)…</code></td><td>マクロの繰り返し</td></tr>
</tbody></table>
<!--
Table B-7 shows symbols that create comments.
-->
<p>表B-7は、コメントを生成する記号を示しています。</p>
<!--
<span class="caption">Table B-7: Comments</span>
-->
<p><span class="caption">表B-7: コメント</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `//` | Line comment |
| `//!` | Inner line doc comment |
| `///` | Outer line doc comment |
| `/*...*/` | Block comment |
| `/*!...*/` | Inner block doc comment |
| `/**...*/` | Outer block doc comment |
-->
<table><thead><tr><th>シンボル</th><th>説明</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>行コメント</td></tr>
<tr><td><code>//!</code></td><td>内部行docコメント</td></tr>
<tr><td><code>///</code></td><td>外部行docコメント</td></tr>
<tr><td><code>/*...*/</code></td><td>ブロックコメント</td></tr>
<tr><td><code>/*!...*/</code></td><td>内部ブロックdocコメント</td></tr>
<tr><td><code>/**...*/</code></td><td>外部ブロックdocコメント</td></tr>
</tbody></table>
<!--
#### Tuples
-->
<h4 id="タプル"><a class="header" href="#タプル">タプル</a></h4>
<!--
Table B-8 shows symbols that appear in the context of using tuples.
-->
<p>表B-8は、タプルの文脈で出現する記号を示しています。</p>
<!--
<span class="caption">Table B-8: Tuples</span>
-->
<p><span class="caption">表B-8: タプル</span></p>
<!--
| Symbol | Explanation |
|--------|-------------|
| `()` | Empty tuple (aka unit), both literal and type |
| `(expr)` | Parenthesized expression |
| `(expr,)` | Single-element tuple expression |
| `(type,)` | Single-element tuple type |
| `(expr, ...)` | Tuple expression |
| `(type, ...)` | Tuple type |
| `expr(expr, ...)` | Function call expression; also used to initialize tuple `struct`s and tuple `enum` variants |
| `ident!(...)`, `ident!{...}`, `ident![...]` | Macro invocation |
| `expr.0`, `expr.1`, etc. | Tuple indexing |
-->
<table><thead><tr><th>シンボル</th><th>説明</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>空のタプル (ユニットとしても知られる)、リテラル、型両方</td></tr>
<tr><td><code>(expr)</code></td><td>括弧付きの式</td></tr>
<tr><td><code>(expr,)</code></td><td>1要素タプル式</td></tr>
<tr><td><code>(type,)</code></td><td>1要素タプル型</td></tr>
<tr><td><code>(expr, ...)</code></td><td>タプル式</td></tr>
<tr><td><code>(type, ...)</code></td><td>タプル型</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>関数呼び出し式; タプル<code>struct</code>やタプル<code>enum</code>列挙子を初期化するのにも使用される</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>マクロ呼び出し</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, など</td><td>タプル添え字アクセス</td></tr>
</tbody></table>
<!--
Table B-9 shows the contexts in which curly braces are used.
-->
<p>表B-9は、波括弧が使用される文脈を表示しています。</p>
<!--
<span class="caption">Table B-9: Curly Brackets</span>
-->
<p><span class="caption">表B-9: 波括弧</span></p>
<!--
| Context | Explanation |
|---------|-------------|
| `{...}` | Block expression |
| `Type {...}` | `struct` literal |
-->
<table><thead><tr><th>文脈</th><th>説明</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>ブロック式</td></tr>
<tr><td><code>Type {...}</code></td><td><code>struct</code>リテラル</td></tr>
</tbody></table>
<!--
Table B-10 shows the contexts in which square brackets are used.
-->
<p>表B-10は、角括弧が使用される文脈を表示しています。</p>
<!--
<span class="caption">Table B-10: Square Brackets</span>
-->
<p><span class="caption">表B-10: 角括弧</span></p>
<!--
| Context | Explanation |
|---------|-------------|
| `[...]` | Array literal |
| `[expr; len]` | Array literal containing `len` copies of `expr` |
| `[type; len]` | Array type containing `len` instances of `type` |
| `expr[expr]` | Collection indexing. Overloadable (`Index`, `IndexMut`) |
| `expr[..]`, `expr[a..]`, `expr[..b]`, `expr[a..b]` | Collection indexing pretending to be collection slicing, using `Range`, `RangeFrom`, `RangeTo`, or `RangeFull` as the “index” |
-->
<table><thead><tr><th>文脈</th><th>説明</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>配列リテラル</td></tr>
<tr><td><code>[expr; len]</code></td><td><code>len</code>個<code>expr</code>を含む配列リテラル</td></tr>
<tr><td><code>[type; len]</code></td><td><code>len</code>個の<code>type</code>のインスタンスを含む配列型</td></tr>
<tr><td><code>expr[expr]</code></td><td>コレクション添え字アクセス。オーバーロード可能 (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td><code>Range</code>、<code>RangeFrom</code>、<code>RangeTo</code>、<code>RangeFull</code>を「添え字」として使用してコレクション・スライシングの振りをするコレクション添え字アクセス</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><!--
## Appendix C: Derivable Traits
-->
<h2 id="付録c-導出可能なトレイト"><a class="header" href="#付録c-導出可能なトレイト">付録C: 導出可能なトレイト</a></h2>
<!--
In various places in the book, we’ve discussed the `derive` attribute, which
you can apply to a struct or enum definition. The `derive` attribute generates
code that will implement a trait with its own default implementation on the
type you’ve annotated with the `derive` syntax.
-->
<p>本のいろんな箇所で<code>derive</code>属性について議論しました。これは構造体や、enum定義に適用できます。
<code>derive</code>属性は、<code>derive</code>記法で注釈した型に対して独自の既定の実装でトレイトを実装するコードを生成します。</p>
<!--
In this appendix, we provide a reference of all the traits in the standard
library that you can use with `derive`. Each section covers:
-->
<p>この付録では、標準ライブラリの<code>derive</code>と共に使用できる全トレイトの参照を提供します。各節は以下を講義します:</p>
<!--
* What operators and methods deriving this trait will enable
* What the implementation of the trait provided by `derive` does
* What implementing the trait signifies about the type
* The conditions in which you’re allowed or not allowed to implement the trait
* Examples of operations that require the trait
-->
<ul>
<li>このトレイトを導出する演算子やメソッドで可能になること</li>
<li><code>derive</code>が提供するトレイトの実装がすること</li>
<li>トレイトを実装することが型についてどれほど重要か</li>
<li>そのトレイトを実装できたりできなかったりする条件</li>
<li>そのトレイトが必要になる処理の例</li>
</ul>
<!--
If you want different behavior than that provided by the `derive` attribute,
consult the standard library documentation for each trait for details on how to
manually implement them.
-->
<p><code>derive</code>属性が提供する以外の異なる振る舞いが欲しいなら、それらを手動で実装する方法の詳細について、
各トレイトの標準ライブラリのドキュメンテーションを調べてください。</p>
<!--
The rest of the traits defined in the standard library can’t be implemented on
your types using `derive`. These traits don’t have sensible default behavior,
so it’s up to you to implement them in the way that makes sense for what you’re
trying to accomplish.
-->
<p>標準ライブラリで定義されている残りのトレイトは、<code>derive</code>で自分の型に実装することはできません。
これらのトレイトには知覚できるほどの既定の振る舞いはないので、自分が達成しようしていることに対して、
道理が通る方法でそれらを実装するのはあなた次第です。</p>
<!--
An example of a trait that can’t be derived is `Display`, which handles
formatting for end users. You should always consider the appropriate way to
display a type to an end user. What parts of the type should an end user be
allowed to see? What parts would they find relevant? What format of the data
would be most relevant to them? The Rust compiler doesn’t have this insight, so
it can’t provide appropriate default behavior for you.
-->
<p>導出できないトレイトの例は<code>Display</code>で、これはエンドユーザ向けのフォーマットを扱います。常に、エンドユーザ向けに型を表示する適切な方法について、
考慮すべきです。型のどの部分をエンドユーザは見ることができるべきでしょうか？どの部分を関係があると考えるでしょうか？
どんな形式のデータがエンドユーザにとって最も関係があるでしょうか？Rustコンパイラには、
この見識がないため、適切な既定動作を提供してくれないのです。</p>
<!--
The list of derivable traits provided in this appendix is not comprehensive:
libraries can implement `derive` for their own traits, making the list of
traits you can use `derive` with truly open-ended. Implementing `derive`
involves using a procedural macro, which is covered in Appendix D.
-->
<p>この付録で提供される導出可能なトレイトのリストは、包括的ではありません: ライブラリは、自身のトレイトに<code>derive</code>を実装でき、
<code>derive</code>と共に使用できるトレイトのリストが実に限りのないものになってしまうのです。<code>derive</code>の実装には、
プロシージャルなマクロが関連します。マクロについては、付録Dで講義します。</p>
<!--
### `Debug` for Programmer Output
-->
<h3 id="プログラマ用の出力のdebug"><a class="header" href="#プログラマ用の出力のdebug">プログラマ用の出力の<code>Debug</code></a></h3>
<!--
The `Debug` trait enables debug formatting in format strings, which you
indicate by adding `:?` within `{}` placeholders.
-->
<p><code>Debug</code>トレイトにより、フォーマット文字列でのデバッグ整形が可能になり、
<code>{}</code>プレースホルダー内に<code>:?</code>を追記することで表します。</p>
<!--
The `Debug` trait allows you to print instances of a type for debugging
purposes, so you and other programmers using your type can inspect an instance
at a particular point in a program’s execution.
-->
<p><code>Debug</code>トレイトにより、デバッグ目的で型のインスタンスを出力できるようになるので、あなたや型を使用する他のプログラマが、
プログラムの実行の特定の箇所でインスタンスを調べられます。</p>
<!--
The `Debug` trait is required, for example, in use of the `assert_eq!` macro.
This macro prints the values of instances given as arguments if the equality
assertion fails so programmers can see why the two instances weren’t equal.
-->
<p><code>Debug</code>トレイトは、例えば、<code>assert_eq!</code>マクロを使用する際などに必要になります。
このマクロは、プログラマがどうして2つのインスタンスが等価でなかったのか確認できるように、
等価アサートが失敗したら、引数として与えられたインスタンスの値を出力します。</p>
<!--
### `PartialEq` and `Eq` for Equality Comparisons
-->
<h3 id="等価比較のためのpartialeqとeq"><a class="header" href="#等価比較のためのpartialeqとeq">等価比較のための<code>PartialEq</code>と<code>Eq</code></a></h3>
<!--
The `PartialEq` trait allows you to compare instances of a type to check for
equality and enables use of the `==` and `!=` operators.
-->
<p><code>PartialEq</code>トレイトにより、型のインスタンスを比較して、等価性をチェックでき、<code>==</code>と<code>!=</code>演算子の使用を可能にします。</p>
<!--
Deriving `PartialEq` implements the `eq` method. When `PartialEq` is derived on
structs, two instances are equal only if *all* fields are equal, and the
instances are not equal if any fields are not equal. When derived on enums,
each variant is equal to itself and not equal to the other variants.
-->
<p><code>PartialEq</code>を導出すると、<code>eq</code>メソッドを実装します。構造体に<code>PartialEq</code>を導出すると、
<em>全</em>フィールドが等しい時のみ2つのインスタンスは等価になり、いずれかのフィールドが等価でなければ、
インスタンスは等価ではなくなります。enumに導出すると、各列挙子は、自身には等価ですが、他の列挙子には等価ではありません。</p>
<!--
The `PartialEq` trait is required, for example, with the use of the
`assert_eq!` macro, which needs to be able to compare two instances of a type
for equality.
-->
<p><code>PartialEq</code>トレイトは例えば、<code>assert_eq!</code>マクロを使用する際に必要になります。
これは、等価性のためにとある型の2つのインスタンスを比較できる必要があります。</p>
<!--
The `Eq` trait has no methods. Its purpose is to signal that for every value of
the annotated type, the value is equal to itself. The `Eq` trait can only be
applied to types that also implement `PartialEq`, although not all types that
implement `PartialEq` can implement `Eq`. One example of this is floating point
number types: the implementation of floating point numbers states that two
instances of the not-a-number (`NaN`) value are not equal to each other.
-->
<p><code>Eq</code>トレイトにはメソッドはありません。その目的は、注釈された型の全値に対して、値が自身と等しいことを通知することです。
<code>Eq</code>トレイトは、<code>PartialEq</code>を実装する全ての型が<code>Eq</code>を実装できるわけではないものの、
<code>PartialEq</code>も実装する型に対してのみ適用できます。これの一例は、浮動小数点数型です: 
浮動小数点数の実装により、非数字(<code>NaN</code>)値の2つのインスタンスはお互いに等価ではないことが宣言されます。</p>
<!--
An example of when `Eq` is required is for keys in a `HashMap<K, V>` so the
`HashMap<K, V>` can tell whether two keys are the same.
-->
<p><code>Eq</code>が必要になる一例が、<code>HashMap&lt;K, V&gt;</code>のキーで、<code>HashMap&lt;K, V&gt;</code>が、2つのキーが同じであると判定できます。</p>
<!--
### `PartialOrd` and `Ord` for Ordering Comparisons
-->
<h3 id="順序付き比較のためのpartialordとord"><a class="header" href="#順序付き比較のためのpartialordとord">順序付き比較のための<code>PartialOrd</code>と<code>Ord</code></a></h3>
<!--
The `PartialOrd` trait allows you to compare instances of a type for sorting
purposes. A type that implements `PartialOrd` can be used with the `<`, `>`,
`<=`, and `>=` operators. You can only apply the `PartialOrd` trait to types
that also implement `PartialEq`.
-->
<p><code>PartialOrd</code>トレイトにより、ソートする目的で型のインスタンスを比較できます。<code>PartialOrd</code>を実装する型は、
<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>演算子を使用することができます。<code>PartialEq</code>も実装する型に対してのみ、
<code>PartialOrd</code>トレイトを適用できます。</p>
<!--
Deriving `PartialOrd` implements the `partial_cmp` method, which returns an
`Option<Ordering>` that will be `None` when the values given don’t produce an
ordering. An example of a value that doesn’t produce an ordering, even though
most values of that type can be compared, is the not-a-number (`NaN`) floating
point value. Calling `partial_cmp` with any floating point number and the `NaN`
floating point value will return `None`.
-->
<p><code>PartialOrd</code>を導出すると、<code>partial_cmp</code>メソッドを実装し、これは、与えられた値が順序付けられない時に<code>None</code>になる<code>Option&lt;Ordering&gt;</code>を返します。
その型のほとんどの値は比較できるものの、順序付けできない値の例として、非数字(<code>NaN</code>)浮動小数点値が挙げられます。
<code>partial_cmp</code>をあらゆる浮動小数点数と<code>NaN</code>浮動小数点数で呼び出すと、<code>None</code>が返るでしょう。</p>
<!--
When derived on structs, `PartialOrd` compares two instances by comparing the
value in each field in the order in which the fields appear in the struct
definition. When derived on enums, variants of the enum declared earlier in the
enum definition are considered less than the variants listed later.
-->
<p>構造体に導出すると、フィールドが構造体定義で現れる順番で各フィールドの値を比較することで2つのインスタンスを比較します。
enumに導出すると、enum定義で先に定義された列挙子が、後に列挙された列挙子よりも小さいと考えられます。</p>
<!--
The `PartialOrd` trait is required, for example, for the `gen_range` method
from the `rand` crate that generates a random value in the range specified by a
low value and a high value.
-->
<p><code>PartialOrd</code>トレイトが必要になる例には、低い値と高い値で指定される範囲の乱数を生成する<code>rand</code>クレートの<code>gen_range</code>メソッドが挙げられます。</p>
<!--
The `Ord` trait allows you to know that for any two values of the annotated
type, a valid ordering will exist. The `Ord` trait implements the `cmp` method,
which returns an `Ordering` rather than an `Option<Ordering>` because a valid
ordering will always be possible. You can only apply the `Ord` trait to types
that also implement `PartialOrd` and `Eq` (and `Eq` requires `PartialEq`). When
derived on structs and enums, `cmp` behaves the same way as the derived
implementation for `partial_cmp` does with `PartialOrd`.
-->
<p><code>Ord</code>トレイトにより、注釈した型のあらゆる2つの値に対して、合法な順序付けが行えることがわかります。
<code>Ord</code>トレイトは<code>cmp</code>メソッドを実装し、これは、常に合法な順序付けが可能なので、<code>Option&lt;Ordering&gt;</code>ではなく、
<code>Ordering</code>を返します。<code>PartialOrd</code>と<code>Eq</code>(<code>Eq</code>は<code>PartialEq</code>も必要とします)も実装している型にしか、
<code>Ord</code>トレイトを適用することはできません。構造体とenumで導出したら、<code>PartialOrd</code>で、
<code>partial_cmp</code>の導出した実装と同じように<code>cmp</code>は振る舞います。</p>
<!--
An example of when `Ord` is required is when storing values in a `BTreeSet<T>`,
a data structure that stores data based on the sort order of the values.
-->
<p><code>Ord</code>が必要になる例は、<code>BTreeSet&lt;T&gt;</code>に値を格納する時です。
これは、値のソート順に基づいてデータを格納するデータ構造です。</p>
<!--
### `Clone` and `Copy` for Duplicating Values
-->
<h3 id="値を複製するcloneとcopy"><a class="header" href="#値を複製するcloneとcopy">値を複製する<code>Clone</code>と<code>Copy</code></a></h3>
<!--
The `Clone` trait allows you to explicitly create a deep copy of a value, and
the duplication process might involve running arbitrary code and copying heap
data. See the “Ways Variables and Data Interact: Clone” section in Chapter 4
for more information on `Clone`.
-->
<p><code>Clone</code>トレイトにより値のディープコピーを明示的に行うことができ、複製のプロセスは、任意のコードを実行し、
ヒープデータをコピーすることに関係がある可能性があります。<code>Clone</code>について詳しくは、
第4章の「変数とデータの相互作用法: Clone」節を参照されたし。</p>
<!--
Deriving `Clone` implements the `clone` method, which when implemented for the
whole type, calls `clone` on each of the parts of the type. This means all the
fields or values in the type must also implement `Clone` to derive `Clone`.
-->
<p><code>Clone</code>を導出すると、<code>clone</code>メソッドを実装し、これは型全体に対して実装されると、
型の各部品に対して<code>clone</code>を呼び出します。要するに、<code>Clone</code>を導出するには、
型のフィールドと値全部も<code>Clone</code>を実装していなければならないということです。</p>
<!--
An example of when `Clone` is required is when calling the `to_vec` method on a
slice. The slice doesn’t own the type instances it contains, but the vector
returned from `to_vec` will need to own its instances, so `to_vec` calls
`clone` on each item. Thus, the type stored in the slice must implement `Clone`.
-->
<p><code>Clone</code>が必要になる例は、スライスに対して<code>to_vec</code>メソッドを呼び出すことです。スライスは、
含んでいる型のインスタンスの所有権を持たないが、<code>to_vec</code>で返されるベクタはそのインスタンスを所有する必要があるので、
<code>to_vec</code>は各要素に対して<code>clone</code>を呼び出します。故に、スライスに格納される型は、<code>Clone</code>を実装しなければならないのです。</p>
<!--
The `Copy` trait allows you to duplicate a value by only copying bits stored on
the stack; no arbitrary code is necessary. See the “Stack-Only Data: Copy”
section in Chapter 4 for more information on `Copy`.
-->
<p><code>Copy</code>トレイトにより、スタックに格納されたビットをコピーするだけで値を複製できます; 任意のコードは必要ありません。
<code>Copy</code>について詳しくは、第4章の「スタックのみのデータ: Copy」を参照されたし。</p>
<!--
The `Copy` trait doesn’t define any methods to prevent programmers from
overloading those methods and violating the assumption that no arbitrary code
is being run. That way, all programmers can assume that copying a value will be
very fast.
-->
<p><code>Copy</code>トレイトは、プログラマがメソッドをオーバーロードし、任意のコードが実行されないという前提を侵害することを妨げるメソッドは何も定義しません。
そのため、全プログラマは、値のコピーは非常に高速であることを前提にすることができます。</p>
<!--
You can derive `Copy` on any type whose parts all implement `Copy`. You can
only apply the `Copy` trait to types that also implement `Clone`, because a
type that implements `Copy` has a trivial implementation of `Clone` that
performs the same task as `Copy`.
-->
<p>部品すべてが<code>Copy</code>を実装する任意の型に対して<code>Copy</code>を導出することができます。<code>Clone</code>も実装する型に対してのみ、
<code>Copy</code>トレイトを適用することができます。何故なら、<code>Copy</code>を実装する型には、
<code>Copy</code>と同じ作業を行う<code>Clone</code>の<ruby>瑣末<rp>(</rp><rt>さまつ</rt><rp>)</rp></ruby>な実装があるからです。</p>
<!--
The `Copy` trait is rarely required; types that implement `Copy` have
optimizations available, meaning you don’t have to call `clone`, which makes
the code more concise.
-->
<p><code>Copy</code>トレイトは稀にしか必要になりません; <code>Copy</code>を実装する型では最適化が利用可能になります。
つまり、<code>clone</code>を呼び出す必要がなくなり、コードがより簡潔になるということです。</p>
<!--
Everything possible with `Copy` you can also accomplish with `Clone`, but the
code might be slower or have to use `clone` in places.
-->
<p><code>Copy</code>で可能なこと全てが<code>Clone</code>でも達成可能ですが、コードがより遅い可能性や、
<code>clone</code>を使用しなければならない箇所があったりします。</p>
<!--
### `Hash` for Mapping a Value to a Value of Fixed Size
-->
<h3 id="値を固定サイズの値にマップするhash"><a class="header" href="#値を固定サイズの値にマップするhash">値を固定サイズの値にマップする<code>Hash</code></a></h3>
<!--
The `Hash` trait allows you to take an instance of a type of arbitrary size and
map that instance to a value of fixed size using a hash function. Deriving
`Hash` implements the `hash` method. The derived implementation of the `hash`
method combines the result of calling `hash` on each of the parts of the type,
meaning all fields or values must also implement `Hash` to derive `Hash`.
-->
<p><code>Hash</code>トレイトにより、任意のサイズの型のインスタンスを取り、そのインスタンスをハッシュ関数で固定サイズの値にマップできます。
<code>Hash</code>を導出すると、<code>hash</code>メソッドを実装します。<code>hash</code>の導出された実装は、
型の各部品に対して呼び出した<code>hash</code>の結果を組み合わせます。つまり、<code>Hash</code>を導出するには、
全フィールドと値も<code>Hash</code>を実装しなければならないということです。</p>
<!--
An example of when `Hash` is required is in storing keys in a `HashMap<K, V>`
to store data efficiently.
-->
<p><code>Hash</code>が必要になる例は、<code>HashMap&lt;K, V&gt;</code>にキーを格納し、データを効率的に格納することです。</p>
<!--
### `Default` for Default Values
-->
<h3 id="既定値のためのdefault"><a class="header" href="#既定値のためのdefault">既定値のための<code>Default</code></a></h3>
<!--
The `Default` trait allows you to create a default value for a type. Deriving
`Default` implements the `default` function. The derived implementation of the
`default` function calls the `default` function on each part of the type,
meaning all fields or values in the type must also implement `Default` to
derive `Default.`
-->
<p><code>Default</code>トレイトにより、型に対して既定値を生成できます。<code>Default</code>を導出すると、<code>default</code>関数を実装します。
<code>default</code>関数の導出された実装は、型の各部品に対して<code>default</code>関数を呼び出します。つまり、
<code>Default</code>を導出するには、型の全フィールドと値も<code>Default</code>を実装しなければならないということです。</p>
<!--
The `Default::default` function is commonly used in combination with the struct
update syntax discussed in the “Creating Instances From Other Instances With
Struct Update Syntax” section in Chapter 5. You can customize a few fields of a
struct and then set and use a default value for the rest of the fields by using
`..Default::default()`.
-->
<p><code>Default::default</code>関数は、
第5章の「構造体更新記法で他のインスタンスからインスタンスを生成する」節で議論した構造体更新記法と組み合わせてよく使用されます。
構造体のいくつかのフィールドをカスタマイズし、それから<code>..Default::default()</code>を使用して、
残りのフィールドに対して既定値をセットし使用することができます。</p>
<!--
The `Default` trait is required when you use the method `unwrap_or_default` on
`Option<T>` instances, for example. If the `Option<T>` is `None`, the method
`unwrap_or_default` will return the result of `Default::default` for the type
`T` stored in the `Option<T>`.
-->
<p>例えば、<code>Default</code>トレイトは、<code>Option&lt;T&gt;</code>インスタンスに対してメソッド<code>unwrap_or_default</code>を使用する時に必要になります。
<code>Option&lt;T&gt;</code>が<code>None</code>ならば、メソッド<code>unwrap_or_default</code>は、<code>Option&lt;T&gt;</code>に格納された型<code>T</code>に対して<code>Default::default</code>の結果を返します。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Appendix D - Useful Development Tools
-->
<h2 id="付録d---便利な開発ツール"><a class="header" href="#付録d---便利な開発ツール">付録D - 便利な開発ツール</a></h2>
<!--
In this appendix, we talk about some useful development tools that the Rust
project provides. We’ll look at automatic formatting, quick ways to apply
warning fixes, a linter, and integrating with IDEs.
-->
<p>この付録では、Rustプロジェクトの提供する便利な開発ツールについていくつかお話します。
自動フォーマット、警告に対する修正をすばやく適用する方法、lintツール、そしてIDEとの統合について見ていきます。</p>
<!--
### Automatic Formatting with `rustfmt`
-->
<h3 id="rustfmtを使った自動フォーマット"><a class="header" href="#rustfmtを使った自動フォーマット"><code>rustfmt</code>を使った自動フォーマット</a></h3>
<!--
The `rustfmt` tool reformats your code according to the community code style.
Many collaborative projects use `rustfmt` to prevent arguments about which
style to use when writing Rust: everyone formats their code using the tool.
-->
<p><code>rustfmt</code>というツールは、コミュニティのコードスタイルに合わせてあなたのコードをフォーマットしてくれます。
Rustを書くときにどのスタイルを使うかで揉めないように、多くの共同で行われるプロジェクトが<code>rustfmt</code>を使っています：全員がこのツールでコードをフォーマットするのです。</p>
<!--
To install `rustfmt`, enter the following:
-->
<p><code>rustfmt</code>をインストールするには、以下を入力してください：</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<!--
This command gives you `rustfmt` and `cargo-fmt`, similar to how Rust gives you
both `rustc` and `cargo`. To format any Cargo project, enter the following:
-->
<p>これで<code>rustfmt</code>と<code>cargo-fmt</code>が使えるようになります。これは<code>rustc</code>と<code>cargo</code>の両方のコマンドがあるのと似たようなものです。
どんなCargoのプロジェクトも、次を入力するとフォーマットできます：</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<!--
Running this command reformats all the Rust code in the current crate. This
should only change the code style, not the code semantics. For more information
on `rustfmt`, see [its documentation][rustfmt].
-->
<p>このコマンドを実行すると、現在のクレートのあらゆるRustコードをフォーマットし直します。
これを行うと、コードのスタイルのみが変わり、コードの意味は変わりません。
<code>rustfmt</code>についてより詳しく知るには<a href="https://github.com/rust-lang/rustfmt">ドキュメント</a>を読んでください。</p>
<!--
### Fix Your Code with `rustfix`
-->
<h3 id="rustfixでコードを修正する"><a class="header" href="#rustfixでコードを修正する"><code>rustfix</code>でコードを修正する</a></h3>
<!--
The rustfix tool is included with Rust installations and can automatically fix
some compiler warnings. If you’ve written code in Rust, you’ve probably seen
compiler warnings. For example, consider this code:
-->
<p>rustfixというツールはRustをインストールすると同梱されており、コンパイラの警告 (warning) を自動で直してくれます。
Rustでコードを書いたことがある人なら、コンパイラの警告を見たことがあるでしょう。
たとえば、下のコードを考えます：</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<!--
Here, we’re calling the `do_something` function 100 times, but we never use the
variable `i` in the body of the `for` loop. Rust warns us about that:
-->
<p>ここで、<code>do_something</code>関数を100回呼んでいますが、<code>for</code>ループの内部で変数<code>i</code>を一度も使っていません。
Rustはこれについて警告します：</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 1..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<!--
The warning suggests that we use `_i` as a name instead: the underscore
indicates that we intend for this variable to be unused. We can automatically
apply that suggestion using the `rustfix` tool by running the command `cargo
fix`:
-->
<p>警告は、変数名に<code>_i</code>を使ってはどうかと提案しています：アンダーバーはその変数を使わないという意図を示すのです。
<code>cargo fix</code>というコマンドを実行することで、この提案を<code>rustfix</code>ツールで自動で適用できます。</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<!--
When we look at *src/main.rs* again, we’ll see that `cargo fix` has changed the
code:
-->
<p><em>src/main.rs</em>をもう一度見てみると、<code>cargo fix</code>によってコードが変更されていることがわかります。</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<!--
The `for` loop variable is now named `_i`, and the warning no longer appears.
-->
<p><code>for</code>ループの変数は<code>_i</code>という名前になったので、警告はもう現れません。</p>
<!--
You can also use the `cargo fix` command to transition your code between
different Rust editions. Editions are covered in Appendix E.
-->
<p><code>cargo fix</code>コマンドを使うと、異なるRust editionの間でコードを変換することもできます。
editionについては付録Eに書いています。</p>
<!--
### More Lints with Clippy
-->
<h3 id="clippyでもっとlintを"><a class="header" href="#clippyでもっとlintを">Clippyでもっとlintを</a></h3>
<!--
The Clippy tool is a collection of lints to analyze your code so you can catch
common mistakes and improve your Rust code.
-->
<p>Clippyというツールは、コードを分析することで、よくある間違いを見つけ、Rustのコードを改善させてくれるlintを集めたものです（訳注：いわゆる静的解析ツール）。</p>
<!--
To install Clippy, enter the following:
-->
<p>Clippyをインストールするには、次を入力してください：</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<!--
To run Clippy’s lints on any Cargo project, enter the following:
-->
<p>Clippyのlintは、次のコマンドでどんなCargoプロジェクトに対しても実行できます：</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<!--
For example, say you write a program that uses an approximation of a
mathematical constant, such as pi, as this program does:
-->
<p>たとえば、下のように、円周率などの数学定数の近似を使ったプログラムを書いているとします。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<!--
Running `cargo clippy` on this project results in this error:
-->
<p><code>cargo clippy</code>をこのプロジェクトに実行すると次のエラーを得ます：</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: #[deny(clippy::approx_constant)] on by default
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<!--
This error lets you know that Rust has this constant defined more precisely and
that your program would be more correct if you used the constant instead. You
would then change your code to use the `PI` constant. The following code
doesn’t result in any errors or warnings from Clippy:
-->
<p>あなたは、このエラーのおかげで、Rustにはより正確に定義された定数がすでにあり、これを代わりに使うとプログラムがより正しくなるかもしれないと気づくことができます。
なので、あなたはコードを定数<code>PI</code>を使うように変更するでしょう。
以下のコードはもうClippyからエラーや警告は受けません。</p>
<!--
<span class="filename">Filename: src/main.rs</span>
-->
<p><span class="filename">ファイル名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<!--
For more information on Clippy, see [its documentation][clippy].
-->
<p>Clippyについてより詳しく知るには、<a href="https://github.com/rust-lang/rust-clippy">ドキュメント</a>を読んでください。</p>
<!--
### IDE Integration Using the Rust Language Server
-->
<h3 id="rust-language-serverを使ってideと統合する"><a class="header" href="#rust-language-serverを使ってideと統合する">Rust Language Serverを使ってIDEと統合する</a></h3>
<!--
To help IDE integration, the Rust project distributes the *Rust Language
Server* (`rls`). This tool speaks the [Language Server
Protocol][lsp], which is a specification for IDEs and programming
languages to communicate with each other. Different clients can use the `rls`,
such as [the Rust plug-in for Visual Studio Code][vscode].
-->
<p>IDEでの開発の助けになるよう、Rustプロジェクトは <em>Rust Language Server</em> (<code>rls</code>)を配布しています。
このツールは、<a href="http://langserver.org/">Language Server Protocol</a>という、IDEとプログラミング言語が対話するための仕様に対応しています。
<a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">Visual Studio CodeのRustプラグイン</a>をはじめ、様々なクライアントが<code>rls</code>を使うことができます。</p>
<!--
To install the `rls`, enter the following:
-->
<p><code>rls</code>をインストールするには、以下を入力してください：</p>
<pre><code class="language-console">$ rustup component add rls
</code></pre>
<!--
Then install the language server support in your particular IDE; you’ll gain
abilities such as autocompletion, jump to definition, and inline errors.
-->
<p>つづけて、あなたのIDE向けのlanguage serverサポートをインストールしてください。
すると、自動補完、定義へのジャンプ、インラインのエラー表示などの機能が得られるはずです。</p>
<!--
For more information on the `rls`, see [its documentation][rls].
-->
<p><code>rls</code>についてより詳しく知るには<a href="https://github.com/rust-lang/rls">ドキュメント</a>を読んでください。</p>
<div style="break-before: page; page-break-before: always;"></div><!--
## Appendix E - Editions
-->
<h2 id="付録eエディション"><a class="header" href="#付録eエディション">付録E：エディション</a></h2>
<!--
In Chapter 1, you saw that `cargo new` adds a bit of metadata to your
*Cargo.toml* file about an edition. This appendix talks about what that means!
-->
<p>第1章で、<code>cargo new</code>が エディションに関するちょっとしたメタデータを <em>Cargo.toml</em> に追加しているのを見ましたね。
この付録ではその意味についてお話します！</p>
<!--
The Rust language and compiler have a six-week release cycle, meaning users get
a constant stream of new features. Other programming languages release larger
changes less often; Rust releases smaller updates more frequently. After a
while, all of these tiny changes add up. But from release to release, it can be
difficult to look back and say, “Wow, between Rust 1.10 and Rust 1.31, Rust has
changed a lot!”
-->
<p>Rust言語とコンパイラは6週間のリリースサイクルを採用しています。つまり、ユーザにはコンスタントに新しい機能が流れてくるというわけです。
他のプログラミング言語は、より少ない回数で、より大きなリリースを行いますが、Rustは小さなアップデートを頻繁に行います。
しばらくすると、これらの小さな変更が溜まっていきます。
しかし、これらを振り返って、「Rust 1.10とRust 1.31を比較すると、すごく変わったねえ！」などとリリースごとに言うのは難しいです。</p>
<!--
Every two or three years, the Rust team produces a new Rust *edition*. Each
edition brings together the features that have landed into a clear package with
fully updated documentation and tooling. New editions ship as part of the usual
six-week release process.
-->
<p>2、3年ごとに、RustチームはRustの新しい <em>エディション</em> を作ります。
それぞれのエディションには、それまでにRustにやってきた新しい機能が、完全に更新されたドキュメントとツール群とともに、一つのパッケージとなってまとめられています。
新しいエディションは通常の6週間ごとのリリースの一部として配布されます。</p>
<!--
Editions serve different purposes for different people:
-->
<p>それぞれの人々にとってエディションは異なる意味を持ちます。</p>
<!--
* For active Rust users, a new edition brings together incremental changes into
  an easy-to-understand package.
* For non-users, a new edition signals that some major advancements have
  landed, which might make Rust worth another look.
* For those developing Rust, a new edition provides a rallying point for the
  project as a whole.
-->
<ul>
<li>アクティブなRustユーザにとっては、新しいエディションは、少しずつ増えてきた変更点を理解しやすいパッケージにしてまとめるものです。</li>
<li>Rustユーザでない人にとっては、新しいエディションは、何かしら大きな達成がなされたことを示します。Rustには今一度目を向ける価値があると感じさせるかもしれません。</li>
<li>Rustを開発している人にとっては、新しいエディションは、プロジェクト全体の目標地点となります。</li>
</ul>
<!--
At the time of this writing, three Rust editions are available: Rust 2015, Rust
2018, and Rust 2021. This book is written using Rust 2021 edition idioms.
-->
<p>この文書を書いている時点（訳注：原文のコミットは2021年12月23日）では、3つのRustのエディションが利用できます。
Rust 2015、Rust 2018、Rust 2021です。
この本はRust 2021エディションの慣例に従って書かれています。</p>
<!--
The `edition` key in *Cargo.toml* indicates which edition the compiler should
use for your code. If the key doesn’t exist, Rust uses `2015` as the edition
value for backward compatibility reasons.
-->
<p><em>Cargo.toml</em> における<code>edition</code>キーは、コードに対してコンパイラがどのエディションを適用すべきかを示しています。
もしキーが存在しなければ、Rustは後方互換性のため<code>2015</code>をエディションの値として使います。</p>
<!--
Each project can opt in to an edition other than the default 2015 edition.
Editions can contain incompatible changes, such as including a new keyword that
conflicts with identifiers in code. However, unless you opt in to those
changes, your code will continue to compile even as you upgrade the Rust
compiler version you use.
-->
<p>標準の2015エディション以外のエディションを使うという選択はそれぞれのプロジェクトですることができます。
エディションには、コード内の識別子と衝突してしまう新しいキーワードの導入など、互換性のない変更が含まれる可能性があります。
しかし、それらの変更を選択しない限り、Rustのコンパイラのバージョンを更新しても、コードは変わらずコンパイルできます。</p>
<!--
All Rust compiler versions support any edition that existed prior to that
compiler’s release, and they can link crates of any supported editions
together. Edition changes only affect the way the compiler initially parses
code. Therefore, if you’re using Rust 2015 and one of your dependencies uses
Rust 2018, your project will compile and be able to use that dependency. The
opposite situation, where your project uses Rust 2018 and a dependency uses
Rust 2015, works as well.
-->
<p>Rustコンパイラは全バージョンにおいて、そのコンパイラのリリースまでに存在したすべてのエディションをサポートしており、またサポートされているエディションのクレートはすべてリンクできます。
エディションの変更はコンパイラが最初にコードを構文解析するときにのみ影響します。
なので、あなたがRust 2015を使っていて、依存先にRust 2018を使うものがあったとしても、あなたのプロジェクトはコンパイルでき、その依存先を使うことができます。
逆に、あなたのプロジェクトがRust 2018を、依存先がRust 2015を使っていても、同じく問題はありません。</p>
<!--
To be clear: most features will be available on all editions. Developers using
any Rust edition will continue to see improvements as new stable releases are
made. However, in some cases, mainly when new keywords are added, some new
features might only be available in later editions. You will need to switch
editions if you want to take advantage of such features.
-->
<p>まあ実のところ、ほとんどの機能はすべてのエディションで利用可能でしょう。
どのRustエディションを使っている開発者も、新しい安定リリースが出ると改善したなと感じるのは変わらないでしょう。
しかし、場合によって（多くは新しいキーワードが追加されたとき）は、新機能が新しいエディションでしか利用できないことがあるかもしれません。
そのような機能を利用したいなら、エディションを切り替える必要があるでしょう。</p>
<!--
For more details, the [*Edition
Guide*](https://doc.rust-lang.org/stable/edition-guide/) is a complete book
about editions that enumerates the differences between editions and explains
how to automatically upgrade your code to a new edition via `cargo fix`.
-->
<p>より詳しく知りたいなら、<a href="https://doc.rust-lang.org/stable/edition-guide/"><em>エディションガイド</em></a>という、エディションに関するすべてを説明している本があります。
エディション同士の違いや、<code>cargo fix</code>を使って自動的にコードを新しいエディションにアップグレードする方法が書かれています。</p>
<blockquote>
<p>訳注：日本語版のエディションガイドは<a href="https://doc.rust-jp.rs/edition-guide/">こちら</a>にあります。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><!--
## Appendix F: Translations of the Book
-->
<h2 id="付録f-本の翻訳"><a class="header" href="#付録f-本の翻訳">付録F: 本の翻訳</a></h2>
<!--
For resources in languages other than English. Most are still in progress; see
[the Translations label][label] to help or let us know about a new translation!
-->
<p>英語以外の言語の資料についてです。ほとんどはまだ翻訳中です。
手助けいただける際や、新しい翻訳について教えていただける際は、
<a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">Translationsラベル</a>を確認してください！</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">简体中文</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">alternate</a></li>
<li><a href="https://github.com/AgeOfWar/rust-book-it">Italiano</a></li>
<li><a href="https://github.com/rust-lang-ru/book">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/idanmel/rust-book-heb">עברית</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/pomokhtari/rust-book-fa">Farsi</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
# Appendix G - How Rust is Made and “Nightly Rust”
-->
<h2 id="付録g-rustの作られ方とnightly-rust"><a class="header" href="#付録g-rustの作られ方とnightly-rust">付録G: Rustの作られ方と“Nightly Rust”</a></h2>
<!--
This appendix is about how Rust is made and how that affects you as a Rust
developer. We mentioned that the output in this book was generated by stable
Rust 1.21.0, but any examples that compile should continue to compile in any
stable version of Rust greater than that. This section is to explain how we
ensure this is true!
-->
<p>この付録は、Rustのでき方と、それがRust開発者としてあなたにどう影響するかについてです。
この本の出力は安定版Rust 1.21.0で生成されていますが、コンパイルできるいかなる例も、
それより新しいRustのどんな安定版でもコンパイルでき続けられるはずということに触れました。
この節は、これが本当のことであると保証する方法を説明します！</p>
<!--
### Stability Without Stagnation
-->
<h3 id="停滞なしの安定性"><a class="header" href="#停滞なしの安定性">停滞なしの安定性</a></h3>
<!--
As a language, Rust cares a *lot* about the stability of your code. We want
Rust to be a rock-solid foundation you can build on, and if things were
constantly changing, that would be impossible. At the same time, if we can’t
experiment with new features, we may not find out important flaws until after
their release, when we can no longer change things.
-->
<p>言語として、Rustはコードの安定性について<em>大い</em>に注意しています。Rustには、その上に建築できる岩のように硬い基礎であってほしく、
物事が定期的に変わっていたら、それは実現できません。同時に新しい機能で実験できなければ、もはや何も変更できないリリースの時まで、
重大な<ruby>瑕疵<rp>(</rp><rt>かし</rt><rp>)</rp></ruby>を発見できなくなるかもしれません。</p>
<!--
Our solution to this problem is what we call “stability without stagnation”,
and our guiding principle is this: you should never have to fear upgrading to a
new version of stable Rust. Each upgrade should be painless, but should also
bring you new features, fewer bugs, and faster compile times.
-->
<p>この問題に対する我々の解決策は「停滞なしの安定性」と呼ばれるもので、ガイドの原則は以下の通りです:
安定版Rustの新しいバージョンにアップグレードするのを恐れる必要は何もないはずです。各アップグレードは痛みのないもののはずですが、
新しい機能、より少ないバグ、高速なコンパイル時間も齎すべきです。</p>
<!--
### Choo, Choo! Release Channels and Riding the Trains
-->
<h3 id="シュポシュポリリースチャンネルと列車に乗ること"><a class="header" href="#シュポシュポリリースチャンネルと列車に乗ること">シュポシュポ！リリースチャンネルと列車に乗ること</a></h3>
<!--
Rust development operates on a *train schedule*. That is, all development is
done on the `master` branch of the Rust repository. Releases follow a software
release train model, which has been used by Cisco IOS and other software
projects. There are three *release channels* for Rust:
-->
<p>Rust開発は、<em>電車のダイヤ</em>に合わせて処理されます。つまり、全開発はRustリポジトリの<code>master</code>ブランチで行われます。
リリースはソフトウェアのリリーストレインモデル(software release train model)に従い、これはCisco IOSや他のソフトウェアプロジェクトで活用されています。
Rustには<em>リリースチャンネル</em>が3つあります:</p>
<blockquote>
<p>注釈: software release train modelとは、あるバージョンのソフトウェアリリースの順番を列車に見立て、
列車のダイヤのように、決まった間隔でリリースに持って行く手法のことの模様。一つの列車は、Rustの場合、
ナイトリー、ベータ、安定版の順に「駅」に停車していくものと思われる。</p>
</blockquote>
<!--
* Nightly
* Beta
* Stable
-->
<ul>
<li>ナイトリー</li>
<li>ベータ</li>
<li>安定版</li>
</ul>
<!--
Most Rust developers primarily use the stable channel, but those who want to
try out experimental new features may use nightly or beta.
-->
<p>多くのRust開発者は主に安定版チャンネルを使用しますが、新しい実験的な機能を試したい方は、
ナイトリーやベータを使用するかもしれません。</p>
<!--
Here’s an example of how the development and release process works: let’s
assume that the Rust team is working on the release of Rust 1.5. That release
happened in December of 2015, but it will provide us with realistic version
numbers. A new feature is added to Rust: a new commit lands on the `master`
branch. Each night, a new nightly version of Rust is produced. Every day is a
release day, and these releases are created by our release infrastructure
automatically. So as time passes, our releases look like this, once a night:
-->
<p>こちらが、開発とリリースプロセスの動き方の例です: RustチームがRust1.5のリリースに取り掛かっていると想定しましょう。
そのリリースは、2015年の11月に発生しましたが、現実的なバージョンナンバーを与えてくれるでしょう。
新しい機能がRustに追加されます: 新しいコミットが<code>master</code>ブランチに着地します。毎晩、新しいナイトリ版のRustが生成されます。
毎日がリリース日で、これらのリリースは、リリースインフラにより自動で作成されます。故に、
時間が経てばリリースは、毎晩1回、以下のような見た目になります:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<!--
Every six weeks, it’s time to prepare a new release! The `beta` branch of the
Rust repository branches off from the `master` branch used by nightly. Now,
there are two releases:
-->
<p>6週間ごとに、新しいリリースを準備するタイミングになります！Rustリポジトリの<code>beta</code>ブランチが、
ナイトリで使用される<code>master</code>ブランチから枝分かれします。さて、リリースが二つになりました:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<!--
Most Rust users do not use beta releases actively, but test against beta in
their CI system to help Rust discover possible regressions. In the meantime,
there’s still a nightly release every night:
-->
<p>ほとんどのRustユーザはベータリリースを積極的には使用しませんが、自身のCIシステム内でベータに対してテストを行い、
Rustが不具合の可能性を発見するのを手伝います。その間も、やはりナイトリリリースは毎晩あります:</p>
<blockquote>
<p>注釈: CIはContinuous Integration(継続統合といったところか)のことと思われる。開発者のコードを1日に何度も、
メインのブランチに統合することらしい。</p>
</blockquote>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<!--
Let’s say a regression is found. Good thing we had some time to test the beta
release before the regression snuck into a stable release! The fix is applied
to `master`, so that nightly is fixed, and then the fix is backported to the
`beta` branch, and a new release of beta is produced:
-->
<p>不具合が見つかったとしましょう。よいことに、不具合が安定版のリリースにこっそり持ち込まれる前にベータリリースをテストする時間がありました！
修正が<code>master</code>に適用されるので、ナイトリは修正され、それから修正が<code>beta</code>ブランチにバックポートされ、
ベータの新しいリリースが生成されます:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<!--
Six weeks after the first beta was created, it’s time for a stable release! The
`stable` branch is produced from the `beta` branch:
-->
<p>最初のベータが作成されてから6週間後、安定版のリリースの時間です！<code>stable</code>ブランチが<code>beta</code>ブランチから生成されます:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<!--
Hooray! Rust 1.5 is done! However, we’ve forgotten one thing: because the six
weeks have gone by, we also need a new beta of the *next* version of Rust, 1.6.
So after `stable` branches off of `beta`, the next version of `beta` branches
off of `nightly` again:
-->
<p>やりました！Rust1.5が完了しました！ですが、1つ忘れていることがあります: 6週間が経過したので、
<em>次</em>のバージョンのRust(1.6)の新しいベータも必要です。従って、<code>stable</code>が<code>beta</code>から枝分かれした後に、
次のバージョンの<code>beta</code>が<code>nightly</code>から再度枝分かれします:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<!--
This is called the “train model” because every six weeks, a release “leaves the
station”, but still has to take a journey through the beta channel before it
arrives as a stable release.
-->
<p>これが「トレイン・モデル」と呼ばれます。6週間ごとにリリースが「駅を出発する」からですが、
安定版リリースとして到着する前にベータチャンネルの旅をそれでもしなければなりません。</p>
<!--
Rust releases every six weeks, like clockwork. If you know the date of one Rust
release, you can know the date of the next one: it’s six weeks later. A nice
aspect of having releases scheduled every six weeks is that the next train is
coming soon. If a feature happens to miss a particular release, there’s no need
to worry: another one is happening in a short time! This helps reduce pressure
to sneak possibly unpolished features in close to the release deadline.
-->
<p>Rustは6週間ごとに時計仕掛けのようにリリースされます。あるRustリリースの日付を知っていれば、
次のリリースの日付もわかります: 6週間後です。6週間ごとにリリースを組むことのいい側面は、次の列車がすぐにやってくることです。
ある機能が偶然、特定のリリースを逃しても、心配する必要はありません: 別のリリースがすぐに起きます！
これにより、リリースの締め切りが近い洗練されていない可能性のある機能をこっそり持ち込むプレッシャーが減る助けになるのです。</p>
<!--
Thanks to this process, you can always check out the next build of Rust and
verify for yourself that it’s easy to upgrade to: if a beta release doesn’t
work as expected, you can report it to the team and get it fixed before the
next stable release happens! Breakage in a beta release is relatively rare, but
`rustc` is still a piece of software, and bugs do exist.
-->
<p>このプロセスのおかげで、Rustの次のビルドを常に確認し、アップグレードするのが容易であると自身に対して確かめることができます:
ベータリリースが予想した通りに動かなければ、チームに報告して、次の安定版のリリースが起きる前に直してもらうことができるのです！
ベータリリースでの破損はどちらかといえば稀ですが、<code>rustc</code>もソフトウェアの一種であり、バグは確実に存在します。</p>
<!--
### Unstable Features
-->
<h3 id="安定しない機能"><a class="header" href="#安定しない機能">安定しない機能</a></h3>
<!--
There’s one more catch with this release model: unstable features. Rust uses a
technique called “feature flags” to determine what features are enabled in a
given release. If a new feature is under active development, it lands on
`master`, and therefore, in nightly, but behind a *feature flag*. If you, as a
user, wish to try out the work-in-progress feature, you can, but you must be
using a nightly release of Rust and annotate your source code with the
appropriate flag to opt in.
-->
<p>このリリースモデルにはもう一つ掴み所があります: 安定しない機能です。Rustは「機能フラグ」と呼ばれるテクニックを使用して、
あるリリースで有効にする機能を決定します。新しい機能が活発に開発中なら、<code>master</code>に着地し、
故にナイトリーでは<em>機能フラグ</em>の背後に存在します。ユーザとして、絶賛作業中の機能を試したいとお望みならば、
可能ですが、ナイトリリリースのRustを使用し、ソースコードに適切なフラグを注釈して同意しなければなりません。</p>
<!--
If you’re using a beta or stable release of Rust, you can’t use any feature
flags. This is the key that allows us to get practical use with new features
before we declare them stable forever. Those who wish to opt into the bleeding
edge can do so, and those who want a rock-solid experience can stick with
stable and know that their code won’t break. Stability without stagnation.
-->
<p>ベータか安定リリースのRustを使用しているなら、機能フラグは使用できません。これが、永遠に安定であると宣言する前に、
新しい機能を実用に供することができる鍵になっています。最先端を選択するのをお望みの方はそうすることができ、
岩のように硬い経験をお望みの方は、安定版に執着し自分のコードが壊れることはないとわかります。停滞なしの安定性です。</p>
<!--
This book only contains information about stable features, as in-progress
features are still changing, and surely they’ll be different between when this
book was written and when they get enabled in stable builds. You can find
documentation for nightly-only features online.
-->
<p>この本は安定な機能についての情報のみ含んでいます。現在進行形の機能は、変化中であり、
確実にこの本が執筆された時と安定版ビルドで有効化された時で異なるからです。ナイトリ限定の機能についてのドキュメンテーションは、
オンラインで発見できます。</p>
<!--
### Rustup and the Role of Rust Nightly
-->
<h3 id="rustupとrustナイトリの役目"><a class="header" href="#rustupとrustナイトリの役目">RustupとRustナイトリの役目</a></h3>
<!--
Rustup makes it easy to change between different release channels of Rust, on a
global or per-project basis. By default, you’ll have stable Rust installed. To
install nightly, for example:
-->
<p>rustupは、グローバルかプロジェクトごとにRustのリリースチャンネルを変更しやすくしてくれます。
標準では、安定版のRustがインストールされます。例えば、ナイトリをインストールするには:</p>
<pre><code class="language-text">$ rustup install nightly
</code></pre>
<!--
You can see all of the *toolchains* (releases of Rust and associated
components) you have installed with `rustup` as well. Here’s an example on one
of your authors’ Windows computer:
-->
<p><code>rustup</code>でインストールした全ツールチェーン(Rustのリリースと関連するコンポーネント)も確認できます。
こちらは、著者の一人のWindowsコンピュータの例です:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<!--
As you can see, the stable toolchain is the default. Most Rust users use stable
most of the time. You might want to use stable most of the time, but use
nightly on a specific project, because you care about a cutting-edge feature.
To do so, you can use `rustup override` in that project’s directory to set the
nightly toolchain as the one `rustup` should use when you’re in that directory:
-->
<p>おわかりのように、安定版のツールチェーンが標準です。ほとんどのRustユーザは、ほとんどの場合、安定版を使用します。
あなたもほとんどの場合安定版を使用したい可能性がありますが、最前線の機能が気になるので、特定のプロジェクトではナイトリを使用したいかもしれません。
そうするためには、そのプロジェクトのディレクトリで<code>rustup override</code>を使用して、そのディレクトリにいる時に、
<code>rustup</code>が使用するべきツールチェーンとしてナイトリ版のものをセットします。</p>
<pre><code class="language-text">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<!--
Now, every time you call `rustc` or `cargo` inside of
*~/projects/needs-nightly*, `rustup` will make sure that you are using nightly
Rust, rather than your default of stable Rust. This comes in handy when you
have a lot of Rust projects!
-->
<p>これで <em>~/projects/needs-nightly</em>内で<code>rustc</code>や<code>cargo</code>を呼び出す度に、<code>rustup</code>は既定の安定版のRustではなく、
ナイトリRustを使用していることを確かめます。Rustプロジェクトが大量にある時には、重宝します。</p>
<!--
### The RFC Process and Teams
-->
<h3 id="rfcプロセスとチーム"><a class="header" href="#rfcプロセスとチーム">RFCプロセスとチーム</a></h3>
<!--
So how do you learn about these new features? Rust’s development model follows
a *Request For Comments (RFC) process*. If you’d like an improvement in Rust,
you can write up a proposal, called an RFC.
-->
<p>では、これらの新しい機能をどう習うのでしょうか？Rustの開発モデルは、<em>Request For Comments (RFC; コメントの要求)プロセス</em>に従っています。
Rustに改善を行いたければ、RFCと呼ばれる提案を書き上げます。</p>
<!--
Anyone can write RFCs to improve Rust, and the proposals are reviewed and
discussed by the Rust team, which is comprised of many topic subteams. There’s
a full list of the teams [on Rust’s
website](https://www.rust-lang.org/en-US/team.html), which includes teams for
each area of the project: language design, compiler implementation,
infrastructure, documentation, and more. The appropriate team reads the
proposal and the comments, writes some comments of their own, and eventually,
there’s consensus to accept or reject the feature.
-->
<p>誰もがRFCを書いてRustを改善でき、提案はRustチームにより査読され議論され、このチームは多くの話題のサブチームから構成されています。
<a href="https://www.rust-lang.org/en-US/team.html">RustのWebサイト</a>にはチームの完全なリストがあり、
プロジェクトの各分野のチームも含みます: 言語設計、コンパイラ実装、インフラ、ドキュメンテーションなどです。
適切なチームが提案とコメントを読み、自身のコメントを書き、最終的にその機能を受け入れるか拒否するかの同意があります。</p>
<!--
If the feature is accepted, an issue is opened on the Rust repository, and
someone can implement it. The person who implements it very well may not be the
person who proposed the feature in the first place! When the implementation is
ready, it lands on the `master` branch behind a feature gate, as we discussed
in the “Unstable Features” section.
-->
<p>機能が受け入れられれば、Rustリポジトリでissueが開かれ、誰かがそれを実装します。うまく実装できる人は、
そもそもその機能を提案した人ではないかもしれません！実装の準備ができたら、
「安定しない機能」節で議論したように、機能ゲートの背後の<code>master</code>に着地します。</p>
<!--
After some time, once Rust developers who use nightly releases have been able
to try out the new feature, team members will discuss the feature, how it’s
worked out on nightly, and decide if it should make it into stable Rust or not.
If the decision is to move forward, the feature gate is removed, and the
feature is now considered stable! It rides the trains into a new stable release
of Rust.
-->
<p>時間経過後、一旦ナイトリリリースを使用するRust開発者が新しい機能を試すことができたら、チームのメンバーがその機能と、
ナイトリでどう機能しているかについて議論し、安定版のRustに導入すべきかどうか決定します。
決定が進行させることだったら、機能ゲートは取り除かれ、その機能はもう安定と考えられます！
Rustの新しい安定版リリースまで、列車に乗っているのです。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="ferris.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
